---
author: ZhgChgLi
categories:
- ZRealm Dev.
date: 2023-03-11T17:09:22.165+0000
description: ZMarkupParser HTML to NSAttributedString æ¸²æŸ“å¼•æ“çš„å¼€å‘å®å½•
image:
  path: /assets/2724f02f6e7/1*A0yXupXW9-F9ZWe4gp2ObA.jpeg
last_modified_at: 2023-08-05T16:15:39.420+0000
pin: true
render_with_liquid: false
tags:
- simplified-chinese
- ios-app-development
- html-parsing
- nsattributedstring
- html
- rendering
title: æ‰‹å·¥æ‰“é€  HTML è§£æå™¨çš„é‚£äº›äº‹
---

### æ‰‹å·¥æ‰“é€  HTML è§£æå™¨çš„é‚£äº›äº‹



ZMarkupParser HTML to NSAttributedString æ¸²æŸ“å¼•æ“çš„å¼€å‘å®å½•



HTML String çš„ Tokenization è½¬æ¢ã€Normalization å¤„ç†ã€Abstract Syntax Tree çš„äº§ç”Ÿã€Visitor Pattern / Builder Pattern çš„åº”ç”¨, è¿˜æœ‰ä¸€äº›æ‚è°ˆâ€¦



#### æ¥ç»­



å»å¹´å‘è¡¨äº†ç¯‡ã€Œ[ **TL;DR]** [è‡ªè¡Œå®ç° iOS NSAttributedString HTML Render](../a8c2d26cc734/) ã€çš„æ–‡ç« ï¼Œç²—æµ…çš„ä»‹ç»å¯ä»¥ä½¿ç”¨ XMLParser å»å‰–æ HTML å†å°†å…¶è½¬æ¢æˆ NSAttributedString.Keyï¼Œæ–‡ä¸­çš„ç¨‹å¼æ¶æ„åŠæ€è·¯éƒ½å¾ˆé›¶ä¹±ï¼Œå› æ˜¯è¿‡æ°´çºªå½•ä¸€ä¸‹ä¹‹å‰é‡åˆ°çš„é—®é¢˜åŠå½“åˆå¹¶æ²¡æœ‰èŠ±å¤ªå¤šæ—¶é—´ç ”ç©¶æ­¤è®®é¢˜ã€‚



### Convert HTML String to NSAttributedString



å†æ¬¡é‡æ–°æ¢è®¨æ­¤è®®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦èƒ½å°† API ç»™çš„ HTML å­—ä¸²è½¬æ¢æˆ NSAttributedString ï¼Œå¹¶å¥—ç”¨å¯¹åº”æ ·å¼æ”¾åˆ° UITextView/UILabel ä¸­æ˜¾ç¤ºã€‚



e.g. `<b>Test<a>Link</a></b>` è¦èƒ½æ˜¾ç¤ºæˆ **Test [Link](https://blog.zhgchg.li){:target="_blank"}**



- æ³¨1
  ä¸å»ºè®®ä½¿ç”¨ HTML åšä¸º App ä¸èµ„æ–™é—´çš„æ²Ÿé€šæ¸²æŸ“åª’ä»‹ï¼Œå›  HTML è§„æ ¼è¿‡äºå¼¹æ€§ï¼ŒApp æ— æ³•æ”¯æ´æ‰€æœ‰ HTML æ ·å¼ï¼Œä¹Ÿæ²¡æœ‰å®˜æ–¹çš„ HTML è½¬æ¢æ¸²æŸ“å¼•æ“ã€‚


- æ³¨2
  iOS 14 å¼€å§‹å¯ä½¿ç”¨å®˜æ–¹åŸç”Ÿçš„ AttributedString è§£æ Markdownæˆ–å¼•å…¥ apple/swift-markdown Swift Package è§£æ Markdownã€‚


- æ³¨3
  å› æ•å¸ä¸“æ¡ˆåºå¤§ä¸”å·²åº”ç”¨ HTML åšä¸ºåª’ä»‹å¤šå¹´ï¼Œæ‰€ä»¥æš‚æ—¶æ— æ³•å…¨é¢æ›´æ¢ä¸º Markdown æˆ–å…¶ä»– Markupã€‚


- **æ³¨4**
  **è¿™è¾¹çš„ HTML å¹¶ä¸æ˜¯è¦ç”¨æ¥æ˜¾ç¤ºæ•´ä¸ª HTML ç½‘é¡µï¼Œåªæ˜¯æŠŠ HTML åšä¸ºæ ·å¼ Markdown æ¸²æŸ“å­—ä¸²æ ·å¼ã€‚**
  **(è¦æ¸²æŸ“æ•´é¡µã€å¤æ‚åŒ…å«å›¾ç‰‡è¡¨æ ¼çš„ HTMLï¼Œä¾ç„¶è¦ä½¿ç”¨ WevView loadHTML)**



> å¼ºçƒˆå»ºè®®ä½¿ç”¨ Markdown åšä¸ºå­—ä¸²æ¸²æŸ“åª’ä»‹è¯­è¨€ï¼Œå¦‚æœæ‚¨çš„ä¸“æ¡ˆè·Ÿæˆ‘æœ‰ä¸€æ ·å›°æ‰°ä¸å¾—ä¸ä½¿ç”¨ HTML å¹¶è‹¦æ— ä¼˜é›…çš„ to NSAttributedString è½¬æ¢å·¥å…·ï¼Œ å†è¯·ä½¿ç”¨ã€‚



> è¿˜è®°å¾—ä¸Šä¸€ç¯‡æ–‡ç« çš„æœ‹å‹ä¹Ÿå¯ä»¥ç›´æ¥è·³åˆ° ZhgChgLi / ZMarkupParser ç« èŠ‚ã€‚



#### NSAttributedString.DocumentType.html



ç½‘è·¯ä¸Šèƒ½æ‰¾åˆ°çš„ HTML to NSAttributedString çš„åšæ³•éƒ½æ˜¯è¦æˆ‘ä»¬ç›´æ¥ä½¿ç”¨ NSAttributedString è‡ªå¸¦çš„ options æ¸²æŸ“ HTMLï¼ŒèŒƒä¾‹å¦‚ä¸‹ï¼š



```swift
let htmlString = "<b>Test<a>Link</a></b>"
let data = htmlString.data(using: String.Encoding.utf8)!
let attributedOptions:[NSAttributedString.DocumentReadingOptionKey: Any] = [
  .documentType :NSAttributedString.DocumentType.html,
  .characterEncoding: String.Encoding.utf8.rawValue
]
let attributedString = try! NSAttributedString(data: data, options: attributedOptions, documentAttributes: nil)
```



**æ­¤åšæ³•çš„é—®é¢˜ï¼š**



- æ•ˆèƒ½å·®ï¼šæ­¤æ–¹æ³•æ˜¯é€è¿‡ WebView Core å»æ¸²æŸ“å‡ºæ ·å¼ï¼Œå†åˆ‡å› Main Thread ç»™ UI æ˜¾ç¤ºï¼›æ¸²æŸ“ 300 å¤šä¸ªå­—å…ƒå°±éœ€ 0.03 Secã€‚


- ä¼šåƒå­—ï¼šä¾‹å¦‚è¡Œé”€æ–‡æ¡ˆå¯èƒ½ä¼šä½¿ç”¨ `<Congratulation!>` ä¼šè¢«å½“æˆ HTML Tag è¢«å»é™¤æ‰ã€‚


- æ— æ³•å®¢åˆ¶åŒ–ï¼šä¾‹å¦‚æ— æ³•æŒ‡å®š HTML çš„ç²—ä½“åœ¨ NSAttributedString ä¸­å¯¹åº”çš„ç²—ä½“ç¨‹åº¦ã€‚


- [iOS â‰¥ 12 å¼€å§‹ä¼šé›¶æ˜Ÿé—ªé€€çš„é—®é¢˜ä¸”å®˜æ–¹æ— è§£](https://developer.apple.com/forums/thread/115405){:target="_blank"}


- åœ¨ iOS 15 å‡ºç° [å¤§é‡é—ªé€€](../a8c2d26cc734/) ï¼Œæµ‹è¯•å‘ç°ä½ç”µé‡æƒ…å†µä¸‹ä¼š 100% é—ªé€€ (iOS â‰¥ 15.2 å·²ä¿®æ­£)


- å­—ä¸²å¤ªé•¿ä¼šé—ªé€€ï¼Œå®æµ‹è¾“å…¥è¶…è¿‡ 54,600+ é•¿åº¦å­—ä¸²å°±ä¼š 100% é—ªé€€ (EXC_BAD_ACCESS)



å¯¹ä¸æˆ‘ä»¬æœ€ç—›çš„è¿˜æ˜¯é—ªé€€é—®é¢˜ï¼ŒiOS 15 å‘å¸ƒåˆ° 15.2 ä¿®æ­£ä¹‹å‰ï¼ŒApp å§‹ç»ˆè¢«æ­¤é—®é¢˜éœ¸æ¦œï¼Œä»æ•°æ®æ¥çœ‹ï¼Œ2022/03/11~2022/06/08 å°±é€ æˆäº† 2.4K+ æ¬¡é—ªé€€ã€å½±å“ 1.4K+ ä½ä½¿ç”¨è€…ã€‚



æ­¤é—ªé€€é—®é¢˜è‡ª iOS 12 å¼€å§‹å°±æœ‰ï¼ŒiOS 15 åªæ˜¯è¸©åˆ°æ›´å¤§çš„å‘ï¼Œä½†æˆ‘çŒœ iOS 15.2 çš„ä¿®æ­£ä¹Ÿåªæ˜¯è¡¥æ´ï¼Œå®˜æ–¹æ— æ³•æ ¹é™¤ã€‚



å…¶æ¬¡é—®é¢˜æ˜¯æ•ˆèƒ½ï¼Œå› ä¸ºåšä¸ºå­—ä¸²æ ·å¼ Markup Languageï¼Œä¼šå¤§é‡åº”ç”¨åœ¨ App ä¸Šçš„ UILabel/UITextViewï¼Œå¦‚åŒå‰è¿°ä¸€ä¸ª Label å°±éœ€è¦ 0.03 Secï¼Œåˆ—è¡¨*UILabel/UITextView ä¹˜ä¸‹æ¥å°±ä¼šå¯¹ä½¿ç”¨è€…æ“ä½œæ‰‹æ„Ÿä¸Šäº§ç”Ÿå¡é¡¿ã€‚



#### XMLParser



ç¬¬äºŒä¸ªæ–¹æ¡ˆæ˜¯ [ä¸Šç¯‡æ–‡ç« ](../a8c2d26cc734/) ä»‹ç»çš„ï¼Œä½¿ç”¨ XMLParser è§£ææˆå¯¹åº”çš„ NSAttributedString Key å¹¶å¥—ç”¨æ ·å¼ã€‚



å¯å‚è€ƒ [SwiftRichString](https://github.com/malcommac/SwiftRichString){:target="_blank"} çš„å®ç°åŠ [ä¸Šä¸€ç¯‡æ–‡ç« å†…å®¹](../a8c2d26cc734/) ã€‚



> ä¸Šä¸€ç¯‡ä¹Ÿåªæ˜¯æ¢ç©¶å‡ºå¯ä»¥ä½¿ç”¨ XMLParser è§£æ HTML å¹¶åšå¯¹åº”è½¬æ¢ï¼Œç„¶åå®Œæˆå®éªŒæ€§çš„å®ä½œï¼Œä½†å¹¶æ²¡æœ‰æŠŠå®ƒè®¾è®¡æˆä¸€ä¸ªæœ‰æ¶æ„å¥½æ‰©å……çš„ã€Œå·¥å…·ã€ã€‚



**æ­¤åšæ³•çš„é—®é¢˜ï¼š**



- å®¹é”™ç‡ 0ï¼š `<br>` / `<Congratulation!>` / `<b>Bold<i>Bold+Italic</b>Italic</i>`
  ä»¥ä¸Šä¸‰ç§ HTML æœ‰å¯èƒ½å‡ºç°çš„æƒ…å¢ƒï¼Œåœ¨ XMLParser è§£æéƒ½ä¼šå‡ºé”™ç›´æ¥ Throw Error æ˜¾ç¤ºç©ºç™½ã€‚


- ä½¿ç”¨ XMLParserï¼ŒHTML å­—ä¸²å¿…é¡»å®Œå…¨ç¬¦åˆ XML è§„åˆ™ï¼Œæ— æ³•åƒæµè§ˆå™¨æˆ– NSAttributedString.DocumentType.html å®¹é”™æ­£å¸¸æ˜¾ç¤ºã€‚



#### ç«™åœ¨å·¨äººçš„è‚©è†€ä¸Š



ä»¥ä¸Šä¸¤ä¸ªæ–¹æ¡ˆéƒ½ä¸èƒ½å®Œç¾ä¼˜é›…çš„è§£å†³ HTML é—®é¢˜ï¼Œäºæ˜¯å¼€å§‹æœå¯»æœ‰æ— ç°æˆçš„è§£å†³æ–¹æ¡ˆã€‚



- [johnxnguyen](https://github.com/johnxnguyen){:target="_blank"} / [Down](https://github.com/johnxnguyen/Down){:target="_blank"}
  åªæ”¯æ´è¾“å…¥ Markdown è½¬æ¢æˆ Any (XML/NSAttributedStringâ€¦)ï¼Œä½†ä¸æ”¯æ´è¾“å…¥ HTML è½¬æ¢ã€‚


- [malcommac](https://github.com/malcommac){:target="_blank"} / [SwiftRichString](https://github.com/malcommac/SwiftRichString){:target="_blank"}
  åº•å±‚æ˜¯ä½¿ç”¨ XMLParserï¼Œå®æµ‹å‰è¿°æ¡ˆä¾‹ä¹Ÿä¼šæœ‰ä¸€æ ·å®¹é”™ç‡ 0 çš„é—®é¢˜ã€‚


- [scinfu](https://github.com/scinfu){:target="_blank"} / [SwiftSoup](https://github.com/scinfu/SwiftSoup){:target="_blank"}
  åªæ”¯æ´ HTML Parser(Selector) [ä¸æ”¯æ´è½¬æ¢æˆ NSAttributedString](https://github.com/scinfu/SwiftSoup/issues/127){:target="_blank"} ã€‚



> æ‰¾äº†ä¸€å¤§åœˆç»“æœéƒ½ç±»ä¼¼ä¸Šæ–¹çš„ä¸“æ¡ˆ Orzï¼Œæ²¡æœ‰å·¨äººçš„è‚©è†€å¯ä»¥ç«™ã€‚



### ZhgChgLi/ZMarkupParser



[![](https://repository-images.githubusercontent.com/602927147/57ce75c1-8548-449c-b44a-f4b0451ed5ea)](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}



æ²¡æœ‰å·¨äººçš„è‚©è†€ï¼Œåªå¥½è‡ªå·±å½“å·¨äººäº†ï¼Œäºæ˜¯è‡ªè¡Œå¼€å‘äº† HTML String to NSAttributedString å·¥å…·ã€‚



ä½¿ç”¨çº¯ Swift å¼€å‘ï¼Œé€è¿‡ Regex å‰–æå‡º HTML Tag å¹¶ç»è¿‡ Tokenizationï¼Œåˆ†æä¿®æ­£ Tag æ­£ç¡®æ€§(ä¿®æ­£æ²¡æœ‰ end çš„ tag & é”™ä½ tag)ï¼Œå†è½¬æ¢æˆ abstract syntax treeï¼Œæœ€ç»ˆä½¿ç”¨ Visitor Pattern å°† HTML Tag ä¸æŠ½è±¡æ ·å¼å¯¹åº”ï¼Œå¾—åˆ°æœ€ç»ˆ NSAttributedString ç»“æœï¼›å…¶ä¸­ä¸ä¾èµ–ä»»ä½• Parser Libã€‚



#### ç‰¹è‰²



- æ”¯æ´ HTML Render (to NSAttributedString) / Stripper (å‰¥ç¦» HTML Tag) / Selector åŠŸèƒ½


- æ¯” `NSAttributedString.DocumentType.html` æ›´é«˜çš„æ•ˆèƒ½


- è‡ªåŠ¨åˆ†æä¿®æ­£ Tag æ­£ç¡®æ€§(ä¿®æ­£æ²¡æœ‰ end çš„ tag & é”™ä½ tag)


- æ”¯æ´ä» `style=â€color:redâ€¦â€` åŠ¨æ€è®¾å®šæ ·å¼


- æ”¯æ´å®¢åˆ¶åŒ–æ ·å¼æŒ‡å®šï¼Œä¾‹å¦‚ç²—ä½“è¦å¤š **ç²—**


- æ”¯æ´å¼¹æ€§å¯æ‰©å……æ ‡ç­¾æˆ–è‡ªè®¢æ ‡ç­¾åŠå±æ€§



> è¯¦ç»†ä»‹ç»ã€å®‰è£…ä½¿ç”¨å¯å‚è€ƒæ­¤ç¯‡æ–‡ç« ï¼šã€Œ [**ZMarkupParser HTML String è½¬æ¢ NSAttributedString å·¥å…·**](../a5643de271e4/) ã€



å¯ç›´æ¥ [git clone ä¸“æ¡ˆ](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} åï¼Œæ‰“å¼€ `ZMarkupParser.xcworkspace` Project é€‰æ‹© `ZMarkupParser-Demo` Target ç›´æ¥ Build & Run èµ·æ¥ç©ç©ã€‚



![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*PzYcnSkW7qKeJBkaiNTKjQ.gif)



[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}



### æŠ€æœ¯ç»†èŠ‚



å†æ¥æ‰æ˜¯æœ¬ç¯‡æ–‡ç« æƒ³åˆ†äº«çš„ï¼Œå…³äºå¼€å‘è¿™ä¸ªå·¥å…·ä¸Šçš„æŠ€æœ¯ç»†èŠ‚ã€‚



![è¿ä½œæµç¨‹æ€»è§ˆ](/assets/2724f02f6e7/1*YF5L7gefMCMwU1wmnGgy6A.png)



è¿ä½œæµç¨‹æ€»è§ˆ



ä¸Šå›¾ä¸ºå¤§æ¦‚çš„è¿ä½œæµç¨‹ï¼Œåé¢æ–‡ç« ä¼šä¸€æ­¥ä¸€æ­¥ä»‹ç»åŠé™„ä¸Šç¨‹å¼ç ã€‚



> âš ï¸ï¸ï¸ï¸ï¸ï¸ æœ¬æ–‡ä¼šå°½é‡ç®€åŒ– Demo Codeã€å‡å°‘æŠ½è±¡è·Ÿæ•ˆèƒ½è€ƒé‡ï¼Œå°½é‡æŠŠé‡å¿ƒæ”¾åœ¨è§£é‡Šè¿ä½œåŸç†ä¸Šï¼›å¦‚éœ€äº†è§£æœ€ç»ˆç»“æœè¯·å‚è€ƒä¸“æ¡ˆ [Source Code](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} ã€‚



### ç¨‹å¼ç åŒ– â€” Tokenization



> a.k.a parser, è§£æ



è°ˆåˆ° HTML æ¸²æŸ“æœ€é‡è¦çš„å°±æ˜¯è§£æçš„ç¯èŠ‚ï¼Œä»¥å¾€æ˜¯é€è¿‡ XMLParser å°† HTML åšä¸º XML è§£æï¼›ä½†æ˜¯æ— æ³•å…‹æœ HTML æ—¥å¸¸ç”¨æ³•å¹¶ä¸æ˜¯ 100% çš„ XML ä¼šé€ æˆè§£æå™¨é”™è¯¯ï¼Œä¸”æ— æ³•åŠ¨æ€ä¿®æ­£ã€‚



æ’é™¤æ‰ä½¿ç”¨ XMLParser è¿™æ¡è·¯ä¹‹åï¼Œåœ¨ Swift ä¸Šç•™ç»™æˆ‘ä»¬çš„å°±åªå‰©ä½¿ç”¨ Regex æ­£åˆ™æ¥åšåŒ¹é…è§£æäº†ã€‚



æœ€ä¸€å¼€å§‹æ²¡æƒ³å¤ªå¤šï¼Œæƒ³è¯´å¯ä»¥ç›´æ¥ç”¨æ­£åˆ™æŒ–å‡ºã€Œæˆå¯¹ã€çš„ HTML Tagï¼Œå†é€’å›å¾€é‡Œé¢ä¸€å±‚ä¸€å±‚æ‰¾ HTML Tagï¼Œç›´åˆ°ç»“æŸï¼›ä½†æ˜¯è¿™æ ·æ²¡æœ‰åŠæ³•è§£å†³ HTML Tag å¯ä»¥åµŒå¥—ï¼Œæˆ–æƒ³æ”¯æ´é”™ä½å®¹é”™çš„é—®é¢˜ï¼Œå› æ­¤æˆ‘ä»¬æŠŠç­–ç•¥æ”¹æˆæŒ–æˆå‡ºã€Œå•ä¸ªã€ HTML Tagï¼Œå¹¶è®°å½•æ˜¯ Start Tag, Close Tag or Self-Closing Tagï¼ŒåŠå…¶ä»–å­—ä¸²ç»„åˆæˆè§£æç»“æœé˜µåˆ—ã€‚



**Tokenization ç»“æ„å¦‚ä¸‹ï¼š**



```swift
enum HTMLParsedResult {
    case start(StartItem) // <a>
    case close(CloseItem) // </a>
    case selfClosing(SelfClosingItem) // <br/>
    case rawString(NSAttributedString)
}

extension HTMLParsedResult {
    class SelfClosingItem {
        let tagName: String
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?
        
        init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) {
            self.tagName = tagName
            self.tagAttributedString = tagAttributedString
            self.attributes = attributes
        }
    }
    
    class StartItem {
        let tagName: String
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?

        // Start Tag æœ‰å¯èƒ½æ˜¯å¼‚å¸¸ HTML Tag ä¹Ÿæœ‰å¯èƒ½æ˜¯æ­£å¸¸æ–‡å­— e.g. <Congratulation!>, åç»­ Normalization åå¦‚æœå‘ç°æ˜¯å­¤ç«‹ Start Tag åˆ™æ ‡è®°ä¸º Trueã€‚
        var isIsolated: Bool = false
        
        init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) {
            self.tagName = tagName
            self.tagAttributedString = tagAttributedString
            self.attributes = attributes
        }
        
        // åç»­ Normalization è‡ªåŠ¨è¡¥ä½ä¿®æ­£ä½¿ç”¨
        func convertToCloseParsedItem() -> CloseItem {
            return CloseItem(tagName: self.tagName)
        }
        
        // åç»­ Normalization è‡ªåŠ¨è¡¥ä½ä¿®æ­£ä½¿ç”¨
        func convertToSelfClosingParsedItem() -> SelfClosingItem {
            return SelfClosingItem(tagName: self.tagName, tagAttributedString: self.tagAttributedString, attributes: self.attributes)
        }
    }
    
    class CloseItem {
        let tagName: String
        init(tagName: String) {
            self.tagName = tagName
        }
    }
}
```



**ä½¿ç”¨çš„æ­£åˆ™å¦‚ä¸‹ï¼š**



```ruby
<(?:(?<closeTag>\/)?(?<tagName>[A-Za-z0-9]+)(?<tagAttributes>(?:\s*(\w+)\s*=\s*(["\\|']).*?\5)*)\s*(?<selfClosingTag>\/)?>)
```



-&gt; [Online Regex101 Playground](https://regex101.com/r/aBrID8/1){:target="_blank"}



- closeTag: åŒ¹é… &lt; `/` a&gt;


- tagName: åŒ¹é… &lt; `a` &gt; or , &lt;/ `a` &gt;


- tagAttributes: åŒ¹é… &lt;a `href=â€https://zhgchg.liâ€ style=â€color:redâ€` &gt;


- selfClosingTag: åŒ¹é… &lt;br `/` &gt;



> *æ­¤æ­£åˆ™è¿˜å¯ä»¥å†ä¼˜åŒ–ï¼Œä¹‹åå†æ¥åš



> æ–‡ç« ååŠæ®µæœ‰æä¾›å…³äºæ­£åˆ™çš„é™„åŠ èµ„æ–™ï¼Œæœ‰å…´è¶£çš„æœ‹å‹å¯ä»¥å‚è€ƒã€‚



**ç»„åˆèµ·æ¥å°±æ˜¯ï¼š**



```swift
var tokenizationResult: [HTMLParsedResult] = []

let expression = try? NSRegularExpression(pattern: pattern, options: expressionOptions)
let attributedString = NSAttributedString(string: "<a>Li<b>nk</a>Bold</b>")
let totalLength = attributedString.string.utf16.count // utf-16 support emoji
var lastMatch: NSTextCheckingResult?

// Start Tags Stack, å…ˆè¿›åå‡º(FILO First In Last Out)
// æ£€æµ‹ HTML å­—ä¸²æ˜¯å¦éœ€è¦åç»­ Normalization ä¿®æ­£é”™ä½æˆ–è¡¥ Self-Closing Tag
var stackStartItems: [HTMLParsedResult.StartItem] = []
var needForamatter: Bool = false

expression.enumerateMatches(in: attributedString.string, range: NSMakeRange(0, totoalLength)) { match, _, _ in
  if let match = match {
    // æ£€æŸ¥ Tag ä¹‹é—´æˆ–æ˜¯åˆ°ç¬¬ä¸€ä¸ª Tag ä¹‹é—´çš„å­—ä¸²
    // e.g. Test<a>Link</a>zzz<b>bold</b>Test2 - > Test,zzz
    let lastMatchEnd = lastMatch?.range.upperBound ?? 0
    let currentMatchStart = match.range.lowerBound
    if currentMatchStart > lastMatchEnd {
      let rawStringBetweenTag = attributedString.attributedSubstring(from: NSMakeRange(lastMatchEnd, (currentMatchStart - lastMatchEnd)))
      tokenizationResult.append(.rawString(rawStringBetweenTag))
    }

    // <a href="https://zhgchg.li">, </a>
    let matchAttributedString = attributedString.attributedSubstring(from: match.range)
    // a, a
    let matchTag = attributedString.attributedSubstring(from: match.range(withName: "tagName"))?.string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    // false, true
    let matchIsEndTag = matchResult.attributedString(from: match.range(withName: "closeTag"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == "/"
    // href="https://zhgchg.li", nil
    // ç”¨æ­£åˆ™å†æ‹†å‡º HTML Attribute, to [String: String], è¯·å‚è€ƒ Source Code
    let matchTagAttributes = parseAttributes(matchResult.attributedString(from: match.range(withName: "tagAttributes")))
    // false, false
    let matchIsSelfClosingTag = matchResult.attributedString(from: match.range(withName: "selfClosingTag"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == "/"

    if let matchAttributedString = matchAttributedString,
       let matchTag = matchTag {
        if matchIsSelfClosingTag {
          // e.g. <br/>
          tokenizationResult.append(.selfClosing(.init(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes)))
        } else {
          // e.g. <a> or </a>
          if matchIsEndTag {
            // e.g. </a>
            // ä» Stack å–å‡ºå‡ºç°ç›¸åŒ TagName çš„ä½ç½®ï¼Œä»æœ€åå¼€å§‹
            if let index = stackStartItems.lastIndex(where: { $0.tagName == matchTag }) {
              // å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªï¼Œä»£è¡¨æœ‰é”™ä½æˆ–é—æ¼å…³é—­çš„ Tag
              if index != stackStartItems.count - 1 {
                  needForamatter = true
              }
              tokenizationResult.append(.close(.init(tagName: matchTag)))
              stackStartItems.remove(at: index)
            } else {
              // å¤šä½™çš„ close tag e.g </a>
              // ä¸å½±å“åç»­ï¼Œç›´æ¥å¿½ç•¥
            }
          } else {
            // e.g. <a>
            let startItem: HTMLParsedResult.StartItem = HTMLParsedResult.StartItem(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes)
            tokenizationResult.append(.start(startItem))
            // å¡åˆ° Stack
            stackStartItems.append(startItem)
          }
        }
     }

    lastMatch = match
  }
}

// æ£€æŸ¥ç»“å°¾çš„ RawString
// e.g. Test<a>Link</a>Test2 - > Test2
if let lastMatch = lastMatch {
  let currentIndex = lastMatch.range.upperBound
  if totoalLength > currentIndex {
    // è¿˜æœ‰å‰©ä½™å­—ä¸²
    let resetString = attributedString.attributedSubstring(from: NSMakeRange(currentIndex, (totoalLength - currentIndex)))
    tokenizationResult.append(.rawString(resetString))
  }
} else {
  // lastMatch = nil, ä»£è¡¨æ²¡æ‰¾åˆ°ä»»ä½•æ ‡ç­¾ï¼Œå…¨éƒ½æ˜¯çº¯æ–‡å­—
  let resetString = attributedString.attributedSubstring(from: NSMakeRange(0, totoalLength))
  tokenizationResult.append(.rawString(resetString))
}

// æ£€æŸ¥ Stack æ˜¯å¦å·²ç»æ¸…ç©ºï¼Œå¦‚æœè¿˜æœ‰ä»£è¡¨æœ‰ Start Tag æ²¡æœ‰å¯¹åº”çš„ End
// æ ‡è®°æˆå­¤ç«‹ Start Tag
for stackStartItem in stackStartItems {
  stackStartItem.isIsolated = true
  needForamatter = true
}

print(tokenizationResult)
// [
//    .start("a",["href":"https://zhgchg.li"])
//    .rawString("Li")
//    .start("b",nil)
//    .rawString("nk")
//    .close("a")
//    .rawString("Bold")
//    .close("b")
// ]
```



![è¿ä½œæµç¨‹å¦‚ä¸Šå›¾](/assets/2724f02f6e7/1*U50CX56M_xy1EXZKb69YeA.png)



è¿ä½œæµç¨‹å¦‚ä¸Šå›¾



æœ€ç»ˆä¼šå¾—åˆ°ä¸€ä¸ª Tokenization ç»“æœé˜µåˆ—ã€‚



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLStringToParsedResultProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLStringToParsedResultProcessor.swift){:target="_blank"} å®ä½œ



### æ ‡å‡†åŒ– â€” Normalization



> a.k.a Formatter, æ­£è§„åŒ–



ç»§ä¸Šä¸€æ­¥å–å¾—åˆæ­¥è§£æç»“æœåï¼Œè§£æä¸­å¦‚æœå‘ç°è¿˜éœ€è¦ Normalizationï¼Œåˆ™éœ€è¦æ­¤æ­¥éª¤ï¼Œè‡ªåŠ¨ä¿®æ­£ HTML Tag é—®é¢˜ã€‚



**HTML Tag é—®é¢˜æœ‰ä»¥ä¸‹ä¸‰ç§ï¼š**



- HTML Tag ä½†é—æ¼ Close Tag: ä¾‹å¦‚ `<br>`


- ä¸€èˆ¬æ–‡å­—è¢«å½“æˆ HTML Tag: ä¾‹å¦‚ `<Congratulation!>`


- HTML Tag å­˜åœ¨é”™ä½é—®é¢˜: ä¾‹å¦‚ `<a>Li<b>nk</a>Bold</b>`



ä¿®æ­£æ–¹å¼ä¹Ÿå¾ˆç®€å•ï¼Œæˆ‘ä»¬éœ€è¦éå† Tokenization ç»“æœçš„å…ƒç´ ï¼Œå°è¯•è¡¥é½ç¼ºæ¼ã€‚



![è¿ä½œæµç¨‹å¦‚ä¸Šå›¾](/assets/2724f02f6e7/1*Wk-U_sQuvLo1OJhcE1BQPQ.png)



è¿ä½œæµç¨‹å¦‚ä¸Šå›¾



```swift
var normalizationResult = tokenizationResult

// Start Tags Stack, å…ˆè¿›åå‡º(FILO First In Last Out)
var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []
var itemIndex = 0
while itemIndex < newItems.count {
    switch newItems[itemIndex] {
    case .start(let item):
        if item.isIsolated {
            // å¦‚æœä¸ºå­¤ç«‹ Start Tag
            if WC3HTMLTagName(rawValue: item.tagName) == nil && (item.attributes?.isEmpty ?? true) {
                // å¦‚æœä¸æ˜¯ WCS å®šä¹‰çš„ HTML Tag & æ²¡æœ‰ä»»ä½• HTML Attribute
                // WC3HTMLTagName Enum å¯å‚è€ƒ Source Code
                // åˆ¤å®šä¸º ä¸€èˆ¬æ–‡å­—è¢«å½“æˆ HTML Tag
                // æ”¹æˆ raw string type
                normalizationResult[itemIndex] = .rawString(item.tagAttributedString)
            } else {
                // å¦åˆ™ï¼Œæ”¹æˆ self-closing tag, e.g. <br> -> <br/>
                normalizationResult[itemIndex] = .selfClosing(item.convertToSelfClosingParsedItem())
            }
            itemIndex += 1
        } else {
            // æ­£å¸¸ Start Tag, åŠ å…¥ Stack
            stackExpectedStartItems.append(item)
            itemIndex += 1
        }
    case .close(let item):
        // é‡åˆ° Close Tag
        // å–å¾— Start Stack Tag åˆ°æ­¤ Close Tag ä¸­é—´éš”çš„ Tags
        // e.g <a><u><b>[CurrentIndex]</a></u></b> -> é—´éš” 0
        // e.g <a><u><b>[CurrentIndex]</a></u></b> -> é—´éš” b,u

        let reversedStackExpectedStartItems = Array(stackExpectedStartItems.reversed())
        guard let reversedStackExpectedStartItemsOccurredIndex = reversedStackExpectedStartItems.firstIndex(where: { $0.tagName == item.tagName }) else {
            itemIndex += 1
            continue
        }
        
        let reversedStackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItems.prefix(upTo: reversedStackExpectedStartItemsOccurredIndex))
        
        // é—´éš” 0, ä»£è¡¨ tag æ²¡é”™ä½
        guard reversedStackExpectedStartItemsOccurred.count != 0 else {
            // is pair, pop
            stackExpectedStartItems.removeLast()
            itemIndex += 1
            continue
        }
        
        // æœ‰å…¶ä»–é—´éš”ï¼Œè‡ªåŠ¨åœ¨å‰å€™è¡¥æœŸé—´æ ¼ Tag
        // e.g <a><u><b>[CurrentIndex]</a></u></b> ->
        // e.g <a><u><b>[CurrentIndex]</b></u></a><b></u></u></b>
        let stackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItemsOccurred.reversed())
        let afterItems = stackExpectedStartItemsOccurred.map({ HTMLParsedResult.start($0) })
        let beforeItems = reversedStackExpectedStartItemsOccurred.map({ HTMLParsedResult.close($0.convertToCloseParsedItem()) })
        normalizationResult.insert(contentsOf: afterItems, at: newItems.index(after: itemIndex))
        normalizationResult.insert(contentsOf: beforeItems, at: itemIndex)
        
        itemIndex = newItems.index(after: itemIndex) + stackExpectedStartItemsOccurred.count
        
        // æ›´æ–° Start Stack Tags
        // e.g. -> b,u
        stackExpectedStartItems.removeAll { startItem in
            return reversedStackExpectedStartItems.prefix(through: reversedStackExpectedStartItemsOccurredIndex).contains(where: { $0 === startItem })
        }
    case .selfClosing, .rawString:
        itemIndex += 1
    }
}

print(normalizationResult)
// [
//    .start("a",["href":"https://zhgchg.li"])
//    .rawString("Li")
//    .start("b",nil)
//    .rawString("nk")
//    .close("b")
//    .close("a")
//    .start("b",nil)
//    .rawString("Bold")
//    .close("b")
// ]
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLParsedResultFormatterProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLParsedResultFormatterProcessor.swift){:target="_blank"} å®ä½œ



### Abstract Syntax Tree



> a.k.a AST, æŠ½è±¡æ ‘



ç»è¿‡ Tokenization & Normalization èµ„æ–™é¢„å¤„ç†å®Œæˆåï¼Œå†æ¥è¦å°†ç»“æœè½¬æ¢æˆæŠ½è±¡æ ‘ğŸŒ²ã€‚



![å¦‚ä¸Šå›¾](/assets/2724f02f6e7/1*40z0o7R0OROURWCQVDmKrw.png)



å¦‚ä¸Šå›¾



è½¬æ¢æˆæŠ½è±¡æ ‘å¯ä»¥æ–¹ä¾¿æˆ‘ä»¬æ—¥åçš„æ“ä½œåŠæ‰©å……ï¼Œä¾‹å¦‚å®ç° Selector åŠŸèƒ½æˆ–æ˜¯åšå…¶ä»–è½¬æ¢ï¼Œä¾‹å¦‚ HTML To Markdownï¼›äº¦æˆ–æ˜¯æ—¥åæƒ³å¢åŠ  Markdown to NSAttributedStringï¼Œåªéœ€å®ç° Markdown çš„ Tokenization & Normalization å°±èƒ½å®Œæˆã€‚



**é¦–å…ˆæˆ‘ä»¬å®šä¹‰ä¸€ä¸ª Markup Protocolï¼Œæœ‰ Child & Parent å±æ€§ï¼Œçºªå½•å¶å­è·Ÿæ ‘æçš„èµ„è®¯:**



```swift
protocol Markup: AnyObject {
    var parentMarkup: Markup? { get set }
    var childMarkups: [Markup] { get set }
    
    func appendChild(markup: Markup)
    func prependChild(markup: Markup)
    func accept<V: MarkupVisitor>(_ visitor: V) -> V.Result
}

extension Markup {
    func appendChild(markup: Markup) {
        markup.parentMarkup = self
        childMarkups.append(markup)
    }
    
    func prependChild(markup: Markup) {
        markup.parentMarkup = self
        childMarkups.insert(markup, at: 0)
    }
}
```



å¦å¤–æ­é…ä½¿ç”¨ [Visitor Pattern](../ba5773a7bfea/) ï¼Œå°†æ¯ç§æ ·å¼å±æ€§éƒ½å®šä¹‰æˆä¸€ä¸ªç‰©ä»¶ Elementï¼Œå†é€è¿‡ä¸åŒçš„ Visit ç­–ç•¥å–å¾—ä¸ªåˆ«çš„å¥—ç”¨ç»“æœã€‚



```swift
protocol MarkupVisitor {
    associatedtype Result
        
    func visit(markup: Markup) -> Result
    
    func visit(_ markup: RootMarkup) -> Result
    func visit(_ markup: RawStringMarkup) -> Result
    
    func visit(_ markup: BoldMarkup) -> Result
    func visit(_ markup: LinkMarkup) -> Result
    //...
}

extension MarkupVisitor {
    func visit(markup: Markup) -> Result {
        return markup.accept(self)
    }
}
```



**åŸºæœ¬ Markup èŠ‚ç‚¹ï¼š**



```swift
// æ ¹èŠ‚ç‚¹
final class RootMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

// å¶èŠ‚ç‚¹
final class RawStringMarkup: Markup {
    let attributedString: NSAttributedString
    
    init(attributedString: NSAttributedString) {
        self.attributedString = attributedString
    }
    
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}
```



**å®šä¹‰ Markup æ ·å¼èŠ‚ç‚¹ï¼š**



```swift
// æ ‘æèŠ‚ç‚¹:

// è¿ç»“æ ·å¼
final class LinkMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

// ç²—ä½“æ ·å¼
final class BoldMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [Markup](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/Markup){:target="_blank"} å®ä½œ



è½¬æ¢æˆæŠ½è±¡æ ‘ä¹‹å‰æˆ‘ä»¬è¿˜éœ€è¦â€¦



#### MarkupComponent



**å› ä¸ºæˆ‘ä»¬çš„æ ‘ç»“æ„ä¸ä¸ä»»ä½•èµ„æ–™ç»“æ„æœ‰ä¾èµ–(ä¾‹å¦‚ a èŠ‚ç‚¹/LinkMarkupï¼Œåº”è¯¥è¦æœ‰ url èµ„è®¯æ‰èƒ½åšåç»­ Render)ã€‚**
**å¯¹æ­¤æˆ‘ä»¬å¦å¤–å®šä¹‰ä¸€ä¸ªå®¹å™¨å­˜æ”¾æ ‘èŠ‚ç‚¹ä¸èŠ‚ç‚¹ç›¸å…³çš„èµ„æ–™èµ„è®¯:**



```swift
protocol MarkupComponent {
    associatedtype T
    var markup: Markup { get }
    var value: T { get }
    
    init(markup: Markup, value: T)
}

extension Sequence where Iterator.Element: MarkupComponent {
    func value(markup: Markup) -> Element.T? {
        return self.first(where:{ $0.markup === markup })?.value as? Element.T
    }
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [MarkupComponent](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/MarkupComponent){:target="_blank"} å®ä½œ



ä¹Ÿå¯å°† Markup å®£å‘Š `Hashable` ï¼Œç›´æ¥ä½¿ç”¨ Dictionary å­˜æ”¾å€¼ `[Markup: Any]` ï¼Œä½†æ˜¯è¿™æ · Markup å°±ä¸èƒ½è¢«å½“ä¸€èˆ¬ type ä½¿ç”¨ï¼Œè¦åŠ ä¸Š `any Markup` ã€‚



#### HTMLTag & HTMLTagName & HTMLTagNameVisitor



HTML Tag Name éƒ¨åˆ†æˆ‘ä»¬ä¹Ÿåšäº†ä¸€å±‚çš„æŠ½è±¡ï¼Œè®©ä½¿ç”¨è€…èƒ½è‡ªè¡Œå†³å®šæœ‰å“ªäº› Tag éœ€è¦è¢«å¤„ç†ï¼Œä¹Ÿèƒ½æ–¹ä¾¿æ—¥åçš„æ‰©å……ï¼Œä¾‹å¦‚: `<strong>` Tag Name åŒæ ·å¯å¯¹åº”åˆ° `BoldMarkup` ã€‚



```
public protocol HTMLTagName {
    var string: String { get }
    func accept<V: HTMLTagNameVisitor>(_ visitor: V) -> V.Result
}

public struct A_HTMLTagName: HTMLTagName {
    public let string: String = WC3HTMLTagName.a.rawValue
    
    public init() {
        
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}

public struct B_HTMLTagName: HTMLTagName {
    public let string: String = WC3HTMLTagName.b.rawValue
    
    public init() {
        
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLTagNameVisitor](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTagNameVisitor.swift){:target="_blank"} å®ä½œ



> å¦å¤–å‚è€ƒ W3C wiki åˆ—ä¸¾äº† HTML tag name enum: [WC3HTMLTagName.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/WC3HTMLTagName.swift){:target="_blank"}



**HTMLTag åˆ™æ˜¯å•çº¯ä¸€ä¸ªå®¹å™¨ç‰©ä»¶ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›èƒ½è®©å¤–éƒ¨æŒ‡å®š HTML Tag å¯¹åº”åˆ°çš„æ ·å¼ï¼Œæ‰€ä»¥å®£å‘Šä¸€ä¸ªå®¹å™¨æ”¾åœ¨ä¸€èµ·:**



```swift
struct HTMLTag {
    let tagName: HTMLTagName
    let customStyle: MarkupStyle? // åé¢ä»‹ç» Render ä¼šè§£é‡Š
    
    init(tagName: HTMLTagName, customStyle: MarkupStyle? = nil) {
        self.tagName = tagName
        self.customStyle = customStyle
    }
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLTag](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTag.swift3){:target="_blank"} å®ä½œ



#### HTMLTagNameToHTMLMarkupVisitor



```swift
struct HTMLTagNameToMarkupVisitor: HTMLTagNameVisitor {
    typealias Result = Markup
    
    let attributes: [String: String]?
    
    func visit(_ tagName: A_HTMLTagName) -> Result {
        return LinkMarkup()
    }
    
    func visit(_ tagName: B_HTMLTagName) -> Result {
        return BoldMarkup()
    }
    //...
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLTagNameToHTMLMarkupVisitor](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagNameToHTMLMarkupVisitor.swift){:target="_blank"} å®ä½œ



#### è½¬æ¢æˆæŠ½è±¡æ ‘ with HTML èµ„æ–™



æˆ‘ä»¬è¦å°† Normalization åçš„ HTML èµ„æ–™ç»“æœè½¬æ¢æˆæŠ½è±¡æ ‘ï¼Œé¦–å…ˆå®£å‘Šä¸€ä¸ªèƒ½å­˜æ”¾ HTML èµ„æ–™çš„ MarkupComponent èµ„æ–™ç»“æ„:



```swift
struct HTMLElementMarkupComponent: MarkupComponent {
    struct HTMLElement {
        let tag: HTMLTag
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?
    }
    
    typealias T = HTMLElement
    
    let markup: Markup
    let value: HTMLElement
    init(markup: Markup, value: HTMLElement) {
        self.markup = markup
        self.value = value
    }
}
```



**è½¬æ¢æˆ Markup æŠ½è±¡æ ‘:**



```swift
var htmlElementComponents: [HTMLElementMarkupComponent] = []
let rootMarkup = RootMarkup()
var currentMarkup: Markup = rootMarkup

let htmlTags: [String: HTMLTag]
init(htmlTags: [HTMLTag]) {
  self.htmlTags = Dictionary(uniqueKeysWithValues: htmlTags.map{ ($0.tagName.string, $0) })
}

// Start Tags Stack, ç¡®ä¿æœ‰æ­£ç¡® pop tag
// å‰é¢å·²ç»åšè¿‡ Normalization äº†, åº”è¯¥ä¸ä¼šå‡ºé”™, åªæ˜¯ç¡®ä¿è€Œå·²
var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []
for thisItem in from {
    switch thisItem {
    case .start(let item):
        let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes)
        let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName))
        // ç”¨ Visitor é—®å¯¹åº”çš„ Markup
        let markup = visitor.visit(tagName: htmlTag.tagName)
        
        // æŠŠè‡ªå·±åŠ å…¥å½“å‰æçš„å¶èŠ‚ç‚¹
        // è‡ªå·±å˜æˆå½“å‰æèŠ‚ç‚¹
        htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes)))
        currentMarkup.appendChild(markup: markup)
        currentMarkup = markup
        
        stackExpectedStartItems.append(item)
    case .selfClosing(let item):
        // ç›´æ¥åŠ å…¥å½“å‰æçš„å¶èŠ‚ç‚¹
        let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes)
        let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName))
        let markup = visitor.visit(tagName: htmlTag.tagName)
        htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes)))
        currentMarkup.appendChild(markup: markup)
    case .close(let item):
        if let lastTagName = stackExpectedStartItems.popLast()?.tagName,
           lastTagName == item.tagName {
            // é‡åˆ° Close Tag, å°±å›åˆ°ä¸Šä¸€å±‚
            currentMarkup = currentMarkup.parentMarkup ?? currentMarkup
        }
    case .rawString(let attributedString):
        // ç›´æ¥åŠ å…¥å½“å‰æçš„å¶èŠ‚ç‚¹
        currentMarkup.appendChild(markup: RawStringMarkup(attributedString: attributedString))
    }
}

// print(htmlElementComponents)
// [(markup: LinkMarkup, (tag: a, attributes: ["href":"zhgchg.li"]...)]
```



![è¿ä½œç»“æœå¦‚ä¸Šå›¾](/assets/2724f02f6e7/1*D-oMszCDzsBpUYnCEWGKHQ.png)



è¿ä½œç»“æœå¦‚ä¸Šå›¾



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLParsedResultToHTMLElementWithRootMarkupProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLParsedResultToHTMLElementWithRootMarkupProcessor.swift){:target="_blank"} å®ä½œ



#### æ­¤æ—¶ï¼Œå…¶å®æˆ‘ä»¬å°±å®Œæˆ Selector çš„åŠŸèƒ½äº† ğŸ‰



```swift
public class HTMLSelector: CustomStringConvertible {
    
    let markup: Markup
    let componets: [HTMLElementMarkupComponent]
    init(markup: Markup, componets: [HTMLElementMarkupComponent]) {
        self.markup = markup
        self.componets = componets
    }
    
    public func filter(_ htmlTagName: String) -> [HTMLSelector] {
        let result = markup.childMarkups.filter({ componets.value(markup: $0)?.tag.tagName.isEqualTo(htmlTagName) ?? false })
        return result.map({ .init(markup: $0, componets: componets) })
    }

    //...
}
```



æˆ‘ä»¬å¯ä»¥ä¸€å±‚ä¸€å±‚ Filter å¶èŠ‚ç‚¹ç‰©ä»¶ã€‚



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLSelector](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLSelector.swift){:target="_blank"} å®ä½œ



### Parser â€” HTML to MarkupSyle (Abstract of NSAttributedString.Key)



å†æ¥æˆ‘ä»¬è¦å…ˆå®Œæˆå°† HTML è½¬æ¢æˆ MarkupStyle (NSAttributedString.Key)ã€‚



NSAttributedString æ˜¯é€è¿‡ NSAttributedString.Key Attributes æ¥è®¾å®šå­—çš„æ ·å¼ï¼Œæˆ‘ä»¬æŠ½è±¡å‡º NSAttributedString.Key çš„æ‰€æœ‰æ ä½å¯¹åº”åˆ° MarkupStyle,MarkupStyleColor,MarkupStyleFont,MarkupStyleParagraphStyleã€‚



**ç›®çš„ï¼š**



- åŸæœ¬çš„ Attributes çš„èµ„æ–™ç»“æ„æ˜¯ `[NSAttributedString.Key: Any?]` ï¼Œå¦‚æœç›´æ¥æš´éœ²å‡ºå»ï¼Œæˆ‘ä»¬å¾ˆéš¾æ§åˆ¶ä½¿ç”¨è€…å¸¦å…¥çš„å€¼ï¼Œå¦‚æœå¸¦é”™è¿˜ä¼šé€ æˆé—ªé€€ï¼Œä¾‹å¦‚ `.font: 123`


- æ ·å¼éœ€è¦å¯ç»§æ‰¿ï¼Œä¾‹å¦‚ `<a><b>test</b></a>` ï¼Œtest å­—ä¸²çš„æ ·å¼å°±æ˜¯ç»§æ‰¿è‡ª link çš„ bold (bold+linke)ï¼›å¦‚æœç›´æ¥æš´éœ² Dictionary å‡ºå»å¾ˆéš¾æ§åˆ¶å¥½ç»§æ‰¿è§„


- å°è£… iOS/macOS (UIKit/Appkit) æ‰€å±ç‰©ä»¶



#### MarkupStyle Struct



```swift
public struct MarkupStyle {
    public var font:MarkupStyleFont
    public var paragraphStyle:MarkupStyleParagraphStyle
    public var foregroundColor:MarkupStyleColor? = nil
    public var backgroundColor:MarkupStyleColor? = nil
    public var ligature:NSNumber? = nil
    public var kern:NSNumber? = nil
    public var tracking:NSNumber? = nil
    public var strikethroughStyle:NSUnderlineStyle? = nil
    public var underlineStyle:NSUnderlineStyle? = nil
    public var strokeColor:MarkupStyleColor? = nil
    public var strokeWidth:NSNumber? = nil
    public var shadow:NSShadow? = nil
    public var textEffect:String? = nil
    public var attachment:NSTextAttachment? = nil
    public var link:URL? = nil
    public var baselineOffset:NSNumber? = nil
    public var underlineColor:MarkupStyleColor? = nil
    public var strikethroughColor:MarkupStyleColor? = nil
    public var obliqueness:NSNumber? = nil
    public var expansion:NSNumber? = nil
    public var writingDirection:NSNumber? = nil
    public var verticalGlyphForm:NSNumber? = nil
    //...

    // ç»§æ‰¿è‡ª...
    // é¢„è®¾: æ ä½ä¸º nil æ—¶ï¼Œä» from å¡«å…¥å½“å‰èµ„æ–™ç‰©ä»¶
    mutating func fillIfNil(from: MarkupStyle?) {
        guard let from = from else { return }
        
        var currentFont = self.font
        currentFont.fillIfNil(from: from.font)
        self.font = currentFont
        
        var currentParagraphStyle = self.paragraphStyle
        currentParagraphStyle.fillIfNil(from: from.paragraphStyle)
        self.paragraphStyle = currentParagraphStyle
        //..
    }

    // MarkupStyle to NSAttributedString.Key: Any
    func render() -> [NSAttributedString.Key: Any] {
        var data: [NSAttributedString.Key: Any] = [:]
        
        if let font = font.getFont() {
            data[.font] = font
        }

        if let ligature = self.ligature {
            data[.ligature] = ligature
        }
        //...
        return data
    }
}

public struct MarkupStyleFont: MarkupStyleItem {
    public enum FontWeight {
        case style(FontWeightStyle)
        case rawValue(CGFloat)
    }
    public enum FontWeightStyle: String {
        case ultraLight, light, thin, regular, medium, semibold, bold, heavy, black
        // ...
    }
    
    public var size: CGFloat?
    public var weight: FontWeight?
    public var italic: Bool?
    //...
}

public struct MarkupStyleParagraphStyle: MarkupStyleItem {
    public var lineSpacing:CGFloat? = nil
    public var paragraphSpacing:CGFloat? = nil
    public var alignment:NSTextAlignment? = nil
    public var headIndent:CGFloat? = nil
    public var tailIndent:CGFloat? = nil
    public var firstLineHeadIndent:CGFloat? = nil
    public var minimumLineHeight:CGFloat? = nil
    public var maximumLineHeight:CGFloat? = nil
    public var lineBreakMode:NSLineBreakMode? = nil
    public var baseWritingDirection:NSWritingDirection? = nil
    public var lineHeightMultiple:CGFloat? = nil
    public var paragraphSpacingBefore:CGFloat? = nil
    public var hyphenationFactor:Float? = nil
    public var usesDefaultHyphenation:Bool? = nil
    public var tabStops: [NSTextTab]? = nil
    public var defaultTabInterval:CGFloat? = nil
    public var textLists: [NSTextList]? = nil
    public var allowsDefaultTighteningForTruncation:Bool? = nil
    public var lineBreakStrategy: NSParagraphStyle.LineBreakStrategy? = nil
    //...
}

public struct MarkupStyleColor {
    let red: Int
    let green: Int
    let blue: Int
    let alpha: CGFloat
    //...
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [MarkupStyle](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/MarkupStyle){:target="_blank"} å®ä½œ



> å¦å¤–ä¹Ÿå‚è€ƒ W3c wiki, browser predefined color name åˆ—ä¸¾äº†å¯¹åº” color name text & color R,G,B enum: [MarkupStyleColorName.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyleColorName.swift){:target="_blank"}



#### HTMLTagStyleAttribute & HTMLTagStyleAttributeVisitor



è¿™è¾¹å¤šæä¸€ä¸‹è¿™ä¸¤ä¸ªç‰©ä»¶ï¼Œå› ä¸º HTML Tag æ˜¯å…è®¸æ­é…ä» CSS è®¾å®šæ ·å¼çš„ï¼›å¯¹æ­¤æˆ‘ä»¬åŒ HTMLTagName çš„æŠ½è±¡ï¼Œå†å¥—ç”¨ä¸€æ¬¡åœ¨ HTML Style Attribute ä¸Šã€‚



ä¾‹å¦‚ HTML å¯èƒ½ä¼šç»™ï¼š `<a style=â€color:red;font-size:14pxâ€>RedLink</a>` ï¼Œä»£è¡¨è¿™ä¸ªè¿ç»“è¦è®¾å®šæˆçº¢è‰²ã€å¤§å° 14pxã€‚



```
public protocol HTMLTagStyleAttribute {
    var styleName: String { get }
    
    func accept<V: HTMLTagStyleAttributeVisitor>(_ visitor: V) -> V.Result
}

public protocol HTMLTagStyleAttributeVisitor {
    associatedtype Result
    
    func visit(styleAttribute: HTMLTagStyleAttribute) -> Result
    func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -> Result
    func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -> Result
    //...
}

public extension HTMLTagStyleAttributeVisitor {
    func visit(styleAttribute: HTMLTagStyleAttribute) -> Result {
        return styleAttribute.accept(self)
    }
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLTagStyleAttribute](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTagStyleAttribute){:target="_blank"} å®ä½œ



#### HTMLTagStyleAttributeToMarkupStyleVisitor



```swift
struct HTMLTagStyleAttributeToMarkupStyleVisitor: HTMLTagStyleAttributeVisitor {
    typealias Result = MarkupStyle?
    
    let value: String
    
    func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -> Result {
        // æ­£åˆ™æŒ–å– Color Hex or Mapping from HTML Pre-defined Color Name, è¯·å‚è€ƒ Source Code
        guard let color = MarkupStyleColor(string: value) else { return nil }
        return MarkupStyle(foregroundColor: color)
    }
    
    func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -> Result {
        // æ­£åˆ™æŒ–å– 10px -> 10, è¯·å‚è€ƒ Source Code
        guard let size = self.convert(fromPX: value) else { return nil }
        return MarkupStyle(font: MarkupStyleFont(size: CGFloat(size)))
    }
    // ...
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLTagAttributeToMarkupStyleVisitor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagAttributeToMarkupStyleVisitor.swift){:target="_blank"} å®ä½œ



init çš„ value = attribute çš„å€¼ï¼Œä¾ç…§ visit ç±»å‹è½¬æ¢åˆ°å¯¹åº” MarkupStyle æ ä½ã€‚



#### HTMLElementMarkupComponentMarkupStyleVisitor



ä»‹ç»å®Œ MarkupStyle ç‰©ä»¶åï¼Œæˆ‘ä»¬è¦ä» Normalization çš„ HTMLElementComponents ç»“æœè½¬æ¢æˆ MarkupStyleã€‚



```swift
// MarkupStyle ç­–ç•¥
public enum MarkupStylePolicy {
    case respectMarkupStyleFromCode // ä» Code æ¥çš„ä¸ºä¸», ç”¨ HTML Style Attribute æ¥çš„å¡«ç©º
    case respectMarkupStyleFromHTMLStyleAttribute // ä» HTML Style Attribute æ¥çš„ä¸ºä¸», ç”¨ Code æ¥çš„å¡«ç©º
}

struct HTMLElementMarkupComponentMarkupStyleVisitor: MarkupVisitor {

    typealias Result = MarkupStyle?
    
    let policy: MarkupStylePolicy
    let components: [HTMLElementMarkupComponent]
    let styleAttributes: [HTMLTagStyleAttribute]

    func visit(_ markup: BoldMarkup) -> Result {
        // .bold åªæ˜¯å®šä¹‰åœ¨ MarkupStyle ä¸­çš„é¢„è®¾æ ·å¼, è¯·å‚è€ƒ Source Code
        return defaultVisit(components.value(markup: markup), defaultStyle: .bold)
    }
    
    func visit(_ markup: LinkMarkup) -> Result {
        // .link åªæ˜¯å®šä¹‰åœ¨ MarkupStyle ä¸­çš„é¢„è®¾æ ·å¼, è¯·å‚è€ƒ Source Code
        var markupStyle = defaultVisit(components.value(markup: markup), defaultStyle: .link) ?? .link
        
        // ä» HtmlElementComponents å–å¾— LinkMarkup å¯¹åº”çš„ HtmlElement
        // ä» HtmlElement ä¸­çš„ attributes æ‰¾ href å‚æ•° (HTML å¸¦ URL String çš„æ–¹å¼)
        if let href = components.value(markup: markup)?.attributes?["href"] as? String,
           let url = URL(string: href) {
            markupStyle.link = url
        }
        return markupStyle
    }

    // ...
}

extension HTMLElementMarkupComponentMarkupStyleVisitor {
    // å–å¾— HTMLTag å®¹å™¨ä¸­æŒ‡å®šæƒ³å®¢åˆ¶åŒ–çš„ MarkupStyle
    private func customStyle(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?) -> MarkupStyle? {
        guard let customStyle = htmlElement?.tag.customStyle else {
            return nil
        }
        return customStyle
    }
    
    // é¢„è®¾åŠ¨ä½œ
    func defaultVisit(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?, defaultStyle: MarkupStyle? = nil) -> Result {
        var markupStyle: MarkupStyle? = customStyle(htmlElement) ?? defaultStyle
        // ä» HtmlElementComponents å–å¾— LinkMarkup å¯¹åº”çš„ HtmlElement
        // çœ‹çœ‹ HtmlElement ä¸­çš„ attributes æœ‰æ²¡æœ‰ `Style` Attribute
        guard let styleString = htmlElement?.attributes?["style"],
              styleAttributes.count > 0 else {
            // æ²¡æœ‰
            return markupStyle
        }

        // æœ‰ Style Attributes
        // åˆ‡å‰² Style Value å­—ä¸²æˆé˜µåˆ—
        // font-size:14px;color:red -> ["font-size":"14px","color":"red"]
        let styles = styleString.split(separator: ";").filter { $0.trimmingCharacters(in: .whitespacesAndNewlines) != "" }.map { $0.split(separator: ":") }
        
        for style in styles {
            guard style.count == 2 else {
                continue
            }
            // e.g font-szie
            let key = style[0].trimmingCharacters(in: .whitespacesAndNewlines)
            // e.g. 14px
            let value = style[1].trimmingCharacters(in: .whitespacesAndNewlines)
            
            if let styleAttribute = styleAttributes.first(where: { $0.isEqualTo(styleName: key) }) {
                // ä½¿ç”¨ä¸Šæ–‡ä¸­çš„ HTMLTagStyleAttributeToMarkupStyleVisitor æ¢å› MarkupStyle
                let visitor = HTMLTagStyleAttributeToMarkupStyleVisitor(value: value)
                if var thisMarkupStyle = visitor.visit(styleAttribute: styleAttribute) {
                    // Style Attribute æœ‰æ¢å›å€¼æ—¶..
                    // åˆå¹¶ä¸Šä¸€ä¸ª MarkupStyle ç»“æœ
                    thisMarkupStyle.fillIfNil(from: markupStyle)
                    markupStyle = thisMarkupStyle
                }
            }
        }
        
        // å¦‚æœæœ‰é¢„è®¾ Style
        if var defaultStyle = defaultStyle {
            switch policy {
                case .respectMarkupStyleFromHTMLStyleAttribute:
                  // Style Attribute MarkupStyle ä¸ºä¸»ï¼Œç„¶å
                  // åˆå¹¶ defaultStyle ç»“æœ
                    markupStyle?.fillIfNil(from: defaultStyle)
                case .respectMarkupStyleFromCode:
                  // defaultStyle ä¸ºä¸»ï¼Œç„¶å
                  // åˆå¹¶ Style Attribute MarkupStyle ç»“æœ
                  defaultStyle.fillIfNil(from: markupStyle)
                  markupStyle = defaultStyle
            }
        }
        
        return markupStyle
    }
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLTagAttributeToMarkupStyleVisitor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagAttributeToMarkupStyleVisitor.swift){:target="_blank"} å®ä½œ



æˆ‘ä»¬ä¼šå®šä¹‰éƒ¨åˆ†é¢„è®¾æ ·å¼åœ¨ [MarkupStyle](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyle%2BExtension.swift){:target="_blank"} ä¸­ï¼Œéƒ¨åˆ† Markup å¦‚æœæ²¡æœ‰ä» Code å¤–éƒ¨æŒ‡å®š Tag æƒ³è¦çš„æ ·å¼æ—¶ä¼šä½¿ç”¨é¢„è®¾æ ·å¼ã€‚



**æ ·å¼ç»§æ‰¿ç­–ç•¥æœ‰ä¸¤ç§ï¼š**



- respectMarkupStyleFromCode:
  ä½¿ç”¨é¢„è®¾æ ·å¼ä¸ºä¸»ï¼›å†çœ‹ Style Attributes ä¸­èƒ½è¡¥ä¸Šä»€ä¹ˆæ ·å¼ï¼Œå¦‚æœæœ¬æ¥å°±æœ‰å€¼åˆ™å¿½ç•¥ã€‚


- respectMarkupStyleFromHTMLStyleAttribute:
  çœ‹ Style Attributes ä¸ºä¸»ï¼›å†çœ‹ é¢„è®¾æ ·å¼ ä¸­èƒ½è¡¥ä¸Šä»€ä¹ˆæ ·å¼ï¼Œå¦‚æœæœ¬æ¥å°±æœ‰å€¼åˆ™å¿½ç•¥ã€‚



#### HTMLElementWithMarkupToMarkupStyleProcessor



å°† Normalization ç»“æœè½¬æ¢æˆ AST & MarkupStyleComponentã€‚



**æ–°å®£å‘Šä¸€ä¸ª MarkupComponent è¿™æ¬¡è¦å­˜æ”¾å¯¹åº” MarkupStyle:**



```swift
struct MarkupStyleComponent: MarkupComponent {
    typealias T = MarkupStyle
    
    let markup: Markup
    let value: MarkupStyle
    init(markup: Markup, value: MarkupStyle) {
        self.markup = markup
        self.value = value
    }
}
```



**ç®€å•éå†ä¸ª Markup Tree & HTMLElementMarkupComponent ç»“æ„:**



```swift
let styleAttributes: [HTMLTagStyleAttribute]
let policy: MarkupStylePolicy
    
func process(from: (Markup, [HTMLElementMarkupComponent])) -> [MarkupStyleComponent] {
  var components: [MarkupStyleComponent] = []
  let visitor = HTMLElementMarkupComponentMarkupStyleVisitor(policy: policy, components: from.1, styleAttributes: styleAttributes)
  walk(markup: from.0, visitor: visitor, components: &components)
  return components
}
    
func walk(markup: Markup, visitor: HTMLElementMarkupComponentMarkupStyleVisitor, components: inout [MarkupStyleComponent]) {
        
  if let markupStyle = visitor.visit(markup: markup) {
    components.append(.init(markup: markup, value: markupStyle))
  }
        
  for markup in markup.childMarkups {
    walk(markup: markup, visitor: visitor, components: &components)
  }
}

// print(components)
// [(markup: LinkMarkup, MarkupStyle(link: https://zhgchg.li, color: .blue)]
// [(markup: BoldMarkup, MarkupStyle(font: .init(weight: .bold))]
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [HTMLElementWithMarkupToMarkupStyleProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLElementWithMarkupToMarkupStyleProcessor.swift){:target="_blank"} å®ä½œ



![æµç¨‹ç»“æœå¦‚ä¸Šå›¾](/assets/2724f02f6e7/1*JEMBNdbQcBgDQ49jFw4ePQ.png)



æµç¨‹ç»“æœå¦‚ä¸Šå›¾



### Render â€” Convert To NSAttributedString



ç°åœ¨æˆ‘ä»¬æœ‰äº† HTML Tag æŠ½è±¡æ ‘ç»“æ„ã€HTML Tag å¯¹åº”çš„ MarkupStyle åï¼›æœ€åä¸€æ­¥æˆ‘ä»¬å°±èƒ½æ¥äº§å‡ºæœ€åçš„ NSAttributedString æ¸²æŸ“ç»“æœã€‚



#### MarkupNSAttributedStringVisitor



visit markup to NSAttributedString



```swift
struct MarkupNSAttributedStringVisitor: MarkupVisitor {
    typealias Result = NSAttributedString
    
    let components: [MarkupStyleComponent]
    // root / base çš„ MarkupStyle, å¤–éƒ¨æŒ‡å®šï¼Œä¾‹å¦‚å¯æŒ‡å®šæ•´ä¸²å­—çš„å¤§å°
    let rootStyle: MarkupStyle?
    
    func visit(_ markup: RootMarkup) -> Result {
        // å¾€ä¸‹çœ‹ RawString ç‰©ä»¶
        return collectAttributedString(markup)
    }
    
    func visit(_ markup: RawStringMarkup) -> Result {
        // å›ä¼  Raw String
        // æœé›†é“¾ä¸Šçš„æ‰€æœ‰ MarkupStyle
        // å¥—ç”¨ Style åˆ° NSAttributedString
        return applyMarkupStyle(markup.attributedString, with: collectMarkupStyle(markup))
    }
    
    func visit(_ markup: BoldMarkup) -> Result {
        // å¾€ä¸‹çœ‹ RawString ç‰©ä»¶
        return collectAttributedString(markup)
    }
    
    func visit(_ markup: LinkMarkup) -> Result {
        // å¾€ä¸‹çœ‹ RawString ç‰©ä»¶
        return collectAttributedString(markup)
    }
    // ...
}

private extension MarkupNSAttributedStringVisitor {
    // å¥—ç”¨ Style åˆ° NSAttributedString
    func applyMarkupStyle(_ attributedString: NSAttributedString, with markupStyle: MarkupStyle?) -> NSAttributedString {
        guard let markupStyle = markupStyle else { return attributedString }
        let mutableAttributedString = NSMutableAttributedString(attributedString: attributedString)
        mutableAttributedString.addAttributes(markupStyle.render(), range: NSMakeRange(0, mutableAttributedString.string.utf16.count))
        return mutableAttributedString
    }

    func collectAttributedString(_ markup: Markup) -> NSMutableAttributedString {
        // collect from downstream
        // Root -> Bold -> String("Bold")
        //      \
        //       > String("Test")
        // Result: Bold Test
        // ä¸€å±‚ä¸€å±‚å¾€ä¸‹æ‰¾ raw string, é€’å› visit å¹¶ç»„åˆå‡ºæœ€ç»ˆ NSAttributedString
        return markup.childMarkups.compactMap({ visit(markup: $0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in
            partialResult.append(attributedString)
            return partialResult
        }
    }
    
    func collectMarkupStyle(_ markup: Markup) -> MarkupStyle? {
        // collect from upstream
        // String("Test") -> Bold -> Italic -> Root
        // Result: style: Bold+Italic
        // ä¸€å±‚ä¸€å±‚ç½‘ä¸Šæ‰¾ parent tag çš„ markupstyle
        // ç„¶åä¸€å±‚ä¸€å±‚ç»§æ‰¿æ ·å¼
        var currentMarkup: Markup? = markup.parentMarkup
        var currentStyle = components.value(markup: markup)
        while let thisMarkup = currentMarkup {
            guard let thisMarkupStyle = components.value(markup: thisMarkup) else {
                currentMarkup = thisMarkup.parentMarkup
                continue
            }

            if var thisCurrentStyle = currentStyle {
                thisCurrentStyle.fillIfNil(from: thisMarkupStyle)
                currentStyle = thisCurrentStyle
            } else {
                currentStyle = thisMarkupStyle
            }

            currentMarkup = thisMarkup.parentMarkup
        }
        
        if var currentStyle = currentStyle {
            currentStyle.fillIfNil(from: rootStyle)
            return currentStyle
        } else {
            return rootStyle
        }
    }
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [MarkupNSAttributedStringVisitor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/Processor/MarkupNSAttributedStringVisitor.swift){:target="_blank"} å®ä½œ



![è¿ä½œæµç¨‹åŠç»“æœå¦‚ä¸Šå›¾](/assets/2724f02f6e7/1*gJA_6uM5tQw2kUJsqIssuw.png)



è¿ä½œæµç¨‹åŠç»“æœå¦‚ä¸Šå›¾



**æœ€ç»ˆæˆ‘ä»¬å¯ä»¥å¾—åˆ°:**



![](/assets/2724f02f6e7/1*LOXfC8yYg2JCeoCH5m7kGA.png)



```swift
Li{
    NSColor = "Blue";
    NSFont = "<UICTFont: 0x145d17600> font-family: \".SFUI-Regular\"; font-weight: normal; font-style: normal; font-size: 13.00pt";
    NSLink = "https://zhgchg.li";
}nk{
    NSColor = "Blue";
    NSFont = "<UICTFont: 0x145d18710> font-family: \".SFUI-Semibold\"; font-weight: bold; font-style: normal; font-size: 13.00pt";
    NSLink = "https://zhgchg.li";
}Bold{
    NSFont = "<UICTFont: 0x145d18710> font-family: \".SFUI-Semibold\"; font-weight: bold; font-style: normal; font-size: 13.00pt";
}
```



> ğŸ‰ğŸ‰ğŸ‰ğŸ‰å®ŒæˆğŸ‰ğŸ‰ğŸ‰ğŸ‰



åˆ°æ­¤æˆ‘ä»¬å°±å®Œæˆäº† HTML String to NSAttributedString çš„æ•´ä¸ªè½¬æ¢è¿‡ç¨‹ã€‚



#### Stripper â€” å‰¥ç¦» HTML Tag



å‰¥ç¦» HTML Tag çš„éƒ¨åˆ†ç›¸å¯¹ç®€å•ï¼Œåªéœ€è¦:



```swift
func attributedString(_ markup: Markup) -> NSAttributedString {
  if let rawStringMarkup = markup as? RawStringMarkup {
    return rawStringMarkup.attributedString
  } else {
    return markup.childMarkups.compactMap({ attributedString($0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in
      partialResult.append(attributedString)
      return partialResult
    }
  }
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [MarkupStripperProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/Processor/MarkupStripperProcessor.swift){:target="_blank"} å®ä½œ



ç±»ä¼¼ Renderï¼Œä½†çº¯ç²¹æ‰¾åˆ° RawStringMarkup åè¿”å›å†…å®¹ã€‚



#### Extend â€” åŠ¨æ€æ‰©å……



ä¸ºäº†èƒ½æ‰©å……æ¶µç›–æ‰€æœ‰ HTMLTag/Style Attribute æ‰€ä»¥å¼€äº†ä¸€ä¸ªåŠ¨æ€æ‰©å……çš„å£ï¼Œæ–¹ä¾¿ç›´æ¥ä» Code åŠ¨æ€æ‰©å……ç‰©ä»¶ã€‚



```swift
public struct ExtendTagName: HTMLTagName {
    public let string: String
    
    public init(_ w3cHTMLTagName: WC3HTMLTagName) {
        self.string = w3cHTMLTagName.rawValue
    }
    
    public init(_ string: String) {
        self.string = string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}
// to
final class ExtendMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []

    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

//----

public struct ExtendHTMLTagStyleAttribute: HTMLTagStyleAttribute {
    public let styleName: String
    public let render: ((String) -> (MarkupStyle?)) // åŠ¨æ€ç”¨ clourse å˜æ›´ MarkupStyle
    
    public init(styleName: String, render: @escaping ((String) -> (MarkupStyle?))) {
        self.styleName = styleName
        self.render = render
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagStyleAttributeVisitor {
        return visitor.visit(self)
    }
}
```



#### ZHTMLParserBuilder



æœ€åæˆ‘ä»¬ä½¿ç”¨ Builder Pattern è®©å¤–éƒ¨ Module å¯ä»¥å¿«é€Ÿæ„å»º ZMarkupParser æ‰€éœ€çš„ç‰©ä»¶ï¼Œå¹¶åšå¥½ Access Level Controlã€‚



```swift
public final class ZHTMLParserBuilder {
    
    private(set) var htmlTags: [HTMLTag] = []
    private(set) var styleAttributes: [HTMLTagStyleAttribute] = []
    private(set) var rootStyle: MarkupStyle?
    private(set) var policy: MarkupStylePolicy = .respectMarkupStyleFromCode
    
    public init() {
        
    }
    
    public static func initWithDefault() -> Self {
        var builder = Self.init()
        for htmlTagName in ZHTMLParserBuilder.htmlTagNames {
            builder = builder.add(htmlTagName)
        }
        for styleAttribute in ZHTMLParserBuilder.styleAttributes {
            builder = builder.add(styleAttribute)
        }
        return builder
    }
    
    public func set(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle?) -> Self {
        return self.add(htmlTagName, withCustomStyle: markupStyle)
    }
    
    public func add(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle? = nil) -> Self {
        // åŒä¸ª tagName åªèƒ½å­˜åœ¨ä¸€ä¸ª
        htmlTags.removeAll { htmlTag in
            return htmlTag.tagName.string == htmlTagName.string
        }
        
        htmlTags.append(HTMLTag(tagName: htmlTagName, customStyle: markupStyle))
        
        return self
    }
    
    public func add(_ styleAttribute: HTMLTagStyleAttribute) -> Self {
        styleAttributes.removeAll { thisStyleAttribute in
            return thisStyleAttribute.styleName == styleAttribute.styleName
        }
        
        styleAttributes.append(styleAttribute)
        
        return self
    }
    
    public func set(rootStyle: MarkupStyle) -> Self {
        self.rootStyle = rootStyle
        return self
    }
    
    public func set(policy: MarkupStylePolicy) -> Self {
        self.policy = policy
        return self
    }
    
    public func build() -> ZHTMLParser {
        // ZHTMLParser init åªå¼€æ”¾ internal, å¤–éƒ¨æ— æ³•ç›´æ¥ init
        // åªèƒ½é€è¿‡ ZHTMLParserBuilder init
        return ZHTMLParser(htmlTags: htmlTags, styleAttributes: styleAttributes, policy: policy, rootStyle: rootStyle)
    }
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [ZHTMLParserBuilder.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/ZHTMLParserBuilder.swift){:target="_blank"} å®ä½œ



**initWithDefault é¢„è®¾ä¼šåŠ å…¥æ‰€æœ‰å·²ç»å®ç°çš„ HTMLTagName/Style Attribute**



```swift
public extension ZHTMLParserBuilder {
    static var htmlTagNames: [HTMLTagName] {
        return [
            A_HTMLTagName(),
            B_HTMLTagName(),
            BR_HTMLTagName(),
            DIV_HTMLTagName(),
            HR_HTMLTagName(),
            I_HTMLTagName(),
            LI_HTMLTagName(),
            OL_HTMLTagName(),
            P_HTMLTagName(),
            SPAN_HTMLTagName(),
            STRONG_HTMLTagName(),
            U_HTMLTagName(),
            UL_HTMLTagName(),
            DEL_HTMLTagName(),
            TR_HTMLTagName(),
            TD_HTMLTagName(),
            TH_HTMLTagName(),
            TABLE_HTMLTagName(),
            IMG_HTMLTagName(handler: nil),
            // ...
        ]
    }
}

public extension ZHTMLParserBuilder {
    static var styleAttributes: [HTMLTagStyleAttribute] {
        return [
            ColorHTMLTagStyleAttribute(),
            BackgroundColorHTMLTagStyleAttribute(),
            FontSizeHTMLTagStyleAttribute(),
            FontWeightHTMLTagStyleAttribute(),
            LineHeightHTMLTagStyleAttribute(),
            WordSpacingHTMLTagStyleAttribute(),
            // ...
        ]
    }
}
```



ZHTMLParser init åªå¼€æ”¾ internalï¼Œå¤–éƒ¨æ— æ³•ç›´æ¥ initï¼Œåªèƒ½é€è¿‡ ZHTMLParserBuilder initã€‚



**ZHTMLParser å°è£…äº† Render/Selector/Stripper æ“ä½œ:**



```swift
public final class ZHTMLParser: ZMarkupParser {
    let htmlTags: [HTMLTag]
    let styleAttributes: [HTMLTagStyleAttribute]
    let rootStyle: MarkupStyle?

    internal init(...) {
    }
    
    // å–å¾— link style attributes
    public var linkTextAttributes: [NSAttributedString.Key: Any] {
        // ...
    }
    
    public func selector(_ string: String) -> HTMLSelector {
        // ...
    }
    
    public func selector(_ attributedString: NSAttributedString) -> HTMLSelector {
        // ...
    }
    
    public func render(_ string: String) -> NSAttributedString {
        // ...
    }
    
    // å…è®¸ä½¿ç”¨ HTMLSelector ç»“æœæ¸²æŸ“å‡ºèŠ‚ç‚¹å†…çš„ NSAttributedString
    public func render(_ selector: HTMLSelector) -> NSAttributedString {
        // ...
    }
    
    public func render(_ attributedString: NSAttributedString) -> NSAttributedString {
        // ...
    }
    
    public func stripper(_ string: String) -> String {
        // ...
    }
    
    public func stripper(_ attributedString: NSAttributedString) -> NSAttributedString {
        // ...
    }
    
  // ...
}
```



> å¯¹åº”åŸå§‹ç ä¸­çš„ [ZHTMLParser.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/ZHTMLParser.swift){:target="_blank"} å®ä½œ



#### UIKit é—®é¢˜



NSAttributedString çš„ç»“æœæˆ‘ä»¬æœ€å¸¸çš„å°±æ˜¯æ”¾åˆ° UITextView ä¸­æ˜¾ç¤ºï¼Œä½†æ˜¯è¦æ³¨æ„:



- UITextView é‡Œçš„è¿ç»“æ ·å¼æ˜¯ç»Ÿä¸€çœ‹ `linkTextAttributes` è®¾å®šè¿ç»“æ ·å¼ï¼Œä¸ä¼šçœ‹ NSAttributedString.Key çš„è®¾å®šï¼Œä¸”æ— æ³•ä¸ªåˆ«è®¾å®šæ ·å¼ï¼›å› æ­¤æ‰ä¼šæœ‰ `ZMarkupParser.linkTextAttributes` è¿™ä¸ªå¼€å£ã€‚


- UILabel æš‚æ—¶æ²¡æœ‰æ–¹å¼æ”¹å˜è¿ç»“æ ·å¼ï¼Œä¸”å›  UILabel æ²¡æœ‰ TextStroageï¼Œè‹¥è¦æ‹¿æ¥è½½å…¥ NSTextAttachment å›¾ç‰‡ï¼›éœ€è¦å¦å¤–æŠ“ä½ UILabelã€‚



```swift
public extension UITextView {
    func setHtmlString(_ string: String, with parser: ZHTMLParser) {
        self.setHtmlString(NSAttributedString(string: string), with: parser)
    }
    
    func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) {
        self.attributedText = parser.render(string)
        self.linkTextAttributes = parser.linkTextAttributes
    }
}
public extension UILabel {
    func setHtmlString(_ string: String, with parser: ZHTMLParser) {
        self.setHtmlString(NSAttributedString(string: string), with: parser)
    }
    
    func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) {
        let attributedString = parser.render(string)
        attributedString.enumerateAttribute(NSAttributedString.Key.attachment, in: NSMakeRange(0, attributedString.string.utf16.count), options: []) { (value, effectiveRange, nil) in
            guard let attachment = value as? ZNSTextAttachment else {
                return
            }
            
            attachment.register(self)
        }
        
        self.attributedText = attributedString
    }
}
```



å› æ­¤å¤š Extension äº† UIKitï¼Œå¤–éƒ¨åªéœ€æ— è„‘ `setHTMLString()` å³å¯å®Œæˆç»‘å®šã€‚



#### å¤æ‚çš„æ¸²æŸ“é¡¹ç›®â€” é¡¹ç›®æ¸…å•



å…³äºé¡¹ç›®æ¸…å•çš„å®ç°çºªå½•ã€‚



**åœ¨ HTML ä¸­ä½¿ç”¨ `<ol>` / `<ul>` åŒ…è£… `<li>` è¡¨ç¤ºé¡¹ç›®æ¸…å•:**



```xml
<ul>
    <li>ItemA</li>
    <li>ItemB</li>
    <li>ItemC</li>
    //...
</ul>
```



ä½¿ç”¨åŒå‰æ–‡è§£ææ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ `visit(_ markup: ListItemMarkup)` å–å¾—å…¶ä»– list item çŸ¥é“å½“å‰ list index (å¾—åˆ©äºæœ‰è½¬æ¢æˆ AST)ã€‚



```swift
func visit(_ markup: ListItemMarkup) -> Result {
  let siblingListItems = markup.parentMarkup?.childMarkups.filter({ $0 is ListItemMarkup }) ?? []
  let position = (siblingListItems.firstIndex(where: { $0 === markup }) ?? 0)
}
```



NSParagraphStyle æœ‰ä¸€ä¸ª NSTextList ç‰©ä»¶å¯ä»¥ç”¨æ¥æ˜¾ç¤º list itemï¼Œä½†æ˜¯åœ¨å®ä½œä¸Šæ— æ³•å®¢åˆ¶åŒ–ç©ºç™½çš„å®½åº¦ (ä¸ªäººè§‰å¾—ç©ºç™½å¤ªå¤§)ï¼Œå¦‚æœé¡¹ç›®ç¬¦å·ä¸å­—ä¸²ä¸­é—´æœ‰ç©ºç™½ä¼šè®©æ¢è¡Œè§¦å‘åœ¨æ­¤ï¼Œæ˜¾ç¤ºä¼šæœ‰ç‚¹å¥‡æ€ªï¼Œå¦‚ä¸‹å›¾:



![](/assets/2724f02f6e7/1*jvIgDjO4DNAKpPZF1balmw.png)



Beter éƒ¨åˆ†æœ‰æœºä¼šé€è¿‡ [è®¾å®š headIndent, firstLineHeadIndent, NSTextTab](https://www.objc.io/issues/9-strings/string-rendering/){:target="_blank"} å®ç°ï¼Œä½†æ˜¯æµ‹è¯•å‘ç°å­—ä¸²å¤ªé•¿ã€å¤§å°æœ‰å˜è¿˜æ˜¯æ— æ³•å®Œç¾å‘ˆç°ç»“æœã€‚



ç›®å‰åªåšåˆ° Acceptableï¼Œè‡ªå·±ç»„åˆé¡¹ç›®æ¸…å•å­—ä¸² insert åˆ°å­—ä¸²å‰ã€‚



æˆ‘ä»¬åªä½¿ç”¨åˆ° NSTextList.MarkerFormat ç”¨æ¥äº§é¡¹ç›®æ¸…å•ç¬¦å·ï¼Œè€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨ NSTextListã€‚



**æ¸…å•ç¬¦å·æ”¯æ´åˆ—è¡¨å¯å‚è€ƒï¼š** [MarkupStyleList.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyleList.swift){:target="_blank"}



**æœ€ç»ˆæ˜¾ç¤ºç»“æœï¼š(** `<ol><li>` **)**



![](/assets/2724f02f6e7/1*yM3VROfUNgnEBfIYwYwPnQ.png)



#### å¤æ‚çš„æ¸²æŸ“é¡¹ç›® â€” Table



ç±»ä¼¼ æ¸…å•é¡¹ç›®çš„å®ç°ï¼Œä½†æ˜¯æ˜¯è¡¨æ ¼ã€‚



**åœ¨ HTML ä¸­ä½¿ç”¨ `<table>` è¡¨æ ¼-&gt;åŒ…è£… `<tr>` è¡¨æ ¼åˆ—-&gt;åŒ…è£… `<td>/<th>` è¡¨ç¤ºè¡¨æ ¼æ ä½:**



```xml
<table>
  <tr>
    <th>Company</th>
    <th>Contact</th>
    <th>Country</th>
  </tr>
  <tr>
    <td>Alfreds Futterkiste</td>
    <td>Maria Anders</td>
    <td>Germany</td>
  </tr>
  <tr>
    <td>Centro comercial Moctezuma</td>
    <td>Francisco Chang</td>
    <td>Mexico</td>
  </tr>
</table>
```



å®æµ‹åŸç”Ÿçš„ `NSAttributedString.DocumentType.html` æ˜¯ç”¨ Private macOS API `NSTextBlock` æ¥å®Œæˆæ˜¾ç¤ºï¼Œå› æ­¤èƒ½å®Œæ•´æ˜¾ç¤º HTML è¡¨æ ¼æ ·å¼åŠå†…å®¹ã€‚



> æœ‰ç‚¹ä½œå¼Šï¼æˆ‘ä»¬æ— æ³•ç”¨ Private API ğŸ¥²



```swift
    func visit(_ markup: TableColumnMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        let siblingColumns = markup.parentMarkup?.childMarkups.filter({ $0 is TableColumnMarkup }) ?? []
        let position = (siblingColumns.firstIndex(where: { $0 === markup }) ?? 0)
        
        // æœ‰æ— ä»å¤–éƒ¨æŒ‡å®šæƒ³è¦çš„å®½åº¦, å¯è®¾ .max ä¸ truncated string
        var maxLength: Int? = markup.fixedMaxLength
        if maxLength == nil {
            // æ²¡æŒ‡å®šåˆ™æ‰¾åˆ°ç¬¬ä¸€è¡ŒåŒä¸€æ çš„ String length åšä¸º max length
            if let tableRowMarkup = markup.parentMarkup as? TableRowMarkup,
               let firstTableRow = tableRowMarkup.parentMarkup?.childMarkups.first(where: { $0 is TableRowMarkup }) as? TableRowMarkup {
                let firstTableRowColumns = firstTableRow.childMarkups.filter({ $0 is TableColumnMarkup })
                if firstTableRowColumns.indices.contains(position) {
                    let firstTableRowColumnAttributedString = collectAttributedString(firstTableRowColumns[position])
                    let length = firstTableRowColumnAttributedString.string.utf16.count
                    maxLength = length
                }
            }
        }
        
        if let maxLength = maxLength {
            // æ ä½è¶…è¿‡ maxLength åˆ™ truncated string
            if attributedString.string.utf16.count > maxLength {
                attributedString.mutableString.setString(String(attributedString.string.prefix(maxLength))+"...")
            } else {
                attributedString.mutableString.setString(attributedString.string.padding(toLength: maxLength, withPad: " ", startingAt: 0))
            }
        }
        
        if position < siblingColumns.count - 1 {
            // æ–°å¢ç©ºç™½åšä¸º spacing, å¤–éƒ¨å¯æŒ‡å®š spacing å®½åº¦å‡ ä¸ªç©ºç™½å­—
            attributedString.append(makeString(in: markup, string: String(repeating: " ", count: markup.spacing)))
        }
        
        return attributedString
    }
    
    func visit(_ markup: TableRowMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        attributedString.append(makeBreakLine(in: markup)) // æ–°å¢æ¢è¡Œ, è¯¦ç»†è¯·å‚è€ƒ Source Code
        return attributedString
    }
    
    func visit(_ markup: TableMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        attributedString.append(makeBreakLine(in: markup)) // æ–°å¢æ¢è¡Œ, è¯¦ç»†è¯·å‚è€ƒ Source Code
        attributedString.insert(makeBreakLine(in: markup), at: 0) // æ–°å¢æ¢è¡Œ, è¯¦ç»†è¯·å‚è€ƒ Source Code
        return attributedString
    }
```



**æœ€ç»ˆå‘ˆç°æ•ˆæœå¦‚ä¸‹å›¾ï¼š**



![](/assets/2724f02f6e7/1*Dft7H2BbeyWIO-dH4QpuSw.png)



not perfect, but acceptable.



#### å¤æ‚çš„æ¸²æŸ“é¡¹ç›® â€” Image



æœ€ç»ˆæ¥è®²ä¸€ä¸ªæœ€å¤§çš„é­”ç‹ï¼Œè½½å…¥è¿œç«¯å›¾ç‰‡åˆ° NSAttributedStringã€‚



**åœ¨ HTML ä¸­ä½¿ç”¨ `<img>` è¡¨ç¤ºå›¾ç‰‡:**



```xml
<img src="https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg" width="300" height="125"/>
```



å¹¶å¯é€è¿‡ `width` / `height` HTML Attribute æŒ‡å®šæƒ³è¦çš„æ˜¾ç¤ºå¤§å°ã€‚



åœ¨ NSAttributedString ä¸­æ˜¾ç¤ºå›¾ç‰‡ï¼Œæ¯”æƒ³åƒä¸­å¤æ‚å¾ˆå¤šï¼›ä¸”æ²¡æœ‰å¾ˆå¥½çš„å®ç°ï¼Œä¹‹å‰åš [UITextView æ–‡ç»•å›¾](../e37d66ea1146/) æ—¶æœ‰ç¨å¾®è¸©è¿‡å‘ï¼Œä½†è¿™æ¬¡åœ¨ç ”ç©¶ä¸€è½®å‘ç°è¿˜æ˜¯æ²¡æœ‰ä¸€ä¸ªå®Œç¾çš„è§£å†³æ–¹æ¡ˆã€‚



ç›®å‰å…ˆå¿½ç•¥ NSTextAttachment åŸç”Ÿä¸èƒ½ reuse é‡Šæ”¾è®°å¿†ä½“çš„é—®é¢˜ï¼Œå…ˆåªå®ç°ä»è¿œç«¯ä¸‹è½½å›¾ç‰‡æ”¾åˆ° NSTextAttachment åœ¨æ”¾åˆ° NSAttributedString ä¸­ï¼Œå¹¶å®ç°è‡ªåŠ¨æ›´æ–°å†…å®¹ã€‚



**æ­¤ç³»åˆ—æ“ä½œåˆå†æ‹†åˆ°å¦ä¸€ä¸ªå°çš„ Project å®ç°ï¼Œæƒ³è¯´æ—¥åæ¯”è¾ƒå¥½ä¼˜åŒ–è·Ÿå¤ç”¨åˆ°å…¶ä»– Project:**



[![](https://opengraph.githubassets.com/5c63c82d77259bfe295dc17bf3eedc073f2e23dbd9598642813af0bcecb5b701/ZhgChgLi/ZNSTextAttachment)](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"}



ä¸»è¦æ˜¯å‚è€ƒ [Asynchronous NSTextAttachments](https://www.cocoanetics.com/2016/09/asynchronous-nstextattachment-1/){:target="_blank"} è¿™ç³»åˆ—æ–‡ç« å®ç°ï¼Œä½†æ˜¯æ›¿æ¢äº†æœ€åçš„æ›´æ–°å†…å®¹éƒ¨åˆ†(ä¸‹è½½å®Œåè¦åˆ·æ–° UI æ‰ä¼šå‘ˆç°)è¿˜æœ‰å¢åŠ  Delegate/DataSource ç»™å¤–éƒ¨æ‰©å……ä½¿ç”¨ã€‚



![è¿åšæµç¨‹ä¸å…³ç³»å¦‚ä¸Šå›¾](/assets/2724f02f6e7/1*JZ8IVVNj9B2l-UBemGbAig.png)



è¿åšæµç¨‹ä¸å…³ç³»å¦‚ä¸Šå›¾



- å®£å‘Š ZNSTextAttachmentable ç‰©ä»¶ï¼Œå°è£… NSTextStorage ç‰©ä»¶(UITextViewè‡ªå¸¦)åŠ UILabel æœ¬èº« (UILabel æ—  NSTextStorage)
  æ“ä½œæ–¹æ³•ä»…ä¸ºå®ç° replace attributedString from NSRange. ( `func replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment)` )


- å®ç°åŸç†æ˜¯å…ˆä½¿ç”¨ `ZNSTextAttachment` åŒ…è£… imageURLã€PlaceholderImageã€æ˜¾è¦æ˜¾ç¤ºçš„å¤§å°èµ„è®¯ï¼Œç„¶åå…ˆç”¨ placeHolder ç›´æ¥æ˜¾ç¤ºå›¾ç‰‡


- å½“ ç³»ç»Ÿéœ€è¦æ­¤å›¾ç‰‡åœ¨ç”»é¢æ—¶ä¼šå‘¼å« `image(forBoundsâ€¦` æ–¹æ³•ï¼Œæ­¤æ—¶æˆ‘ä»¬å¼€å§‹ä¸‹è½½ Image Data


- DataSource å‡ºå»è®©å¤–éƒ¨å¯å†³å®šæ€ä¹ˆä¸‹è½½æˆ–å®ç° Image Cache Policyï¼Œé¢„è®¾ç›´æ¥ä½¿ç”¨ URLSession è¯·æ±‚å›¾ç‰‡ Data


- ä¸‹è½½å®Œæˆå new ä¸€ä¸ªæ–°çš„ `ZResizableNSTextAttachment` å¹¶åœ¨ `attachmentBounds(forâ€¦` å®ç°è‡ªå®šå›¾ç‰‡å¤§å°çš„é€»è¾‘


- å‘¼å« `replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment)` æ–¹æ³•ï¼Œå°† `ZNSTextAttachment` ä½ç½®æ›¿æ¢ä¸º `ZResizableNSTextAttachment`


- å‘å‡º didLoad Delegate é€šçŸ¥ï¼Œè®©å¤–éƒ¨æœ‰éœ€è¦æ—¶å¯ä¸²æ¥


- å®Œæˆ



> **è¯¦ç»†ç¨‹å¼ç å¯å‚è€ƒ [Source Code](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"}** ã€‚



ä¸ä½¿ç”¨ `NSLayoutManager.invalidateLayout(forCharacterRange: range, actualCharacterRange: nil)` ã€ `NSLayoutManager.invalidateDisplay(forCharacterRange: range)` åˆ·æ–° UI çš„åŸå› æ˜¯å‘ç° UI æ²¡æœ‰æ­£ç¡®çš„æ˜¾ç¤ºæ›´æ–°ï¼›æ—¢ç„¶éƒ½çŸ¥é“æ‰€åœ¨ Range äº†ï¼Œç›´æ¥è§¦å‘å–ä»£ NSAttributedStringï¼Œèƒ½ç¡®ä¿ UI æ­£ç¡®æ›´æ–°ã€‚



æœ€ç»ˆæ˜¾ç¤ºç»“æœå¦‚ä¸‹ï¼š



```xml
<span style="color:red">ã“ã‚“ã«ã¡ã¯</span>ã“ã‚“ã«ã¡ã¯ã“ã‚“ã«ã¡ã¯ <br />
<img src="https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg"/>
```



![](/assets/2724f02f6e7/1*bl65v-SVOK3H9ajR-Ksg6w.png)



### Testing & Continuous Integration



è¿™æ¬¡ä¸“æ¡ˆé™¤äº†æ’°å†™ Unit Test å•å…ƒæµ‹è¯•ä¹‹å¤–è¿˜å»ºç«‹äº† Snapshot Test åšæ•´åˆæµ‹è¯•æ–¹ä¾¿å¯¹æœ€ç»ˆçš„ NSAttributedString åšç»¼è§‚çš„æµ‹è¯•æ¯”è¾ƒã€‚



ä¸»è¦åŠŸèƒ½é€»è¾‘éƒ½æœ‰ UnitTests å¹¶åŠ ä¸Šæ•´åˆæµ‹è¯•ï¼Œæœ€ç»ˆ [Test Coverage](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"} åœ¨ **85%** å·¦å³ã€‚



![[ZMarkupParser â€” codecov](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*wV6BZcEGYuT9B9Xy4QzI0w.png)



[ZMarkupParser â€” codecov](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}



#### Snapshot Test



[![](https://opengraph.githubassets.com/b3cc52a5b949767e4cb0af82145ed6474334d3235bd785ee1f7891c6b65fd69a/pointfreeco/swift-snapshot-testing)](https://github.com/pointfreeco/swift-snapshot-testing){:target="_blank"}



**ç›´æ¥å¼•å…¥æ¡†æ¶ä½¿ç”¨:**



```swift
import SnapshotTesting
// ...
func testShouldKeppNSAttributedString() {
  let parser = ZHTMLParserBuilder.initWithDefault().build()
  let textView = UITextView()
  textView.frame.size.width = 390
  textView.isScrollEnabled = false
  textView.backgroundColor = .white
  textView.setHtmlString("html string...", with: parser)
  textView.layoutIfNeeded()
  assertSnapshot(matching: textView, as: .image, record: false)
}
// ...
```



![](/assets/2724f02f6e7/1*hLPeaOTOviA0jTPNOPu1hg.png)



ç›´æ¥æ¯”å¯¹æœ€ç»ˆç»“æœæ˜¯å¦ç¬¦åˆé¢„æœŸï¼Œç¡®ä¿è°ƒæ•´æ•´åˆèµ·æ¥æ²¡æœ‰å¼‚å¸¸ã€‚



#### Codecov Test Coverage



ä¸²æ¥ [Codecov.io](https://about.codecov.io){:target="_blank"} (free for Public Repo) è¯„ä¼° Test Coverageï¼Œåªéœ€å®‰è£… Codecov Github App & è®¾è®¡å³å¯ã€‚



[![](https://storage.googleapis.com/codecov-cdn/static/Codecov-icon-600x600.png)](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}



Codecov &lt;-&gt; Github Repo è®¾å®šå¥½åï¼Œä¹Ÿå¯ä»¥åœ¨ä¸“æ¡ˆæ ¹ç›®å½•åŠ ä¸Š `codecov.yml`



```yaml
comment:                  # this is a top-level key
  layout: "reach, diff, flags, files"
  behavior: default
  require_changes: false  # if true: only post the comment if coverage changes
  require_base: no        # [yes :: must have a base report to post]
  require_head: yes       # [yes :: must have a head report to post]
```



è®¾å®šæ¡£ï¼Œè¿™æ ·å¯ä»¥å¯ç”¨æ¯ä¸ª PR å‘å‡ºåï¼Œè‡ªåŠ¨æŠŠ CI è·‘çš„ç»“æœ Comment åˆ°å†…å®¹ã€‚



![](/assets/2724f02f6e7/1*AcKpF4dijglahV-iVYLvvA.png)



#### Continuous Integration



Github Action, CI æ•´åˆ: `ci.yml`



```yaml
name: CI

on:
  workflow_dispatch:
  pull_request:
    types: [opened, reopened]
  push:
    branches:
    - main

jobs:
  build:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v3
      - name: spm build and test
        run: \\|
          set -o pipefail
          xcodebuild test -workspace ZMarkupParser.xcworkspace -testPlan ZMarkupParser -scheme ZMarkupParser -enableCodeCoverage YES -resultBundlePath './scripts/TestResult.xcresult' -destination 'platform=iOS Simulator,name=iPhone 14,OS=16.1' build test \\| xcpretty
      - name: Codecov
        uses: codecov/codecov-action@v3.1.1
        with:
          xcode: true
          xcode_archive_path: './scripts/TestResult.xcresult'
```



æ­¤è®¾å®šæ˜¯åœ¨ PR opened/reopend or push main branch æ—¶è·‘ build and test æœ€åæŠŠ test coverage æŠ¥å‘Šä¸Šä¼ åˆ° codecov.



#### Regex



å…³äºæ­£è§„è¡¨ç¤ºæ³•ï¼Œæ¯ç”¨åˆ°ä¸€æ¬¡å°±åˆå†ç²¾è¿›ä¸€æ¬¡ï¼›è¿™æ¬¡å®é™…æ²¡ç”¨åˆ°å¤ªå¤šï¼Œä½†æ˜¯å› ä¸ºæœ¬æ¥æƒ³ç”¨ä¸€ä¸ªæ­£åˆ™æŒ–å‡ºæˆå¯¹çš„ HTML Tag æ‰€ä»¥ä¹Ÿå¤šç ”ç©¶è¿‡è¦æ€ä¹ˆæ’°å†™ã€‚



ä¸€äº›è¿™æ¬¡æ–°å­¦ä¹ çš„ cheat sheet ç¬”è®°â€¦



- `?:` å¯ä»¥è®© ( ) åŒ¹é… group ç»“æœï¼Œä½†ä¸ä¼šæ•è·è¿”å›
  e.g. `(?:https?:\/\/)?(?:www\.)?example\.com` åœ¨ `https://www,example.com` ä¼šè¿”å›æ•´ä¸ªç½‘å€è€Œä¸æ˜¯ `https://` , `www`


- `.+?` éè´ªå©ªçš„åŒ¹é… (æ‰¾åˆ°æœ€è¿‘çš„å°±è¿”å›)
  e.g. `<.+?>` åœ¨ `<a>test</a>` ä¼šè¿”å› `<a>` , `</a>` è€Œéæ•´ä¸ªå­—ä¸²


- `(?=XYZ)` ä»»ä½•å­—ä¸²ç›´åˆ° `XYZ` å­—ä¸²å‡ºç°ï¼›è¦æ³¨æ„ï¼Œå¦ä¸€ä¸ªä¸ä¹‹ç›¸ä¼¼çš„ `[^XYZ]` æ˜¯ä»£è¡¨ä»»ä½•å­—ä¸²ç›´åˆ° `X or Y or Z` å­—å…ƒå‡ºç°
  e.g. `(?:__)(.+?(?=__))(?:__)` (ä»»ä½•å­—ä¸²ç›´åˆ° `__` ) ä¼šåŒ¹é…å‡º `test`


- `?R` é€’å›å¾€å†…æ‰¾ä¸€æ ·è§„åˆ™çš„å€¼
  e.g. `\((?:[^()]\\|((?R)))+\)` åœ¨ `(simple) (and(nested))` ä¼šåŒ¹é…å‡º `(simple)` , `(and(nested))` , `(nested)`


- `?<GroupName>` â€¦ `\k<GroupName>` åŒ¹é…å‰é¢çš„ Group Name
  e.g. `(?<tagName><a>).*(\k<GroupName>)`


- `(?(X)yes\\|no)` ç¬¬ `X` ä¸ªåŒ¹é…ç»“æœæœ‰å€¼(ä¹Ÿå¯ä»¥ç”¨ Group Name)æ—¶åˆ™åŒ¹é…åé¢æ¡ä»¶ `yes` å¦åˆ™åŒ¹é… `no`
  **Swift æš‚æ—¶ä¸æ”¯æ´**



**å…¶ä»– Regex å¥½æ–‡ï¼š**



- [Swift æ­£åˆ™é€ŸæŸ¥æ‰‹å†Œ](https://onevcat.com/2022/11/swift-regex/){:target="_blank"}


- [æ­£åˆ™è¡¨è¾¾å¼æ˜¯å¦‚ä½•è¿ä½œçš„ï¼Ÿ](https://mp.weixin.qq.com/s/i_C4ATnajxRDGlTA8dJDHg){:target="_blank"} -&gt; **åç»­ä¼˜åŒ–æ­¤ä¸“æ¡ˆçš„æ­£åˆ™æ•ˆèƒ½æ—¶å¯å‚è€ƒ**


- [Regex é”™è¯¯å¯¼è‡´æ— ç©·å¯»æ‰¾ï¼Œæœ€ç»ˆå¼•å‘ä¼ºæœå™¨æ•…éšœçš„æ¡ˆä¾‹](https://juejin.cn/post/6850418120390082574){:target="_blank"}


- [Regex101 å³ä¸‹æ–¹å¯æŸ¥è¯¢æ‰€æœ‰æ­£åˆ™è§„åˆ™](https://regex101.com){:target="_blank"}



#### Swift Package Manager & Cocoapods



è¿™ä¹Ÿæ˜¯æˆ‘ç¬¬ä¸€æ¬¡å¼€å‘ SPM & Cocoapodsâ€¦è›®æœ‰è¶£çš„ï¼ŒSPM çœŸçš„æ–¹ä¾¿ï¼›ä½†æ˜¯è¸©åˆ°åŒæ—¶ä¸¤ä¸ªä¸“æ¡ˆä¾èµ–åŒä¸ªå¥—ä»¶çš„è¯ï¼ŒåŒæ—¶å¼€ä¸¤ä¸ªä¸“æ¡ˆä¼šæœ‰å…¶ä¸­ä¸€ä¸ªæ‰¾ä¸åˆ°è¯¥å¥—ä»¶ç„¶å Build ä¸èµ·æ¥ã€‚ã€‚ã€‚



Cocoapods æœ‰ä¸Šä¼  ZMarkupParser ä½†æ²¡æµ‹è¯•æ­£ä¸æ­£å¸¸ï¼Œå› ä¸ºæˆ‘æ˜¯ç”¨ SPM ğŸ˜ã€‚



#### ChatGPT



å®é™…æ­é…å¼€å‘ä½“éªŒä¸‹æ¥ï¼Œè§‰å¾—åªæœ‰åœ¨ååŠ©æ¶¦ç¨¿ Readme æ—¶æœ€æœ‰ç”¨ï¼›åœ¨å¼€å‘ä¸Šç›®å‰æ²¡ä½“ä¼šåˆ°æœ‰æ„Ÿçš„åœ°æ–¹ï¼›å› ä¸ºè¯¢é—® mid-senior ä»¥ä¸Šçš„é—®é¢˜ï¼Œä»–ä¹Ÿç»™ä¸å‡ºä¸ªç¡®åˆ‡ç­”æ¡ˆç”šæ˜¯æ˜¯é”™è¯¯çš„ç­”æ¡ˆ (æœ‰é‡åˆ°é—®ä»–ä¸€äº›æ­£åˆ™è§„åˆ™ï¼Œç­”æ¡ˆä¸å¤ªæ­£ç¡®)ï¼Œæ‰€ä»¥æœ€åè¿˜æ˜¯å›åˆ° Google äººå·¥æ‰¾æ­£ç¡®è§£ç­”ã€‚



æ›´ä¸è¦è¯´è¯·ä»–å†™ Code äº†ï¼Œé™¤éæ˜¯ç®€å•çš„ Code Gen Objectï¼›ä¸ç„¶ä¸è¦å¹»æƒ³ä»–èƒ½ç›´æ¥å®Œæˆæ•´ä¸ªå·¥å…·æ¶æ„ã€‚ *(è‡³å°‘ç›®å‰æ˜¯è¿™æ ·ï¼Œæ„Ÿè§‰å†™ Code è¿™å— Copilot å¯èƒ½æ›´æœ‰å¸®åŠ©)*



ä½†ä»–å¯ä»¥ç»™ä¸€äº›çŸ¥è¯†ç›²åŒºçš„å¤§æ–¹å‘ï¼Œè®©æˆ‘ä»¬èƒ½å¿«é€Ÿå¤§ç•¥çŸ¥é“æŸäº›åœ°æ–¹åº”è¯¥ä¼šæ€ä¹ˆåšï¼›æœ‰çš„æ—¶å€™æŒæ¡åº¦å¤ªä½ï¼Œåœ¨ Google åè€Œå¾ˆéš¾å¿«é€Ÿå®šä½åˆ°æ­£ç¡®çš„æ–¹å‘ï¼Œè¿™æ—¶å€™ ChatGPT å°±è›®æœ‰å¸®åŠ©çš„ã€‚



### å£°æ˜



å†ç»ä¸‰ä¸ªå¤šæœˆçš„ç ”ç©¶åŠå¼€å‘ï¼Œå·²ç–²æƒ«ä¸å ªï¼Œä½†è¿˜æ˜¯è¦å£°æ˜ä¸€ä¸‹æ­¤åšæ³•ä»…ä¸ºæˆ‘ç ”ç©¶åå¾—åˆ°çš„å¯è¡Œç»“æœï¼Œä¸ä¸€å®šæ˜¯æœ€ä½³è§£ï¼Œæˆ–è¿˜æœ‰å¯ä¼˜åŒ–çš„åœ°æ–¹ï¼Œè¿™ä¸“æ¡ˆæ›´åƒæ˜¯ä¸€ä¸ªæŠ›ç –å¼•ç‰ï¼Œå¸Œæœ›èƒ½å¾—åˆ°ä¸€ä¸ª Markup Language to NSAttributedString çš„å®Œç¾è§£ç­”ï¼Œ **éå¸¸æ¬¢è¿å¤§å®¶è´¡çŒ®ï¼›æœ‰è®¸å¤šäº‹é¡¹è¿˜éœ€è¦ç¾¤ä¼—çš„åŠ›é‡æ‰èƒ½å®Œå–„** ã€‚



### Contributing



![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} [â­](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*kXjJQnSIJ7x-lSIYtacRrQ.jpeg)



[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} [â­](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}



è¿™è¾¹å…ˆåˆ—ä¸€äº›æ­¤æ—¶æ­¤åˆ»(2023/03/12)æƒ³åˆ°èƒ½æ›´å¥½çš„åœ°æ–¹ï¼Œä¹‹åä¼šåœ¨ Repo ä¸Šçºªå½•ï¼š



1. æ•ˆèƒ½/ç®—æ³•çš„ä¼˜åŒ–ï¼Œè™½ç„¶æ¯”åŸç”Ÿ `NSAttributedString.DocumentType.html` å¿«é€Ÿä¸”ç¨³å®šï¼›ä½†è¿˜æœ‰éœ€å¤šä¼˜åŒ–ç©ºé—´ï¼Œæˆ‘ç›¸ä¿¡æ•ˆèƒ½ç»å¯¹ä¸å¦‚ XMLParserï¼›å¸Œæœ›æœ‰æœä¸€æ—¥èƒ½æœ‰åŒæ ·çš„æ•ˆèƒ½ä½†åˆèƒ½ä¿æŒå®¢åˆ¶åŒ–åŠè‡ªåŠ¨ä¿®æ­£å®¹é”™


2. æ”¯æ´æ›´å¤š HTML Tagã€Style Attribute è½¬æ¢è§£æ


3. [ZNSTextAttachment](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"} å†ä¼˜åŒ–ï¼Œå®ç° reuse èƒ½ï¼Œé‡Šæ”¾è®°å¿†ä½“ï¼›å¯èƒ½è¦ç ”ç©¶ CoreText


4. æ”¯æ´ Markdown è§£æï¼Œå› åº•å±‚æŠ½è±¡å…¶å®ä¸å±€é™äº HTMLï¼›æ‰€ä»¥åªè¦å»ºå¥½å‰é¢çš„ Markdown è½¬ Markup ç‰©ä»¶å°±èƒ½å®Œæˆ Markdown è§£æï¼›å› æ­¤æˆ‘å–åå« ZMarkupParserï¼Œè€Œä¸æ˜¯ ZHTMLParserï¼Œå°±æ˜¯å¸Œæœ›æœ‰æœä¸€æ—¥ä¹Ÿèƒ½æ”¯æ´ Markdown to NSAttributedString


5. æ”¯æ´ Any to Any, e.g. HTML To Markdown, Markdown To HTMLï¼Œå› æˆ‘ä»¬æœ‰åŸå§‹çš„ AST æ ‘(Markup ç‰©ä»¶)ï¼Œæ‰€ä»¥å®ç°ä»»æ„ Markup é—´çš„è½¬æ¢æ˜¯æœ‰æœºä¼šçš„


6. å®ç° css `!important` åŠŸèƒ½ï¼ŒåŠ å¼ºæŠ½è±¡ MarkupStyle çš„ç»§æ‰¿ç­–ç•¥


7. åŠ å¼º HTML Selector åŠŸèƒ½ï¼Œç›®å‰åªæ˜¯æœ€ç²—æµ…çš„ filter åŠŸèƒ½


8. å¥½å¤šå¥½å¤š, æ¬¢è¿å¼€ [issue](https://github.com/ZhgChgLi/ZMarkupParser/issues){:target="_blank"}



> [å¦‚æœæ‚¨å¿ƒæœ‰ä½™è€ŒåŠ›ä¸è¶³ï¼Œä¹Ÿå¯ä»¥é€è¿‡ç»™æˆ‘ä¸€é¢— â­ è®© Repo å¯ä»¥è¢«æ›´å¤šäººçœ‹è§ï¼Œè¿›è€Œè®© Github å¤§ç¥æœ‰æœºä¼šååŠ©è´¡çŒ®ï¼](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}



### æ€»ç»“



![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*A0yXupXW9-F9ZWe4gp2ObA.jpeg)



[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}



ä»¥ä¸Šå°±æ˜¯æˆ‘å¼€å‘ ZMarkupParser çš„æ‰€æœ‰æŠ€æœ¯ç»†èŠ‚åŠå¿ƒè·¯å†ç¨‹ï¼ŒèŠ±è´¹äº†æˆ‘å¿«ä¸‰ä¸ªæœˆçš„ä¸‹ç­åŠå‡æ—¥æ—¶é—´ï¼Œæ— æ•°çš„ç ”ç©¶åŠå®è·µè¿‡ç¨‹ï¼Œåˆ°æ’°å†™æµ‹è¯•ã€æå‡ Test Coverageã€å»ºç«‹ CIï¼›æœ€åæ‰æœ‰ä¸€ä¸ªçœ‹èµ·æ¥æœ‰ç‚¹æ ·å­çš„æˆæœï¼›å¸Œæœ›è¿™ä¸ªå·¥å…·æœ‰è§£å†³æ‰æœ‰ç›¸åŒå›°æ‰°çš„æœ‹å‹ï¼Œä¹Ÿå¸Œæœ›å¤§å®¶èƒ½ä¸€èµ·è®©è¿™ä¸ªå·¥å…·å˜å¾—æ›´å¥½ã€‚



![[pinkoi.com](https://www.pinkoi.com){:target="_blank"}](/assets/2724f02f6e7/0*9YdJaNSQXlAfmT21.jpg)



[pinkoi.com](https://www.pinkoi.com){:target="_blank"}



ç›®å‰æœ‰åº”ç”¨åœ¨æ•å¸ [pinkoi.com](https://www.pinkoi.com){:target="_blank"} çš„ iOS ç‰ˆ App ä¸Šï¼Œæ²¡æœ‰å‘ç°é—®é¢˜ã€‚ğŸ˜„



#### å»¶ä¼¸é˜…è¯»



- [ZMarkupParser HTML String è½¬æ¢ NSAttributedString å·¥å…·](../a5643de271e4/)


- [String Rendering](https://www.objc.io/issues/9-strings/string-rendering/){:target="_blank"}


- [Asynchronous NSTextAttachments](https://www.cocoanetics.com/2016/09/asynchronous-nstextattachment-1/){:target="_blank"}



æœ‰ä»»ä½•é—®é¢˜åŠæŒ‡æ•™æ¬¢è¿ [ä¸æˆ‘è”ç»œ](https://www.zhgchg.li/contact){:target="_blank"} ã€‚



*[Post](https://medium.com/zrealm-ios-dev/%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0-html-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B-2724f02f6e7){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*