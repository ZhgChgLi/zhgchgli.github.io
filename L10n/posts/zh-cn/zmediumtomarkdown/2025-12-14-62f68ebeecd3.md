---
author: ZhgChgLi
categories:
- ZRealm Dev.
date: 2025-12-14T08:17:06.562+0000
description: ä½¿ç”¨æœ‰é™çŠ¶æ€æœºä¸ Design Patterns å°è£… DispatchSourceTimerï¼Œä½¿å…¶æ›´å®‰å…¨æ˜“ç”¨ã€‚
image:
  path: /assets/62f68ebeecd3/1*2CWJW1fPOAZdU3nqeJ2JeQ.jpeg
last_modified_at: 2025-12-14T16:24:36.634+0000
render_with_liquid: false
tags:
- ios-app-development
- design-patterns
- timer
- swift
- finite-state-machine
- simplified-chinese
title: iOS Timer ä¸ DispatchSourceTimer å¦‚ä½•é€‰æ‹©ä¸å®‰å…¨çš„ä½¿ç”¨?
---

### [iOS] Timer ä¸ DispatchSourceTimer å¦‚ä½•é€‰æ‹©ä¸å®‰å…¨çš„ä½¿ç”¨?



ä½¿ç”¨æœ‰é™çŠ¶æ€æœºä¸ Design Patterns å°è£… DispatchSourceTimerï¼Œä½¿å…¶æ›´å®‰å…¨æ˜“ç”¨ã€‚



![Photo by [Ralph Hutter](https://unsplash.com/@pixelfreund?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/62f68ebeecd3/1*2CWJW1fPOAZdU3nqeJ2JeQ.jpeg)



Photo by [Ralph Hutter](https://unsplash.com/@pixelfreund?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}



#### å…³äº Timer



åœ¨ iOS å¼€å‘ä¸­ä¸€å®šä¼šé‡åˆ°çš„éœ€æ±‚åœºæ™¯ã€ŒTimer å®šæ—¶è§¦å‘å™¨ã€ï¼›ä» UI å±‚é¢ä¸Šæ˜¾ç¤ºå€’æ•°è®¡æ—¶ã€Banner è½®æ’­åˆ°èµ„æ–™é€»è¾‘å±‚é¢ä¸Šçš„å®šæ—¶å‘é€ Eventsã€å®šæ—¶æ¸…é™¤é‡Šæ”¾èµ„æ–™ï¼›æˆ‘ä»¬éƒ½éœ€è¦ Timer æ¥å¸®åŠ©æˆ‘ä»¬è¾¾æˆç›®æ ‡ã€‚



### [Foundation â€” Timer (NSTimer)](https://developer.apple.com/documentation/foundation/timer){:target="_blank"}



Timer åº”è¯¥æ˜¯å¤§å®¶æœ€ç›´è§‰ä¼šå…ˆæƒ³åˆ°çš„ APIï¼Œä½†æ˜¯åœ¨é€‰æ‹©åŠä½¿ç”¨ Timer ä¸Šæˆ‘ä»¬éœ€è¦æ³¨æ„ä»¥ä¸‹å‡ ä¸ªç‚¹ã€‚



#### ä¼˜ç¼ºç‚¹



**Timer çš„ä¼˜ç‚¹ï¼š**



- é»˜è®¤ä¸ UI å·¥ä½œæ•´åˆï¼Œä¸éœ€è¦ç‰¹åˆ«åˆ‡ Main Thread æ‰§è¡Œ


- è‡ªåŠ¨è°ƒæ•´è§¦å‘æ—¶æœºä¼˜åŒ–ä½¿ç”¨ç”µé‡


- ä½¿ç”¨å¤æ‚åº¦è¾ƒä½ï¼Œæœ€å¤šåªä¼šå‘ç”Ÿ Retain Cycle æˆ–å¿˜è®°åœæ­¢ Timerï¼Œä½†ä¸ä¼šç›´æ¥é€ æˆ Crash



**Timer çš„ç¼ºç‚¹ï¼š**



- ç²¾ç¡®åº¦å— RunLoop çŠ¶æ€å½±å“ï¼Œåœ¨ UI é«˜äº’åŠ¨æˆ– Mode åˆ‡æ¢æ—¶å¯èƒ½å»¶åè§¦å‘


- ä¸æ”¯æ´ `suspend` , `resume` , `activate` â€¦ç­‰è¿›é˜¶æ“ä½œ



#### é€‚åˆåœºæ™¯



UI å±‚é¢éœ€æ±‚ï¼Œä¾‹å¦‚è½®æ’­ Banners (Auto Scroll ScrollView)æˆ–æ˜¯ä¼˜æƒ åˆ¸é¢†å–å€’æ•°è®¡æ—¶ï¼›è¿™äº›åªè¦æ±‚ä½¿ç”¨è€…åœ¨å‰æ™¯å½“å‰ç”»é¢èƒ½å“åº”å†…å®¹çš„åœºæ™¯ï¼Œæˆ‘ä¼šé€‰æ‹©ç›´æ¥ç”¨ Timerï¼Œæ–¹ä¾¿ã€å¿«é€Ÿã€å®‰å…¨çš„è¾¾æˆç›®çš„ã€‚



#### ç”Ÿå‘½å‘¨æœŸ



![](/assets/62f68ebeecd3/1*rQrIoCxCdwoFCgqZc1zE8A.png)



åœ¨ UI Main Thread ä¸Šå»ºç«‹ Timerï¼ŒTimer ä¼šè¢« Main Thread çš„ RunLoop å¼ºæŒæœ‰ã€å¹¶é€è¿‡ RunLoop è½®è¯¢æœºåˆ¶å®šæœŸè§¦å‘ï¼Œç›´åˆ° Timer invalidate( ) æ‰ä¼šè¢«é‡Šæ”¾ï¼›å› æ­¤æˆ‘ä»¬éœ€è¦åœ¨ ViewController ä¸Šå¼ºæŒæœ‰ Timer å¹¶åœ¨ deinit æ—¶å‘¼å« Timer invalidate( )ï¼Œæ‰èƒ½åœ¨ç”»é¢é€€å‡ºåæ­£ç¡®ç»ˆæ­¢é‡Šæ”¾ Timerã€‚



- â­ï¸ï¸ï¸View Controller å¼ºæŒæœ‰ Timerï¼Œ **Timer çš„ Execution Block (handler / closure)åŠ¡å¿…ä¸º Weak Selfï¼›å¦åˆ™ä¼š Retain Cycleã€‚**


- â­ï¸ï¸ï¸åŠ¡å¿…åœ¨ View Controller ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶å‘¼å« Timer invalidate( )ï¼Œå¦åˆ™ RunLoop ä»ä¼šæŒæœ‰ Timer ç»§ç»­æ‰§è¡Œã€‚



> *RunLoop æ˜¯ Thread å†…çš„äº‹ä»¶å¤„ç†å›åœˆï¼Œä¼šè½®è¯¢æ¥æ”¶å¤„ç†äº‹ä»¶ï¼› **Main Thread ç³»ç»Ÿä¼šè‡ªåŠ¨å»ºç«‹ RunLoop (RunLoop.main)** ï¼Œé™¤æ­¤ä¹‹å¤–å…¶ä»– Thread ä¸ä¸€å®šä¼šæœ‰ RunLoopã€‚*



#### ä½¿ç”¨



æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ `Timer.scheduledTimer` å®£å‘Šä¸€ä¸ª Timer (ä¼šè‡ªåŠ¨åŠ å…¥ RunLoop.main & **Mode: .default** ):



```swift
final class HomeViewController: UIViewController {
    
    private var timer: Timer?
    
    deinit {
        self.timer?.invalidate()
        self.timer = nil
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        startCarousel()
    }
    
    private func startCarousel() {
        self.timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true, block: { [weak self] _ in
            self?.doSomething()
        })
    }

    private func doSomething() {
        print("Hello World!")
    }
}
```



ä¹Ÿå¯ä»¥è‡ªè¡Œå®£å‘Š Timer ç‰©ä»¶åŠ å…¥åˆ° RunLoop:



```swift
let timer= Timer(timeInterval: 1.0, repeats: true) { [weak self] _ in
  // do something..
}
self.timer = timer
// åŠ å…¥ RunLoop åæ‰ä¼šå¼€å§‹æ‰§è¡Œ
RunLoop.main.add(timer, forMode: .default)
```



#### Timer çš„æ“ä½œæ–¹æ³•



- `invalidate()` ç»ˆæ­¢ Timer


- `fire()` ç«‹å³è§¦å‘ä¸€æ¬¡



#### RunLoop **Mode çš„å½±å“**



- `.default` ï¼šé¢„è®¾åŠ å…¥çš„ Modeï¼Œä¸»è¦æ˜¯å¤„ç† UI æ˜¾ç¤ºã€‚
  **ä¼šåœ¨åˆ‡æ¢åˆ° `.tracking` Mode æ—¶å…ˆæš‚åœ**


- `.tracking` ï¼šå¤„ç† ScrollView æ»šåŠ¨ã€Gesture æ‰‹åŠ¿ã€‚


- `.common` ï¼š `.default` + `.tracking` éƒ½ä¼šå¤„ç†ã€‚



> *â­ï¸ï¸ï¸â­ï¸ï¸ï¸â­ï¸ï¸ï¸å› æ­¤åœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„ Timer æ˜¯åŠ åˆ° `.default` Modeï¼Œ **ä¼šåœ¨ä½¿ç”¨è€…æ»šåŠ¨ ScrollView æˆ–æ˜¯æ‰‹åŠ¿æ“ä½œæ—¶è‡ªåŠ¨æš‚åœ** ï¼Œç­‰åˆ°æ“ä½œç»“æŸåæ‰ä¼šç»§ç»­ï¼Œå¯èƒ½é€ æˆ Timer å»¶åè§¦å‘æˆ–æ˜¯æ¬¡æ•°ä½äºé¢„æœŸã€‚*



**å¯¹æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ Timer æ”¹åŠ å…¥åˆ° .common Mode å°±èƒ½è§£å†³ä»¥ä¸Šé—®é¢˜:**



```swift
RunLoop.main.add(timer, forMode: .common)
```



### [Grand Central Dispatch â€” DispatchSourceTimer](https://developer.apple.com/documentation/dispatch/dispatchsourcetimer){:target="_blank"}



é™¤äº† Timer ä¹‹å¤–ï¼ŒGCD ä¹Ÿæä¾›äº†å¦ä¸€ä¸ª DispatchSourceTimer æ–¹æ³•å¯ä¾›é€‰æ‹©ã€‚



#### ä¼˜ç¼ºç‚¹



**DispatchSourceTimer çš„ä¼˜ç‚¹ï¼š**



- æ“ä½œå¼¹æ€§(æ”¯æ´ `suspend` , `resume` ) è¾ƒå¥½


- ç²¾ç¡®åº¦ä¸å¯é ç¨‹åº¦è¾ƒé«˜ï¼šä¾èµ– GCD Queue


- å¯è‡ªè¡Œè®¾å®š leeway æ§åˆ¶è€—ç”µé‡


- å¯ç¨³å®šå¸¸é©»ä»»åŠ¡ (GCD Queue)



**DispatchSourceTimer çš„ç¼ºç‚¹ï¼š**



- UI æ“ä½œéœ€è‡ªè¡Œåˆ‡æ¢å› Main Thread


- API ä½¿ç”¨å¤æ‚ä¸”æœ‰é¡ºåºï¼Œ **ç”¨é”™ä¼š Crash**


- éœ€è¦å°è£…æ‰èƒ½å®‰å…¨ä½¿ç”¨



#### é€‚åˆåœºæ™¯



ç›¸è¾ƒ Timer é€‚åˆ UI å±‚é¢çš„åœºæ™¯ï¼ŒDispatchSourceTimer æ¯”è¾ƒé€‚åˆåšé‚£äº›è·Ÿ UI æˆ–ä½¿ç”¨è€…å½“å‰ç”»é¢æ— å…³çš„ä»»åŠ¡åœºæ™¯ï¼›æœ€å¸¸è§çš„å°±æ˜¯å‘é€ Tracking äº‹ä»¶ï¼Œæˆ‘ä»¬ä¼šå®šæ—¶æŠŠä½¿ç”¨è€…æ“ä½œäº§ç”Ÿçš„äº‹ä»¶å‘é€åˆ°ä¼ºæœå™¨ï¼Œæˆ–æ˜¯å®šæ—¶æ¸…ç†æ— ç”¨çš„ CoreData èµ„æ–™ï¼›è¿™äº›å°±å¾ˆé€‚åˆä½¿ç”¨ DispatchSourceTimerã€‚



#### ç”Ÿå‘½å‘¨æœŸ



![](/assets/62f68ebeecd3/1*2hIwImzm6ubpc5zK_roI3Q.png)



DispatchSourceTimer çš„ç”Ÿå‘½å‘¨æœŸå–å†³äºæ˜¯å¦ä»è¢«å¤–éƒ¨ç‰©ä»¶æŒæœ‰ï¼›GCD queue æœ¬èº«ä¸ä¼šå¼ºæŒæœ‰ timer çš„ ownerï¼Œåªè´Ÿè´£è°ƒåº¦ä¸æ‰§è¡Œäº‹ä»¶ã€‚



#### é—ªé€€é—®é¢˜



DispatchSourceTimer è™½ç„¶æä¾›æ›´å¤šå¯æ“ä½œæ–¹æ³•ï¼š `activate` , `suspend` , `resume` , `cancel` ï¼›ä½†æ˜¯å®ƒæå…¶æ•æ„Ÿï¼Œåªè¦å‘¼å«çš„é¡ºåºä¸å¯¹å°±ä¼šç›´é—ªé€€ (EXC_BREAKPOINT/DispatchSourceTimer) éå¸¸å±é™©ã€‚



![](/assets/62f68ebeecd3/1*04cApJDt29a-98zgb9Wd2A.png)



**ä»¥ä¸‹æƒ…å†µå‡ä¼šç›´æ¥é—ªé€€ï¼š**



- âŒ suspend( ) ä¸ resume( ) æ²¡æœ‰æˆå¯¹ä½¿ç”¨
  suspend( ) ååˆå‘¼å«ä¸€æ¬¡ suspend( )
  resume( ) ååˆå‘¼å«ä¸€æ¬¡ resume( )


- âŒ suspend( ) åå‘¼å« cancel( )
  éœ€è¦å…ˆ resume( ) æ‰èƒ½ cancel( )


- âŒ suspend( ) çŠ¶æ€ä¸‹ Timer è¢«é‡Šæ”¾ (nil)


- âŒ cancel( ) åå†å‘¼å«å…¶ä»–æ“ä½œ



#### ä½¿ç”¨ Finite-State Machine æœ‰é™çŠ¶æ€æœºå°è£…æ“ä½œ



è¿›å…¥æœ¬ç¯‡æ–‡ç« çš„å¦ä¸€ä¸ªé‡ç‚¹ï¼Œè¯¥å¦‚ä½•å®‰å…¨çš„ä½¿ç”¨ DispatchSourceTimer?



![](/assets/62f68ebeecd3/1*S33K4OWFUPMocZvM4dLWvw.png)



å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬ä½¿ç”¨æœ‰é™çŠ¶æ€æœºå°è£… DispatchSourceTimer çš„æ“ä½œï¼Œä½¿å…¶å¯ä»¥æ›´å®‰å…¨ã€æ›´å®¹æ˜“çš„ä½¿ç”¨:



```swift
final class DispatchSourceTimerMachine {
    // æœ‰é™çŠ¶æ€æœºæœ‰å“ªäº›çŠ¶æ€
    private enum TimerState {
        // åˆå§‹çŠ¶æ€
        case idle
        // æ‰§è¡Œä¸­
        case running
        // æš‚åœä¸­
        case suspended
        // ç»ˆæ­¢ä¸­
        case cancelled
    }

    private var timer: DispatchSourceTimer?
    private lazy var timerQueue: DispatchQueue = {
        DispatchQueue(label: "li.zhgchg.DispatchSourceTimerMachine", qos: .background)
    }()

    private var _state: TimerState = .idle
    
    deinit {
        // Owner ç‰©ä»¶æ¶ˆå¤±æ—¶ï¼ŒåŒæ­¥ cancel timer
        // è™½ä¸åšä¹Ÿä¸å½±å“(handler æ˜¯ weak)ï¼Œä½†æ˜¯å¯ä»¥ç¡®ä¿æµç¨‹ç¬¦åˆé¢„æœŸ
        if _state == .suspended {
            timer?.resume()
            _state = .running
        }
        if _state == .running {
            timer?.cancel()
            timer = nil
            _state = .cancelled
        }
    }

    // å¯åŠ¨ Timer
    func activate(repeatTimeInterval: DispatchTimeInterval, handler: DispatchSource.DispatchSourceHandler?) {
        // åªæœ‰ idle, cancelled çŠ¶æ€å¯ä»¥å¯ç”¨ Timer
        guard [.idle, .cancelled].contains(_state) else { return }
        
        // å»ºç«‹ Timer and activate()
        let timer = makeTimer(repeatTimeInterval: repeatTimeInterval, handler: handler)
        self.timer = timer
        timer.activate()
        
        // åˆ‡æ¢åˆ° running çŠ¶æ€
        _state = .running
    }

    // æš‚åœ Timer
    func suspend() {
        // åªæœ‰åœ¨ running çŠ¶æ€å¯ä»¥æš‚åœ Timer
        guard [.running].contains(_state) else { return }
        
        // æš‚åœ Timer
        timer?.suspend()
        
        // åˆ‡æ¢åˆ° suspended çŠ¶æ€
        _state = .suspended
    }

    // æ¢å¤ Timer
    func resume() {
        // åªæœ‰åœ¨ suspended çŠ¶æ€å¯ä»¥æ¢å¤ Timer
        guard [.suspended].contains(_state) else { return }
        
        // æ¢å¤ Timer
        timer?.resume()
        
        // åˆ‡æ¢åˆ° running çŠ¶æ€
        _state = .running
    }

    // ç»ˆæ­¢ Timer
    func cancel() {
        // åªæœ‰åœ¨ suspended, running çŠ¶æ€å¯ä»¥ç»ˆæ­¢ Timer
        guard [.suspended, .running].contains(_state) else { return }
        
        // å¦‚æœå½“å‰æ˜¯ suspended çŠ¶æ€ï¼Œå…ˆ resume() å†ç»ˆæ­¢
        // æ­¤ä¸º DispatchSourceTimer çš„é™åˆ¶ï¼Œåªèƒ½åœ¨ running æ‰èƒ½ cancel()
        if _state == .suspended {
            self.resume()
        }

        // ç»ˆæ­¢ Timer
        timer?.cancel()
        timer = nil
        
        // åˆ‡æ¢åˆ° cancelled çŠ¶æ€
        _state = .cancelled
    }
    
    private func makeTimer(repeatTimeInterval: DispatchTimeInterval, handler: DispatchSourceProtocol.DispatchSourceHandler?) -> DispatchSourceTimer {
        let timer = DispatchSource.makeTimerSource(queue: timerQueue)
        timer.schedule(deadline: .now(), repeating: repeatTimeInterval)
        timer.setEventHandler(qos: .background, handler: handler)
        return timer
    }
}
```



æˆ‘ä»¬ç®€å•ä½¿ç”¨æœ‰é™çŠ¶æ€æœºã€Œå°è£…äº†çŠ¶æ€å¯ä»¥è½¬æ¢æˆä»€ä¹ˆçŠ¶æ€ã€ä¸ã€ŒçŠ¶æ€éœ€è¦åšä»€ä¹ˆã€çš„é€»è¾‘ï¼Œå¦‚æœåœ¨é”™è¯¯çš„çŠ¶æ€ä¸‹å‘¼å«ä¼šè¢«å¿½ç•¥(ä¸ä¼šé—ªé€€)ï¼Œæˆ‘ä»¬è¿˜å¤šåšäº†ä¸€äº›ä¼˜åŒ–ï¼Œä¾‹å¦‚ suspended çŠ¶æ€ä¹Ÿèƒ½ cancelã€cancelled çŠ¶æ€èƒ½é‡æ–° activateã€‚



> ***å»¶ä¼¸é˜…è¯»ï¼š***



> *ä¹‹å‰å†™è¿‡å¦ä¸€ç¯‡æ–‡ç« ã€Œ [Design Patterns å®æˆ˜åº”ç”¨ï½œå°è£… Socket.IO å³æ—¶é€šè®¯æ¶æ„](https://zhgchg.li/posts/pinkoi-engineering/design-patterns-%E5%AF%A6%E6%88%B0%E6%87%89%E7%94%A8-%E5%B0%81%E8%A3%9D-socket-io-%E5%8D%B3%E6%99%82%E9%80%9A%E8%A8%8A%E6%9E%B6%E6%A7%8B%E8%88%87%E4%B8%83%E5%A4%A7%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90-78507a8de6a5/#%E9%9C%80%E6%B1%82%E5%A0%B4%E6%99%AF-3){:target="_blank"} ã€ä¸­ä¹Ÿæœ‰ä½¿ç”¨åˆ°æœ‰é™çŠ¶æ€æœºï¼Œå¦å¤–è¿˜å¤šä½¿ç”¨äº† State Patternã€‚*



> *Finite-State Machine æœ‰é™çŠ¶æ€æœº: å…³æ³¨çš„æ˜¯çŠ¶æ€ä¹‹é—´çš„è½¬æ¢æ§åˆ¶ä¸è¯¥åšä»€ä¹ˆã€‚*



> *State Pattern: å…³æ³¨çš„æ˜¯æ¯ä¸ªçŠ¶æ€å†…çš„è¡Œä¸ºé€»è¾‘ã€‚*



#### ä½¿ç”¨ Serial Queue æ“ä½œæœ‰é™çŠ¶æ€æœºçŠ¶æ€è½¬æ¢



æœ‰äº†çŠ¶æ€æœºç¡®ä¿ DispatchSourceTimer èƒ½å®‰å…¨ä½¿ç”¨ä¹‹åè¿˜æ²¡ç»“æŸï¼Œæˆ‘ä»¬æ— æ³•ä¿è¯åœ¨å¤–éƒ¨å‘¼å«ä½¿ç”¨ DispatchSourceTimerMachine çš„åœ°æ–¹æ˜¯åœ¨åŒä¸ª Threadï¼Œå¦‚æœä¸åŒ Thread éƒ½æ“ä½œäº†è¿™ä¸ªç‰©ä»¶å°±ä¼šé€ æˆ Race Condition ä¸€æ ·ä¼šå¼•å‘é—ªé€€ã€‚



```swift
final class DispatchSourceTimerMachine {
    // æœ‰é™çŠ¶æ€æœºæœ‰å“ªäº›çŠ¶æ€
    private enum TimerState {
        // åˆå§‹çŠ¶æ€
        case idle
        // æ‰§è¡Œä¸­
        case running
        // æš‚åœä¸­
        case suspended
        // ç»ˆæ­¢ä¸­
        case cancelled
    }

    private var timer: DispatchSourceTimer?
    private lazy var timerQueue: DispatchQueue = {
        DispatchQueue(label: "li.zhgchg.DispatchSourceTimerMachine", qos: .background)
    }()

    private var _state: TimerState = .idle

    private static let operationQueueSpecificKey = DispatchSpecificKey<ObjectIdentifier>()
    private lazy var operationQueueSpecificValue: ObjectIdentifier = ObjectIdentifier(self)
    private lazy var operationQueue: DispatchQueue = {
        let queue = DispatchQueue(label: "li.zhgchg.DispatchSourceTimerMachine.operationQueue")
        queue.setSpecific(key: Self.operationQueueSpecificKey, value: operationQueueSpecificValue)
        return queue
    }()
    private func operation(async: Bool = true, _ work: @escaping () -> Void) {
        if DispatchQueue.getSpecific(key: Self.operationQueueSpecificKey) == operationQueueSpecificValue {
            work()
        } else {
            if async {
                operationQueue.async(execute: work)
            } else {
                operationQueue.sync(execute: work)
            }
        }
    }
    
    deinit {
        // Owner ç‰©ä»¶æ¶ˆå¤±æ—¶ï¼ŒåŒæ­¥ cancel timer
        // è™½ä¸åšä¹Ÿä¸å½±å“(handler æ˜¯ weak)ï¼Œä½†æ˜¯å¯ä»¥ç¡®ä¿æµç¨‹ç¬¦åˆé¢„æœŸ
        // ç¡®ä¿ sync æ‰§è¡Œå®Œæ¯•
        operation(async: false) { [self] in
            if _state == .suspended {
                timer?.resume()
                _state = .running
            }
            if _state == .running {
                timer?.cancel()
                timer = nil
                _state = .cancelled
            }
        }
    }

    // å¯åŠ¨ Timer
    func activate(repeatTimeInterval: DispatchTimeInterval, handler: DispatchSource.DispatchSourceHandler?) {
        operation { [weak self] in
            guard let self = self else { return }
            // åªæœ‰ idle, cancelled çŠ¶æ€å¯ä»¥å¯ç”¨ Timer
            guard [.idle, .cancelled].contains(_state) else { return }
            
            // å»ºç«‹ Timer and activate()
            let timer = makeTimer(repeatTimeInterval: repeatTimeInterval, handler: handler)
            self.timer = timer
            timer.activate()
            
            // åˆ‡æ¢åˆ° running çŠ¶æ€
            _state = .running
        }
    }

    // æš‚åœ Timer
    func suspend() {
        operation { [weak self] in
            guard let self = self else { return }
            // åªæœ‰åœ¨ running çŠ¶æ€å¯ä»¥æš‚åœ Timer
            guard [.running].contains(_state) else { return }
            
            // æš‚åœ Timer
            timer?.suspend()
            
            // åˆ‡æ¢åˆ° suspended çŠ¶æ€
            _state = .suspended
        }
    }

    // æ¢å¤ Timer
    func resume() {
        operation { [weak self] in
            guard let self = self else { return }
            // åªæœ‰åœ¨ suspended çŠ¶æ€å¯ä»¥æ¢å¤ Timer
            guard [.suspended].contains(_state) else { return }
            
            // æ¢å¤ Timer
            timer?.resume()
            
            // åˆ‡æ¢åˆ° running çŠ¶æ€
            _state = .running
        }
    }

    // ç»ˆæ­¢ Timer
    func cancel() {
        operation { [weak self] in
            guard let self = self else { return }
            // åªæœ‰åœ¨ suspended, running çŠ¶æ€å¯ä»¥ç»ˆæ­¢ Timer
            guard [.suspended, .running].contains(_state) else { return }
            
            // å¦‚æœå½“å‰æ˜¯ suspended çŠ¶æ€ï¼Œå…ˆ resume() å†ç»ˆæ­¢
            // æ­¤ä¸º DispatchSourceTimer çš„é™åˆ¶ï¼Œåªèƒ½åœ¨ running æ‰èƒ½ cancel()
            if _state == .suspended {
                self.resume()
            }
            
            // ç»ˆæ­¢ Timer
            timer?.cancel()
            timer = nil
            
            // åˆ‡æ¢åˆ° cancelled çŠ¶æ€
            _state = .cancelled
        }
    }
    
    private func makeTimer(repeatTimeInterval: DispatchTimeInterval, handler: DispatchSourceProtocol.DispatchSourceHandler?) -> DispatchSourceTimer {
        let timer = DispatchSource.makeTimerSource(queue: timerQueue)
        timer.schedule(deadline: .now(), repeating: repeatTimeInterval)
        timer.setEventHandler(qos: .background, handler: handler)
        return timer
    }
}
```



ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å®‰å…¨æ— å¿§çš„ä½¿ç”¨ `DispatchSourceTimerMachine` ç‰©ä»¶ä½œä¸º Timer äº†:



```typescript
final class TrackingEventSender {

    private let timerMachine = DispatchSourceTimerMachine()
    public var events: [String: String] = []

    // å¯åŠ¨å®šæœŸ tracking
    func startTracking() {
        timerMachine.activate(repeatTimeInterval: .seconds(30)) { [weak self] in
            self?.sendTrackingEvent()
        }
    }

    // æš‚åœ trackingï¼ˆä¾‹å¦‚ App è¿›èƒŒæ™¯ï¼‰
    func pauseTracking() {
        timerMachine.suspend()
    }

    // æ¢å¤ trackingï¼ˆä¾‹å¦‚ App å›å‰æ™¯ï¼‰
    func resumeTracking() {
        timerMachine.resume()
    }

    // åœæ­¢ trackingï¼ˆä¾‹å¦‚é¡µé¢ç¦»å¼€ï¼‰
    func stopTracking() {
        timerMachine.cancel()
    }

    private func sendTrackingEvent() {
        // send events to server...
    }
}
```



åˆ°æ­¤å¦‚ä½•å®‰å…¨çš„ä½¿ç”¨ DispatchSourceTimer ç¯èŠ‚å·²ç»“æŸï¼Œå†æ¥å»¶ä¼¸å‡ ä¸ª Design Patterns çš„ä½¿ç”¨ï¼Œæ–¹ä¾¿æˆ‘ä»¬æŠ½è±¡ç‰©ä»¶è¿›è¡Œæµ‹è¯•è·Ÿ DispatchSourceHandler æ‰§è¡Œé€»è¾‘æŠ½è±¡ã€‚



#### å»¶ä¼¸ â€” ä½¿ç”¨ Adapter Pattern + Factory Pattern äº§ç”Ÿ DispatchSourceTimer (åˆ©äºæŠ½è±¡æµ‹è¯•)



DispatchSourceTimer æ˜¯ GCD çš„ Objective-C ç‰©ä»¶ï¼Œåœ¨æµ‹è¯•ç¯èŠ‚æˆ‘ä»¬å¾ˆéš¾å¯¹å…¶ Mock (æ—  Protocol)ï¼›å› æ­¤æˆ‘ä»¬éœ€è¦è‡ªå·±å®šä¹‰ä¸€å±‚ Protocol + Factory Pattern äº§ç”Ÿï¼Œè®© TimerStateMachine æ˜¯èƒ½å†™æµ‹è¯•çš„ã€‚



**Adapter Patternâ€” å°è£… DispatchSourceTimer æ“ä½œ:**



```swift
public protocol TimerAdapter {
    func schedule(repeating: DispatchTimeInterval)
    func setEventHandler(handler: DispatchSourceProtocol.DispatchSourceHandler?)
    func activate()
    func suspend()
    func resume()
    func cancel()
}

// DispatchSourceTimer çš„ Adapter å®ç°
final class DispatchSourceTimerAdapter: TimerAdapter {
    // åŸå§‹çš„ DispatchSourceTimer
    private let timer: DispatchSourceTimer

    init(label: String = "li.zhgchg.DispatchSourceTimerAdapter") {
        let queue = DispatchQueue(label: label, qos: .background)
        let timer = DispatchSource.makeTimerSource(queue: queue)
        self.timer = timer
    }

    func schedule(repeating: DispatchTimeInterval) {
        timer.schedule(deadline: .now(), repeating: repeating)
    }

    func setEventHandler(handler: DispatchSourceProtocol.DispatchSourceHandler?) {
        timer.setEventHandler(qos: .background, handler: handler)
    }

    func activate() {
        timer.activate()
    }

    func suspend() {
        timer.suspend()
    }

    func resume() {
        timer.resume()
    }

    func cancel() {
        timer.cancel()
    }
}
```



**Factory Pattern â€” æŠ½è±¡äº§ç”Ÿ TimerAdapter çš„æ–¹æ³•:**



```swift
protocol DispatchSourceTimerAdapterFactorySpec {
    func makeTimer(repeatTimeInterval: DispatchTimeInterval, handler: DispatchSourceProtocol.DispatchSourceHandler?) -> TimerAdapter
}

// å°è£… DispatchSourceTimerAdapter äº§ç”Ÿæ­¥éª¤
final class DispatchSourceTimerAdapterFactory: DispatchSourceTimerAdapterFactorySpec {
    public func makeTimer(repeatTimeInterval: DispatchTimeInterval, handler: DispatchSourceProtocol.DispatchSourceHandler?) -> TimerAdapter {
        let timer = DispatchSourceTimerAdapter()
        timer.schedule(repeating: repeatTimeInterval)
        timer.setEventHandler(handler: handler)
        return timer
    }
}
```



**ç»„åˆä½¿ç”¨:**



```swift
var stateMachine = DispatchSourceTimerMachine(timerFactory: DispatchSourceTimerAdapterFactory())

//
final class DispatchSourceTimerMachine {
    // ç•¥..
    private var timer: TimerAdapter?
    private let timerFactory: DispatchSourceTimerAdapterFactorySpec
    public init(timerFactory: DispatchSourceTimerAdapterFactorySpec) {
        self.timerFactory = timerFactory
    }
    // ç•¥..

    func activate(repeatTimeInterval: DispatchTimeInterval, handler: DispatchSource.DispatchSourceHandler?) {
        onQueue { [weak self] in
            guard let self else { return }
            guard [.idle, .cancelled].contains(_state) else { return }
            // ä½¿ç”¨ Factory MakeTimer
            let timer = timerFactory.makeTimer(repeatTimeInterval: repeatTimeInterval, handler: handler)
            self.timer = timer

            timer.activate()
            _state = .running
        }
    }

    // ç•¥..
}
```



è¿™æ ·æˆ‘ä»¬å°±èƒ½å¯¹ `TimerAdapter` / `DispatchSourceTimerAdapterFactorySpec` åœ¨æµ‹è¯•ç¯èŠ‚æ’°å†™ Mock Object è·‘å•å…ƒæµ‹è¯•ã€‚



#### å»¶ä¼¸ â€” ä½¿ç”¨ ***Strategy*** Pattern å°è£… DispatchSourceHandler å·¥ä½œ



å‡è®¾æˆ‘ä»¬çš„ DispatchSourceHandler å¸Œæœ›æ‰§è¡Œçš„äº‹èƒ½åŠ¨æ€æ”¹å˜ï¼Œå¯ä»¥ä½¿ç”¨ Strategy Pattern æ¥å°è£…å·¥ä½œå†…å®¹ã€‚



**TrackingHandlerStrategy:**



```swift
protocol TrackingHandlerStrategy {
    static var target: String { get }
    func execute()
}

// Home Event
final class HomeTrackingHandlerStrategy: TrackingHandlerStrategy {
    static var target: String = "home"
    func execute() {
       // fetch home event logs..and send
    }
}

// Product Event
final class ProductTrackingHandlerStrategy: TrackingHandlerStrategy {
    static var target: String = "product"
    func execute() {
       // fetch product event logs..and send
    }
}
```



**ç»„åˆä½¿ç”¨ï¼š**



```swift
var sender = TrackingEventSender()
sender.register(event: HomeTrackingHandlerStrategy())
sender.register(event: ProductTrackingHandlerStrategy())
sender.startTracking()

// ...

//

final class TrackingEventSender {

    private let timerMachine = DispatchSourceTimerMachine()
    private var events: [String: TrackingHandlerStrategy] = [:]

    // æ³¨å†Œéœ€è¦çš„ Event ç­–ç•¥
    func register(event: TrackingHandlerStrategy) {
        events[type(of: event).target] = event
    }

    func retrive<T: TrackingHandlerStrategy>(event: T.Type) -> T? {
        return events[event.target] as? T
    }

    // å¯åŠ¨å®šæœŸ tracking
    func startTracking() {
        timerMachine.activate(repeatTimeInterval: .seconds(30)) { [weak self] in
            self?.events.values.forEach { event in
                event.execute()
            }
        }
    }

    // æš‚åœ trackingï¼ˆä¾‹å¦‚ App è¿›èƒŒæ™¯ï¼‰
    func pauseTracking() {
        timerMachine.suspend()
    }

    // æ¢å¤ trackingï¼ˆä¾‹å¦‚ App å›å‰æ™¯ï¼‰
    func resumeTracking() {
        timerMachine.resume()
    }

    // åœæ­¢ trackingï¼ˆä¾‹å¦‚é¡µé¢ç¦»å¼€ï¼‰
    func stopTracking() {
        timerMachine.cancel()
    }
}
```



#### é¸£è°¢



æ„Ÿè°¢ [Ethan Huang](https://medium.com/u/e13f6afcf9b9){:target="_blank"} å¤§å¤§ Donate çš„ **5 Beers** :



[![](https://c7.patreon.com/https%3A%2F%2Fwww.patreon.com%2F%2Fcard-teaser-image%2Fcreator%2F6512681%3Fc=4366071272298850039/selector/%23creator-teaser%2C.png)](https://www.patreon.com/cw/ethanhuang13/home?vanity=ethanhuang13){:target="_blank"}



> *çš„ç¡®å¿«åŠå¹´æ²¡å†™ä»€ä¹ˆäº†ï¼Œæ–°å·¥ä½œåˆšåˆ°èŒï¼ŒæŒç»­æ‰¾å¯»çµæ„Ÿä¸­ï¼ğŸ’ª*



> ä¸‹ä¸€ç¯‡å¯èƒ½åˆ†äº« Fastlane Match å‡­è¯ç®¡ç†è·Ÿ Self-hosted Runner çš„å»ºç½®è¿‡ç¨‹. .æˆ–æ˜¯ Bitbucket Pipeline. .æˆ–æ˜¯ AppStoreConnect APIâ€¦



### å»¶ä¼¸é˜…è¯»



- [**Design Patterns çš„å®æˆ˜åº”ç”¨çºªå½• (å°è£… Sockiet.io)**](../78507a8de6a5/)


- [Design Patterns çš„å®æˆ˜åº”ç”¨çºªå½• (å°è£… WKWebView)](../f4b02ee342a4/)


- [Visitor Pattern in Swift](../ba5773a7bfea/)


- [Visitor Pattern in TableView](../60473cb47550/)



æœ‰ä»»ä½•é—®é¢˜åŠæŒ‡æ•™æ¬¢è¿ [ä¸æˆ‘è”ç»œ](https://www.zhgchg.li/contact){:target="_blank"} ã€‚



*[Post](https://dev.zhgchg.li/ios-timer-%E8%88%87-dispatchsourcetimer-%E5%A6%82%E4%BD%95%E9%81%B8%E6%93%87%E8%88%87%E5%AE%89%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8-62f68ebeecd3){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*