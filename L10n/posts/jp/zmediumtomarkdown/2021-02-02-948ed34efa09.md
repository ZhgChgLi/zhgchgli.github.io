---
author: ZhgChgLi
categories:
- ZRealmの開発
date: 2021-02-02T14:13:50.686+0000
description: iOSユーザー向けに、Sign in with Appleを超えるアカウント統合とパスワード管理でログイン体験を劇的に向上。複数プラットフォームをシームレスに連携し、手間なく安全にアクセス可能にします。
image:
  path: /assets/948ed34efa09/1*QRYrbCDXcDmUU9fK66YgAA.jpeg
last_modified_at: 2024-04-13T08:48:34.721+0000
render_with_liquid: false
tags:
- iOS
- iOSアプリ開発
- パスワードセキュリティ
- ウェブ認証情報
- Appleでサインイン
- japanese
- ai-translation
title: iOS 跨平台帳號密碼統合｜Sign in with Apple 以上のログイン強化法
---

### iOS クロスプラットフォームのアカウント・パスワード統合、ログイン体験の向上

Sign in with Apple に加えて導入すべき機能

![Photo by [Dan Nelson](https://unsplash.com/@danny144?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/948ed34efa09/1*QRYrbCDXcDmUU9fK66YgAA.jpeg)

写真提供：[Dan Nelson](https://unsplash.com/@danny144?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}

### 機能

同時にウェブサイトとアプリを提供しているサービスで最もよくある問題は、ユーザーがウェブサイトで登録・ログインしパスワードを保存しているにもかかわらず、アプリをインストールして開くと、ログイン時に再度アカウントとパスワードを入力しなければならず非常に不便であることです。この機能は、既に端末に保存されているアカウント情報をウェブサイトと関連付けられたアプリに自動で入力し、ユーザーのログインプロセスを高速化します。

### 効果図

![](/assets/948ed34efa09/1*z-zjGdt17LYCr8Am6kekFA.gif)

余計な説明はなしで、まず完成した画面をお見せします；一見すると iOS ≥ 11 の Password AutoFill 機能のように見えるかもしれません；しかしよく見ると、キーボードは表示されておらず、「保存済みのパスワードを選択」ボタンを押して初めてアカウントとパスワードの選択ウィンドウが表示されます。

Password AutoFill に触れたので、まずは少し引っ張って、Password AutoFill の紹介と設定方法から始めましょう！

### パスワード自動入力

![](/assets/948ed34efa09/1*BZQcOoRV5IcRuI2HsSmKRQ.gif)

サポート範囲：iOS ≥ 11

現在はもう iOS 14 なので、この機能は非常に一般的で特に珍しいものではありません。APP 内のアカウント・パスワードのログイン画面でキーボードを呼び出すと、ウェブ版サービスのアカウント・パスワードを素早く選択でき、選択すると自動で入力されてすぐにログインできます！

#### では、APPとWebはどのように認識し合うのでしょうか？

Associated Domains！APP内でAssociated Domainsを指定し、ウェブサイトにapple-app-site-associationファイルをアップロードすると、両者が認識し合えます。

**1. プロジェクト設定の「Signing & Capabilities」-> 左上の「+ Capabilities」->「Associated Domains」**

![](/assets/948ed34efa09/1*0oVHvGSzUA5cohhsSyuamA.png)

`webcredentials:あなたのサイトのドメイン` を追加します（例：`webcredentials:google.com`）。

**2. [Apple開発者アカウント](https://developer.apple.com/account/){:target="_blank"} にログインする**

「 **Membership** 」タブで「 **Team ID** 」を記録します

![](/assets/948ed34efa09/1*LLlPP2VVCinVdrMsXWvj3g.png)

**3.「Certificates, Identifiers & Profiles」→「Identifiers」→ プロジェクトを見つける → 「Associated Domains」機能を有効化**

![](/assets/948ed34efa09/1*ssGVeTV7AAfkbf1iYeQX7Q.png)

**APP 側の設定が完了しました！**

**4.Webサイト側の設定**

「**apple-app-site-association**」という名前のファイル（拡張子なし）を作成し、テキストエディタで開いて、以下の内容を入力してください：

```json
{
  "webcredentials": {
    "apps": [
      "TeamID.BundleId"
    ]
  }
}
```

`TeamID.BundleId` をあなたのプロジェクト設定に置き換えてください（例：TeamID = `ABCD` 、BundleID = `li.zhgchg.demoapp` =&gt; `ABCD.li.zhgchg.demoapp`）

このファイルをウェブサイトの `ルートディレクトリ` または `/.well-known` ディレクトリにアップロードしてください。例えば、あなたの `webcredentials サイトドメイン` が `google.com` の場合、このファイルは `google.com/apple-app-site-association` または `google.com/.well-known/apple-app-site-association` にアクセス可能である必要があります。

**補足：サブドメイン**

![](/assets/948ed34efa09/1*ObLXi_XGDDR4A3Mo1WdIEA.png)

公式ドキュメントからの抜粋ですが、サブドメインの場合はすべて Associated Domains に記載する必要があります。

**Web 側の設定が完了しました！**

**補足：applinks**

ここで発見したのは、universal link の `applinks` を設定していれば、`webcredentials` を追加しなくても効果があるということです。しかし、後の問題を避けるために、ドキュメント通りに設定しましょう。

#### プログラムに戻る

Code 部分、TextField を以下のように設定するだけで十分です：

```swift
usernameTextField.textContentType = .username
passwordTextField.textContentType = .password
```

新規登録の場合、パスワード確認欄には以下を使用できます：

```swift
repeatPasswordTextField.textContentType = .newPassword
```

この時点で再度 Build & Run した後、アカウント入力時にキーボード上部に同じサイトで保存されたパスワードの候補が表示されます。

#### 完了！

![](/assets/948ed34efa09/1*VKsfZLnzoNno-IgPRp-odg.jpeg)

#### 表示されませんか？

自動入力パスワード機能がオフになっている可能性があります（シミュレーターのデフォルトはオフです）。「設定」->「パスワード」->「自動入力パスワード」->「自動入力パスワード」をオンにしてください。

![](/assets/948ed34efa09/1*a0vCvZA6PajjOwc8DFymIg.jpeg)

あるいは、そのウェブサイトに既存のパスワードがない場合でも、「設定」->「パスワード」-> 右上の「+ 新規追加」-> で追加できます。

![](/assets/948ed34efa09/1*kOsFAy-UifNMor84LGEovw.jpeg)

### 本題に入る

前菜のPassword AutoFillの紹介が終わったら、次に本題に入ります；効果図のような効果をどのように実現するか。

#### [Shared Web Credentials](https://developer.apple.com/documentation/security/shared_web_credentials){:target="_blank"}

iOS 8.0 から始まりましたが、以前はあまり APP で使われていませんでした。Password AutoFill が登場する前から、この API を使ってウェブサイトのアカウント情報を統合し、ユーザーが素早く選択できるようにしていました。

Shared Web Credentials は、アカウントとパスワードの読み取りだけでなく、新規追加、既存のアカウントとパスワードの編集、削除も可能です。

#### 設定

> ***⚠️ 設定部分は前述の Password AutoFill 設定と同様に Associated Domains を正しく設定してください。***

> つまり、Password AutoFill 機能の強化版と言えます！！

同様に、まず Password AutoFill に必要な環境を整えてからこの「高度な」機能を使用する必要があります。

#### 読み取り

使用 `SecRequestSharedWebCredential` メソッドで操作を行う場合：

```swift
SecRequestSharedWebCredential(nil, nil) { (credentials, error) in
  guard error == nil else {
    DispatchQueue.main.async {
      //エラーを表示する
    }
    return
  }
  
  guard CFArrayGetCount(credentials) > 0,
    let dict = unsafeBitCast(CFArrayGetValueAtIndex(credentials, 0), to: CFDictionary.self) as? Dictionary<String, String>,
    let account = dict[kSecAttrAccount as String],
    let password = dict[kSecSharedPassword as String] else {
      DispatchQueue.main.async {
        //エラーを表示する
      }
      return
    }
    
    DispatchQueue.main.async {
      //アカウントとパスワードをテキストフィールドに入力する
    }
}
```

`SecRequestSharedWebCredential(fqdn, account, completionHandler)`

- **fqdn** 複数の `webcredentials` ドメインがある場合、特定のものを指定するか、null を使って指定しないことも可能です。

- **account** 指定するアカウントを検索する場合に使用し、null を指定すると未指定になります

![](/assets/948ed34efa09/1*PNRbIoN3vr64ZstYphpR9w.gif)

効果図。（最初の効果図と異なることに気づいたかもしれません）

> ***⚠️ この読み取り方法は iOS 14 で非推奨となりました！***

> ***⚠️ この読み取り方法は iOS 14 で非推奨になりました！***

> ***⚠️ この読み取り方法は iOS 14 で非推奨になりました！***

> `"ASAuthorizationController を使って ASAuthorizationPasswordRequest を作成する（AuthenticationServices フレームワーク）"`

この方法は iOS 8 から iOS 14 までにのみ適用され、iOS 13 以降は **Sign in with Apple** と同じ API である「**AuthenticationServices**」を使用できます。

#### **AuthenticationServices の読み取り方法**

対応バージョン iOS ≥ 13

```swift
import AuthenticationServices

class ViewController: UIViewController {
  override func viewDidLoad() {
      super.viewDidLoad()
      //...
      let request: ASAuthorizationPasswordRequest = ASAuthorizationPasswordProvider().createRequest()
      let controller = ASAuthorizationController(authorizationRequests: [request])
      controller.delegate = self
      controller.performRequests()
      //...
  }
}

extension ViewController: ASAuthorizationControllerDelegate {
    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
        
        if let credential = authorization.credential as? ASPasswordCredential {
          // credential.user、credential.passwordをテキストフィールドに入力する
        }
        // else if as? ASAuthorizationAppleIDCredential... Sign in with Apple
    }
    func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
        // エラーをアラート表示する
    }
}
```

![](/assets/948ed34efa09/1*z-zjGdt17LYCr8Am6kekFA.gif)

効果図では、新しい方法がフローや表示面で Sign in with Apple とより良く統合できることがわかります。

> ***⚠️ このログインは*** *Sign in with Apple（これは別のものです）* ***の代わりにはなりません。***

#### アカウント情報を「パスワード」に書き込む

Deprecated となったのは読み取り部分のみで、新規追加、削除、編集の部分は従来通り使用可能です。

追加、削除、編集の部分は `SecAddSharedWebCredential` を使って操作します。

```swift
SecAddSharedWebCredential(domain as CFString, account as CFString, password as CFString?) { (error) in
  DispatchQueue.main.async {
    guard error == nil else {
      // エラーを通知
      return
    }
    // 成功を通知
  }
}
```

`SecAddSharedWebCredential(fqdn, account, password, completionHandler)`

- **fqdn** は保存するドメインを自由に指定できます。必ずしも `webcredentials` 内である必要はありません。

- **account** は追加、変更、削除するアカウントを指定します。

- 削除する場合は **password** に **`nil`** を渡します。

- 処理ロジック：
  - account が存在し、password が入力されている場合 = password を変更する
  - account が存在し、password が nil の場合 = domain から account と password を削除する
  - account が存在せず、password が入力されている場合 = domain に account と password を追加する

![](/assets/948ed34efa09/1*dGN5rv4jZ-wlY9HYoymNCQ.png)

> ***⚠️*** *また、バックグラウンドで勝手に変更されるわけではなく、変更するたびに確認ダイアログが表示され、ユーザーが「パスワードを更新」を押して初めてデータが変更されます。*

#### パスワードジェネレーター

最後の小さな機能、パスワードジェネレーター。

`SecCreateSharedWebCredentialPassword()` を使用して操作します。

```swift
let password = SecCreateSharedWebCredentialPassword() as String? ?? ""
// 共有ウェブ資格情報のパスワードを作成
```

![](/assets/948ed34efa09/1*Xd-CiH62N354u6JPQ4b8cQ.png)

生成器が作成するパスワードは、英大文字・小文字と数字で構成され、「-」で区切られています（例: Jpn-4t2-gaF-dYk）。

### 完全なテストプロジェクトのダウンロード

[![](https://opengraph.githubassets.com/095b2f29388301a3e997e079aedecc973eae5656fc782e8889e7f462d7875681/zhgchgli0718/webcredentialsDemo)](https://github.com/zhgchgli0718/webcredentialsDemo){:target="_blank"}

![](/assets/948ed34efa09/1*B9q4goRZPLvW4613OnW2oA.png)

### 不満点

もしサードパーティのパスワード管理ツール（例：onepass、lastpass）を使用している場合、キーボードのPassword AutoFillでは表示および入力が可能ですが、AuthenticationServicesやSecRequestSharedWebCredentialでは表示されないことがあります。この要件を満たす方法があるかは不明です。

![](/assets/948ed34efa09/1*o_UTxA4Epty8XAM6cOsiUw.jpeg)

### 終わり

ご覧いただきありがとうございます。また、[saiday](https://twitter.com/saiday){:target="_blank"} さんと街声に、この機能を教えていただき感謝します XD。

さらに XCode ≥ 12.5 のシミュレーターに録画機能が追加され、GIF保存にも対応していてとても便利です！

![](/assets/948ed34efa09/1*LUaFOoZHai41oFNFkh6b4A.jpeg)

シミュレーターで「Command」+「R」を押して録画を開始し、赤い点をクリックして録画を停止します。右下に表示されるプレビュー画像を「右クリック」→「Save as Animated GIF」でGIFとして保存し、そのまま記事内に貼り付けられます！

ご質問やご意見がございましたら、[こちらからご連絡ください](https://www.zhgchg.li/contact){:target="_blank"} 。

*[Post](https://medium.com/zrealm-ios-dev/ios-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%B8%B3%E8%99%9F%E5%AF%86%E7%A2%BC%E6%95%B4%E5%90%88%E5%8A%A0%E5%BC%B7%E7%99%BB%E5%85%A5%E9%AB%94%E9%A9%97-948ed34efa09){:target="_blank"} は Medium から [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"} によって変換されました。*