---
author: ZhgChgLi
categories:
- ZRealmの開発
date: 2021-03-23T17:09:34.747+0000
description: Firebase FirestoreとFunctionsを活用し、推播統計のテスト用APIサービスを即時構築。開発者が直面する複雑な連携問題を解決し、効率的な検証環境を実現します。
image:
  path: /assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg
last_modified_at: 2024-04-13T16:34:17.362+0000
render_with_liquid: false
tags:
- iosアプリ開発
- firebase
- google-cloud-platform
- 通知
- ios
- japanese
- ai-translation
title: Firebase Firestore｜FunctionsでAPIサービスを迅速構築：テスト環境を即セットアップ
---

### Firebase Firestore + Functions を使ってテスト用の API サービスを素早く構築する

プッシュ通知の統計が Firebase Firestore + Functions に出会ったとき

![Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg)

Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}

### はじめに

#### プッシュ通知の正確な統計機能

最近、APPに導入したい機能について、実装前はバックエンドからAPNS/FCMにデータを送信した成功可否をプッシュ通知の母数として扱い、クリックを記録して「クリック率」を計算していました。しかし、この方法は非常に不正確で、母数には多くの無効な端末や、APPが削除されていても（すぐには無効にならない場合がある）、プッシュ通知の権限をオフにしている端末も含まれており、バックエンドで送信成功の返答を得てしまいます。

iOS 10以降、Notification Service Extensionを実装することで、プッシュ通知のバナーが表示されるタイミングでこっそりAPIを呼び出して統計を取ることができます。利点は非常に正確で、ユーザーのプッシュ通知バナーが表示されたときだけAPIを呼び出します。アプリが削除されたり、通知がオフになっていたり、バナー表示が無効の場合は動作しません。バナーが表示されたことをプッシュ通知の母数とし、クリック数と組み合わせることで「正確なクリック率」を得ることができます。

> *詳細な原理および実装方法は、以前の記事「[i **OS ≥ 10 Notification Service Extension 応用 (Swift)**](../cb6eba52a342/)」をご参照ください。*

> *現在のテストでは、APPのロス率はおそらく0％です。実際の一般的な応用例としては、Lineのメッセージのピアツーピア暗号化（プッシュ通知のメッセージは暗号化されており、スマホで受信してから復号して表示されます）があります。*

#### 問題

APP 側の役割は実は大きくなく、iOS/Android は似たような機能を実装するだけです（ただし、Android は中国市場を考慮する場合、プッシュ通知フレームワークを別途実装する必要があり、やや複雑です）。より大きな負荷はバックエンドやサーバー側の処理にあります。プッシュ通知を一斉に送信すると同時に API 呼び出しで記録を返すため、サーバーの最大接続数が飽和する可能性があります。さらに RDBMS で記録を保存している場合は問題がより深刻になります。統計データのロスが発生する場合、多くはこの部分で起きています。

> *ここではログをファイルに書き込み、必要に応じて集計表示を行います。*

> *また、後で考えたところ、一度に送信して同時に戻ってくる状況では、想像ほどの数にはならないかもしれません。なぜなら、プッシュ通知も一気に十万や百万件を送ることはなく、数件ずつバッチ送信するからです。バッチで送信して同時に戻ってくる数を耐えられれば十分です！*

### プロトタイプ

元の問題を考慮して、バックエンドは修正に時間がかかり、市場も成果にあまり関心がない可能性があります。そこで、まず使えるリソースでプロトタイプを作成して様子を見ようと思います。

ここでは、ほとんどのアプリが使用する Firebase サービスの中から、Functions と Firestore の機能を選択しています。

#### Firebase Functions

[Functions](https://developers.google.com/learn/topics/functions){:target="_blank"} は Google が提供するサーバーレスサービスで、プログラムのロジックを作成するだけで、Google が自動的にサーバーや実行環境を準備し、サーバーの拡張やトラフィックの管理を気にする必要がありません。

[Firebase Functions](https://firebase.google.com/docs/functions){:target="_blank"} は実際には Google Cloud Functions と同じですが、JavaScript (node.js) のみで作成できます。試したことはありませんが、Google Cloud Functions で他の言語を選んで Firebase サービスをインポートすれば、同様に使えると思います。

APIで使う場合は、node.jsファイルを書いて、実際のURL（例: my-project.cloudfunctions.net/getUser）を取得し、Request情報を取得して適切なResponseロジックを自分で作成できます。

> *以前に書いた Google Functions に関する記事「 [Python+Google Cloud Platform+Line Bot を使って定期作業を自動化する](../70a1409b149a/) 」*

> *Firebase Functions は Blaze プラン（使用した分だけ支払う）を有効にする必要があります。*

![](/assets/9659db1357e4/1*YqIJ1tr2Ay-oLVjSSU0zUg.png)

#### Firebase Firestore

[Firebase Firestore](https://firebase.google.com/docs/firestore){:target="_blank"} は、NoSql データベースで、データの保存と管理に使用されます。

Firebase Functions と組み合わせることで、Request 時に Firestore を import してデータベースを操作し、Response をユーザーに返すことで、簡単な Restful API サービスを構築できます！

> 実践開始！

### node.js 環境のインストール

こちらでは NVM、node.js のバージョン管理ツールを使ってインストールと管理を行うことをおすすめします（python の pyenv のように）。

NVM Github プロジェクトからインストール用シェルスクリプトをコピー：

[![](https://repository-images.githubusercontent.com/612230/53a0c44a-1f6e-4f8d-918f-89762fafe369)](https://github.com/nvm-sh/nvm#installing-and-updating){:target="_blank"}

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh \\| bash
```

インストール中にエラーが発生した場合は、`~/.bashrc` または `~/.zshrc` ファイルが存在するか確認してください。ファイルがない場合は、`touch ~/.bashrc` または `touch ~/.zshrc` でファイルを作成してから、再度インストールスクリプトを実行してください。

次に `nvm install node` を使って最新版の node.js をインストールできます。

![](/assets/9659db1357e4/1*5fxz4HD9q4feAqO0zXbojg.png)

npm のインストールが成功し、バージョンを確認するには、以下を実行してください：

`npm --version`

![](/assets/9659db1357e4/1*VHZMRFIDzFA9AxmsDNqNlA.png)

### Firebase Functions のデプロイ

#### Firebase-tools のインストール：

```bash
npm install -g firebase-tools
```

![](/assets/9659db1357e4/1*POfMR0p1600iYqy8rzQkTQ.png)

インストールが成功したら、初回使用時に以下を入力してください：

```bash
firebase login
```

![](/assets/9659db1357e4/1*kqeECyXVPOq1cpKvcdOBeA.png)

Firebase ログイン認証を完了する。

プロジェクトの起動：

```bash
firebase init
```

![](/assets/9659db1357e4/1*Xx2grpX2PZb3wEFt9mQbNw.png)

Firebase init のあるパスをメモしてください：

```
このディレクトリで Firebase プロジェクトを初期化しようとしています：
```

ここではインストールする Firebase CLI ツールを選択できます。「↑」「↓」キーで選択し、「スペースキー」で決定します。ここでは「Functions」のみ、または「Firestore」も含めて選択してインストールできます。

**=== Functions セットアップ**

![](/assets/9659db1357e4/1*2gd9pAIdLAkJRhROpJtPKA.png)

- 言語選択「 **JavaScript** 」

- 「use ESLint to catch probable bugs and enforce style」に関する文法スタイルチェックは、**はい / いいえ どちらでも可**。

- npmで依存関係をインストールしますか？ **はい**

**===エミュレーターのセットアップ**

![](/assets/9659db1357e4/1*xHWp195BZIZdXyUd-ub78g.png)

ローカル環境で Functions や Firestore の機能・設定をテストでき、使用量にカウントされず、デプロイして公開するまで待つ必要がありません。

> *個人の必要に応じてインストールしてください。私はインストールしましたが使っていません．．．小さな機能だけなので。*

### コーディング！

上記で記録したパスに移動し、`functions` フォルダを見つけて、その中の `index.js` ファイルをエディタで開いてください。

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
admin.initializeApp();

exports.hello = functions.https.onRequest((req, res) => {
    const targetID = req.query.targetID
    const action = req.body.action
    const name = req.body.name

    res.send({"targetID": targetID, "action": action, "name": name});
    return
})
```

上記の内容を貼り付けて、パスインターフェース `/hello` を定義しました。これにより、URLの**クエリ** `?targetID=`、**POST**の `action`、`name` パラメータ情報を返します。

修正＆保存が完了したら、コンソールに戻ります：

```bash
firebase deploy
```

> ***以降の変更は必ず `firebase deploy` コマンドを実行してから反映されます。***

検証開始＆Firebaseへのデプロイ…

![](/assets/9659db1357e4/1*hUdvD4ANKD3s73mLWNZZOQ.png)

少しお待ちください。`Deploy complete!` の後、最初のリクエスト＆レスポンスのページが完成します！

この時点で Firebase → Functions ページに戻ることができます：

![](/assets/9659db1357e4/1*SY4iJZL6gDEZ5AEcepIpMA.png)

先ほど作成したインターフェースとURLの場所が表示されます。

以下のURLをコピーしてPostManでテストしてください：

![](/assets/9659db1357e4/1*OMfLkdg12QHsp-yc9RkKvA.png)

> *POST Body は必ず `x-www-form-urlencoded` を選択してください。*

**成功！**

### ログ

プログラム内で次のように使用できます：

```javascript
functions.logger.log("ログ:", value);
```

ログ記録を行う。

Firebase -> Functions -> ログでログ結果を確認できます：

![](/assets/9659db1357e4/1*Wi-4MbPh2tVJ_utdhzN4_A.png)

### 例の目標

> 記事の追加、編集、削除、取得、および「いいね」機能を持つAPIの作成

Restful API の機能設計を実現したいため、上記の純粋な Path 方式は使わず、`Express` フレームワークを利用して実装します。

#### POST 新しい記事を追加

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// 挿入
app.post('/', async (req, res) => { // ここでの POST は HTTPメソッドのPOSTを指します
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null \\|\\| content == null \\|\\| author == null) {
        return res.status(400).send({"message":"パラメータエラー！"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"追加成功！"});
});

exports.post= functions.https.onRequest(app); // ここでの POST は /post パスを指します
```

現在は Express を使ってネットワークリクエストを処理します。ここではまず、パス `/` の POST メソッドを追加します。最後の行は、すべてのパスが `/post` の下にあることを示しています。次に、更新・削除の API を追加します。

下 `firebase deploy` が成功したら、Post Man に戻ってテストします：

![](/assets/9659db1357e4/1*yVAjhlr6wLdONeG7nY0VEw.png)

Post Man が成功した後、Firebase -> Firestore に移動してデータが正しく書き込まれているか確認できます：

![](/assets/9659db1357e4/1*xYVrRdFro3bQVHx05JUaTw.png)

#### PUT 記事の編集

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// 更新
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"}); 
    } else if (title == null \\|\\| content == null \\|\\| author == null) {
        return res.status(400).send({"message":"パラメーターエラー！"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"更新成功！"});
});

exports.post= functions.https.onRequest(app);
```

デプロイ＆テスト方法は新規作成と同様で、Post ManのHTTPメソッドを`PUT`に変更することを忘れないでください。

#### DELETE 記事を削除する

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// 削除
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"記事が削除されました！"});
})

exports.post= functions.https.onRequest(app);
```

デプロイ＆テスト方法は新規作成と同様で、Post ManのHTTPメソッドを`DELETE`に変更してください。

追加、変更、削除が終わったので、次は検索をしましょう！

#### SELECT で記事を取得する

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// 一覧取得
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// 詳細取得
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

exports.post= functions.https.onRequest(app);
```

![](/assets/9659db1357e4/1*n_mI4l1EmhpWK8M_FbrzbQ.png)

デプロイ＆テスト方法は新規作成と同様で、PostmanのHTTPメソッドを `GET` に変更し、`Body` を `none` に戻してください。

#### InsertOrUpdate?

時々、値が存在する場合は更新し、存在しない場合は新規作成したいことがあります。その場合は `set` と `merge: true` を組み合わせて使います：

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// 挿入または更新
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"パラメータエラー！"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"追加成功！"});
});

exports.post= functions.https.onRequest(app);
```

ここではタグの追加を例に、デプロイ＆テスト方法は追加と同様で、Firestoreが同じデータを繰り返し追加しないことが確認できます。

![](/assets/9659db1357e4/1*qkTMGjC0EkrMO85-6pQFwg.png)

#### 記事のいいねカウンター

もし記事データに「likeCount」フィールドが追加されて、いいね数を記録する場合、どうすればよいでしょうか？

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// 投稿に「いいね」
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"いいね成功！"});
});

exports.post= functions.https.onRequest(app);
```

`increment` という変数を使うと、値を取り出して +1 する操作を直接行えます。

#### 大量トラフィックの記事いいねカウンター

Firestore には [書き込み速度制限](https://cloud.google.com/firestore/quotas?hl=zh-tw#soft_limits){:target="_blank"} があるため：

![](/assets/9659db1357e4/1*U9ubGe3M8XEdx9XGAV8nfA.png)

**1つのドキュメントには1秒に1回しか書き込めません**。そのため、いいねをする人が増えると、同時リクエストで遅くなる可能性があります。

公式が提供する解決方法「 [Distributed counters](https://cloud.google.com/firestore/docs/solutions/counters#node.js_2){:target="_blank"} 」は特に高度な技術ではなく、複数の分散された likeCount フィールドを使って集計し、読み込み時に合計を計算するだけです。

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// 分散カウンター いいねポスト
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"いいね成功！"});
});


exports.post= functions.https.onRequest(app);
```

![](/assets/9659db1357e4/1*GhNEcWUjgvYRYCMBk1DayA.png)

以上はカウントを分散したフィールドで記録し、書き込みの遅延を防ぐ方法です。しかし、分散フィールドが多すぎると読み取りコスト（$$）が増えますが、いいねのたびに新しいレコードを追加するよりは安価でしょう。

#### Siege ツールを使った負荷テスト

`brew` を使って `siege` をインストールする

```bash
brew install siege
```

*p.s brew: command not found が表示された場合は、まず [brew](https://brew.sh/index_zh-tw){:target="_blank"} パッケージ管理ツールをインストールしてください* ：

```bash
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
```

インストールが完了したら、以下を実行してください：

```bash
siege -c 100 -r 1 -H 'Content-Type: application/json' 'https://us-central1-project.cloudfunctions.net/post/like/id POST {}'
```

負荷テストを実施する：

- `-c 100` ：100個のタスクを同時に実行

- `-r 1` ：各タスクが1回リクエストを実行する

- `-H ‘Content-Type: application/json’` ：POSTの場合に追加が必要です

- `‘https://us-central1-project.cloudfunctions.net/post/like/id POST {}’` ：POSTのURL、Post Body（例：`{“name”:”1234”}`）

実行完了後、実行結果が表示されます：

![](/assets/9659db1357e4/1*BUcMfJJ4x_mgK0HHLc6C4g.png)

`successful_transactions: 100` は 100 回すべて成功したことを示します。

**Firebase -&gt; Firestore で結果にデータ損失がないか確認できます：**

![](/assets/9659db1357e4/1*wd5z743Zp9xtjKhhcMaVOg.png)

> 成功しました！

#### 完全なサンプルコード

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// 挿入
app.post('/', async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null \\|\\| content == null \\|\\| author == null) {
        return res.status(400).send({"message":"パラメータエラー！"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"追加成功！"});
});

// 更新
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"}); 
    } else if (title == null \\|\\| content == null \\|\\| author == null) {
        return res.status(400).send({"message":"パラメータエラー！"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"更新成功！"});
});

// 削除
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"記事削除成功！"});
});

// 一覧取得
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// 単一取得
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

// 挿入または更新
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"パラメータエラー！"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"追加成功！"});
});

// いいね
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"いいね成功！"});
});

// 分散カウンターいいね
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"記事が見つかりません！"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"いいね成功！"});
});


exports.post= functions.https.onRequest(app);
```

### 本題に戻って、プッシュ通知の統計

最初にやりたかったこと、プッシュ通知の統計機能に戻りましょう。

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

const vaildPlatformTypes = ["iOS","Android"]
const vaildActionTypes = ["clicked","received"]

// ログを挿入
app.post('/', async (req, res) => {
    const increment = admin.firestore.FieldValue.increment(1);
    const platformType = req.body.platformType;
    const pushID = req.body.pushID;
    const actionType =  req.body.actionType;

    if (!vaildPlatformTypes.includes(platformType) \\|\\| pushID == undefined \\|\\| !vaildActionTypes.includes(actionType)) {
        return res.status(400).send({"message":"參數錯誤！"});
    } else {
        await admin.firestore().collection(platformType).doc(actionType+"_"+pushID).collection("shards").doc((Math.floor(Math.random()*10)+1).toString())
        .set({count: increment}, {merge: true})
        res.status(201).send({"message":"紀錄成功！"});
    }
});

// ログを表示
app.get('/:type/:id', async (req, res) => {
    // received
    const receivedDocs = await admin.firestore().collection(req.params.type).doc("received_"+req.params.id).collection("shards").get();
    var received = 0;
    receivedDocs.forEach(doc => {
      received += doc.data().count;
    });

    // clicked
    const clickedDocs = await admin.firestore().collection(req.params.type).doc("clicked_"+req.params.id).collection("shards").get();
    var clicked = 0;
    clickedDocs.forEach(doc => {
        clicked += doc.data().count;
    });
    
    res.status(200).send({"received":received,"clicked":clicked});
});

exports.notification = functions.https.onRequest(app);
```

#### プッシュ通知記録の追加

![](/assets/9659db1357e4/1*3koe6QBxF9oOhBDqjF5mhA.png)

#### プッシュ通知の統計数値を確認する

```
https://us-centra1-xxx.cloudfunctions.net/notification/iOS/1
```

![](/assets/9659db1357e4/1*SStEkNoDjiL7pffC2pHDkQ.png)

また、プッシュ通知の数を統計するインターフェースも作成しました。

#### トラブルシューティング

> *node.js の使い方に慣れていなかったため、最初にデータを追加する際に `await` を付け忘れ、さらに書き込み速度制限もあり、大量トラフィック時にデータロスが発生しました…*

![](/assets/9659db1357e4/1*dVsBhKJQ3qqxlSvv-mCENA.png)

### 価格設定

Firebase Functions と Firestore の料金プランも忘れずに参照してください。

#### Functions

- <https://cloud.google.com/functions/pricing?hl=zh-tw>{:target="_blank"}

![](/assets/9659db1357e4/1*76yRqeDyrp0kFmGHN4ZNXg.png)

![運算時間](/assets/9659db1357e4/1*G_At8v80BQl81EUqPuUIbQ.png)

運算時間

![ネットワーク](/assets/9659db1357e4/1*iXk7oKFidHfzRVwrDvKX0A.png)

ネットワーク

> *Cloud Functions は計算時間リソースに対して永久無料プランを提供しており、GB/秒および GHz/秒の計算時間が含まれます。200万回の呼び出しに加えて、無料プランでは 400,000 GB/秒 と 200,000 GHz/秒 の計算時間、さらに毎月 5 GB のインターネットアウトバウンドトラフィックも提供されます。*

#### Firestore

- <https://cloud.google.com/firestore/pricing?hl=zh-tw>{:target="_blank"}

![](/assets/9659db1357e4/1*ylduiqevk4WH-eNc8EOpvQ.png)

- [計算例](https://cloud.google.com/firestore/docs/billing-example?hl=zh-tw){:target="_blank"}

> ***価格は予告なく変更されることがありますので、公式サイトの最新情報をご確認ください。***

### 結論

タイトルにあるように「テスト用」「テスト用」「テスト用」として、上記のサービスを本番環境や製品のコアとして使用することはあまり推奨しません。

#### 料金が高く、移行が難しい

以前、ある大きなサービスがFirebaseを使って立ち上げられたと聞きましたが、後にデータやトラフィックが増えて料金が非常に高くなりました。移行も難しく、コードは問題ありませんがデータの移行は非常に困難でした。初期に少しコストを節約しただけで、後に大きな損失を招く結果となり、あまり価値がなかったと言えます。

#### テスト用のみ

以上の理由から、Firebase Functions + Firestore を使って構築した API サービスは、個人的にはテストやプロトタイプの製品デモにのみ使用することをお勧めします。

#### もっと機能

Functions は Authentication（認証）や Storage（ファイルアップロード）とも連携できますが、この部分は調査していません。

### 参考資料

- <https://firebase.google.com/docs/firestore/query-data/queries>{:target="_blank"}

- <https://coder.tw/?p=7198>{:target="_blank"}

- <https://firebase.google.com/docs/firestore/solutions/counters#node.js_1>{:target="_blank"}

- <https://javascript.plainenglish.io/firebase-cloud-functions-tutorial-creating-a-rest-api-8cbc51479f80>{:target="_blank"}

### 関連記事

- [Python+Google Cloud Platform+Line Botを使って定期的な作業を自動化する](../70a1409b149a/)

- [i **OS ≥ 10 Notification Service Extension アプリケーション (Swift)**](../cb6eba52a342/)

- [Google Apps Script を使って Gmail メールを Slack に転送する](../d414bdbdb8c9/)

ご質問やご意見がございましたら、[こちらからご連絡ください](https://www.zhgchg.li/contact){:target="_blank"} 。

*[Post](https://medium.com/zrealm-ios-dev/%E4%BD%BF%E7%94%A8-firebase-firestore-functions-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8F%AF%E4%BE%9B%E6%B8%AC%E8%A9%A6%E7%9A%84-api-%E6%9C%8D%E5%8B%99-9659db1357e4){:target="_blank"} は Medium から [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"} によって変換されました。*