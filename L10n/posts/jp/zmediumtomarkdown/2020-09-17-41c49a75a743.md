---
author: ZhgChgLi
categories:
- ZRealmã®é–‹ç™º
date: 2020-09-17T15:53:20.026+0000
description: Xcodeãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã«Swiftã§Run Scriptã‚’ä½œæˆã—ã€å¤šè¨€èªLocalizationã¨Image Assetsã®æ¬ æã‚’è‡ªå‹•ãƒã‚§ãƒƒã‚¯ã€‚æ‰‹é–“å‰Šæ¸›ã¨å“è³ªå‘ä¸Šã‚’å®Ÿç¾ã™ã‚‹å…·ä½“çš„æ‰‹æ³•ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚
image:
  path: /assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg
last_modified_at: 2024-04-13T08:35:25.885+0000
render_with_liquid: false
tags:
- ios
- shell-script
- xcode
- iosã‚¢ãƒ—ãƒªé–‹ç™º
- ãƒ„ãƒ¼ãƒ«ã‚­ãƒƒãƒˆ
- japanese
- ai-translation
title: Xcodeã§Swiftã‚’æ´»ç”¨ï½œRun Scriptã§å¤šè¨€èªã¨ç”»åƒè³‡ç”£ã®æ¬ æã‚’è‡ªå‹•æ¤œå‡º
---

### Xcodeã§ç›´æ¥Swiftã‚’ä½¿ã£ã¦Shell Scriptã‚’æ›¸ãï¼

Localization å¤šè¨€èªãŠã‚ˆã³ Image Assets ã®ä¸è¶³ãƒã‚§ãƒƒã‚¯å°å…¥ã€Swift ã§ä½œã‚‹ Shell Script ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

![Photo by [Glenn Carstens-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg)

Photo by [Glenn Carstens-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}

### èƒŒæ™¯

è‡ªåˆ†ã®ä¸æ³¨æ„ã§ã€å¤šè¨€èªãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç·¨é›†ã™ã‚‹éš›ã«ã€Œ;ã€ã‚’ã‚ˆãæŠœã‹ã—ã¦ã—ã¾ã„ã€ãã®ãŸã‚ã«ã‚¢ãƒ—ãƒªã®ãƒ“ãƒ«ãƒ‰å¾Œã®è¨€èªè¡¨ç¤ºãŒèª¤ã‚‹ã“ã¨ãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚ã•ã‚‰ã«é–‹ç™ºãŒé€²ã‚€ã«ã¤ã‚Œã¦è¨€èªãƒ•ã‚¡ã‚¤ãƒ«ãŒã©ã‚“ã©ã‚“å¤§ãããªã‚Šã€é‡è¤‡ã—ãŸã‚Šä½¿ã‚ã‚Œãªããªã£ãŸæ–‡è¨€ãŒæ··åœ¨ã—ã¦éå¸¸ã«æ··ä¹±ã—ã¦ã„ã¾ã™ï¼ˆç”»åƒã‚¢ã‚»ãƒƒãƒˆã‚‚åŒæ§˜ã®çŠ¶æ³ã§ã™ï¼‰ã€‚

ãšã£ã¨ã“ã®åˆ†é‡ã®å•é¡Œã‚’åŠ©ã‘ã‚‹ãƒ„ãƒ¼ãƒ«ã‚’æ¢ã—ã¦ã„ã¾ã—ãŸã€‚ä»¥å‰ã¯ [iOSLocalizationEditor](https://github.com/igorkulman/iOSLocalizationEditor){:target="_blank"} ã¨ã„ã† Mac ã‚¢ãƒ—ãƒªã‚’ä½¿ã£ã¦ã„ã¾ã—ãŸãŒã€ã“ã‚Œã¯ä¸»ã«ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã®ç·¨é›†ãƒ„ãƒ¼ãƒ«ã§ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’èª­ã¿å–ã‚Šç·¨é›†ã™ã‚‹ã‚‚ã®ã§ã€è‡ªå‹•ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚

### æœŸå¾…ã•ã‚Œã‚‹æ©Ÿèƒ½

build æ™‚ã«å¤šè¨€èªã®ã‚¨ãƒ©ãƒ¼ã€æ¬ è½ã€é‡è¤‡ã€Image Assets ã®æ¬ è½ã‚’è‡ªå‹•ã§ãƒã‚§ãƒƒã‚¯ã§ãã¾ã™ã€‚

### è§£æ±ºç­–

æœŸå¾…ã™ã‚‹æ©Ÿèƒ½ã‚’å®Ÿç¾ã™ã‚‹ã«ã¯ã€Build Phases ã« Run Script ãƒã‚§ãƒƒã‚¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã—ã‹ã—ã€ãƒã‚§ãƒƒã‚¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ shell script ã§æ›¸ãå¿…è¦ãŒã‚ã‚Šã€è‡ªåˆ†ã® shell script ã®ç¿’ç†Ÿåº¦ãŒã‚ã¾ã‚Šé«˜ããªã‹ã£ãŸãŸã‚ã€æ—¢å­˜ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ãƒãƒƒãƒˆã§æ¢ã—ã¦ã¿ã¦ã‚‚å®Œå…¨ã«æœŸå¾…é€šã‚Šã®æ©Ÿèƒ½ã‚’æŒã¤ã‚‚ã®ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚è«¦ã‚ã‹ã‘ãŸã¨ãã«ãµã¨æ€ã„ã¤ãã¾ã—ãŸï¼š

> **Shell Script ã¯ Swift ã§æ›¸ã‘ã‚‹ã‚“ã§ã™**ï¼

shell script ã«æ¯”ã¹ã¦ã‚ˆã‚Šé¦´æŸ“ã¿ãŒã‚ã‚Šã€ç¿’ç†Ÿåº¦ã‚‚é«˜ã„ã§ã™ï¼ã“ã®æ–¹å‘ã§æ¢ã—ãŸã¨ã“ã‚ã€æ—¢å­˜ã®ãƒ„ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’2ã¤è¦‹ã¤ã‘ã¾ã—ãŸï¼

[freshOS](https://freshos.github.io/){:target="_blank"} ãƒãƒ¼ãƒ ãŒä½œæˆã—ãŸ2ã¤ã®ãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«ï¼š

- [**Localize ğŸ**](https://github.com/freshOS/Localize){:target="_blank"}

- [**Asset Checker ğŸ‘®**](https://github.com/s4cha/AssetChecker){:target="_blank"}

å®Œå…¨ã«ç§ãŸã¡ã®æœŸå¾…ã™ã‚‹æ©Ÿèƒ½è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã™ï¼ã—ã‹ã‚‚ Swift ã§æ›¸ã‹ã‚Œã¦ã„ã‚‹ã®ã§ã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚„æ”¹é€ ã‚‚ç°¡å˜ã§ã™ã€‚

#### [Localize ğŸ](https://github.com/freshOS/Localize){:target="_blank"} å¤šè¨€èªãƒ•ã‚¡ã‚¤ãƒ«æ¤œæŸ»ãƒ„ãƒ¼ãƒ«

**æ©Ÿèƒ½ï¼š**

- ãƒ“ãƒ«ãƒ‰æ™‚ã«è‡ªå‹•ã§ãƒã‚§ãƒƒã‚¯

- ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã®è‡ªå‹•æ•´å½¢ã¨æ•´ç†

- å¤šè¨€èªãŠã‚ˆã³ä¸»è¦è¨€èªã®æ¬ è½ã‚„ä½™åˆ†ãªéƒ¨åˆ†ã®ãƒã‚§ãƒƒã‚¯

- å¤šè¨€èªã®é‡è¤‡æ–‡ã®ãƒã‚§ãƒƒã‚¯

- å¤šè¨€èªã®æœªç¿»è¨³æ–‡ã®ãƒã‚§ãƒƒã‚¯

- å¤šè¨€èªã§æœªä½¿ç”¨ã®æ–‡è¨€ã®ãƒã‚§ãƒƒã‚¯

**ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•ï¼š**

1. [ãƒ„ãƒ¼ãƒ«ã® Swift ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰](https://github.com/freshOS/Localize/blob/master/Localize.swift){:target="_blank"}

2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«é…ç½®ã—ã¾ã™ ä¾‹: `${SRCROOT}/Localize.swift`

3. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šã‚’é–‹ã â†’ iOSã‚¿ãƒ¼ã‚²ãƒƒãƒˆ â†’ Build Phases â†’ å·¦ä¸Šã®ã€Œ+ã€ â†’ New Run Script Phase â†’ ã‚¹ã‚¯ãƒªãƒ—ãƒˆå†…å®¹ã«ãƒ‘ã‚¹ã‚’è²¼ã‚Šä»˜ã‘ EX: `${SRCROOT}/Localize.swift`

![](/assets/41c49a75a743/1*k2OHjrcQaQIWLqV7G57TgA.png)

4. Xcodeã§ `Localize.swift` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã„ã¦è¨­å®šã‚’ç·¨é›†ã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸Šéƒ¨ã«å¤‰æ›´å¯èƒ½ãªè¨­å®šé …ç›®ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ï¼š

```swift
// ãƒã‚§ãƒƒã‚¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æœ‰åŠ¹ã«ã™ã‚‹
let enabled = true

// ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
let relativeLocalizableFolders = "/Resources/Languages"

// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆã‚³ãƒ¼ãƒ‰å†…ã§ã‚­ãƒ¼ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã‹ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ï¼‰
let relativeSourceFolder = "/Sources"

// ã‚³ãƒ¼ãƒ‰å†…ã® NSLocalized ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã®æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³
// è¿½åŠ å¯èƒ½ã€å¤‰æ›´ä¸è¦
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\"", // Swift ã¨ Objc ãƒã‚¤ãƒ†ã‚£ãƒ–
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine å‘¼ã³å‡ºã—
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen ç”Ÿæˆ
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized ãƒ‘ã‚¿ãƒ¼ãƒ³
]

// ã€Œæœªä½¿ç”¨ã®ã‚­ãƒ¼è­¦å‘Šã€ã‚’ç„¡è¦–ã™ã‚‹ã‚­ãƒ¼
let ignoredFromUnusedKeys: [String] = []
/* ä¾‹
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

// ãƒ¡ã‚¤ãƒ³è¨€èª
let masterLanguage = "en"

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ a-z ã‚½ãƒ¼ãƒˆãƒ»æ•´ç†ã‚’æœ‰åŠ¹ã«ã™ã‚‹
let sanitizeFiles = false

// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒå˜ä¸€è¨€èªã‹å¤šè¨€èªã‹
let singleLanguage = false

// æœªç¿»è¨³ã‚­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã‚’æœ‰åŠ¹ã«ã™ã‚‹
let checkForUntranslated = true
```

5. ãƒ“ãƒ«ãƒ‰ï¼æˆåŠŸï¼

![](/assets/41c49a75a743/1*74osParg9RRi2gcRx9ELuw.png)

**ãƒã‚§ãƒƒã‚¯çµæœã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ï¼š**

- **Build Error** âŒ **ï¼š**
  - [Duplication] ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«å†…ã§é …ç›®ãŒé‡è¤‡ã—ã¦ã„ã¾ã™
  - [Unused Key] ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹é …ç›®ãŒã‚³ãƒ¼ãƒ‰å†…ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã›ã‚“
  - [Missing] ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã«å®šç¾©ã•ã‚Œã¦ã„ãªã„é …ç›®ãŒã‚³ãƒ¼ãƒ‰å†…ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™
  - [Redundant] ã“ã®ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã®é …ç›®ã¯ãƒ¡ã‚¤ãƒ³ã®ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã«æ¯”ã¹ã¦ä½™åˆ†ã§ã™
  - [Missing Translation] é …ç›®ã¯ãƒ¡ã‚¤ãƒ³ã®ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ã‚Šã¾ã™ãŒã€ã“ã®ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯æ¬ ã‘ã¦ã„ã¾ã™

- **Build Warning** âš ï¸ **ï¼š**
  - [Potentially Untranslated] ã“ã®é …ç›®ã¯ç¿»è¨³ã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆãƒ¡ã‚¤ãƒ³è¨€èªãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã¨åŒã˜ã§ã™ï¼‰

> ***ã¾ã å®Œäº†ã—ã¦ã„ã¾ã›ã‚“ã€‚ç¾åœ¨ã¯è‡ªå‹•ãƒã‚§ãƒƒã‚¯ã®é€šçŸ¥ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ãŒã€ã•ã‚‰ã«è‡ªåˆ†ã§ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚***

**ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒæ­£è¦è¡¨ç¾ï¼š**

`Localize.swift` ã®å…ˆé ­è¨­å®šãƒ–ãƒ­ãƒƒã‚¯ patterns éƒ¨åˆ†ã®æœ€åˆã®é …ç›®ã‚’æŒ¯ã‚Šè¿”ã£ã¦ã¿ã¾ã—ã‚‡ã†ï¼š

`"NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\""`

Swift/ObjCã® `NSLocalizedString()` ãƒ¡ã‚½ãƒƒãƒ‰ã«ãƒãƒƒãƒã—ã¾ã™ã€‚ã“ã®æ­£è¦è¡¨ç¾ã¯ `"Home.Title"` ã®ã‚ˆã†ãªå½¢å¼ã®æ–‡ã ã‘ã«ãƒãƒƒãƒã—ã¾ã™ã€‚å®Œå…¨ãªæ–‡ç« ã‚„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä»˜ãã®å ´åˆã¯ã€èª¤ã£ã¦[Unused Key]ã¨åˆ¤æ–­ã•ã‚Œã¾ã™ã€‚

EX: `"Hi, %@ welcome to my app"ã€"Hello World!"` **â† ã“ã‚Œã‚‰ã®æ–‡ã¯ãƒãƒƒãƒã—ã¾ã›ã‚“**

patterns ã®è¨­å®šã‚’æ–°ãŸã«è¿½åŠ ã™ã‚‹ã‹ã€æ—¢å­˜ã® patterns ã‚’æ¬¡ã®ã‚ˆã†ã«å¤‰æ›´ã§ãã¾ã™ï¼š

`"NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\""`

ä¸»ã« `NSLocalizedString` ãƒ¡ã‚½ãƒƒãƒ‰ã®å¾Œã®ãƒãƒƒãƒãƒ³ã‚°æ–‡ã‚’èª¿æ•´ã—ã€ä»»æ„ã®æ–‡å­—åˆ—ã‚’ `"` ãŒå‡ºç¾ã™ã‚‹ã¾ã§å–å¾—ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚ã”è‡ªèº«ã®ãƒ‹ãƒ¼ã‚ºã«åˆã‚ã›ã¦ã€[ã“ã¡ã‚‰](https://rubular.com/r/5eXvGy3svsAHyT){:target="_blank"}ã‹ã‚‰ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚‚å¯èƒ½ã§ã™ã€‚

**å¤šè¨€èªãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½ã‚’è¿½åŠ ï¼š**

ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯è¨€èªãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹å¯¾å¿œãƒã‚§ãƒƒã‚¯ã®ã¿ã‚’è¡Œã„ã€ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®æ­£ç¢ºã•ï¼ˆã€Œ**;**ã€ã‚’å¿˜ã‚Œã¦ã„ãªã„ã‹ãªã©ï¼‰ã¯ãƒã‚§ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚å¿…è¦ãªå ´åˆã¯ã”è‡ªèº«ã§è¿½åŠ ã—ã¦ãã ã•ã„ï¼

```swift
//....
let formatResult = shell("plutil -lint \(location)")
guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
  let str = "\(path)/\(name).lproj"
            + "/Localizable.strings:1: "
            + "error: [File Invaild] "
            + "ã“ã® Localizable.strings ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒç„¡åŠ¹ã§ã™ã€‚"
  print(str)
  numberOfErrors += 1
  return
}
//....

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```

`shell()` ã‚’è¿½åŠ ã—ã¦ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã€`plutil -lint` ã‚’ä½¿ã£ã¦ plist ã®ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ­£ç¢ºæ€§ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã‚„ã€Œ;ã€ã®ä¸è¶³ãŒã‚ã‚‹å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã€å•é¡Œãªã‘ã‚Œã° `OK` ã‚’è¿”ã—ã¦åˆ¤å®šã—ã¾ã™ï¼

ãƒã‚§ãƒƒã‚¯ç®‡æ‰€ã¯ LocalizationFiles->process() -> `let location = singleLanguageâ€¦` ã®å¾Œã€ç´„135è¡Œç›®ã‚ãŸã‚Šã«è¿½åŠ ã§ãã¾ã™ã€‚ã¾ãŸã¯ã€æœ€å¾Œã«æä¾›ã™ã‚‹å®Œå…¨æ”¹é€ ç‰ˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

**ãã®ä»–ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼š**

ç§ãŸã¡ã¯è‡ªåˆ†ã®ãƒ‹ãƒ¼ã‚ºã«åˆã‚ã›ã¦ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€error ã‚’ warning ã«å¤‰æ›´ã—ãŸã‚Šã€ç‰¹å®šã®ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½ï¼ˆä¾‹ï¼šPotentially Untranslatedã€Unused Keyï¼‰ã‚’ç„¡åŠ¹ã«ã—ãŸã‚Šã§ãã¾ã™ã€‚ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ Swift ãªã®ã§ã€æ…£ã‚Œã¦ã„ã‚‹ç§ãŸã¡ã«ã¯å®‰å¿ƒã—ã¦å¤‰æ›´ã§ãã¾ã™ï¼é–“é•ã£ã¦å£Šã™å¿ƒé…ã‚‚ã‚ã‚Šã¾ã›ã‚“ï¼

ãƒ“ãƒ«ãƒ‰æ™‚ã«ã‚¨ãƒ©ãƒ¼âŒã‚’å‡ºã™ã«ã¯ï¼š

```
print("Projectãƒ•ã‚¡ã‚¤ãƒ«.lproj" + "/ãƒ•ã‚¡ã‚¤ãƒ«:è¡Œ: " + "error: ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸")
```

build æ™‚ã« Warning âš ï¸ ã‚’è¡¨ç¤ºã•ã›ã‚‹ã«ã¯ï¼š

```
print("Projectãƒ•ã‚¡ã‚¤ãƒ«.lproj" + "/ãƒ•ã‚¡ã‚¤ãƒ«:è¡Œ: " + "warning: è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸")
```

**æœ€çµ‚é­”æ”¹ç‰ˆï¼š**

```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// WHAT
// 1. ä»–ã®ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã§æ¬ è½ã—ã¦ã„ã‚‹ã‚­ãƒ¼ã‚’æ¤œå‡ºã™ã‚‹
// 2. æœªç¿»è¨³ã®å¯èƒ½æ€§ãŒã‚ã‚‹ã‚­ãƒ¼ã‚’æ¤œå‡ºã™ã‚‹
// 3. é‡è¤‡ã—ã¦ã„ã‚‹ã‚­ãƒ¼ã‚’æ¤œå‡ºã™ã‚‹
// 4. æœªä½¿ç”¨ã®ã‚­ãƒ¼ã‚’æ¤œå‡ºã—ã€ä¸€æ‹¬å‰Šé™¤ç”¨ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç”Ÿæˆã™ã‚‹

// MARK: Start Of Configurable Section

/*
 ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æœ‰åŠ¹ã¾ãŸã¯ç„¡åŠ¹ã«ã§ãã¾ã™
 */
let enabled = true

/*
 ãƒ‘ã‚¹ã‚’ã“ã“ã«è¨˜å…¥ã—ã¦ãã ã•ã„ã€‚ä¾‹ ->  Resources/Localizations/Languages
 */
let relativeLocalizableFolders = "/streetvoice/SupportingFiles"

/*
 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã§å®Ÿéš›ã«ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºã‚­ãƒ¼ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚©ãƒ«ãƒ€ã®ãƒ‘ã‚¹ã§ã™
 */
let relativeSourceFolder = "/streetvoice"

/*
 ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºã‚’èªè­˜ã™ã‚‹ãŸã‚ã®æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚
 */
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\"", // Swift ã¨ Objc ãƒã‚¤ãƒ†ã‚£ãƒ–
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine å‘¼ã³å‡ºã—
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen ç”Ÿæˆ
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized ãƒ‘ã‚¿ãƒ¼ãƒ³
]

/*
 "æœªä½¿ç”¨" ã¨èªè­˜ã—ãŸããªã„ã‚­ãƒ¼ã§ã™
 ä¾‹ãˆã°ã€é€£çµã—ã¦ä½¿ã†ã‚­ãƒ¼ã¯è§£æã§æ¤œå‡ºã•ã‚Œãªã„ãŸã‚ã€
 èª¤æ¤œçŸ¥ã‚’é˜²ããŸã‚ã«ã“ã“ã«è¿½åŠ ã—ã¦ãã ã•ã„ :)
 */
let ignoredFromUnusedKeys: [String] = []
/* ä¾‹
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

let masterLanguage = "base"

/*
 ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚ºã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚„ç©ºè¡Œã‚’å‰Šé™¤ã—ã€
 ã‚­ãƒ¼ã‚’ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆé †ã«ä¸¦ã¹æ›¿ãˆã¾ã™ã€‚
 */
let sanitizeFiles = false

/*
 è¤‡æ•°è¨€èªãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚
 */
let singleLanguage = false

/*
 ã‚¢ãƒ—ãƒªå†…ã«å­˜åœ¨ã™ã‚‹ãŒãƒã‚¹ã‚¿ãƒ¼ç¿»è¨³ã«ãªã„ã‚­ãƒ¼ãŒã‚ã‚‹å ´åˆã«ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹ã‹ã©ã†ã‹
 */
let checkForUntranslated = false

// MARK: End Of Configurable Section

if enabled == false {
    print("Localization check cancelled")
    exit(000)
}

// å¯¾å¿œè¨€èªã®ãƒªã‚¹ãƒˆã‚’è‡ªå‹•æ¤œå‡º
func listSupportedLanguages() -> [String] {
    var sl: [String] = []
    let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
    if !FileManager.default.fileExists(atPath: path) {
        print("Invalid configuration: \(path) does not exist.")
        exit(1)
    }
    let enumerator = FileManager.default.enumerator(atPath: path)
    let extensionName = "lproj"
    print("Found these languages:")
    while let element = enumerator?.nextObject() as? String {
        if element.hasSuffix(extensionName) {
            print(element)
            let name = element.replacingOccurrences(of: ".\(extensionName)", with: "")
            sl.append(name)
        }
    }
    return sl
}

let supportedLanguages = listSupportedLanguages()
var ignoredFromSameTranslation: [String: [String]] = [:]
let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
var numberOfWarnings = 0
var numberOfErrors = 0

struct LocalizationFiles {
    var name = ""
    var keyValue: [String: String] = [:]
    var linesNumbers: [String: Int] = [:]

    init(name: String) {
        self.name = name
        process()
    }

    mutating func process() {
        if sanitizeFiles {
            removeCommentsFromFile()
            removeEmptyLinesFromFile()
            sortLinesAlphabetically()
        }
        let location = singleLanguage ? "\(path)/Localizable.strings" : "\(path)/\(name).lproj/Localizable.strings"
        
        let formatResult = shell("plutil -lint \(location)")
        guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
            let str = "\(path)/\(name).lproj"
                + "/Localizable.strings:1: "
                + "error: [File Invaild] "
                + "ã“ã® Localizable.strings ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ãŒç„¡åŠ¹ã§ã™ã€‚"
            print(str)
            numberOfErrors += 1
            return
        }
        
        guard let string = try? String(contentsOfFile: location, encoding: .utf8) else {
            return
        }

        let lines = string.components(separatedBy: .newlines)
        keyValue = [:]

        let pattern = "\"(.*)\" = \"(.+)\";"
        let regex = try? NSRegularExpression(pattern: pattern, options: [])
        var ignoredTranslation: [String] = []

        for (lineNumber, line) in lines.enumerated() {
            let range = NSRange(location: 0, length: (line as NSString).length)

            // ç„¡è¦–ã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³
            let ignoredPattern = "\"(.*)\" = \"(.+)\"; *\\/\\/ *ignore-same-translation-warning"
            let ignoredRegex = try? NSRegularExpression(pattern: ignoredPattern, options: [])
            if let ignoredMatch = ignoredRegex?.firstMatch(in: line,
                                                           options: [],
                                                           range: range) {
                let key = (line as NSString).substring(with: ignoredMatch.range(at: 1))
                ignoredTranslation.append(key)
            }

            if let firstMatch = regex?.firstMatch(in: line, options: [], range: range) {
                let key = (line as NSString).substring(with: firstMatch.range(at: 1))
                let value = (line as NSString).substring(with: firstMatch.range(at: 2))

                if keyValue[key] != nil {
                    let str = "\(path)/\(name).lproj"
                        + "/Localizable.strings:\(linesNumbers[key]!): "
                        + "error: [Duplication] \"\(key)\" "
                        + "\(name.uppercased()) ãƒ•ã‚¡ã‚¤ãƒ«ã§é‡è¤‡ã—ã¦ã„ã¾ã™"
                    print(str)
                    numberOfErrors += 1
                } else {
                    keyValue[key] = value
                    linesNumbers[key] = lineNumber + 1
                }
            }
        }
        print(ignoredFromSameTranslation)
        ignoredFromSameTranslation[name] = ignoredTranslation
    }

    func rebuildFileString(from lines: [String]) -> String {
        return lines.reduce("") { (r: String, s: String) -> String in
            (r == "") ? (r + s) : (r + "\n" + s)
        }
    }

    func removeEmptyLinesFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeCommentsFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { !$0.hasPrefix("//") }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func sortLinesAlphabetically() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            let lines = string.components(separatedBy: .newlines)

            var s = ""
            for (i, l) in sortAlphabetically(lines).enumerated() {
                s += l
                if i != lines.count - 1 {
                    s += "\n"
                }
            }
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeEmptyLinesFromLines(_ lines: [String]) -> [String] {
        return lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
    }

    func sortAlphabetically(_ lines: [String]) -> [String] {
        return lines.sorted()
    }
}

// MARK: - ãƒ¡ãƒ¢ãƒªå†…ã«ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€

let masterLocalizationFile = LocalizationFiles(name: masterLanguage)
let localizationFiles = supportedLanguages
    .filter { $0 != masterLanguage }
    .map { LocalizationFiles(name: $0) }

// MARK: - æœªä½¿ç”¨ã‚­ãƒ¼ã‚’æ¤œå‡º

let sourcesPath = FileManager.default.currentDirectoryPath + relativeSourceFolder
let fileManager = FileManager.default
let enumerator = fileManager.enumerator(atPath: sourcesPath)
var localizedStrings: [String] = []
while let swiftFileLocation = enumerator?.nextObject() as? String {
    // æ‹¡å¼µå­ã‚’ãƒã‚§ãƒƒã‚¯
    if swiftFileLocation.hasSuffix(".swift") \\|\\| swiftFileLocation.hasSuffix(".m") \\|\\| swiftFileLocation.hasSuffix(".mm") {
        let location = "\(sourcesPath)/\(swiftFileLocation)"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            for p in patterns {
                let regex = try? NSRegularExpression(pattern: p, options: [])
                let range = NSRange(location: 0, length: (string as NSString).length) // Obj c ç”¨
                regex?.enumerateMatches(in: string,
                                        options: [],
                                        range: range,
                                        using: { result, _, _ in
                                            if let r = result {
                                                let value = (string as NSString).substring(with: r.range(at: r.numberOfRanges - 1))
                                                localizedStrings.append(value)
                                            }
                })
            }
        }
    }
}

var masterKeys = Set(masterLocalizationFile.keyValue.keys)
let usedKeys = Set(localizedStrings)
let ignored = Set(ignoredFromUnusedKeys)
let unused = masterKeys.subtracting(usedKeys).subtracting(ignored)
let untranslated = usedKeys.subtracting(masterKeys)

// ã“ã“ã§æœªä½¿ç”¨ã‚­ãƒ¼ã‚’ä¸€æ‹¬å‰Šé™¤ã™ã‚‹ãŸã‚ã®Xcodeæ­£è¦è¡¨ç¾ã®ç½®æ›ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç”Ÿæˆï¼
var replaceCommand = "\"("
var counter = 0
for v in unused {
    var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[v]!): "
    str += "error: [Unused Key] \"\(v)\" ã¯ä¸€åº¦ã‚‚ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã›ã‚“"
    print(str)
    numberOfErrors += 1
    if counter != 0 {
        replaceCommand += "\\|"
    }
    replaceCommand += v
    if counter == unused.count - 1 {
        replaceCommand += ")\" = \".*\";"
    }
    counter += 1
}

print(replaceCommand)

// MARK: - å„ç¿»è¨³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚¹ã‚¿ãƒ¼(en)ã¨æ¯”è¼ƒ

for file in localizationFiles {
    for k in masterLocalizationFile.keyValue.keys {
        if file.keyValue[k] == nil {
            var str = "\(path)/\(file.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[k]!): "
            str += "error: [Missing] \"\(k)\" ãŒ \(file.name.uppercased()) ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ã‚Šã¾ã›ã‚“"
            print(str)
            numberOfErrors += 1
        }
    }

    let redundantKeys = file.keyValue.keys.filter { !masterLocalizationFile.keyValue.keys.contains($0) }

    for k in redundantKeys {
        let str = "\(path)/\(file.name).lproj/Localizable.strings:\(file.linesNumbers[k]!): "
            + "error: [Redundant key] \"\(k)\" ã¯ \(file.name.uppercased()) ãƒ•ã‚¡ã‚¤ãƒ«ã§å†—é•·ã§ã™"

        print(str)
    }
}

if checkForUntranslated {
    for key in untranslated {
        var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:1: "
        str += "error: [Missing Translation] \(key) ã¯ç¿»è¨³ã•ã‚Œã¦ã„ã¾ã›ã‚“"

        print(str)
        numberOfErrors += 1
    }
}

print("è­¦å‘Šã®æ•° : \(numberOfWarnings)")
print("ã‚¨ãƒ©ãƒ¼ã®æ•° : \(numberOfErrors)")

if numberOfErrors > 0 {
    exit(1)
}

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```

> ***æœ€å¾Œæœ€å¾Œã€ã¾ã çµ‚ã‚ã£ã¦ã„ã¾ã›ã‚“ï¼***

ç§ãŸã¡ã® Swift ãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®èª¿æ•´ãŒå®Œäº†ã—ãŸã‚‰ã€**ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¦å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã«ã™ã‚‹ã“ã¨ã§ãƒ“ãƒ«ãƒ‰æ™‚é–“ã‚’çŸ­ç¸®**ã—ã¾ã—ã‚‡ã†ã€‚ãã†ã—ãªã„ã¨ã€æ¯å›ãƒ“ãƒ«ãƒ‰æ™‚ã«å†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒç™ºç”Ÿã—ï¼ˆç´„90%ã®æ™‚é–“ã‚’å‰Šæ¸›å¯èƒ½ï¼‰ã€æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ã€‚

ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚’é–‹ãã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã®ãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒã‚ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•ã—ã¦å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼š

```bash
swiftc -o Localize Localize.swift
```

![](/assets/41c49a75a743/1*rwq_KZIDW-Lvtpd2xmgjDw.png)

![](/assets/41c49a75a743/1*BCKtqshZxHH17j3nBGtNlg.png)

ãã—ã¦ Build Phases ã«æˆ»ã‚Šã€Script ã®å†…å®¹ã®ãƒ‘ã‚¹ã‚’å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã«å¤‰æ›´ã—ã¾ã™ã€‚

EX: `${SRCROOT}/Localize`

![](/assets/41c49a75a743/1*ewhCXzXNuS0MCTMCuINWng.png)

**å®Œäº†ï¼**

#### ãƒ„ãƒ¼ãƒ« 2. [**Asset Checker ğŸ‘®**](https://github.com/s4cha/AssetChecker){:target="_blank"} **ç”»åƒãƒªã‚½ãƒ¼ã‚¹ãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«**

**æ©Ÿèƒ½ï¼š**

- build æ™‚ã«è‡ªå‹•ã§ãƒã‚§ãƒƒã‚¯

- ç”»åƒã®æ¬ è½ãƒã‚§ãƒƒã‚¯ï¼šåå‰ã¯å‘¼ã³å‡ºã•ã‚Œã¦ã„ã‚‹ãŒã€ç”»åƒãƒªã‚½ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å­˜åœ¨ã—ãªã„ã‚‚ã®

- ç”»åƒã®ä½™åˆ†ï¼šåå‰ã¯æœªä½¿ç”¨ã ãŒã€ç”»åƒãƒªã‚½ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å­˜åœ¨ã™ã‚‹ã‚‚ã®

**ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•ï¼š**

1. [ãƒ„ãƒ¼ãƒ«ã® Swift ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰](https://github.com/freshOS/AssetChecker/blob/master/Classes/main.swift){:target="_blank"}

2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«é…ç½®ã—ã¾ã™ ä¾‹: `${SRCROOT}/AssetChecker.swift`

3. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šã‚’é–‹ã â†’ iOSã‚¿ãƒ¼ã‚²ãƒƒãƒˆ â†’ Build Phases â†’ å·¦ä¸Šã®ã€Œ+ã€ â†’ New Run Script Phase â†’ ã‚¹ã‚¯ãƒªãƒ—ãƒˆå†…å®¹ã«ãƒ‘ã‚¹ã‚’è²¼ã‚Šä»˜ã‘ã‚‹

```bash
${SRCROOT}/AssetChecker.swift ${SRCROOT}/å°ˆæ¡ˆç›®éŒ„ ${SRCROOT}/Resources/Images.xcassets
//${SRCROOT}/Resources/Images.xcassets = ã‚ãªãŸã® .xcassets ã®å ´æ‰€
```

![](/assets/41c49a75a743/1*TPLS60W1iQiGFzU-inf3aA.png)

ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç›´æ¥ãƒ‘ã‚¹ã«æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿1ï¼šãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´æ‰€ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿2ï¼šç”»åƒãƒªã‚½ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´æ‰€ï¼›ã¾ãŸã¯å¤šè¨€èªãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«ã¨åŒæ§˜ã« `AssetChecker.swift` ã®å…ˆé ­ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®šãƒ–ãƒ­ãƒƒã‚¯ã‚’ç·¨é›†ã—ã¦ãã ã•ã„ï¼š

```swift
// è¨­å®šã—ã¦ãã ã•ã„ \o/

// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´æ‰€ï¼ˆç”»åƒãŒã‚³ãƒ¼ãƒ‰å†…ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹æ¤œç´¢ã™ã‚‹ãŸã‚ï¼‰
var sourcePathOption:String? = nil

// .xcassets ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´æ‰€
var assetCatalogPathOption:String? = nil

// æœªä½¿ç”¨ã®è­¦å‘Šã‚’ç„¡è¦–ã™ã‚‹é …ç›®
let ignoredUnusedNames = [String]()
```

4. ãƒ“ãƒ«ãƒ‰ï¼æˆåŠŸï¼

**ãƒã‚§ãƒƒã‚¯çµæœã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ï¼š**

- **Build Error** âŒ **ï¼š**
  - [Asset Missing] ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã§å‘¼ã³å‡ºã•ã‚Œã¦ã„ã‚‹ãŒã€ç”»åƒãƒªã‚½ãƒ¼ã‚¹ãƒ•ã‚©ãƒ«ãƒ€ã«å­˜åœ¨ã—ãªã„é …ç›®

- **Build Warning** âš ï¸ **ï¼š**
  - [Asset Unused] é …ç›®ã¯ã‚³ãƒ¼ãƒ‰å†…ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã›ã‚“ãŒã€ç”»åƒãƒªã‚½ãƒ¼ã‚¹ãƒ•ã‚©ãƒ«ãƒ€ã«ã¯å­˜åœ¨ã—ã¾ã™
  *p.s ç”»åƒãŒå‹•çš„ãªå¤‰æ•°ã§æä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«ã¯èªè­˜ã§ãã¾ã›ã‚“ã€‚ãã®å ´åˆã¯ `ignoredUnusedNames` ã«è¿½åŠ ã—ã¦ä¾‹å¤–ã«è¨­å®šã—ã¦ãã ã•ã„ã€‚*

ä»–ã®æ“ä½œã¯å¤šè¨€èªãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«ã¨åŒæ§˜ãªã®ã§ã“ã“ã§ã¯çœç•¥ã—ã¾ã™ï¼›æœ€ã‚‚é‡è¦ãªã®ã¯ã€**èª¿æ•´å¾Œã«å¿…ãšã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¦å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã«ã—ã€run script ã®å†…å®¹ã‚’å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã«å¤‰æ›´ã™ã‚‹ã“ã¨ã‚’å¿˜ã‚Œãªã„ã§ãã ã•ã„ï¼**

#### è‡ªåˆ†ã®ãƒ„ãƒ¼ãƒ«ã‚’é–‹ç™ºã—ã‚ˆã†ï¼

> ***ç”»åƒãƒªã‚½ãƒ¼ã‚¹ãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å‚è€ƒã«ã§ãã¾ã™ï¼š***

```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// è¨­å®šã—ã¦ãã ã•ã„ \o/
var sourcePathOption:String? = nil
var assetCatalogPathOption:String? = nil
let ignoredUnusedNames = [String]()

for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        sourcePathOption = arg
    case 2:
        assetCatalogPathOption = arg
    default:
        break
    }
}

guard let sourcePath = sourcePathOption else {
    print("AssetChecker:: error: ã‚½ãƒ¼ã‚¹ãƒ‘ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼")
    exit(0)
}

guard let assetCatalogAbsolutePath = assetCatalogPathOption else {
    print("AssetChecker:: error: ã‚¢ã‚»ãƒƒãƒˆã‚«ã‚¿ãƒ­ã‚°ã®ãƒ‘ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼")
    exit(0)
}

print("\(sourcePath) å†…ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰ \(assetCatalogAbsolutePath) ã®ã‚¢ã‚»ãƒƒãƒˆã‚’æ¤œç´¢ä¸­")

/* ã“ã“ã«èª¤æ¤œçŸ¥ã™ã‚‹ã‚¢ã‚»ãƒƒãƒˆã‚’è¿½åŠ ã—ã¦ãã ã•ã„
 ä¾‹ãˆã°ã€å®Ÿè¡Œæ™‚ã«ã‚¢ã‚»ãƒƒãƒˆåã‚’ç”Ÿæˆã™ã‚‹å ´åˆãªã©
let ignoredUnusedNames = [
    "IconArticle",
    "IconMedia",
    "voteEN",
    "voteES",
    "voteFR"
] 
*/


// MARK : - è¨­å®šçµ‚äº†
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}


// MARK: - ã‚¢ã‚»ãƒƒãƒˆä¸€è¦§å–å¾—
func listAssets() -> [String] {
    let extensionName = "imageset"
    let enumerator = FileManager.default.enumerator(atPath: assetCatalogAbsolutePath)
    return elementsInEnumerator(enumerator)
        .filter { $0.hasSuffix(extensionName) }                             // ã‚¢ã‚»ãƒƒãƒˆã‹ã©ã†ã‹
        .map { $0.replacingOccurrences(of: ".\(extensionName)", with: "") } // æ‹¡å¼µå­ã‚’å‰Šé™¤
        .map { $0.components(separatedBy: "/").last ?? $0 }                 // ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ã‚’å‰Šé™¤
}


// MARK: - ã‚³ãƒ¼ãƒ‰å†…ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‚¢ã‚»ãƒƒãƒˆä¸€è¦§å–å¾—
func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // Image Literal
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // Swiftã®UIImageå‘¼ã³å‡ºã—
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // UIImageã®å‘¼ã³å‡ºã—
        "\\<image name=\"\(namePattern)\".*", // Storyboardã®ãƒªã‚½ãƒ¼ã‚¹
        "R.image.\(namePattern)\\(\\)" // R.swiftå¯¾å¿œ
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Swiftã¨Obj-Cãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿
            .map { "\(sourcePath)/\($0)" }                              // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ç”Ÿæˆ
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’å–å¾—
            .compactMap{$0}
            .compactMap{$0}                                             // nilã‚’é™¤å»
            .map(localizedStrings)                                      // localizedStringsã‚’æ¤œç´¢
            .flatMap{$0}                                                // å¹³å¦åŒ–
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Swiftã¨Obj-Cãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿
            .map { "\(sourcePath)/\($0)" }                              // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ç”Ÿæˆ
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’å–å¾—
            .flatMap{$0}
            .flatMap{$0}                                                // nilã‚’é™¤å»
            .map(localizedStrings)                                      // localizedStringsã‚’æ¤œç´¢
            .flatMap{$0}                                                // å¹³å¦åŒ–
    #endif
}


// MARK: - ã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹
let assets = Set(listAssets())
let used = Set(listUsedAssetLiterals() + ignoredUnusedNames)


// æœªä½¿ç”¨ã‚¢ã‚»ãƒƒãƒˆã®è­¦å‘Šã‚’ç”Ÿæˆ
let unused = assets.subtracting(used)
unused.forEach { print("\(assetCatalogAbsolutePath):: warning: [Asset Unused] \($0)") }


// å£Šã‚ŒãŸï¼ˆå­˜åœ¨ã—ãªã„ï¼‰ã‚¢ã‚»ãƒƒãƒˆã®ã‚¨ãƒ©ãƒ¼ã‚’ç”Ÿæˆ
let broken = used.subtracting(assets)
broken.forEach { print("\(assetCatalogAbsolutePath):: error: [Asset Missing] \($0)") }

if broken.count > 0 {
    exit(1)
}
```

è¨€èªãƒã‚§ãƒƒã‚¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨æ¯”ã¹ã¦ã€ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ã‚·ãƒ³ãƒ—ãƒ«ã§é‡è¦ãªæ©Ÿèƒ½ãŒã™ã¹ã¦æƒã£ã¦ãŠã‚Šã€ã¨ã¦ã‚‚å‚è€ƒã«ãªã‚Šã¾ã™ï¼

*P.S ã‚³ãƒ¼ãƒ‰ã« `localizedStrings()` ã¨ã„ã†åå‰ãŒå‡ºã¦ãã‚‹ã®ã¯ã€å¤šè¨€èªãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«ã®ãƒ­ã‚¸ãƒƒã‚¯ã‹ã‚‰æµç”¨ã—ã¦ãƒ¡ã‚½ãƒƒãƒ‰åã‚’å¤‰æ›´ã—å¿˜ã‚ŒãŸã¨æ€ã‚ã‚Œã¾ã™ XD*

**ä¾‹ãˆã°ï¼š**

```swift
for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        // å¼•æ•°1
    case 2:
        // å¼•æ•°2
    default:
        break
    }
}
```

^å¤–éƒ¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹æ–¹æ³•

```swift
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}

func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // ç”»åƒãƒªãƒ†ãƒ©ãƒ«
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® UIImage å‘¼ã³å‡ºã— (Swift)
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® UIImage å‘¼ã³å‡ºã—
        "\\<image name=\"\(namePattern)\".*", // ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãƒœãƒ¼ãƒ‰ã®ãƒªã‚½ãƒ¼ã‚¹
        "R.image.\(namePattern)\\(\\)" // R.swift ã‚µãƒãƒ¼ãƒˆ
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Swift ã¨ Obj-C ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿
            .map { "\(sourcePath)/\($0)" }                              // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ä½œæˆ
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’å–å¾—
            .compactMap{$0}
            .compactMap{$0}                                             // nil ã‚’é™¤å»
            .map(localizedStrings)                                      // localizedStrings ã®å‡ºç¾ã‚’æ¤œç´¢
            .flatMap{$0}                                                // ãƒ•ãƒ©ãƒƒãƒˆåŒ–
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Swift ã¨ Obj-C ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿
            .map { "\(sourcePath)/\($0)" }                              // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ä½œæˆ
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’å–å¾—
            .flatMap{$0}
            .flatMap{$0}                                                // nil ã‚’é™¤å»
            .map(localizedStrings)                                      // localizedStrings ã®å‡ºç¾ã‚’æ¤œç´¢
            .flatMap{$0}                                                // ãƒ•ãƒ©ãƒƒãƒˆåŒ–
    #endif
}
```

^ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èµ°æŸ»ã—ã¦æ­£è¦è¡¨ç¾ã§ãƒãƒƒãƒãƒ³ã‚°ã™ã‚‹æ–¹æ³•

```swift
// ãƒ“ãƒ«ãƒ‰æ™‚ã«ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ âŒï¼š
print("Projectæª”æ¡ˆ.lproj" + "/æª”æ¡ˆ:è¡Œ: " + "error: ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸")
// ãƒ“ãƒ«ãƒ‰æ™‚ã«è­¦å‘Šã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ âš ï¸ï¼š
print("Projectæª”æ¡ˆ.lproj" + "/æª”æ¡ˆ:è¡Œ: " + "warning: è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸")
```

^ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯è­¦å‘Šã‚’å‡ºåŠ›ã™ã‚‹

ä»¥ä¸Šã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ æ–¹æ³•ã‚’ç·åˆçš„ã«å‚è€ƒã«ã—ã¦ã€è‡ªåˆ†ã®æ¬²ã—ã„ãƒ„ãƒ¼ãƒ«ã‚’ä½œæˆã§ãã¾ã™ã€‚

### ã¾ã¨ã‚

ã“ã‚Œã‚‰ã®ãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«ã‚’å°å…¥ã™ã‚‹ã“ã¨ã§ã€é–‹ç™ºãŒã‚ˆã‚Šå®‰å¿ƒã§åŠ¹ç‡çš„ã«ãªã‚Šã€å†—é•·ã•ã‚‚æ¸›ã‚‰ã›ã¾ã™ã€‚ã¾ãŸã€ä»Šå›ã®çµŒé¨“ã§è¦–é‡ãŒåºƒãŒã£ãŸãŸã‚ã€ä»Šå¾Œæ–°ã—ã„ãƒ“ãƒ«ãƒ‰ãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®è¦ä»¶ãŒã‚ã£ã¦ã‚‚ã€æœ€ã‚‚æ…£ã‚Œè¦ªã—ã‚“ã  Swift è¨€èªã§ç›´æ¥ä½œæˆã§ãã¾ã™ï¼

ã”è³ªå•ã‚„ã”æ„è¦‹ãŒã‚ã‚Šã¾ã—ãŸã‚‰ã€[ã“ã¡ã‚‰ã‹ã‚‰ã”é€£çµ¡ãã ã•ã„](https://www.zhgchg.li/contact){:target="_blank"} ã€‚

*[Post](https://medium.com/zrealm-ios-dev/xcode-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-swift-%E6%92%B0%E5%AF%AB-run-script-41c49a75a743){:target="_blank"} ã¯ Medium ã‹ã‚‰ [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"} ã«ã‚ˆã£ã¦å¤‰æ›ã•ã‚Œã¾ã—ãŸã€‚*