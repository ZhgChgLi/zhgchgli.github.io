---
author: ZhgChgLi
categories:
- ZRealmã®é–‹ç™º
date: 2023-03-11T17:09:22.165+0000
description: HTMLè§£æã«æ‚©ã‚€é–‹ç™ºè€…å‘ã‘ã«ã€ZMarkupParserã‚’ä½¿ã£ãŸNSAttributedStringå¤‰æ›ã®æ‰‹æ³•ã‚’è§£èª¬ã€‚æ‰‹ä½œã‚Šãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³ã§é«˜é€Ÿã‹ã¤æ­£ç¢ºãªæç”»ã‚’å®Ÿç¾ã—ã€é–‹ç™ºåŠ¹ç‡ã¨è¡¨ç¤ºå“è³ªã‚’å¤§å¹…ã«å‘ä¸Šã•ã›ã¾ã™ã€‚
image:
  path: /assets/2724f02f6e7/1*A0yXupXW9-F9ZWe4gp2ObA.jpeg
last_modified_at: 2023-08-05T16:15:39.420+0000
pin: true
render_with_liquid: false
tags:
- iOSã‚¢ãƒ—ãƒªé–‹ç™º
- HTMLè§£æ
- NSAttributedString
- HTML
- ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
- japanese
- ai-translation
title: HTMLè§£æå™¨é–‹ç™ºï¼šZMarkupParserã§NSAttributedStringã¸ã®é«˜é€Ÿå¤‰æ›ï½œæ‰‹ä½œã‚Šãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³ã®å®Ÿè·µ
---

### æ‰‹ä½œã‚Šã®HTMLãƒ‘ãƒ¼ã‚µãƒ¼ã«ã¾ã¤ã‚ã‚‹è©±

ZMarkupParser HTML ã‹ã‚‰ NSAttributedString ã¸ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³é–‹ç™ºè¨˜éŒ²

HTMLæ–‡å­—åˆ—ã®ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚ºå¤‰æ›ã€æ­£è¦åŒ–å‡¦ç†ã€æŠ½è±¡æ§‹æ–‡æœ¨ã®ç”Ÿæˆã€Visitorãƒ‘ã‚¿ãƒ¼ãƒ³ï¼Builderãƒ‘ã‚¿ãƒ¼ãƒ³ã®é©ç”¨ã€ãã—ã¦ã„ãã¤ã‹ã®é›‘è«‡â€¦

#### ç¶šã

å»å¹´ç™ºè¡¨ã—ãŸè¨˜äº‹ã€Œ[ **TL;DR]** [è‡ªè¡Œå®Ÿè£… iOS NSAttributedString HTML Render](../a8c2d26cc734/)ã€ã§ã¯ã€XMLParserã‚’ä½¿ã£ã¦HTMLã‚’è§£æã—ã€NSAttributedString.Keyã«å¤‰æ›ã™ã‚‹æ–¹æ³•ã‚’ç°¡å˜ã«ç´¹ä»‹ã—ã¾ã—ãŸã€‚è¨˜äº‹å†…ã®ã‚³ãƒ¼ãƒ‰æ§‹æˆã‚„è€ƒãˆæ–¹ã¯éå¸¸ã«æ•£æ¼«ã§ã€å½“æ™‚ã¯å•é¡Œç‚¹ã®è¨˜éŒ²ã¨ã—ã¦æ®‹ã—ãŸã ã‘ã§ã€ã“ã®ãƒ†ãƒ¼ãƒã«ã‚ã¾ã‚Šæ™‚é–“ã‚’å‰²ã„ã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚

### HTMLæ–‡å­—åˆ—ã‚’NSAttributedStringã«å¤‰æ›ã™ã‚‹

å†åº¦ã“ã®å•é¡Œã‚’æ¤œè¨ã™ã‚‹ã¨ã€APIã‹ã‚‰å–å¾—ã—ãŸHTMLæ–‡å­—åˆ—ã‚’NSAttributedStringã«å¤‰æ›ã—ã€å¯¾å¿œã™ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨ã—ã¦UITextView/UILabelã«è¡¨ç¤ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ä¾‹ï¼š`<b>Test<a>Link</a></b>` ã¯ **Test [Link](https://blog.zhgchg.li){:target="_blank"}** ã®ã‚ˆã†ã«è¡¨ç¤ºã§ãã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

- è¨»1  
  HTMLã‚’Appã¨ãƒ‡ãƒ¼ã‚¿é–“ã®é€šä¿¡ã‚„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®åª’ä½“ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚HTMLã®ä»•æ§˜ãŒéå¸¸ã«æŸ”è»ŸãªãŸã‚ã€Appã¯ã™ã¹ã¦ã®HTMLã‚¹ã‚¿ã‚¤ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã§ããšã€å…¬å¼ã®HTMLå¤‰æ›ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³ã‚‚å­˜åœ¨ã—ã¾ã›ã‚“ã€‚

- è¨»2  
  iOS 14ä»¥é™ã¯å…¬å¼ã®ãƒã‚¤ãƒ†ã‚£ãƒ–AttributedStringã‚’ä½¿ã£ã¦Markdownã‚’è§£æã—ãŸã‚Šã€apple/swift-markdown Swiftãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å°å…¥ã—ã¦Markdownã‚’è§£æã—ãŸã‚Šã§ãã¾ã™ã€‚

- è¨»3  
  å¼Šç¤¾ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯å¤§è¦æ¨¡ã§ã€é•·å¹´HTMLã‚’åª’ä»‹ã¨ã—ã¦ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚ã€ç¾æ™‚ç‚¹ã§ã¯Markdownã‚„ä»–ã®ãƒãƒ¼ã‚¯ã‚¢ãƒƒãƒ—ã¸å…¨é¢çš„ã«ç§»è¡Œã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

- **æ³¨4**  
  **ã“ã“ã§ã®HTMLã¯ã€ã‚¦ã‚§ãƒ–ãƒšãƒ¼ã‚¸å…¨ä½“ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã¯ãªãã€HTMLã‚’ã‚¹ã‚¿ã‚¤ãƒ«ä»˜ãMarkdownã®ã‚ˆã†ã«æ–‡å­—åˆ—ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹ãŸã‚ã«ä½¿ã£ã¦ã„ã¾ã™ã€‚**  
  **ï¼ˆãƒšãƒ¼ã‚¸å…¨ä½“ã‚„ç”»åƒãƒ»è¡¨ã‚’å«ã‚€è¤‡é›‘ãªHTMLã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹å ´åˆã¯ã€å¼•ãç¶šãWebViewã®loadHTMLã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ï¼‰**

> å¼·ãMarkdownã‚’æ–‡å­—åˆ—ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®ãƒãƒ¼ã‚¯ã‚¢ãƒƒãƒ—è¨€èªã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚ã‚‚ã—ã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒç§ã¨åŒã˜ã‚ˆã†ã«HTMLã‚’ä½¿ã‚ã–ã‚‹ã‚’å¾—ãšã€å„ªã‚ŒãŸNSAttributedStringã¸ã®å¤‰æ›ãƒ„ãƒ¼ãƒ«ãŒãªã„å ´åˆã¯ã€ãœã²æœ¬ãƒ„ãƒ¼ãƒ«ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚

> å‰å›ã®è¨˜äº‹ã‚’èª­ã‚“ã æ–¹ã¯ã€ç›´æ¥ ZhgChgLi / ZMarkupParser ã®ç« ã«é€²ã‚“ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚

#### NSAttributedString.DocumentType.html

ãƒãƒƒãƒˆä¸Šã§è¦‹ã¤ã‹ã‚‹ HTML ã‹ã‚‰ NSAttributedString ã¸ã®å¤‰æ›æ–¹æ³•ã¯ã€ã»ã¨ã‚“ã©ãŒ NSAttributedString ã«å†…è”µã•ã‚Œã¦ã„ã‚‹ options ã‚’ä½¿ã£ã¦ç›´æ¥ HTML ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹æ–¹æ³•ã§ã™ã€‚ä¾‹ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š

```swift
let htmlString = "<b>Test<a>Link</a></b>"
let data = htmlString.data(using: String.Encoding.utf8)!
let attributedOptions:[NSAttributedString.DocumentReadingOptionKey: Any] = [
  .documentType :NSAttributedString.DocumentType.html,
  .characterEncoding: String.Encoding.utf8.rawValue
]
let attributedString = try! NSAttributedString(data: data, options: attributedOptions, documentAttributes: nil)
```

**ã“ã®æ–¹æ³•ã®å•é¡Œç‚¹ï¼š**

- åŠ¹ç‡ãŒæ‚ªã„ï¼šã“ã®æ–¹æ³•ã¯ WebView ã®ã‚³ã‚¢ã‚’ä½¿ã£ã¦ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã€ãã®å¾Œãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã«æˆ»ã—ã¦ UI ã«è¡¨ç¤ºã—ã¦ã„ã‚‹ãŸã‚ã€300æ–‡å­—ä»¥ä¸Šã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã«0.03ç§’ã‹ã‹ã‚Šã¾ã™ã€‚

- æ–‡å­—ãŒæ¬ ã‘ã‚‹å•é¡Œï¼šä¾‹ãˆã°ã€ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°æ–‡æ¡ˆã§ `<Congratulation!>` ã‚’ä½¿ã†ã¨ã€HTMLã‚¿ã‚°ã¨èªè­˜ã•ã‚Œã¦å‰Šé™¤ã•ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚

- ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºä¸å¯ï¼šä¾‹ãˆã°ã€HTMLã®å¤ªå­—ãŒNSAttributedStringã®ã©ã®ç¨‹åº¦ã®å¤ªã•ã«å¯¾å¿œã™ã‚‹ã‹æŒ‡å®šã§ãã¾ã›ã‚“ã€‚

- [iOS â‰¥ 12 ã‹ã‚‰æ–­ç¶šçš„ã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹å•é¡Œã§å…¬å¼ã®è§£æ±ºç­–ã¯ãªã—](https://developer.apple.com/forums/thread/115405){:target="_blank"}

- iOS 15 ã§ [å¤§é‡ã‚¯ãƒ©ãƒƒã‚·ãƒ¥](../a8c2d26cc734/) ãŒç™ºç”Ÿã—ã€ãƒ†ã‚¹ãƒˆã®çµæœã€ä½ãƒãƒƒãƒ†ãƒªãƒ¼çŠ¶æ…‹ã§ã¯ 100% ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã“ã¨ãŒåˆ¤æ˜ã—ã¾ã—ãŸï¼ˆiOS â‰¥ 15.2 ã§ä¿®æ­£æ¸ˆã¿ï¼‰

- æ–‡å­—åˆ—ãŒé•·ã™ãã‚‹ã¨ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã™ã€‚å®Ÿæ¸¬ã§54,600æ–‡å­—ä»¥ä¸Šã®å…¥åŠ›ã§100%ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ï¼ˆEXC_BAD_ACCESSï¼‰ã—ã¾ã™ã€‚

å¯¾ã—ã¦ç§ãŸã¡ãŒæœ€ã‚‚æ‚©ã¾ã•ã‚ŒãŸã®ã¯ã‚„ã¯ã‚Šã‚¯ãƒ©ãƒƒã‚·ãƒ¥å•é¡Œã§ã€iOS 15ã®ãƒªãƒªãƒ¼ã‚¹ã‹ã‚‰15.2ã®ä¿®æ­£ã¾ã§ã€ã‚¢ãƒ—ãƒªã¯å¸¸ã«ã“ã®å•é¡Œã§ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’ç‹¬å ã—ã¦ã„ã¾ã—ãŸã€‚ãƒ‡ãƒ¼ã‚¿ã«ã‚ˆã‚‹ã¨ã€2022/03/11ã€œ2022/06/08ã®é–“ã«2.4Kå›ä»¥ä¸Šã®ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ãŒç™ºç”Ÿã—ã€1.4Käººä»¥ä¸Šã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å½±éŸ¿ã‚’ä¸ãˆã¾ã—ãŸã€‚

ã“ã®ã‚¯ãƒ©ãƒƒã‚·ãƒ¥å•é¡Œã¯iOS 12ã‹ã‚‰å­˜åœ¨ã—ã¦ãŠã‚Šã€iOS 15ã§ã¯ã•ã‚‰ã«å¤§ããªå•é¡Œã«ç›´é¢ã—ã¾ã—ãŸãŒã€iOS 15.2ã®ä¿®æ­£ã¯ã‚ãã¾ã§å¿œæ€¥å‡¦ç½®ã§ã‚ã‚Šã€å…¬å¼ã«ã¯æ ¹æœ¬çš„ãªè§£æ±ºã¯ã§ãã¦ã„ãªã„ã¨æ¨æ¸¬ã—ã¾ã™ã€‚

æ¬¡ã«å•é¡Œã¨ãªã‚‹ã®ã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã§ã™ã€‚æ–‡å­—åˆ—ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒãƒ¼ã‚¯ã‚¢ãƒƒãƒ—è¨€èªã¨ã—ã¦ã€Appå†…ã®UILabel/UITextViewã§å¤šç”¨ã•ã‚Œã¾ã™ãŒã€å‰è¿°ã®ã‚ˆã†ã«1ã¤ã®Labelã§0.03ç§’ã‹ã‹ã‚‹ãŸã‚ã€è¤‡æ•°ã®UILabel/UITextViewã«ãªã‚‹ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œæ™‚ã«å‹•ä½œãŒã‚«ã‚¯ã¤ãåŸå› ã¨ãªã‚Šã¾ã™ã€‚

#### XMLParser

ç¬¬äºŒã®æ–¹æ³•ã¯[å‰å›ã®è¨˜äº‹](../a8c2d26cc734/)ã§ç´¹ä»‹ã—ãŸã‚‚ã®ã§ã€XMLParserã‚’ä½¿ã£ã¦å¯¾å¿œã™ã‚‹NSAttributedStringã®ã‚­ãƒ¼ã«è§£æã—ã€ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨ã™ã‚‹æ–¹æ³•ã§ã™ã€‚

å‚è€ƒã«ã§ãã‚‹ã®ã¯ [SwiftRichString](https://github.com/malcommac/SwiftRichString){:target="_blank"} ã®å®Ÿè£…ãŠã‚ˆã³ [å‰å›ã®è¨˜äº‹å†…å®¹](../a8c2d26cc734/) ã§ã™ã€‚

> å‰å›ã¯ XMLParser ã‚’ä½¿ã£ã¦ HTML ã‚’è§£æã—ã€å¯¾å¿œå¤‰æ›ã‚’è¡Œã†ã“ã¨ãŒã§ãã‚‹ã“ã¨ã‚’æ¢ç©¶ã—ã€å®Ÿé¨“çš„ãªå®Ÿè£…ã‚’å®Œæˆã•ã›ã¾ã—ãŸãŒã€ãã‚Œã‚’æ§‹é€ åŒ–ã•ã‚Œæ‹¡å¼µå¯èƒ½ãªã€Œãƒ„ãƒ¼ãƒ«ã€ã¨ã—ã¦è¨­è¨ˆã—ãŸã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

**ã“ã®æ–¹æ³•ã®å•é¡Œç‚¹ï¼š**

- å®¹éŒ¯ç‡ 0ï¼š `<br>` / `<Congratulation!>` / `<b>Bold<i>Bold+Italic</b>Italic</i>`
  ä¸Šè¨˜ã®3ç¨®é¡ã®HTMLã®å ´åˆã€XMLParserã§è§£æã™ã‚‹ã¨å¿…ãšã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã€ç©ºç™½ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

- XMLParserã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€HTMLæ–‡å­—åˆ—ã¯å®Œå…¨ã«XMLè¦å‰‡ã«æº–æ‹ ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã€ãƒ–ãƒ©ã‚¦ã‚¶ã‚„NSAttributedString.DocumentType.htmlã®ã‚ˆã†ã«ã‚¨ãƒ©ãƒ¼ã‚’è¨±å®¹ã—ã¦æ­£å¸¸ã«è¡¨ç¤ºã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

#### å·¨äººã®è‚©ã«ç«‹ã£ã¦

ä»¥ä¸Šã®äºŒã¤ã®æ–¹æ³•ã§ã¯HTMLã®å•é¡Œã‚’å®Œç’§ã‹ã¤å„ªé›…ã«è§£æ±ºã§ããªã‹ã£ãŸãŸã‚ã€æ—¢å­˜ã®è§£æ±ºç­–ãŒãªã„ã‹æ¢ã—å§‹ã‚ã¾ã—ãŸã€‚

- [johnxnguyen](https://github.com/johnxnguyen){:target="_blank"} / [Down](https://github.com/johnxnguyen/Down){:target="_blank"}  
  Markdown ã‚’å…¥åŠ›ã¨ã—ã¦ Any (XML/NSAttributedString ãªã©) ã«å¤‰æ›ã™ã‚‹ã“ã¨ã®ã¿ã‚µãƒãƒ¼ãƒˆã—ã¦ãŠã‚Šã€HTML ã‚’å…¥åŠ›ã¨ã—ã¦ã®å¤‰æ›ã¯ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚

- [malcommac](https://github.com/malcommac){:target="_blank"} / [SwiftRichString](https://github.com/malcommac/SwiftRichString){:target="_blank"}  
  å†…éƒ¨ã§ã¯ XMLParser ã‚’ä½¿ç”¨ã—ã¦ãŠã‚Šã€å‰è¿°ã®ã‚±ãƒ¼ã‚¹ã§ã‚‚åŒæ§˜ã«å®¹éŒ¯ç‡ 0 ã®å•é¡ŒãŒç™ºç”Ÿã—ã¾ã™ã€‚

- [scinfu](https://github.com/scinfu){:target="_blank"} / [SwiftSoup](https://github.com/scinfu/SwiftSoup){:target="_blank"}  
  HTMLãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ï¼‰ã®ã¿å¯¾å¿œã—ã€[NSAttributedStringã¸ã®å¤‰æ›ã¯æœªå¯¾å¿œ](https://github.com/scinfu/SwiftSoup/issues/127){:target="_blank"}ã€‚

> ä¸€é€šã‚Šæ¢ã—ã¾ã—ãŸãŒã€ä¸Šè¨˜ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ãªã‚‚ã®ã°ã‹ã‚Šã§ã€é ¼ã‚Œã‚‹å·¨äººã®è‚©ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ Orzã€‚

### ZhgChgLi/ZMarkupParser

[![](https://repository-images.githubusercontent.com/602927147/57ce75c1-8548-449c-b44a-f4b0451ed5ea)](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

å·¨äººã®è‚©ã«ä¹—ã‚Œãªã„ã®ã§ã€è‡ªåˆ†è‡ªèº«ãŒå·¨äººã«ãªã‚‹ã—ã‹ãªãã€HTMLæ–‡å­—åˆ—ã‚’NSAttributedStringã«å¤‰æ›ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã‚’è‡ªä½œã—ã¾ã—ãŸã€‚

ç´”ç²‹ãª Swift ã§é–‹ç™ºã—ã€Regex ã‚’ä½¿ã£ã¦ HTML ã‚¿ã‚°ã‚’è§£æã—ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚ºã—ã¾ã™ã€‚ã‚¿ã‚°ã®æ­£ç¢ºæ€§ã‚’è§£æãƒ»ä¿®æ­£ï¼ˆçµ‚äº†ã‚¿ã‚°ã®ãªã„ã‚¿ã‚°ã‚„ä½ç½®ã®ãšã‚ŒãŸã‚¿ã‚°ã®ä¿®æ­£ï¼‰ã—ãŸå¾Œã€æŠ½è±¡æ§‹æ–‡æœ¨ã«å¤‰æ›ã—ã¾ã™ã€‚æœ€çµ‚çš„ã« Visitor ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”¨ã„ã¦ HTML ã‚¿ã‚°ã¨æŠ½è±¡ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å¯¾å¿œã•ã›ã€æœ€çµ‚çš„ãª NSAttributedString ã‚’å¾—ã¾ã™ã€‚ã“ã®éç¨‹ã§ã„ã‹ãªã‚‹ãƒ‘ãƒ¼ã‚µãƒ¼ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚‚ä½¿ç”¨ã—ã¦ã„ã¾ã›ã‚“ã€‚

#### ç‰¹å¾´

- HTMLãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆNSAttributedStringã¸ã®å¤‰æ›ï¼‰ï¼ã‚¹ãƒˆãƒªãƒƒãƒ‘ãƒ¼ï¼ˆHTMLã‚¿ã‚°ã®é™¤å»ï¼‰ï¼ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼æ©Ÿèƒ½ã‚’ã‚µãƒãƒ¼ãƒˆ

- `NSAttributedString.DocumentType.html` ã‚ˆã‚Šé«˜ã„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹

- ã‚¿ã‚°ã®æ­£ç¢ºæ€§ã‚’è‡ªå‹•è§£æãƒ»ä¿®æ­£ï¼ˆendã‚¿ã‚°ã®ãªã„ã‚¿ã‚°ã‚„ãšã‚ŒãŸã‚¿ã‚°ã®ä¿®æ­£ï¼‰

- `style=â€color:redâ€¦â€` ã‹ã‚‰ã®å‹•çš„ãªã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šã‚’ã‚µãƒãƒ¼ãƒˆ

- ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ«ã®æŒ‡å®šã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€å¤ªå­—ã‚’ **å¤ªå­—** ã«ã™ã‚‹ãªã©ã€‚

- æŸ”è»Ÿã«æ‹¡å¼µå¯èƒ½ãªã‚¿ã‚°ã‚„ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚°ãŠã‚ˆã³å±æ€§ã‚’ã‚µãƒãƒ¼ãƒˆ

> è©³ç´°ãªç´¹ä»‹ã¨ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»ä½¿ç”¨æ–¹æ³•ã¯ã€ã“ã¡ã‚‰ã®è¨˜äº‹ã‚’ã”å‚ç…§ãã ã•ã„ï¼šã€Œ[**ZMarkupParser HTML String ã‹ã‚‰ NSAttributedString å¤‰æ›ãƒ„ãƒ¼ãƒ«**](../a5643de271e4/)ã€

ç›´æ¥ [git clone ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} ã—ã¦ã€`ZMarkupParser.xcworkspace` ã‚’é–‹ãã€`ZMarkupParser-Demo` ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã®ã¾ã¾ãƒ“ãƒ«ãƒ‰ï¼†å®Ÿè¡Œã—ã¦è©¦ã›ã¾ã™ã€‚

![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*PzYcnSkW7qKeJBkaiNTKjQ.gif)

[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

### æŠ€è¡“çš„è©³ç´°æƒ…å ±

æ¬¡ã«ã€æœ¬è¨˜äº‹ã§å…±æœ‰ã—ãŸã„ã€ã“ã®ãƒ„ãƒ¼ãƒ«é–‹ç™ºã«é–¢ã™ã‚‹æŠ€è¡“çš„ãªè©³ç´°ã§ã™ã€‚

![é‹ä½œæµç¨‹ç·è¦§](/assets/2724f02f6e7/1*YF5L7gefMCMwU1wmnGgy6A.png)

é‹ç”¨ãƒ•ãƒ­ãƒ¼æ¦‚è¦

ä¸Šå›³ã¯å¤§ã¾ã‹ãªå‹•ä½œãƒ•ãƒ­ãƒ¼ã§ã‚ã‚Šã€ä»¥é™ã®è¨˜äº‹ã§é †ã‚’è¿½ã£ã¦èª¬æ˜ã—ã€ã‚³ãƒ¼ãƒ‰ã‚‚æ·»ä»˜ã—ã¾ã™ã€‚

> âš ï¸ï¸ï¸ï¸ï¸ï¸ æœ¬æ–‡ã§ã¯ãƒ‡ãƒ¢ã‚³ãƒ¼ãƒ‰ã‚’ã§ãã‚‹ã ã‘ç°¡ç•¥åŒ–ã—ã€æŠ½è±¡åŒ–ã‚„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®è€ƒæ…®ã‚’æ¸›ã‚‰ã—ã¦ã€å‹•ä½œåŸç†ã®èª¬æ˜ã«é‡ç‚¹ã‚’ç½®ã„ã¦ã„ã¾ã™ã€‚æœ€çµ‚çš„ãªçµæœã«ã¤ã„ã¦ã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã® [Source Code](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} ã‚’ã”å‚ç…§ãã ã•ã„ã€‚

### ã‚³ãƒ¼ãƒ‰åŒ– â€” ãƒˆãƒ¼ã‚¯ãƒ³åŒ–

> åˆ¥åãƒ‘ãƒ¼ã‚µãƒ¼ã€è§£æ

HTMLãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã§æœ€ã‚‚é‡è¦ãªã®ã¯è§£æã®æ®µéšã§ã™ã€‚å¾“æ¥ã¯XMLParserã‚’ä½¿ã£ã¦HTMLã‚’XMLã¨ã—ã¦è§£æã—ã¦ã„ã¾ã—ãŸãŒã€HTMLã¯æ—¥å¸¸çš„ã«ä½¿ã‚ã‚Œã‚‹éš›ã«100%ã®XMLã§ã¯ãªã„ãŸã‚ã€è§£æã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã€å‹•çš„ãªä¿®æ­£ãŒã§ãã¾ã›ã‚“ã§ã—ãŸã€‚

XMLParser ã‚’ä½¿ã†æ–¹æ³•ã‚’é™¤å¤–ã™ã‚‹ã¨ã€Swift ã§æ®‹ã•ã‚Œã‚‹ã®ã¯ Regex æ­£è¦è¡¨ç¾ã‚’ä½¿ã£ã¦ãƒãƒƒãƒãƒ³ã‚°è§£æã‚’è¡Œã†æ–¹æ³•ã ã‘ã«ãªã‚Šã¾ã™ã€‚

æœ€åˆã¯ã‚ã¾ã‚Šè€ƒãˆãšã«ã€ã€Œãƒšã‚¢ã€ã«ãªã£ãŸHTMLã‚¿ã‚°ã‚’æ­£è¦è¡¨ç¾ã§ç›´æ¥æŠ½å‡ºã—ã€å†å¸°çš„ã«å†…éƒ¨ã®HTMLã‚¿ã‚°ã‚’ä¸€å±¤ãšã¤æ¢ã—ã¦ã„ã‘ã°è‰¯ã„ã¨æ€ã£ã¦ã„ã¾ã—ãŸã€‚ã—ã‹ã—ã€ã“ã®æ–¹æ³•ã§ã¯HTMLã‚¿ã‚°ã®å…¥ã‚Œå­ã‚„ã€ä¸æ•´åˆã®ã‚ã‚‹ã‚¿ã‚°ã®è¨±å®¹ï¼ˆã‚¨ãƒ©ãƒ¼è€æ€§ï¼‰ã‚’è§£æ±ºã§ãã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€æˆ¦ç•¥ã‚’å¤‰æ›´ã—ã€ã€Œå˜ä¸€ã€ã®HTMLã‚¿ã‚°ã‚’æŠ½å‡ºã—ã€ãã‚ŒãŒé–‹å§‹ã‚¿ã‚°ã€çµ‚äº†ã‚¿ã‚°ã€ã¾ãŸã¯è‡ªå·±çµ‚äº†ã‚¿ã‚°ã‹ã‚’è¨˜éŒ²ã—ã€ãã®ä»–ã®æ–‡å­—åˆ—ã¨çµ„ã¿åˆã‚ã›ã¦è§£æçµæœã®é…åˆ—ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã«ã—ã¾ã—ãŸã€‚

**Tokenization ã®æ§‹é€ ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š**

```swift
enum HTMLParsedResult {
    case start(StartItem) // <a>
    case close(CloseItem) // </a>
    case selfClosing(SelfClosingItem) // <br/>
    case rawString(NSAttributedString)
}

extension HTMLParsedResult {
    class SelfClosingItem {
        let tagName: String
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?
        
        init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) {
            self.tagName = tagName
            self.tagAttributedString = tagAttributedString
            self.attributes = attributes
        }
    }
    
    class StartItem {
        let tagName: String
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?

        // Start Tag ã¯ç•°å¸¸ãª HTML ã‚¿ã‚°ã§ã‚ã‚‹å¯èƒ½æ€§ã‚‚ã‚ã‚Šã€æ­£å¸¸ãªæ–‡å­—åˆ—ã§ã‚ã‚‹å¯èƒ½æ€§ã‚‚ã‚ã‚Šã¾ã™ã€‚ä¾‹: <Congratulation!>ã€‚å¾Œã®æ­£è¦åŒ–ã§å­¤ç«‹ã—ãŸ Start Tag ã¨åˆ¤æ–­ã•ã‚ŒãŸå ´åˆã€true ã«ãƒãƒ¼ã‚¯ã•ã‚Œã¾ã™ã€‚
        var isIsolated: Bool = false
        
        init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) {
            self.tagName = tagName
            self.tagAttributedString = tagAttributedString
            self.attributes = attributes
        }
        
        // å¾Œã®æ­£è¦åŒ–ã§è‡ªå‹•è£œå®Œä¿®æ­£ã«ä½¿ç”¨
        func convertToCloseParsedItem() -> CloseItem {
            return CloseItem(tagName: self.tagName)
        }
        
        // å¾Œã®æ­£è¦åŒ–ã§è‡ªå‹•è£œå®Œä¿®æ­£ã«ä½¿ç”¨
        func convertToSelfClosingParsedItem() -> SelfClosingItem {
            return SelfClosingItem(tagName: self.tagName, tagAttributedString: self.tagAttributedString, attributes: self.attributes)
        }
    }
    
    class CloseItem {
        let tagName: String
        init(tagName: String) {
            self.tagName = tagName
        }
    }
}
```

**ä½¿ç”¨ã—ãŸæ­£è¦è¡¨ç¾ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š**

```ruby
<(?:(?<closeTag>\/)?(?<tagName>[A-Za-z0-9]+)(?<tagAttributes>(?:\s*(\w+)\s*=\s*(["\\|']).*?\5)*)\s*(?<selfClosingTag>\/)?>)
```

-> [Online Regex101 Playground](https://regex101.com/r/aBrID8/1){:target="_blank"}

- closeTag: `<` `/` `a` ã«ãƒãƒƒãƒã™ã‚‹

- tagName: `<a>` ã¾ãŸã¯ `</a>` ã«ãƒãƒƒãƒã™ã‚‹

- tagAttributes: &lt;a `href=â€https://zhgchg.liâ€ style=â€color:redâ€` ã«ãƒãƒƒãƒã™ã‚‹

- selfClosingTag: &lt;br `/` &gt; ã«ãƒãƒƒãƒã™ã‚‹

> *ã“ã®æ­£è¦è¡¨ç¾ã¯ã¾ã æœ€é©åŒ–å¯èƒ½ã§ã€å¾Œã§æ”¹è‰¯ã—ã¾ã™ã€‚

> è¨˜äº‹ã®å¾ŒåŠéƒ¨åˆ†ã«ã¯æ­£è¦è¡¨ç¾ã«é–¢ã™ã‚‹è¿½åŠ è³‡æ–™ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚èˆˆå‘³ã®ã‚ã‚‹æ–¹ã¯ãœã²ã”è¦§ãã ã•ã„ã€‚

**çµ„ã¿åˆã‚ã›ã‚‹ã¨ã“ã†ãªã‚Šã¾ã™ï¼š**

```swift
var tokenizationResult: [HTMLParsedResult] = []

let expression = try? NSRegularExpression(pattern: pattern, options: expressionOptions)
let attributedString = NSAttributedString(string: "<a>Li<b>nk</a>Bold</b>")
let totalLength = attributedString.string.utf16.count // utf-16 ã¯çµµæ–‡å­—ã‚’ã‚µãƒãƒ¼ãƒˆ
var lastMatch: NSTextCheckingResult?

// é–‹å§‹ã‚¿ã‚°ã®ã‚¹ã‚¿ãƒƒã‚¯ã€å…ˆå…¥ã‚Œå¾Œå‡ºã—(FILO First In Last Out)
// HTMLæ–‡å­—åˆ—ãŒå¾Œç¶šã®Normalizationã§èª¤ã£ãŸä½ç½®ã‚„Self-Closingã‚¿ã‚°ã®è£œæ­£ãŒå¿…è¦ã‹æ¤œæŸ»
var stackStartItems: [HTMLParsedResult.StartItem] = []
var needForamatter: Bool = false

expression.enumerateMatches(in: attributedString.string, range: NSMakeRange(0, totoalLength)) { match, _, _ in
  if let match = match {
    // ã‚¿ã‚°é–“ã‚„æœ€åˆã®ã‚¿ã‚°ã¾ã§ã®æ–‡å­—åˆ—ã‚’ãƒã‚§ãƒƒã‚¯
    // ä¾‹: Test<a>Link</a>zzz<b>bold</b>Test2 - > Test,zzz
    let lastMatchEnd = lastMatch?.range.upperBound ?? 0
    let currentMatchStart = match.range.lowerBound
    if currentMatchStart > lastMatchEnd {
      let rawStringBetweenTag = attributedString.attributedSubstring(from: NSMakeRange(lastMatchEnd, (currentMatchStart - lastMatchEnd)))
      tokenizationResult.append(.rawString(rawStringBetweenTag))
    }

    // <a href="https://zhgchg.li">, </a>
    let matchAttributedString = attributedString.attributedSubstring(from: match.range)
    // a, a
    let matchTag = attributedString.attributedSubstring(from: match.range(withName: "tagName"))?.string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    // false, true
    let matchIsEndTag = matchResult.attributedString(from: match.range(withName: "closeTag"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == "/"
    // href="https://zhgchg.li", nil
    // æ­£è¦è¡¨ç¾ã§HTMLå±æ€§ã‚’[String: String]ã«åˆ†è§£ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§
    let matchTagAttributes = parseAttributes(matchResult.attributedString(from: match.range(withName: "tagAttributes")))
    // false, false
    let matchIsSelfClosingTag = matchResult.attributedString(from: match.range(withName: "selfClosingTag"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == "/"

    if let matchAttributedString = matchAttributedString,
       let matchTag = matchTag {
        if matchIsSelfClosingTag {
          // ä¾‹: <br/>
          tokenizationResult.append(.selfClosing(.init(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes)))
        } else {
          // ä¾‹: <a> ã¾ãŸã¯ </a>
          if matchIsEndTag {
            // ä¾‹: </a>
            // ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰åŒã˜TagNameã®ä½ç½®ã‚’æœ€å¾Œã‹ã‚‰æ¢ã™
            if let index = stackStartItems.lastIndex(where: { $0.tagName == matchTag }) {
              // æœ€å¾Œã§ãªã‘ã‚Œã°èª¤ã£ãŸä½ç½®ã‚„é–‰ã˜å¿˜ã‚Œã‚¿ã‚°ã‚ã‚Š
              if index != stackStartItems.count - 1 {
                  needForamatter = true
              }
              tokenizationResult.append(.close(.init(tagName: matchTag)))
              stackStartItems.remove(at: index)
            } else {
              // ä½™åˆ†ãªé–‰ã˜ã‚¿ã‚°ä¾‹: </a>
              // å¾Œç¶šã«å½±éŸ¿ã—ãªã„ã®ã§ç„¡è¦–
            }
          } else {
            // ä¾‹: <a>
            let startItem: HTMLParsedResult.StartItem = HTMLParsedResult.StartItem(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes)
            tokenizationResult.append(.start(startItem))
            // ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ 
            stackStartItems.append(startItem)
          }
        }
     }

    lastMatch = match
  }
}

// çµ‚ç«¯ã®RawStringã‚’ãƒã‚§ãƒƒã‚¯
// ä¾‹: Test<a>Link</a>Test2 - > Test2
if let lastMatch = lastMatch {
  let currentIndex = lastMatch.range.upperBound
  if totoalLength > currentIndex {
    // ã¾ã æ®‹ã‚Šã®æ–‡å­—åˆ—ã‚ã‚Š
    let resetString = attributedString.attributedSubstring(from: NSMakeRange(currentIndex, (totoalLength - currentIndex)))
    tokenizationResult.append(.rawString(resetString))
  }
} else {
  // lastMatch = nilã€ã‚¿ã‚°ãªã—ã§å…¨ã¦ç´”ãƒ†ã‚­ã‚¹ãƒˆ
  let resetString = attributedString.attributedSubstring(from: NSMakeRange(0, totoalLength))
  tokenizationResult.append(.rawString(resetString))
}

// ã‚¹ã‚¿ãƒƒã‚¯ãŒç©ºã‹ãƒã‚§ãƒƒã‚¯ã€æ®‹ã£ã¦ã„ã‚Œã°å¯¾å¿œã™ã‚‹çµ‚äº†ã‚¿ã‚°ãªã—ã®é–‹å§‹ã‚¿ã‚°ã‚ã‚Š
// å­¤ç«‹ã—ãŸé–‹å§‹ã‚¿ã‚°ã¨ã—ã¦ãƒãƒ¼ã‚¯
for stackStartItem in stackStartItems {
  stackStartItem.isIsolated = true
  needForamatter = true
}

print(tokenizationResult)
// [
//    .start("a",["href":"https://zhgchg.li"])
//    .rawString("Li")
//    .start("b",nil)
//    .rawString("nk")
//    .close("a")
//    .rawString("Bold")
//    .close("b")
// ]
```

![é‹ä½œãƒ•ãƒ­ãƒ¼ã¯ä¸Šå›³ã®é€šã‚Šã§ã™](/assets/2724f02f6e7/1*U50CX56M_xy1EXZKb69YeA.png)

é‹ç”¨ã®æµã‚Œã¯ä¸Šå›³ã®é€šã‚Šã§ã™ã€‚

æœ€çµ‚çš„ã« Tokenization ã®çµæœé…åˆ—ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ [HTMLStringToParsedResultProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLStringToParsedResultProcessor.swift){:target="_blank"} ã®å®Ÿè£…

### æ¨™æº–åŒ– â€” Normalization

> åˆ¥å Formatterã€æ­£è¦åŒ–

å‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã§åˆæœŸè§£æçµæœã‚’å–å¾—ã—ãŸå¾Œã€è§£æä¸­ã«ã•ã‚‰ã«æ­£è¦åŒ–ãŒå¿…è¦ã¨åˆ¤æ–­ã•ã‚ŒãŸå ´åˆã€ã“ã®ã‚¹ãƒ†ãƒƒãƒ—ã§è‡ªå‹•çš„ã«HTMLã‚¿ã‚°ã®å•é¡Œã‚’ä¿®æ­£ã—ã¾ã™ã€‚

**HTMLã‚¿ã‚°ã®å•é¡Œã¯ä»¥ä¸‹ã®3ç¨®é¡ãŒã‚ã‚Šã¾ã™ï¼š**

- HTMLã‚¿ã‚°ã§é–‰ã˜ã‚¿ã‚°ãŒãªã„å ´åˆï¼šä¾‹ãˆã° `<br>`

- ä¸€èˆ¬ã®æ–‡å­—ãŒHTMLã‚¿ã‚°ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ä¾‹ï¼šä¾‹ãˆã° `<Congratulation!>`

- HTMLã‚¿ã‚°ã®ä¸æ•´åˆå•é¡Œï¼šä¾‹ãˆã° `<a>Li<b>nk</a>Bold</b>`

ä¿®æ­£æ–¹æ³•ã‚‚éå¸¸ã«ç°¡å˜ã§ã€Tokenization ã®çµæœã®è¦ç´ ã‚’é †ã«å‡¦ç†ã—ã€æ¬ è½ã‚’è£œå®Œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

![é‹ä½œãƒ•ãƒ­ãƒ¼ã¯ä¸Šå›³ã®é€šã‚Š](/assets/2724f02f6e7/1*Wk-U_sQuvLo1OJhcE1BQPQ.png)

é‹ç”¨ãƒ•ãƒ­ãƒ¼ã¯ä¸Šå›³ã®é€šã‚Šã§ã™

```swift
var normalizationResult = tokenizationResult

// é–‹å§‹ã‚¿ã‚°ã®ã‚¹ã‚¿ãƒƒã‚¯ã€å…ˆå…¥ã‚Œå¾Œå‡ºã—(FILO First In Last Out)
var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []
var itemIndex = 0
while itemIndex < newItems.count {
    switch newItems[itemIndex] {
    case .start(let item):
        if item.isIsolated {
            // å­¤ç«‹ã—ãŸé–‹å§‹ã‚¿ã‚°ã®å ´åˆ
            if WC3HTMLTagName(rawValue: item.tagName) == nil && (item.attributes?.isEmpty ?? true) {
                // WC3ã§å®šç¾©ã•ã‚Œã¦ã„ãªã„HTMLã‚¿ã‚°ã‹ã¤å±æ€§ãŒãªã„å ´åˆ
                // WC3HTMLTagName Enumã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å‚ç…§
                // ä¸€èˆ¬æ–‡å­—ãŒHTMLã‚¿ã‚°ã¨ã—ã¦èª¤èªã•ã‚ŒãŸã¨åˆ¤æ–­
                // raw stringã‚¿ã‚¤ãƒ—ã«å¤‰æ›´
                normalizationResult[itemIndex] = .rawString(item.tagAttributedString)
            } else {
                // ãã‚Œä»¥å¤–ã¯ã‚»ãƒ«ãƒ•ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ³ã‚°ã‚¿ã‚°ã«å¤‰æ›´ã€ä¾‹: <br> -> <br/>
                normalizationResult[itemIndex] = .selfClosing(item.convertToSelfClosingParsedItem())
            }
            itemIndex += 1
        } else {
            // é€šå¸¸ã®é–‹å§‹ã‚¿ã‚°ã¯ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ 
            stackExpectedStartItems.append(item)
            itemIndex += 1
        }
    case .close(let item):
        // é–‰ã˜ã‚¿ã‚°ã«é­é‡
        // é–‰ã˜ã‚¿ã‚°ã¾ã§ã®é–‹å§‹ã‚¿ã‚°ã‚¹ã‚¿ãƒƒã‚¯ã®é–“ã®ã‚¿ã‚°ã‚’å–å¾—
        // ä¾‹ <a><u><b>[CurrentIndex]</a></u></b> -> é–“éš” 0
        // ä¾‹ <a><u><b>[CurrentIndex]</a></u></b> -> é–“éš” b,u

        let reversedStackExpectedStartItems = Array(stackExpectedStartItems.reversed())
        guard let reversedStackExpectedStartItemsOccurredIndex = reversedStackExpectedStartItems.firstIndex(where: { $0.tagName == item.tagName }) else {
            itemIndex += 1
            continue
        }
        
        let reversedStackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItems.prefix(upTo: reversedStackExpectedStartItemsOccurredIndex))
        
        // é–“éš”ãŒ0ãªã‚‰ã‚¿ã‚°ã¯ãšã‚Œã¦ã„ãªã„
        guard reversedStackExpectedStartItemsOccurred.count != 0 else {
            // ãƒšã‚¢ãªã®ã§ãƒãƒƒãƒ—
            stackExpectedStartItems.removeLast()
            itemIndex += 1
            continue
        }
        
        // ä»–ã®ã‚¿ã‚°ãŒé–“ã«ã‚ã‚‹å ´åˆã€è‡ªå‹•ã§ãšã‚Œã¦ã„ã‚‹ã‚¿ã‚°ã‚’è£œæ­£
        // ä¾‹ <a><u><b>[CurrentIndex]</a></u></b> ->
        // ä¾‹ <a><u><b>[CurrentIndex]</b></u></a><b></u></u></b>
        let stackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItemsOccurred.reversed())
        let afterItems = stackExpectedStartItemsOccurred.map({ HTMLParsedResult.start($0) })
        let beforeItems = reversedStackExpectedStartItemsOccurred.map({ HTMLParsedResult.close($0.convertToCloseParsedItem()) })
        normalizationResult.insert(contentsOf: afterItems, at: newItems.index(after: itemIndex))
        normalizationResult.insert(contentsOf: beforeItems, at: itemIndex)
        
        itemIndex = newItems.index(after: itemIndex) + stackExpectedStartItemsOccurred.count
        
        // é–‹å§‹ã‚¿ã‚°ã‚¹ã‚¿ãƒƒã‚¯ã‚’æ›´æ–°
        // ä¾‹ -> b,u
        stackExpectedStartItems.removeAll { startItem in
            return reversedStackExpectedStartItems.prefix(through: reversedStackExpectedStartItemsOccurredIndex).contains(where: { $0 === startItem })
        }
    case .selfClosing, .rawString:
        itemIndex += 1
    }
}

print(normalizationResult)
// [
//    .start("a",["href":"https://zhgchg.li"])
//    .rawString("Li")
//    .start("b",nil)
//    .rawString("nk")
//    .close("b")
//    .close("a")
//    .start("b",nil)
//    .rawString("Bold")
//    .close("b")
// ]
```

> å…ƒã®ã‚³ãƒ¼ãƒ‰ã® [HTMLParsedResultFormatterProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLParsedResultFormatterProcessor.swift){:target="_blank"} ã®å®Ÿè£…å¯¾å¿œ

### æŠ½è±¡æ§‹æ–‡æœ¨ (Abstract Syntax Tree)

> åˆ¥å ASTã€æŠ½è±¡æ§‹æ–‡æœ¨

Tokenization ã¨ Normalization ã«ã‚ˆã‚‹ãƒ‡ãƒ¼ã‚¿å‰å‡¦ç†ãŒå®Œäº†ã—ãŸå¾Œã€çµæœã‚’æŠ½è±¡æ§‹æ–‡æœ¨ğŸŒ²ã«å¤‰æ›ã—ã¾ã™ã€‚

![å¦‚ä¸Šå›³](/assets/2724f02f6e7/1*40z0o7R0OROURWCQVDmKrw.png)

ä¸Šå›³ã®ã‚ˆã†ã«

æŠ½è±¡æ§‹æ–‡æœ¨ã«å¤‰æ›ã™ã‚‹ã“ã¨ã§ã€å°†æ¥çš„ãªæ“ä½œã‚„æ‹¡å¼µãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼æ©Ÿèƒ½ã®å®Ÿè£…ã‚„ä»–ã®å¤‰æ›ï¼ˆHTMLã‹ã‚‰Markdownã¸ã®å¤‰æ›ãªã©ï¼‰ãŒå¯èƒ½ã§ã™ã€‚ã¾ãŸã€å°†æ¥çš„ã«Markdownã‹ã‚‰NSAttributedStringã¸ã®å¤‰æ›ã‚’è¿½åŠ ã—ãŸã„å ´åˆã‚‚ã€Markdownã®ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒãƒ¼ãƒãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã™ã‚‹ã ã‘ã§å¯¾å¿œã§ãã¾ã™ã€‚

**ã¾ãš Markup Protocol ã‚’å®šç¾©ã—ã¾ã™ã€‚Child ã¨ Parent ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¡ã€è‘‰ã¨æã®æƒ…å ±ã‚’è¨˜éŒ²ã—ã¾ã™:**

```swift
protocol Markup: AnyObject {
    var parentMarkup: Markup? { get set }
    var childMarkups: [Markup] { get set }
    
    func appendChild(markup: Markup)
    func prependChild(markup: Markup)
    func accept<V: MarkupVisitor>(_ visitor: V) -> V.Result
}

extension Markup {
    func appendChild(markup: Markup) {
        markup.parentMarkup = self
        childMarkups.append(markup)
    }
    
    func prependChild(markup: Markup) {
        markup.parentMarkup = self
        childMarkups.insert(markup, at: 0)
    }
}
```

ã¾ãŸ [Visitor Pattern](../ba5773a7bfea/) ã‚’çµ„ã¿åˆã‚ã›ã¦ä½¿ç”¨ã—ã€å„ã‚¹ã‚¿ã‚¤ãƒ«å±æ€§ã‚’ Element ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦å®šç¾©ã—ã€ç•°ãªã‚‹ Visit æˆ¦ç•¥ã§ãã‚Œãã‚Œã®é©ç”¨çµæœã‚’å–å¾—ã—ã¾ã™ã€‚

```swift
protocol MarkupVisitor {
    associatedtype Result
        
    func visit(markup: Markup) -> Result
    
    func visit(_ markup: RootMarkup) -> Result
    func visit(_ markup: RawStringMarkup) -> Result
    
    func visit(_ markup: BoldMarkup) -> Result
    func visit(_ markup: LinkMarkup) -> Result
    //...
}

extension MarkupVisitor {
    func visit(markup: Markup) -> Result {
        return markup.accept(self)
    }
}
```

**åŸºæœ¬çš„ãª Markup ãƒãƒ¼ãƒ‰ï¼š**

```swift
// ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰
final class RootMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

// è‘‰ãƒãƒ¼ãƒ‰
final class RawStringMarkup: Markup {
    let attributedString: NSAttributedString
    
    init(attributedString: NSAttributedString) {
        self.attributedString = attributedString
    }
    
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}
```

**Markupã‚¹ã‚¿ã‚¤ãƒ«ãƒãƒ¼ãƒ‰ã®å®šç¾©ï¼š**

```swift
// æãƒãƒ¼ãƒ‰:

// ãƒªãƒ³ã‚¯ã‚¹ã‚¿ã‚¤ãƒ«
final class LinkMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

// å¤ªå­—ã‚¹ã‚¿ã‚¤ãƒ«
final class BoldMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}
```

> å…ƒã®ã‚³ãƒ¼ãƒ‰å†…ã® [Markup](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/Markup){:target="_blank"} ã®å®Ÿè£…å¯¾å¿œ

æŠ½è±¡æ§‹æ–‡æœ¨ã«å¤‰æ›ã™ã‚‹å‰ã«ã€ç§ãŸã¡ã¯ã¾ã â€¦

#### MarkupComponent

**ãªãœãªã‚‰ã€ç§ãŸã¡ã®ãƒ„ãƒªãƒ¼æ§‹é€ ã¯ã©ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«ã‚‚ä¾å­˜ã—ã¦ã„ãªã„ã‹ã‚‰ã§ã™ï¼ˆä¾‹ãˆã° a ãƒãƒ¼ãƒ‰/LinkMarkup ã¯ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®ãŸã‚ã« URL æƒ…å ±ãŒå¿…è¦ã§ã™ï¼‰ã€‚**  
**ã“ã‚Œã«å¯¾ã—ã¦ã€ãƒ„ãƒªãƒ¼ãƒãƒ¼ãƒ‰ã¨ãƒãƒ¼ãƒ‰ã«é–¢é€£ã™ã‚‹ãƒ‡ãƒ¼ã‚¿æƒ…å ±ã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’åˆ¥é€”å®šç¾©ã—ã¦ã„ã¾ã™ï¼š**

```swift
protocol MarkupComponent {
    associatedtype T
    var markup: Markup { get }
    var value: T { get }
    
    init(markup: Markup, value: T)
}

extension Sequence where Iterator.Element: MarkupComponent {
    func value(markup: Markup) -> Element.T? {
        return self.first(where:{ $0.markup === markup })?.value as? Element.T
    }
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® [MarkupComponent](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/MarkupComponent){:target="_blank"} å®Ÿè£…

Markup ã‚’ `Hashable` ã¨å®£è¨€ã—ã¦ã€ç›´æ¥ Dictionary ã«å€¤ `[Markup: Any]` ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€ã“ã®å ´åˆ Markup ã¯é€šå¸¸ã®å‹ã¨ã—ã¦ä½¿ç”¨ã§ããšã€`any Markup` ã¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

#### HTMLTag & HTMLTagName & HTMLTagNameVisitor

HTML Tag Name éƒ¨åˆ†ã§ã‚‚ä¸€å±¤ã®æŠ½è±¡åŒ–ã‚’è¡Œã„ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå‡¦ç†ã™ã‚‹ Tag ã‚’è‡ªç”±ã«æ±ºã‚ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚ã¾ãŸã€å°†æ¥çš„ãªæ‹¡å¼µã‚‚å®¹æ˜“ã§ã™ã€‚ä¾‹ãˆã°ã€`<strong>` Tag Name ã¯ `BoldMarkup` ã«å¯¾å¿œã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```
public protocol HTMLTagName {
    var string: String { get }
    func accept<V: HTMLTagNameVisitor>(_ visitor: V) -> V.Result
}

public struct A_HTMLTagName: HTMLTagName {
    public let string: String = WC3HTMLTagName.a.rawValue
    
    public init() {
        
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}

public struct B_HTMLTagName: HTMLTagName {
    public let string: String = WC3HTMLTagName.b.rawValue
    
    public init() {
        
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® [HTMLTagNameVisitor](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTagNameVisitor.swift){:target="_blank"} å®Ÿè£…

> ã¾ãŸã€W3C wiki ã‚’å‚ç…§ã—ã€HTML ã‚¿ã‚°åã®åˆ—æŒ™å‹ã‚’ç¤ºã—ã¦ã„ã¾ã™: [WC3HTMLTagName.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/WC3HTMLTagName.swift){:target="_blank"}

**HTMLTag ã¯å˜ç´”ãªã‚³ãƒ³ãƒ†ãƒŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚å¤–éƒ¨ã‹ã‚‰ HTML ã‚¿ã‚°ã«å¯¾å¿œã™ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æŒ‡å®šã§ãã‚‹ã‚ˆã†ã«ã€ã‚³ãƒ³ãƒ†ãƒŠã¨ã—ã¦ã¾ã¨ã‚ã¦å®£è¨€ã—ã¦ã„ã¾ã™:**

```swift
struct HTMLTag {
    let tagName: HTMLTagName
    let customStyle: MarkupStyle? // å¾Œã§ç´¹ä»‹ã™ã‚‹Renderã§èª¬æ˜ã—ã¾ã™
    
    init(tagName: HTMLTagName, customStyle: MarkupStyle? = nil) {
        self.tagName = tagName
        self.customStyle = customStyle
    }
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® [HTMLTag](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTag.swift3){:target="_blank"} å®Ÿè£…

#### HTMLTagNameToHTMLMarkupVisitor

```swift
struct HTMLTagNameToMarkupVisitor: HTMLTagNameVisitor {
    typealias Result = Markup
    
    let attributes: [String: String]?
    
    func visit(_ tagName: A_HTMLTagName) -> Result {
        return LinkMarkup() // ãƒªãƒ³ã‚¯ãƒãƒ¼ã‚¯ã‚¢ãƒƒãƒ—ã‚’è¿”ã™
    }
    
    func visit(_ tagName: B_HTMLTagName) -> Result {
        return BoldMarkup() // å¤ªå­—ãƒãƒ¼ã‚¯ã‚¢ãƒƒãƒ—ã‚’è¿”ã™
    }
    //...
}
```

> å…ƒã®ã‚³ãƒ¼ãƒ‰ä¸­ã® [HTMLTagNameToHTMLMarkupVisitor](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagNameToHTMLMarkupVisitor.swift){:target="_blank"} ã®å®Ÿè£…å¯¾å¿œ

#### HTMLãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æŠ½è±¡æ§‹æ–‡æœ¨ã¸ã®å¤‰æ›

Normalization å¾Œã® HTML ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½è±¡æ§‹æ–‡æœ¨ã«å¤‰æ›ã™ã‚‹ãŸã‚ã«ã€ã¾ãš HTML ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã§ãã‚‹ MarkupComponent ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’å®£è¨€ã—ã¾ã™:

```swift
struct HTMLElementMarkupComponent: MarkupComponent {
    struct HTMLElement {
        let tag: HTMLTag
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?
    }
    
    typealias T = HTMLElement
    
    let markup: Markup
    let value: HTMLElement
    init(markup: Markup, value: HTMLElement) {
        self.markup = markup
        self.value = value
    }
}
```

**Markup æŠ½è±¡æ§‹æ–‡æœ¨ã¸ã®å¤‰æ›:**

```swift
var htmlElementComponents: [HTMLElementMarkupComponent] = []
let rootMarkup = RootMarkup()
var currentMarkup: Markup = rootMarkup

let htmlTags: [String: HTMLTag]
init(htmlTags: [HTMLTag]) {
  self.htmlTags = Dictionary(uniqueKeysWithValues: htmlTags.map{ ($0.tagName.string, $0) })
}

// Start Tags ã‚¹ã‚¿ãƒƒã‚¯ã€æ­£ã—ãã‚¿ã‚°ã‚’ pop ã™ã‚‹ãŸã‚
// äº‹å‰ã« Normalization ã‚’è¡Œã£ã¦ã„ã‚‹ãŸã‚åŸºæœ¬çš„ã«ã‚¨ãƒ©ãƒ¼ã¯èµ·ããªã„ãŒã€å¿µã®ãŸã‚ç¢ºèª
var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []
for thisItem in from {
    switch thisItem {
    case .start(let item):
        let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes)
        let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName))
        // Visitor ã‚’ä½¿ã£ã¦å¯¾å¿œã™ã‚‹ Markup ã‚’å–å¾—
        let markup = visitor.visit(tagName: htmlTag.tagName)
        
        // è‡ªèº«ã‚’ç¾åœ¨ã®æã®è‘‰ãƒãƒ¼ãƒ‰ã«è¿½åŠ 
        // è‡ªèº«ãŒç¾åœ¨ã®æãƒãƒ¼ãƒ‰ã«ãªã‚‹
        htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes)))
        currentMarkup.appendChild(markup: markup)
        currentMarkup = markup
        
        stackExpectedStartItems.append(item)
    case .selfClosing(let item):
        // ç¾åœ¨ã®æã®è‘‰ãƒãƒ¼ãƒ‰ã«ç›´æ¥è¿½åŠ 
        let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes)
        let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName))
        let markup = visitor.visit(tagName: htmlTag.tagName)
        htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes)))
        currentMarkup.appendChild(markup: markup)
    case .close(let item):
        if let lastTagName = stackExpectedStartItems.popLast()?.tagName,
           lastTagName == item.tagName {
            // Close Tag ã«é­é‡ã—ãŸã‚‰ä¸€ã¤ä¸Šã®éšå±¤ã«æˆ»ã‚‹
            currentMarkup = currentMarkup.parentMarkup ?? currentMarkup
        }
    case .rawString(let attributedString):
        // ç¾åœ¨ã®æã®è‘‰ãƒãƒ¼ãƒ‰ã«ç›´æ¥è¿½åŠ 
        currentMarkup.appendChild(markup: RawStringMarkup(attributedString: attributedString))
    }
}

// print(htmlElementComponents)
// [(markup: LinkMarkup, (tag: a, attributes: ["href":"zhgchg.li"]...)]
```

![é‹ä½œçµæœå¦‚ä¸Šå›³](/assets/2724f02f6e7/1*D-oMszCDzsBpUYnCEWGKHQ.png)

å‹•ä½œçµæœã¯ä¸Šã®å›³ã®é€šã‚Šã§ã™

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ [HTMLParsedResultToHTMLElementWithRootMarkupProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLParsedResultToHTMLElementWithRootMarkupProcessor.swift){:target="_blank"} ã®å®Ÿè£…

#### ã“ã®æ™‚ç‚¹ã§ã€å®Ÿã¯ Selector ã®æ©Ÿèƒ½ãŒå®Œæˆã—ã¦ã„ã¾ã™ ğŸ‰

```swift
public class HTMLSelector: CustomStringConvertible {
    
    let markup: Markup
    let componets: [HTMLElementMarkupComponent]
    init(markup: Markup, componets: [HTMLElementMarkupComponent]) {
        self.markup = markup
        self.componets = componets
    }
    
    public func filter(_ htmlTagName: String) -> [HTMLSelector] {
        let result = markup.childMarkups.filter({ componets.value(markup: $0)?.tag.tagName.isEqualTo(htmlTagName) ?? false })
        return result.map({ .init(markup: $0, componets: componets) })
    }

    //...
}
```

ç§ãŸã¡ã¯è‘‰ãƒãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸€å±¤ãšã¤ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã§ãã¾ã™ã€‚

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® [HTMLSelector](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLSelector.swift){:target="_blank"} å®Ÿè£…

### Parser â€” HTMLã‹ã‚‰MarkupStyleã¸ï¼ˆNSAttributedString.Keyã®æŠ½è±¡åŒ–ï¼‰

æ¬¡ã«ã€HTML ã‚’ MarkupStyle (NSAttributedString.Key) ã«å¤‰æ›ã™ã‚‹å‡¦ç†ã‚’å®Œæˆã•ã›ã¾ã™ã€‚

NSAttributedString ã¯ NSAttributedString.Key Attributes ã‚’ä½¿ã£ã¦æ–‡å­—ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®šã—ã¾ã™ã€‚ç§ãŸã¡ã¯ NSAttributedString.Key ã®ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŠ½è±¡åŒ–ã—ã€MarkupStyleã€MarkupStyleColorã€MarkupStyleFontã€MarkupStyleParagraphStyle ã«å¯¾å¿œã•ã›ã¾ã—ãŸã€‚

**ç›®çš„ï¼š**

- å…ƒã® Attributes ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯ `[NSAttributedString.Key: Any?]` ã§ã™ãŒã€ã“ã‚Œã‚’ç›´æ¥å…¬é–‹ã™ã‚‹ã¨ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ¸¡ã™å€¤ã‚’åˆ¶å¾¡ã—ã«ããã€ä¾‹ãˆã° `.font: 123` ã®ã‚ˆã†ã«èª¤ã£ãŸå€¤ã‚’æ¸¡ã™ã¨ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã®åŸå› ã«ãªã‚Šã¾ã™ã€‚

- ã‚¹ã‚¿ã‚¤ãƒ«ã¯ç¶™æ‰¿å¯èƒ½ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã° `<a><b>test</b></a>` ã®å ´åˆã€test ã®æ–‡å­—åˆ—ã‚¹ã‚¿ã‚¤ãƒ«ã¯ãƒªãƒ³ã‚¯ã®å¤ªå­—ï¼ˆbold+linkï¼‰ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚ã‚‚ã—ç›´æ¥ Dictionary ã‚’å…¬é–‹ã™ã‚‹ã¨ã€ç¶™æ‰¿ãƒ«ãƒ¼ãƒ«ã®ç®¡ç†ãŒé›£ã—ããªã‚Šã¾ã™ã€‚

- iOS/macOS (UIKit/AppKit) ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ©ãƒƒãƒ—

#### MarkupStyle æ§‹é€ ä½“

```swift
public struct MarkupStyle {
    public var font:MarkupStyleFont
    public var paragraphStyle:MarkupStyleParagraphStyle
    public var foregroundColor:MarkupStyleColor? = nil
    public var backgroundColor:MarkupStyleColor? = nil
    public var ligature:NSNumber? = nil
    public var kern:NSNumber? = nil
    public var tracking:NSNumber? = nil
    public var strikethroughStyle:NSUnderlineStyle? = nil
    public var underlineStyle:NSUnderlineStyle? = nil
    public var strokeColor:MarkupStyleColor? = nil
    public var strokeWidth:NSNumber? = nil
    public var shadow:NSShadow? = nil
    public var textEffect:String? = nil
    public var attachment:NSTextAttachment? = nil
    public var link:URL? = nil
    public var baselineOffset:NSNumber? = nil
    public var underlineColor:MarkupStyleColor? = nil
    public var strikethroughColor:MarkupStyleColor? = nil
    public var obliqueness:NSNumber? = nil
    public var expansion:NSNumber? = nil
    public var writingDirection:NSNumber? = nil
    public var verticalGlyphForm:NSNumber? = nil
    //...

    // ç¶™æ‰¿å…ƒã‹ã‚‰...
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ nil ã®å ´åˆã€from ã‹ã‚‰ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åŸ‹ã‚ã‚‹
    mutating func fillIfNil(from: MarkupStyle?) {
        guard let from = from else { return }
        
        var currentFont = self.font
        currentFont.fillIfNil(from: from.font)
        self.font = currentFont
        
        var currentParagraphStyle = self.paragraphStyle
        currentParagraphStyle.fillIfNil(from: from.paragraphStyle)
        self.paragraphStyle = currentParagraphStyle
        //..
    }

    // MarkupStyle ã‚’ NSAttributedString.Key: Any ã«å¤‰æ›
    func render() -> [NSAttributedString.Key: Any] {
        var data: [NSAttributedString.Key: Any] = [:]
        
        if let font = font.getFont() {
            data[.font] = font
        }

        if let ligature = self.ligature {
            data[.ligature] = ligature
        }
        //...
        return data
    }
}

public struct MarkupStyleFont: MarkupStyleItem {
    public enum FontWeight {
        case style(FontWeightStyle)
        case rawValue(CGFloat)
    }
    public enum FontWeightStyle: String {
        case ultraLight, light, thin, regular, medium, semibold, bold, heavy, black
        // ...
    }
    
    public var size: CGFloat?
    public var weight: FontWeight?
    public var italic: Bool?
    //...
}

public struct MarkupStyleParagraphStyle: MarkupStyleItem {
    public var lineSpacing:CGFloat? = nil
    public var paragraphSpacing:CGFloat? = nil
    public var alignment:NSTextAlignment? = nil
    public var headIndent:CGFloat? = nil
    public var tailIndent:CGFloat? = nil
    public var firstLineHeadIndent:CGFloat? = nil
    public var minimumLineHeight:CGFloat? = nil
    public var maximumLineHeight:CGFloat? = nil
    public var lineBreakMode:NSLineBreakMode? = nil
    public var baseWritingDirection:NSWritingDirection? = nil
    public var lineHeightMultiple:CGFloat? = nil
    public var paragraphSpacingBefore:CGFloat? = nil
    public var hyphenationFactor:Float? = nil
    public var usesDefaultHyphenation:Bool? = nil
    public var tabStops: [NSTextTab]? = nil
    public var defaultTabInterval:CGFloat? = nil
    public var textLists: [NSTextList]? = nil
    public var allowsDefaultTighteningForTruncation:Bool? = nil
    public var lineBreakStrategy: NSParagraphStyle.LineBreakStrategy? = nil
    //...
}

public struct MarkupStyleColor {
    let red: Int
    let green: Int
    let blue: Int
    let alpha: CGFloat
    //...
}
```

> å…ƒã®ã‚³ãƒ¼ãƒ‰å†…ã® [MarkupStyle](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/MarkupStyle){:target="_blank"} å®Ÿè£…å¯¾å¿œ

> ã¾ãŸã€W3c wiki ã‚„ãƒ–ãƒ©ã‚¦ã‚¶ã®äº‹å‰å®šç¾©ã‚«ãƒ©ãƒ¼åã‚‚å‚ç…§ã—ã€å¯¾å¿œã™ã‚‹ã‚«ãƒ©ãƒ¼åãƒ†ã‚­ã‚¹ãƒˆã¨ã‚«ãƒ©ãƒ¼ã® R,G,B åˆ—æŒ™å‹ã‚’åˆ—æŒ™ã—ã¦ã„ã¾ã™: [MarkupStyleColorName.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyleColorName.swift){:target="_blank"}

#### HTMLTagStyleAttribute & HTMLTagStyleAttributeVisitor

ã“ã“ã§ã“ã®äºŒã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦å°‘ã—è£œè¶³ã—ã¾ã™ã€‚HTMLã‚¿ã‚°ã¯CSSã‹ã‚‰ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®šã™ã‚‹ã“ã¨ãŒè¨±å¯ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€HTMLTagNameã®æŠ½è±¡åŒ–ã¨åŒæ§˜ã«ã€HTMLã®Styleå±æ€§ã«ã‚‚åŒã˜ãæŠ½è±¡åŒ–ã‚’é©ç”¨ã—ã¦ã„ã¾ã™ã€‚

ä¾‹ãˆã°ã€HTML ã¯æ¬¡ã®ã‚ˆã†ã«ä¸ãˆã‚‰ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ï¼š `<a style=â€color:red;font-size:14pxâ€>RedLink</a>` ã€‚ã“ã‚Œã¯ã“ã®ãƒªãƒ³ã‚¯ã‚’èµ¤è‰²ã€ã‚µã‚¤ã‚º14pxã«è¨­å®šã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚

```
public protocol HTMLTagStyleAttribute {
    var styleName: String { get }
    
    func accept<V: HTMLTagStyleAttributeVisitor>(_ visitor: V) -> V.Result
}

public protocol HTMLTagStyleAttributeVisitor {
    associatedtype Result
    
    func visit(styleAttribute: HTMLTagStyleAttribute) -> Result
    func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -> Result
    func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -> Result
    //...
}

public extension HTMLTagStyleAttributeVisitor {
    func visit(styleAttribute: HTMLTagStyleAttribute) -> Result {
        return styleAttribute.accept(self)
    }
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® [HTMLTagStyleAttribute](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTagStyleAttribute){:target="_blank"} å®Ÿè£…

#### HTMLTagStyleAttributeToMarkupStyleVisitor

```swift
struct HTMLTagStyleAttributeToMarkupStyleVisitor: HTMLTagStyleAttributeVisitor {
    typealias Result = MarkupStyle?
    
    let value: String
    
    func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -> Result {
        // æ­£è¦è¡¨ç¾ã§ã‚«ãƒ©ãƒ¼ã®16é€²æ•°ã¾ãŸã¯HTMLã®äº‹å‰å®šç¾©ã‚«ãƒ©ãƒ¼åã‚’æŠ½å‡ºã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„
        guard let color = MarkupStyleColor(string: value) else { return nil }
        return MarkupStyle(foregroundColor: color)
    }
    
    func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -> Result {
        // æ­£è¦è¡¨ç¾ã§10px -> 10ã‚’æŠ½å‡ºã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„
        guard let size = self.convert(fromPX: value) else { return nil }
        return MarkupStyle(font: MarkupStyleFont(size: CGFloat(size)))
    }
    // ...
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® [HTMLTagAttributeToMarkupStyleVisitor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagAttributeToMarkupStyleVisitor.swift){:target="_blank"} å®Ÿè£…

init ã® value ã¯ attribute ã®å€¤ã§ã€visit ã®ç¨®é¡ã«å¿œã˜ã¦å¯¾å¿œã™ã‚‹ MarkupStyle ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚

#### HTMLElementMarkupComponentMarkupStyleVisitor

MarkupStyle ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç´¹ä»‹ãŒçµ‚ã‚ã£ãŸã‚‰ã€Normalization ã® HTMLElementComponents ã®çµæœã‚’ MarkupStyle ã«å¤‰æ›ã—ã¾ã™ã€‚

```swift
// MarkupStyle ãƒãƒªã‚·ãƒ¼
public enum MarkupStylePolicy {
    case respectMarkupStyleFromCode // ã‚³ãƒ¼ãƒ‰ç”±æ¥ã‚’å„ªå…ˆã—ã€HTMLã®Styleå±æ€§ã¯è£œå®Œã¨ã—ã¦ä½¿ç”¨
    case respectMarkupStyleFromHTMLStyleAttribute // HTMLã®Styleå±æ€§ã‚’å„ªå…ˆã—ã€ã‚³ãƒ¼ãƒ‰ç”±æ¥ã¯è£œå®Œã¨ã—ã¦ä½¿ç”¨
}

struct HTMLElementMarkupComponentMarkupStyleVisitor: MarkupVisitor {

    typealias Result = MarkupStyle?
    
    let policy: MarkupStylePolicy
    let components: [HTMLElementMarkupComponent]
    let styleAttributes: [HTMLTagStyleAttribute]

    func visit(_ markup: BoldMarkup) -> Result {
        // .bold ã¯ MarkupStyle ã«å®šç¾©ã•ã‚ŒãŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã§ã™ã€‚ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
        return defaultVisit(components.value(markup: markup), defaultStyle: .bold)
    }
    
    func visit(_ markup: LinkMarkup) -> Result {
        // .link ã¯ MarkupStyle ã«å®šç¾©ã•ã‚ŒãŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã§ã™ã€‚ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
        var markupStyle = defaultVisit(components.value(markup: markup), defaultStyle: .link) ?? .link
        
        // HtmlElementComponents ã‹ã‚‰ LinkMarkup ã«å¯¾å¿œã™ã‚‹ HtmlElement ã‚’å–å¾—
        // HtmlElement ã® attributes ã‹ã‚‰ href ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾— (HTMLã§URLæ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã•ã‚Œã‚‹æ–¹å¼)
        if let href = components.value(markup: markup)?.attributes?["href"] as? String,
           let url = URL(string: href) {
            markupStyle.link = url
        }
        return markupStyle
    }

    // ...
}

extension HTMLElementMarkupComponentMarkupStyleVisitor {
    // HTMLTag ã‚³ãƒ³ãƒ†ãƒŠã‹ã‚‰ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ãŸã„ MarkupStyle ã‚’å–å¾—
    private func customStyle(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?) -> MarkupStyle? {
        guard let customStyle = htmlElement?.tag.customStyle else {
            return nil
        }
        return customStyle
    }
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†
    func defaultVisit(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?, defaultStyle: MarkupStyle? = nil) -> Result {
        var markupStyle: MarkupStyle? = customStyle(htmlElement) ?? defaultStyle
        // HtmlElementComponents ã‹ã‚‰ LinkMarkup ã«å¯¾å¿œã™ã‚‹ HtmlElement ã‚’å–å¾—
        // HtmlElement ã® attributes ã« `style` å±æ€§ãŒã‚ã‚‹ã‹ç¢ºèª
        guard let styleString = htmlElement?.attributes?["style"],
              styleAttributes.count > 0 else {
            // ãªã„å ´åˆ
            return markupStyle
        }

        // Styleå±æ€§ãŒã‚ã‚‹å ´åˆ
        // Styleå€¤ã®æ–‡å­—åˆ—ã‚’åˆ†å‰²ã—ã¦é…åˆ—ã«å¤‰æ›
        // ä¾‹: font-size:14px;color:red -> ["font-size":"14px","color":"red"]
        let styles = styleString.split(separator: ";").filter { $0.trimmingCharacters(in: .whitespacesAndNewlines) != "" }.map { $0.split(separator: ":") }
        
        for style in styles {
            guard style.count == 2 else {
                continue
            }
            // ä¾‹: font-size
            let key = style[0].trimmingCharacters(in: .whitespacesAndNewlines)
            // ä¾‹: 14px
            let value = style[1].trimmingCharacters(in: .whitespacesAndNewlines)
            
            if let styleAttribute = styleAttributes.first(where: { $0.isEqualTo(styleName: key) }) {
                // å…ˆã«èª¬æ˜ã—ãŸ HTMLTagStyleAttributeToMarkupStyleVisitor ã‚’ä½¿ã£ã¦ MarkupStyle ã«å¤‰æ›
                let visitor = HTMLTagStyleAttributeToMarkupStyleVisitor(value: value)
                if var thisMarkupStyle = visitor.visit(styleAttribute: styleAttribute) {
                    // Styleå±æ€§ã§å€¤ãŒå¤‰æ›ã•ã‚ŒãŸå ´åˆ
                    // ä»¥å‰ã® MarkupStyle çµæœã¨ãƒãƒ¼ã‚¸
                    thisMarkupStyle.fillIfNil(from: markupStyle)
                    markupStyle = thisMarkupStyle
                }
            }
        }
        
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆ
        if var defaultStyle = defaultStyle {
            switch policy {
                case .respectMarkupStyleFromHTMLStyleAttribute:
                  // Styleå±æ€§ã® MarkupStyle ã‚’å„ªå…ˆã—ã€
                  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã¨ãƒãƒ¼ã‚¸
                    markupStyle?.fillIfNil(from: defaultStyle)
                case .respectMarkupStyleFromCode:
                  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã‚’å„ªå…ˆã—ã€
                  // Styleå±æ€§ã® MarkupStyle ã¨ãƒãƒ¼ã‚¸
                  defaultStyle.fillIfNil(from: markupStyle)
                  markupStyle = defaultStyle
            }
        }
        
        return markupStyle
    }
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® [HTMLTagAttributeToMarkupStyleVisitor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagAttributeToMarkupStyleVisitor.swift){:target="_blank"} å®Ÿè£…

ç§ãŸã¡ã¯ä¸€éƒ¨ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã‚’ [MarkupStyle](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyle%2BExtension.swift){:target="_blank"} ã«å®šç¾©ã—ã¦ãŠã‚Šã€å¤–éƒ¨ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã‚¿ã‚°ã®ã‚¹ã‚¿ã‚¤ãƒ«ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ä¸€éƒ¨ã®ãƒãƒ¼ã‚¯ã‚¢ãƒƒãƒ—ã¯ã“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

**ã‚¹ã‚¿ã‚¤ãƒ«ç¶™æ‰¿ã®æˆ¦ç•¥ã¯2ç¨®é¡ã‚ã‚Šã¾ã™ï¼š**

- respectMarkupStyleFromCode:  
  ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã‚’åŸºæº–ã«ã—ã€Style Attributesã§è£œãˆã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ ã—ã¾ã™ã€‚æ—¢ã«å€¤ãŒã‚ã‚‹å ´åˆã¯ç„¡è¦–ã—ã¾ã™ã€‚

- respectMarkupStyleFromHTMLStyleAttribute:  
  Style Attributesã‚’å„ªå…ˆã—ã€æ¬¡ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã§è£œãˆã‚‹éƒ¨åˆ†ã‚’é©ç”¨ã—ã¾ã™ã€‚æ—¢ã«å€¤ãŒã‚ã‚‹å ´åˆã¯ç„¡è¦–ã—ã¾ã™ã€‚

#### HTMLElementWithMarkupToMarkupStyleProcessor

Normalization ã®çµæœã‚’ AST ã¨ MarkupStyleComponent ã«å¤‰æ›ã™ã‚‹ã€‚

**æ–°ãŸã« MarkupComponent ã‚’å®£è¨€ã—ã¾ã™ã€‚ä»Šå›ã¯å¯¾å¿œã™ã‚‹ MarkupStyle ã‚’æ ¼ç´ã—ã¾ã™:**

```swift
struct MarkupStyleComponent: MarkupComponent {
    typealias T = MarkupStyle
    
    let markup: Markup
    let value: MarkupStyle
    init(markup: Markup, value: MarkupStyle) {
        self.markup = markup
        self.value = value
    }
}
```

**Markup Tree ã¨ HTMLElementMarkupComponent æ§‹é€ ã®ç°¡å˜ãªéæ­´:**

```swift
let styleAttributes: [HTMLTagStyleAttribute]
let policy: MarkupStylePolicy
    
func process(from: (Markup, [HTMLElementMarkupComponent])) -> [MarkupStyleComponent] {
  var components: [MarkupStyleComponent] = []
  let visitor = HTMLElementMarkupComponentMarkupStyleVisitor(policy: policy, components: from.1, styleAttributes: styleAttributes)
  walk(markup: from.0, visitor: visitor, components: &components)
  return components
}
    
func walk(markup: Markup, visitor: HTMLElementMarkupComponentMarkupStyleVisitor, components: inout [MarkupStyleComponent]) {
        
  if let markupStyle = visitor.visit(markup: markup) {
    components.append(.init(markup: markup, value: markupStyle))
  }
        
  for markup in markup.childMarkups {
    walk(markup: markup, visitor: visitor, components: &components)
  }
}

// print(components)
// [(markup: LinkMarkup, MarkupStyle(link: https://zhgchg.li, color: .blue)]
// [(markup: BoldMarkup, MarkupStyle(font: .init(weight: .bold))]
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ [HTMLElementWithMarkupToMarkupStyleProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLElementWithMarkupToMarkupStyleProcessor.swift){:target="_blank"} ã®å®Ÿè£…

![ãƒ•ãƒ­ãƒ¼ã®çµæœã¯ä¸Šå›³ã®é€šã‚Š](/assets/2724f02f6e7/1*JEMBNdbQcBgDQ49jFw4ePQ.png)

å‡¦ç†çµæœã¯ä¸Šå›³ã®é€šã‚Šã§ã™

### Render â€” NSAttributedString ã«å¤‰æ›ã™ã‚‹

ç¾åœ¨ã€HTMLã‚¿ã‚°ã®æŠ½è±¡æ§‹æ–‡æœ¨ã¨HTMLã‚¿ã‚°ã«å¯¾å¿œã™ã‚‹MarkupStyleãŒæƒã£ãŸã®ã§ã€æœ€å¾Œã®ã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦æœ€çµ‚çš„ãªNSAttributedStringã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°çµæœã‚’ç”Ÿæˆã§ãã¾ã™ã€‚

#### MarkupNSAttributedStringVisitor

markup ã‚’ NSAttributedString ã«å¤‰æ›ã™ã‚‹

```swift
struct MarkupNSAttributedStringVisitor: MarkupVisitor {
    typealias Result = NSAttributedString
    
    let components: [MarkupStyleComponent]
    // root / base ã® MarkupStyleã€å¤–éƒ¨ã‹ã‚‰æŒ‡å®šå¯èƒ½ã€‚ä¾‹ï¼šå…¨æ–‡å­—ã®ã‚µã‚¤ã‚ºæŒ‡å®šãªã©
    let rootStyle: MarkupStyle?
    
    func visit(_ markup: RootMarkup) -> Result {
        // ä¸‹ä½ã® RawString ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦‹ã‚‹
        return collectAttributedString(markup)
    }
    
    func visit(_ markup: RawStringMarkup) -> Result {
        // Raw String ã‚’è¿”ã™
        // ãƒã‚§ãƒ¼ãƒ³ä¸Šã®ã™ã¹ã¦ã® MarkupStyle ã‚’åé›†
        // Style ã‚’ NSAttributedString ã«é©ç”¨
        return applyMarkupStyle(markup.attributedString, with: collectMarkupStyle(markup))
    }
    
    func visit(_ markup: BoldMarkup) -> Result {
        // ä¸‹ä½ã® RawString ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦‹ã‚‹
        return collectAttributedString(markup)
    }
    
    func visit(_ markup: LinkMarkup) -> Result {
        // ä¸‹ä½ã® RawString ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦‹ã‚‹
        return collectAttributedString(markup)
    }
    // ...
}

private extension MarkupNSAttributedStringVisitor {
    // Style ã‚’ NSAttributedString ã«é©ç”¨
    func applyMarkupStyle(_ attributedString: NSAttributedString, with markupStyle: MarkupStyle?) -> NSAttributedString {
        guard let markupStyle = markupStyle else { return attributedString }
        let mutableAttributedString = NSMutableAttributedString(attributedString: attributedString)
        mutableAttributedString.addAttributes(markupStyle.render(), range: NSMakeRange(0, mutableAttributedString.string.utf16.count))
        return mutableAttributedString
    }

    func collectAttributedString(_ markup: Markup) -> NSMutableAttributedString {
        // ä¸‹ä½ã‹ã‚‰åé›†
        // Root -> Bold -> String("Bold")
        //      \
        //       > String("Test")
        // çµæœ: Bold Test
        // ä¸€å±¤ãšã¤ä¸‹ã« RawString ã‚’æ¢ã—ã€å†å¸°çš„ã« visit ã—ã¦æœ€çµ‚çš„ãª NSAttributedString ã‚’çµ„ã¿ç«‹ã¦ã‚‹
        return markup.childMarkups.compactMap({ visit(markup: $0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in
            partialResult.append(attributedString)
            return partialResult
        }
    }
    
    func collectMarkupStyle(_ markup: Markup) -> MarkupStyle? {
        // ä¸Šä½ã‹ã‚‰åé›†
        // String("Test") -> Bold -> Italic -> Root
        // çµæœ: style: Bold+Italic
        // ä¸€å±¤ãšã¤è¦ªã‚¿ã‚°ã® markupstyle ã‚’æ¢ã—ã€
        // ãã‚Œã‚’ç¶™æ‰¿ã—ã¦ã„ã
        var currentMarkup: Markup? = markup.parentMarkup
        var currentStyle = components.value(markup: markup)
        while let thisMarkup = currentMarkup {
            guard let thisMarkupStyle = components.value(markup: thisMarkup) else {
                currentMarkup = thisMarkup.parentMarkup
                continue
            }

            if var thisCurrentStyle = currentStyle {
                thisCurrentStyle.fillIfNil(from: thisMarkupStyle)
                currentStyle = thisCurrentStyle
            } else {
                currentStyle = thisMarkupStyle
            }

            currentMarkup = thisMarkup.parentMarkup
        }
        
        if var currentStyle = currentStyle {
            currentStyle.fillIfNil(from: rootStyle)
            return currentStyle
        } else {
            return rootStyle
        }
    }
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ [MarkupNSAttributedStringVisitor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/Processor/MarkupNSAttributedStringVisitor.swift){:target="_blank"} ã®å®Ÿè£…

![é‹ä½œãƒ•ãƒ­ãƒ¼ã¨çµæœã¯ä¸Šå›³ã®é€šã‚Š](/assets/2724f02f6e7/1*gJA_6uM5tQw2kUJsqIssuw.png)

é‹ç”¨ã®æµã‚Œã¨çµæœã¯ä¸Šå›³ã®é€šã‚Šã§ã™ã€‚

**æœ€çµ‚çš„ã«å¾—ã‚‰ã‚Œã‚‹ã‚‚ã®ï¼š**

![](/assets/2724f02f6e7/1*LOXfC8yYg2JCeoCH5m7kGA.png)

```swift
Li{
    NSColor = "Blue";
    NSFont = "<UICTFont: 0x145d17600> font-family: \".SFUI-Regular\"; font-weight: normal; font-style: normal; font-size: 13.00pt";
    NSLink = "https://zhgchg.li";
}nk{
    NSColor = "Blue";
    NSFont = "<UICTFont: 0x145d18710> font-family: \".SFUI-Semibold\"; font-weight: bold; font-style: normal; font-size: 13.00pt";
    NSLink = "https://zhgchg.li";
}Bold{
    NSFont = "<UICTFont: 0x145d18710> font-family: \".SFUI-Semibold\"; font-weight: bold; font-style: normal; font-size: 13.00pt";
}
```

> ğŸ‰ğŸ‰ğŸ‰ğŸ‰çµ‚ã‚ã£ãŸğŸ‰ğŸ‰ğŸ‰ğŸ‰

ã“ã“ã¾ã§ã§ã€HTMLæ–‡å­—åˆ—ã‹ã‚‰NSAttributedStringã¸ã®å¤‰æ›ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Œäº†ã—ã¾ã—ãŸã€‚

#### Stripper â€” HTMLã‚¿ã‚°ã®é™¤å»

å‰¥é›¢ HTML ã‚¿ã‚°ã®éƒ¨åˆ†ã¯æ¯”è¼ƒçš„ç°¡å˜ã§ã€ä»¥ä¸‹ãŒå¿…è¦ã§ã™:

```swift
func attributedString(_ markup: Markup) -> NSAttributedString {
  if let rawStringMarkup = markup as? RawStringMarkup {
    return rawStringMarkup.attributedString
  } else {
    return markup.childMarkups.compactMap({ attributedString($0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in
      partialResult.append(attributedString)
      return partialResult
    }
  }
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ [MarkupStripperProcessor.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/Processor/MarkupStripperProcessor.swift){:target="_blank"} ã®å®Ÿè£…

Render ã«ä¼¼ã¦ã„ã¾ã™ãŒã€ç´”ç²‹ã« RawStringMarkup ã‚’è¦‹ã¤ã‘ã¦å†…å®¹ã‚’è¿”ã—ã¾ã™ã€‚

#### Extend â€” å‹•çš„æ‹¡å¼µ

ã™ã¹ã¦ã® HTMLTag/Style Attribute ã‚’ã‚«ãƒãƒ¼ã§ãã‚‹ã‚ˆã†ã«ã€ã‚³ãƒ¼ãƒ‰ã‹ã‚‰å‹•çš„ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ‹¡å¼µã§ãã‚‹å‹•çš„æ‹¡å¼µã®ä»•çµ„ã¿ã‚’ç”¨æ„ã—ã¾ã—ãŸã€‚

```swift
public struct ExtendTagName: HTMLTagName {
    public let string: String
    
    public init(_ w3cHTMLTagName: WC3HTMLTagName) {
        self.string = w3cHTMLTagName.rawValue
    }
    
    public init(_ string: String) {
        self.string = string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}
// ã‹ã‚‰
final class ExtendMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []

    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

//----

public struct ExtendHTMLTagStyleAttribute: HTMLTagStyleAttribute {
    public let styleName: String
    public let render: ((String) -> (MarkupStyle?)) // å‹•çš„ã«ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã§ MarkupStyle ã‚’å¤‰æ›´
    
    public init(styleName: String, render: @escaping ((String) -> (MarkupStyle?))) {
        self.styleName = styleName
        self.render = render
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagStyleAttributeVisitor {
        return visitor.visit(self)
    }
}
```

#### ZHTMLParserBuilder

æœ€å¾Œã«ã€Builderãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã—ã¦å¤–éƒ¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒZMarkupParserã«å¿…è¦ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿…é€Ÿã«æ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã«ã—ã€ã‚¢ã‚¯ã‚»ã‚¹ãƒ¬ãƒ™ãƒ«ã®åˆ¶å¾¡ã‚‚é©åˆ‡ã«è¡Œã„ã¾ã—ãŸã€‚

```swift
public final class ZHTMLParserBuilder {
    
    private(set) var htmlTags: [HTMLTag] = []
    private(set) var styleAttributes: [HTMLTagStyleAttribute] = []
    private(set) var rootStyle: MarkupStyle?
    private(set) var policy: MarkupStylePolicy = .respectMarkupStyleFromCode
    
    public init() {
        
    }
    
    public static func initWithDefault() -> Self {
        var builder = Self.init()
        for htmlTagName in ZHTMLParserBuilder.htmlTagNames {
            builder = builder.add(htmlTagName)
        }
        for styleAttribute in ZHTMLParserBuilder.styleAttributes {
            builder = builder.add(styleAttribute)
        }
        return builder
    }
    
    public func set(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle?) -> Self {
        return self.add(htmlTagName, withCustomStyle: markupStyle)
    }
    
    public func add(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle? = nil) -> Self {
        // åŒã˜ tagName ã¯ä¸€ã¤ã ã‘å­˜åœ¨å¯èƒ½
        htmlTags.removeAll { htmlTag in
            return htmlTag.tagName.string == htmlTagName.string
        }
        
        htmlTags.append(HTMLTag(tagName: htmlTagName, customStyle: markupStyle))
        
        return self
    }
    
    public func add(_ styleAttribute: HTMLTagStyleAttribute) -> Self {
        styleAttributes.removeAll { thisStyleAttribute in
            return thisStyleAttribute.styleName == styleAttribute.styleName
        }
        
        styleAttributes.append(styleAttribute)
        
        return self
    }
    
    public func set(rootStyle: MarkupStyle) -> Self {
        self.rootStyle = rootStyle
        return self
    }
    
    public func set(policy: MarkupStylePolicy) -> Self {
        self.policy = policy
        return self
    }
    
    public func build() -> ZHTMLParser {
        // ZHTMLParser ã® init ã¯ internal ã®ã¿ã§ã€å¤–éƒ¨ã‹ã‚‰ç›´æ¥åˆæœŸåŒ–ä¸å¯
        // ZHTMLParserBuilder ã‚’é€šã˜ã¦ã®ã¿åˆæœŸåŒ–å¯èƒ½
        return ZHTMLParser(htmlTags: htmlTags, styleAttributes: styleAttributes, policy: policy, rootStyle: rootStyle)
    }
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ [ZHTMLParserBuilder.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/ZHTMLParserBuilder.swift){:target="_blank"} ã®å®Ÿè£…

**initWithDefault ã¯ã€ã™ã§ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã® HTMLTagName/Style Attribute ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è¿½åŠ ã—ã¾ã™**

```swift
public extension ZHTMLParserBuilder {
    static var htmlTagNames: [HTMLTagName] {
        return [
            A_HTMLTagName(),
            B_HTMLTagName(),
            BR_HTMLTagName(),
            DIV_HTMLTagName(),
            HR_HTMLTagName(),
            I_HTMLTagName(),
            LI_HTMLTagName(),
            OL_HTMLTagName(),
            P_HTMLTagName(),
            SPAN_HTMLTagName(),
            STRONG_HTMLTagName(),
            U_HTMLTagName(),
            UL_HTMLTagName(),
            DEL_HTMLTagName(),
            TR_HTMLTagName(),
            TD_HTMLTagName(),
            TH_HTMLTagName(),
            TABLE_HTMLTagName(),
            IMG_HTMLTagName(handler: nil),
            // ...
        ]
    }
}

public extension ZHTMLParserBuilder {
    static var styleAttributes: [HTMLTagStyleAttribute] {
        return [
            ColorHTMLTagStyleAttribute(),
            BackgroundColorHTMLTagStyleAttribute(),
            FontSizeHTMLTagStyleAttribute(),
            FontWeightHTMLTagStyleAttribute(),
            LineHeightHTMLTagStyleAttribute(),
            WordSpacingHTMLTagStyleAttribute(),
            // ...
        ]
    }
}
```

ZHTMLParser ã®åˆæœŸåŒ–ã¯ internal ã®ã¿å…¬é–‹ã—ã¦ãŠã‚Šã€å¤–éƒ¨ã‹ã‚‰ç›´æ¥åˆæœŸåŒ–ã§ãã¾ã›ã‚“ã€‚å¿…ãš ZHTMLParserBuilder ã‚’é€šã˜ã¦åˆæœŸåŒ–ã—ã¦ãã ã•ã„ã€‚

**ZHTMLParser ã¯ Render/Selector/Stripper æ“ä½œã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã„ã¾ã™:**

```swift
public final class ZHTMLParser: ZMarkupParser {
    let htmlTags: [HTMLTag]
    let styleAttributes: [HTMLTagStyleAttribute]
    let rootStyle: MarkupStyle?

    internal init(...) {
    }
    
    // linkã‚¹ã‚¿ã‚¤ãƒ«å±æ€§ã‚’å–å¾—ã™ã‚‹
    public var linkTextAttributes: [NSAttributedString.Key: Any] {
        // ...
    }
    
    public func selector(_ string: String) -> HTMLSelector {
        // ...
    }
    
    public func selector(_ attributedString: NSAttributedString) -> HTMLSelector {
        // ...
    }
    
    public func render(_ string: String) -> NSAttributedString {
        // ...
    }
    
    // HTMLSelectorã®çµæœã‚’ä½¿ã£ã¦ãƒãƒ¼ãƒ‰å†…ã®NSAttributedStringã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å¯èƒ½ã«ã™ã‚‹
    public func render(_ selector: HTMLSelector) -> NSAttributedString {
        // ...
    }
    
    public func render(_ attributedString: NSAttributedString) -> NSAttributedString {
        // ...
    }
    
    public func stripper(_ string: String) -> String {
        // ...
    }
    
    public func stripper(_ attributedString: NSAttributedString) -> NSAttributedString {
        // ...
    }
    
  // ...
}
```

> å¯¾å¿œã™ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã® [ZHTMLParser.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/ZHTMLParser.swift){:target="_blank"} å®Ÿè£…

#### UIKit ã®å•é¡Œ

NSAttributedString ã®çµæœã¯æœ€ã‚‚ã‚ˆã UITextView ã«è¡¨ç¤ºã•ã‚Œã¾ã™ãŒã€æ³¨æ„ãŒå¿…è¦ã§ã™:

- UITextView å†…ã®ãƒªãƒ³ã‚¯ã‚¹ã‚¿ã‚¤ãƒ«ã¯ `linkTextAttributes` ã®è¨­å®šã«çµ±ä¸€ã•ã‚Œã¦ãŠã‚Šã€NSAttributedString.Key ã®è¨­å®šã¯å‚ç…§ã•ã‚Œãšã€å€‹åˆ¥ã«ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®šã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ãã®ãŸã‚ `ZMarkupParser.linkTextAttributes` ã¨ã„ã†ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚

- UILabel ã¯ä¸€æ™‚çš„ã«ãƒªãƒ³ã‚¯ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å¤‰æ›´ã™ã‚‹æ–¹æ³•ãŒãªãã€ã¾ãŸ UILabel ã« TextStorage ãŒãªã„ãŸã‚ã€NSTextAttachment ã®ç”»åƒã‚’èª­ã¿è¾¼ã‚€ã«ã¯åˆ¥é€” UILabel ã‚’å–å¾—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```swift
public extension UITextView {
    func setHtmlString(_ string: String, with parser: ZHTMLParser) {
        self.setHtmlString(NSAttributedString(string: string), with: parser)
    }
    
    func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) {
        self.attributedText = parser.render(string)
        self.linkTextAttributes = parser.linkTextAttributes
    }
}
public extension UILabel {
    func setHtmlString(_ string: String, with parser: ZHTMLParser) {
        self.setHtmlString(NSAttributedString(string: string), with: parser)
    }
    
    func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) {
        let attributedString = parser.render(string)
        attributedString.enumerateAttribute(NSAttributedString.Key.attachment, in: NSMakeRange(0, attributedString.string.utf16.count), options: []) { (value, effectiveRange, nil) in
            guard let attachment = value as? ZNSTextAttachment else {
                return
            }
            
            attachment.register(self)
        }
        
        self.attributedText = attributedString
    }
}
```

ãã®ãŸã‚ã€UIKit ã«å¤šæ•°ã® Extension ã‚’è¿½åŠ ã—ã€å¤–éƒ¨ã‹ã‚‰ã¯å˜ã« `setHTMLString()` ã‚’å‘¼ã¶ã ã‘ã§ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãŒå®Œäº†ã—ã¾ã™ã€‚

#### è¤‡é›‘ãªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é …ç›® â€” ãƒªã‚¹ãƒˆé …ç›®

é …ç›®ãƒªã‚¹ãƒˆã®å®Ÿè£…è¨˜éŒ²ã«ã¤ã„ã¦ã€‚

**HTMLã§ `<ol>` / `<ul>` ã‚’ä½¿ã£ã¦ `<li>` ã‚’åŒ…ã‚€ã“ã¨ã§ãƒªã‚¹ãƒˆé …ç›®ã‚’è¡¨ã—ã¾ã™:**

```xml
<ul>
    <li>ItemA</li>
    <li>ItemB</li>
    <li>ItemC</li>
    //...
</ul>
```

å‰è¿°ã®è§£ææ–¹æ³•ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã€`visit(_ markup: ListItemMarkup)` å†…ã§ä»–ã®ãƒªã‚¹ãƒˆã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ã—ã€ç¾åœ¨ã®ãƒªã‚¹ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ˆASTã«å¤‰æ›ã•ã‚Œã¦ã„ã‚‹ãŸã‚å¯èƒ½ã§ã™ï¼‰ã€‚

```swift
func visit(_ markup: ListItemMarkup) -> Result {
  let siblingListItems = markup.parentMarkup?.childMarkups.filter({ $0 is ListItemMarkup }) ?? []
  let position = (siblingListItems.firstIndex(where: { $0 === markup }) ?? 0)
}
```

NSParagraphStyle ã«ã¯ãƒªã‚¹ãƒˆã‚¢ã‚¤ãƒ†ãƒ ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã® NSTextList ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚Šã¾ã™ãŒã€å®Ÿè£…ä¸Šã€ç©ºç™½ã®å¹…ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã›ã‚“ï¼ˆå€‹äººçš„ã«ã¯ç©ºç™½ãŒå¤§ãã™ãã‚‹ã¨æ„Ÿã˜ã¾ã™ï¼‰ã€‚ã¾ãŸã€é …ç›®ã®è¨˜å·ã¨æ–‡å­—åˆ—ã®é–“ã«ç©ºç™½ãŒã‚ã‚‹ã¨ã€æ”¹è¡ŒãŒãã“ã§ç™ºç”Ÿã—ã€è¡¨ç¤ºãŒå°‘ã—ãŠã‹ã—ããªã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®å›³ã®ã‚ˆã†ã«ï¼š

![](/assets/2724f02f6e7/1*jvIgDjO4DNAKpPZF1balmw.png)

Beter éƒ¨åˆ†ã¯ [è¨­å®š headIndent, firstLineHeadIndent, NSTextTab](https://www.objc.io/issues/9-strings/string-rendering/){:target="_blank"} ã‚’ä½¿ã£ã¦å®Ÿç¾ã§ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ãŒã€ãƒ†ã‚¹ãƒˆã—ãŸã¨ã“ã‚æ–‡å­—åˆ—ãŒé•·ã™ããŸã‚Šã‚µã‚¤ã‚ºãŒå¤‰ã‚ã£ãŸã‚Šã™ã‚‹ã¨ã€å®Œç’§ã«è¡¨ç¤ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚

ç¾åœ¨ã¯ Acceptable ãƒ¬ãƒ™ãƒ«ã¾ã§å®Ÿè£…ã—ã¦ãŠã‚Šã€è‡ªåˆ†ã§é …ç›®ãƒªã‚¹ãƒˆã®æ–‡å­—åˆ—ã‚’çµ„ã¿åˆã‚ã›ã¦æ–‡å­—åˆ—ã®å…ˆé ­ã«æŒ¿å…¥ã—ã¦ã„ã¾ã™ã€‚

ç§ãŸã¡ã¯ NSTextList.MarkerFormat ã®ã¿ã‚’ä½¿ç”¨ã—ã¦ã€ç®‡æ¡æ›¸ãã®è¨˜å·ã‚’ç”Ÿæˆã—ã¦ãŠã‚Šã€ç›´æ¥ NSTextList ã¯ä½¿ç”¨ã—ã¦ã„ã¾ã›ã‚“ã€‚

**ãƒªã‚¹ãƒˆè¨˜å·ã®ã‚µãƒãƒ¼ãƒˆä¸€è¦§ã¯ã“ã¡ã‚‰ã‚’ã”å‚ç…§ãã ã•ã„ï¼š** [MarkupStyleList.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyleList.swift){:target="_blank"}

**æœ€çµ‚è¡¨ç¤ºçµæœï¼š(** `<ol><li>` **)**

![](/assets/2724f02f6e7/1*yM3VROfUNgnEBfIYwYwPnQ.png)

#### è¤‡é›‘ãªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é …ç›® â€” Table

ãƒªã‚¹ãƒˆé …ç›®ã«ä¼¼ã¦ã„ã¾ã™ãŒã€è¡¨ã®å®Ÿè£…ã§ã™ã€‚

**HTMLã§ã®<table>ã®ä½¿ç”¨ -> <tr>ã§è¡Œã‚’åŒ…ã¿ -> <td>/<th>ã§ã‚»ãƒ«ã‚’è¡¨ã™:**

```xml
<table>
  <tr>
    <th>ä¼šç¤¾å</th>
    <th>æ‹…å½“è€…</th>
    <th>å›½</th>
  </tr>
  <tr>
    <td>Alfreds Futterkiste</td>
    <td>Maria Anders</td>
    <td>ãƒ‰ã‚¤ãƒ„</td>
  </tr>
  <tr>
    <td>Centro comercial Moctezuma</td>
    <td>Francisco Chang</td>
    <td>ãƒ¡ã‚­ã‚·ã‚³</td>
  </tr>
</table>
```

å®Ÿéš›ã«ãƒã‚¤ãƒ†ã‚£ãƒ–ã® `NSAttributedString.DocumentType.html` ã¯ã€ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãª macOS API ã® `NSTextBlock` ã‚’ä½¿ã£ã¦è¡¨ç¤ºã‚’å®Ÿç¾ã—ã¦ã„ã‚‹ãŸã‚ã€HTMLã®è¡¨ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚„å†…å®¹ã‚’å®Œå…¨ã«è¡¨ç¤ºã§ãã¾ã™ã€‚

> ã¡ã‚‡ã£ã¨ã‚ºãƒ«ã„ï¼Private APIã¯ä½¿ãˆã¾ã›ã‚“ğŸ¥²

```swift
    func visit(_ markup: TableColumnMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        let siblingColumns = markup.parentMarkup?.childMarkups.filter({ $0 is TableColumnMarkup }) ?? []
        let position = (siblingColumns.firstIndex(where: { $0 === markup }) ?? 0)
        
        // å¤–éƒ¨ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸå¹…ãŒã‚ã‚‹ã‹ã©ã†ã‹ã€.maxã«è¨­å®šã™ã‚‹ã¨æ–‡å­—åˆ—ã¯åˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œã¾ã›ã‚“
        var maxLength: Int? = markup.fixedMaxLength
        if maxLength == nil {
            // æŒ‡å®šãŒãªã‘ã‚Œã°ã€æœ€åˆã®è¡Œã®åŒã˜åˆ—ã®æ–‡å­—åˆ—é•·ã‚’max lengthã¨ã™ã‚‹
            if let tableRowMarkup = markup.parentMarkup as? TableRowMarkup,
               let firstTableRow = tableRowMarkup.parentMarkup?.childMarkups.first(where: { $0 is TableRowMarkup }) as? TableRowMarkup {
                let firstTableRowColumns = firstTableRow.childMarkups.filter({ $0 is TableColumnMarkup })
                if firstTableRowColumns.indices.contains(position) {
                    let firstTableRowColumnAttributedString = collectAttributedString(firstTableRowColumns[position])
                    let length = firstTableRowColumnAttributedString.string.utf16.count
                    maxLength = length
                }
            }
        }
        
        if let maxLength = maxLength {
            // ã‚«ãƒ©ãƒ ãŒmaxLengthã‚’è¶…ãˆã‚‹å ´åˆã¯æ–‡å­—åˆ—ã‚’åˆ‡ã‚Šè©°ã‚ã‚‹
            if attributedString.string.utf16.count > maxLength {
                attributedString.mutableString.setString(String(attributedString.string.prefix(maxLength))+"...")
            } else {
                attributedString.mutableString.setString(attributedString.string.padding(toLength: maxLength, withPad: " ", startingAt: 0))
            }
        }
        
        if position < siblingColumns.count - 1 {
            // ã‚¹ãƒšãƒ¼ã‚¹ã‚’è¿½åŠ ã—ã¦é–“éš”ã‚’ä½œã‚‹ã€‚å¤–éƒ¨ã‹ã‚‰ã‚¹ãƒšãƒ¼ã‚¹ã®å¹…ã‚’æŒ‡å®šå¯èƒ½
            attributedString.append(makeString(in: markup, string: String(repeating: " ", count: markup.spacing)))
        }
        
        return attributedString
    }
    
    func visit(_ markup: TableRowMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        attributedString.append(makeBreakLine(in: markup)) // æ”¹è¡Œã‚’è¿½åŠ ã€è©³ç´°ã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å‚ç…§
        return attributedString
    }
    
    func visit(_ markup: TableMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        attributedString.append(makeBreakLine(in: markup)) // æ”¹è¡Œã‚’è¿½åŠ ã€è©³ç´°ã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å‚ç…§
        attributedString.insert(makeBreakLine(in: markup), at: 0) // æ”¹è¡Œã‚’å…ˆé ­ã«è¿½åŠ ã€è©³ç´°ã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å‚ç…§
        return attributedString
    }
```

**æœ€çµ‚çš„ãªè¡¨ç¤ºã¯ä»¥ä¸‹ã®å›³ã®é€šã‚Šã§ã™ï¼š**

![](/assets/2724f02f6e7/1*Dft7H2BbeyWIO-dH4QpuSw.png)

å®Œç’§ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€è¨±å®¹ç¯„å›²ã§ã™ã€‚

#### è¤‡é›‘ãªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é …ç›® â€” Image

æœ€å¾Œã«æœ€å¤§ã®é›£é–¢ã§ã‚ã‚‹ã€ãƒªãƒ¢ãƒ¼ãƒˆç”»åƒã‚’ NSAttributedString ã«èª­ã¿è¾¼ã‚€ã“ã¨ã«ã¤ã„ã¦è©±ã—ã¾ã™ã€‚

**HTMLã§ `<img>` ã‚’ä½¿ã£ã¦ç”»åƒã‚’è¡¨ç¤ºã™ã‚‹:**

```xml
<img src="https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg" width="300" height="125"/>
```

`width` / `height` ã® HTML å±æ€§ã‚’ä½¿ã£ã¦ã€è¡¨ç¤ºã—ãŸã„ã‚µã‚¤ã‚ºã‚’æŒ‡å®šã§ãã¾ã™ã€‚

NSAttributedString ã§ç”»åƒã‚’è¡¨ç¤ºã™ã‚‹ã®ã¯æƒ³åƒä»¥ä¸Šã«è¤‡é›‘ã§ã€ã†ã¾ãå®Ÿè£…ã§ãã‚‹æ–¹æ³•ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ä»¥å‰ [UITextView æ–‡ç¹åœ–](../e37d66ea1146/) ã‚’ä½œã£ãŸã¨ãã«å°‘ã—è‹¦åŠ´ã—ã¾ã—ãŸãŒã€ä»Šå›æ”¹ã‚ã¦èª¿ã¹ã¦ã¿ã¦ã‚‚å®Œç’§ãªè§£æ±ºç­–ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚

ç¾åœ¨ã¯ NSTextAttachment ã®ãƒã‚¤ãƒ†ã‚£ãƒ–ãªå†åˆ©ç”¨ã‚„ãƒ¡ãƒ¢ãƒªè§£æ”¾ã®å•é¡Œã‚’ç„¡è¦–ã—ã¦ã€ã¾ãšã¯ãƒªãƒ¢ãƒ¼ãƒˆã‹ã‚‰ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ NSTextAttachment ã«å…¥ã‚Œã€ãã‚Œã‚’ NSAttributedString ã«é…ç½®ã—ã€è‡ªå‹•çš„ã«å†…å®¹ã‚’æ›´æ–°ã™ã‚‹æ©Ÿèƒ½ã®ã¿ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

**ã“ã®ã‚·ãƒªãƒ¼ã‚ºã®æ“ä½œã¯åˆ¥ã®å°ã•ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦åˆ†å‰²ã—ã¦å®Ÿè£…ã—ã¾ã—ãŸã€‚å°†æ¥çš„ã«æœ€é©åŒ–ã‚„ä»–ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å†åˆ©ç”¨ãŒã—ã‚„ã™ããªã‚‹ã¨æ€ã£ãŸãŸã‚ã§ã™:**

[![](https://opengraph.githubassets.com/5c63c82d77259bfe295dc17bf3eedc073f2e23dbd9598642813af0bcecb5b701/ZhgChgLi/ZNSTextAttachment)](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"}

ä¸»ã« [Asynchronous NSTextAttachments](https://www.cocoanetics.com/2016/09/asynchronous-nstextattachment-1/){:target="_blank"} ã®ã‚·ãƒªãƒ¼ã‚ºè¨˜äº‹ã‚’å‚è€ƒã«å®Ÿè£…ã—ã¾ã—ãŸãŒã€æœ€å¾Œã®æ›´æ–°å†…å®¹éƒ¨åˆ†ï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã«UIã‚’ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã—ã¦è¡¨ç¤ºã™ã‚‹ï¼‰ã‚’ç½®ãæ›ãˆã€ã•ã‚‰ã«å¤–éƒ¨æ‹¡å¼µç”¨ã«Delegate/DataSourceã‚’è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚

![é‹ç”¨ã®æµã‚Œã¨é–¢ä¿‚ã¯ä¸Šå›³ã®é€šã‚Š](/assets/2724f02f6e7/1*JZ8IVVNj9B2l-UBemGbAig.png)

é‹ç”¨ã®ãƒ•ãƒ­ãƒ¼ã¨é–¢ä¿‚ã¯ä¸Šå›³ã®é€šã‚Šã§ã™ã€‚

- ZNSTextAttachmentable ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®£è¨€ã—ã€NSTextStorage ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆUITextView ã«å†…è”µï¼‰ã¨ UILabel è‡ªèº«ï¼ˆUILabel ã¯ NSTextStorage ã‚’æŒãŸãªã„ï¼‰ã‚’ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚  
  æ“ä½œæ–¹æ³•ã¯ NSRange ã‹ã‚‰ã® attributedString ã®ç½®æ›ã‚’å®Ÿç¾ã™ã‚‹ã ã‘ã§ã™ã€‚ï¼ˆ`func replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment)`ï¼‰

- å®Ÿè£…ã®åŸç†ã¯ã€ã¾ãš `ZNSTextAttachment` ã‚’ä½¿ã£ã¦ imageURLã€PlaceholderImageã€ç›®ç«‹ã¤è¡¨ç¤ºã‚µã‚¤ã‚ºæƒ…å ±ã‚’ãƒ©ãƒƒãƒ—ã—ã€å…ˆã«ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã§ç”»åƒã‚’ç›´æ¥è¡¨ç¤ºã™ã‚‹ã“ã¨ã§ã™ã€‚

- ã‚·ã‚¹ãƒ†ãƒ ãŒç”»é¢ã«ã“ã®ç”»åƒã‚’è¡¨ç¤ºã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã« `image(forBoundsâ€¦` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã€ãã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ç”»åƒãƒ‡ãƒ¼ã‚¿ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹ã—ã¾ã™

- DataSource ã¯å¤–éƒ¨ã§ç”»åƒã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ–¹æ³•ã‚„ Image Cache Policy ã‚’æ±ºå®šã§ãã‚‹ã‚ˆã†ã«ã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ URLSession ã‚’ä½¿ã£ã¦ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ã¾ã™ã€‚

- ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã€æ–°ã—ã `ZResizableNSTextAttachment` ã‚’ç”Ÿæˆã—ã€`attachmentBounds(forâ€¦` å†…ã§ç”»åƒã‚µã‚¤ã‚ºã®ã‚«ã‚¹ã‚¿ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

- `replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment)` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã€`ZNSTextAttachment` ã®ä½ç½®ã‚’ `ZResizableNSTextAttachment` ã«ç½®ãæ›ãˆã¾ã™ã€‚

- didLoad ãƒ‡ãƒªã‚²ãƒ¼ãƒˆé€šçŸ¥ã‚’é€ä¿¡ã—ã€å¤–éƒ¨ãŒå¿…è¦ãªå ´åˆã«é€£æºã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™

- å®Œäº†

> **è©³ç´°ãªã‚³ãƒ¼ãƒ‰ã¯ [Source Code](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"} ã‚’ã”å‚ç…§ãã ã•ã„ã€‚** ã€‚

`NSLayoutManager.invalidateLayout(forCharacterRange: range, actualCharacterRange: nil)` ã‚„ `NSLayoutManager.invalidateDisplay(forCharacterRange: range)` ã‚’ä½¿ã£ã¦ UI ã‚’æ›´æ–°ã—ãªã„ç†ç”±ã¯ã€UI ãŒæ­£ã—ãè¡¨ç¤ºæ›´æ–°ã•ã‚Œãªã„ã“ã¨ãŒåˆ¤æ˜ã—ãŸãŸã‚ã§ã™ã€‚ç¯„å›²ãŒåˆ†ã‹ã£ã¦ã„ã‚‹ã®ã§ã€ç›´æ¥ NSAttributedString ã‚’ç½®ãæ›ãˆã‚‹ã“ã¨ã§ UI ã®æ­£ã—ã„æ›´æ–°ã‚’ä¿è¨¼ã§ãã¾ã™ã€‚

æœ€çµ‚è¡¨ç¤ºçµæœã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š

```xml
<span style="color:red">ã“ã‚“ã«ã¡ã¯</span>ã“ã‚“ã«ã¡ã¯ã“ã‚“ã«ã¡ã¯ <br />
<img src="https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg"/>
```

![](/assets/2724f02f6e7/1*bl65v-SVOK3H9ajR-Ksg6w.png)

### ãƒ†ã‚¹ãƒˆã¨ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

ä»Šå›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€Unit Testï¼ˆå˜ä½“ãƒ†ã‚¹ãƒˆï¼‰ã«åŠ ãˆã¦ã€Snapshot Testã‚’å°å…¥ã—ã€æœ€çµ‚çš„ãªNSAttributedStringã®ç·åˆçš„ãªãƒ†ã‚¹ãƒˆæ¯”è¼ƒã‚’å®¹æ˜“ã«ã—ã¾ã—ãŸã€‚

ä¸»ãªæ©Ÿèƒ½ãƒ­ã‚¸ãƒƒã‚¯ã«ã¯ã™ã¹ã¦ UnitTests ãŒã‚ã‚Šã€çµ±åˆãƒ†ã‚¹ãƒˆã‚‚åŠ ãˆã¦ã„ã¾ã™ã€‚æœ€çµ‚çš„ãª [Test Coverage](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"} ã¯ **85%** å‰å¾Œã§ã™ã€‚

![[ZMarkupParser â€” codecov](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*wV6BZcEGYuT9B9Xy4QzI0w.png)

[ZMarkupParser â€” codecov](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}

#### ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

[![](https://opengraph.githubassets.com/b3cc52a5b949767e4cb0af82145ed6474334d3235bd785ee1f7891c6b65fd69a/pointfreeco/swift-snapshot-testing)](https://github.com/pointfreeco/swift-snapshot-testing){:target="_blank"}

**ç›´æ¥ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’å°å…¥ã—ã¦ä½¿ç”¨:**

```swift
import SnapshotTesting
// ...
func testShouldKeppNSAttributedString() {
  let parser = ZHTMLParserBuilder.initWithDefault().build()
  let textView = UITextView()
  textView.frame.size.width = 390
  textView.isScrollEnabled = false
  textView.backgroundColor = .white
  textView.setHtmlString("html string...", with: parser)
  textView.layoutIfNeeded()
  assertSnapshot(matching: textView, as: .image, record: false)
}
// ...
```

![](/assets/2724f02f6e7/1*hLPeaOTOviA0jTPNOPu1hg.png)

æœ€çµ‚çµæœãŒæœŸå¾…é€šã‚Šã§ã‚ã‚‹ã‹ã‚’ç›´æ¥æ¯”è¼ƒã—ã€èª¿æ•´ã‚„çµ±åˆã«å•é¡ŒãŒãªã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚

#### Codecov ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸

[Codecov.io](https://about.codecov.io){:target="_blank"}ï¼ˆãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒªãƒã‚¸ãƒˆãƒªã¯ç„¡æ–™ï¼‰ã¨é€£æºã—ã¦ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã‚’è©•ä¾¡ã™ã‚‹ã«ã¯ã€Codecovã®GitHubã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦è¨­å®šã™ã‚‹ã ã‘ã§ã™ã€‚

[![](https://storage.googleapis.com/codecov-cdn/static/Codecov-icon-600x600.png)](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}

Codecov &lt;-&gt; Github ãƒªãƒã‚¸ãƒˆãƒªã®è¨­å®šãŒå®Œäº†ã—ãŸã‚‰ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã« `codecov.yml` ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

```yaml
comment:                  # ã“ã‚Œã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ã‚­ãƒ¼ã§ã™
  layout: "reach, diff, flags, files"
  behavior: default
  require_changes: false  # trueã®å ´åˆï¼šã‚«ãƒãƒ¬ãƒƒã‚¸ãŒå¤‰åŒ–ã—ãŸæ™‚ã®ã¿ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿ã—ã¾ã™
  require_base: no        # [yes :: ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿ã«ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒãƒ¼ãƒˆãŒå¿…é ˆ]
  require_head: yes       # [yes :: ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿ã«ãƒ˜ãƒƒãƒ‰ãƒ¬ãƒãƒ¼ãƒˆãŒå¿…é ˆ]
```

è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã€ã“ã‚Œã§å„PRãŒå‡ºã•ã‚ŒãŸå¾Œã«ã€è‡ªå‹•ã§CIã®çµæœã‚’ã‚³ãƒ¡ãƒ³ãƒˆã¨ã—ã¦æŠ•ç¨¿ã§ãã¾ã™ã€‚

![](/assets/2724f02f6e7/1*AcKpF4dijglahV-iVYLvvA.png)

#### ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

Github Action, CI çµ±åˆ: `ci.yml`

```yaml
name: CI

on:
  workflow_dispatch:
  pull_request:
    types: [opened, reopened]
  push:
    branches:
    - main

jobs:
  build:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v3
      - name: spm build and test
        run: \\|
          set -o pipefail
          xcodebuild test -workspace ZMarkupParser.xcworkspace -testPlan ZMarkupParser -scheme ZMarkupParser -enableCodeCoverage YES -resultBundlePath './scripts/TestResult.xcresult' -destination 'platform=iOS Simulator,name=iPhone 14,OS=16.1' build test \\| xcpretty
      - name: Codecov
        uses: codecov/codecov-action@v3.1.1
        with:
          xcode: true
          xcode_archive_path: './scripts/TestResult.xcresult'
```

ã“ã®è¨­å®šã¯ã€PRãŒã‚ªãƒ¼ãƒ—ãƒ³ï¼å†ã‚ªãƒ¼ãƒ—ãƒ³ã•ã‚ŒãŸã¨ãã€ã¾ãŸã¯mainãƒ–ãƒ©ãƒ³ãƒã«ãƒ—ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸã¨ãã«ãƒ“ãƒ«ãƒ‰ã¨ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã€æœ€å¾Œã«ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®ãƒ¬ãƒãƒ¼ãƒˆã‚’codecovã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚

#### Regex

æ­£è¦è¡¨ç¾ã«ã¤ã„ã¦ã¯ã€ä½¿ã†ãŸã³ã«æ”¹è‰¯ã‚’é‡ã­ã¦ã„ã¾ã™ã€‚ä»Šå›ã¯ã‚ã¾ã‚Šå¤šç”¨ã—ã¾ã›ã‚“ã§ã—ãŸãŒã€å…ƒã€…ãƒšã‚¢ã«ãªã£ãŸHTMLã‚¿ã‚°ã‚’æ­£è¦è¡¨ç¾ã§æŠ½å‡ºã—ã‚ˆã†ã¨è€ƒãˆã¦ã„ãŸãŸã‚ã€æ›¸ãæ–¹ã‚’è©³ã—ãèª¿ã¹ã¾ã—ãŸã€‚

ä»Šå›æ–°ã—ãå­¦ã‚“ã ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆã®ãƒ¡ãƒ¢â€¦

- `?:` ã¯ ( ) å†…ã®ãƒãƒƒãƒçµæœã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¾ã™ãŒã€ã‚­ãƒ£ãƒ—ãƒãƒ£ã¯ã—ã¾ã›ã‚“ã€‚  
  ä¾‹ï¼š`(?:https?:\/\/)?(?:www\.)?example\.com` ã¯ `https://www.example.com` ã«å¯¾ã—ã¦ã€`https://` ã‚„ `www` ã§ã¯ãªãã€å…¨ä½“ã®URLã‚’è¿”ã—ã¾ã™ã€‚

- `.+?` ã¯éè²ªæ¬²ãƒãƒƒãƒï¼ˆæœ€ã‚‚è¿‘ã„ã‚‚ã®ã‚’è¦‹ã¤ã‘ãŸã‚‰è¿”ã™ï¼‰ã§ã™ã€‚  
  ä¾‹: `<.+?>` ã¯ `<a>test</a>` ã®ä¸­ã§ `<a>` ã¨ `</a>` ã‚’è¿”ã—ã€æ–‡å­—åˆ—å…¨ä½“ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

- `(?=XYZ)` ã¯ `XYZ` ã¨ã„ã†æ–‡å­—åˆ—ãŒç¾ã‚Œã‚‹ã¾ã§ã®ä»»æ„ã®æ–‡å­—åˆ—ã‚’æ„å‘³ã—ã¾ã™ã€‚æ³¨æ„ã™ã¹ãã¯ã€ä¼¼ã¦ã„ã‚‹ `[^XYZ]` ã¯ `X` ã¾ãŸã¯ `Y` ã¾ãŸã¯ `Z` ã®ã„ãšã‚Œã‹ã®æ–‡å­—ãŒç¾ã‚Œã‚‹ã¾ã§ã®ä»»æ„ã®æ–‡å­—ã‚’è¡¨ã™ã“ã¨ã§ã™ã€‚  
  ä¾‹ï¼š`(?:__)(.+?(?=__))(?:__)` ï¼ˆ`__` ã¾ã§ã®ä»»æ„ã®æ–‡å­—åˆ—ï¼‰ã¯ `test` ã«ãƒãƒƒãƒã—ã¾ã™ã€‚

- `?R` ã¯å†å¸°çš„ã«åŒã˜ãƒ«ãƒ¼ãƒ«ã®å€¤ã‚’å†…éƒ¨ã§æ¤œç´¢ã—ã¾ã™ã€‚  
  ä¾‹ï¼š`\((?:[^()]\\|((?R)))+\)` ã¯ `(simple) (and(nested))` ã«å¯¾ã—ã¦ `(simple)` ã€ `(and(nested))` ã€ `(nested)` ã‚’ãƒãƒƒãƒã—ã¾ã™ã€‚

- `?<GroupName>` ã¯å‰ã®ã‚°ãƒ«ãƒ¼ãƒ—åã«ãƒãƒƒãƒã—ã¾ã™ã€‚  
  ä¾‹: `(?<tagName><a>).*(\k<GroupName>)`

- `(?(X)yes\\|no)` ã¯ç¬¬ `X` ç•ªç›®ã®ãƒãƒƒãƒçµæœã«å€¤ãŒã‚ã‚‹ï¼ˆã‚°ãƒ«ãƒ¼ãƒ—åã‚‚ä½¿ç”¨å¯ï¼‰å ´åˆã¯å¾Œç¶šã®æ¡ä»¶ `yes` ã«ãƒãƒƒãƒã—ã€ãªã‘ã‚Œã° `no` ã«ãƒãƒƒãƒã—ã¾ã™ã€‚  
  **Swift ã¯ç¾æ™‚ç‚¹ã§æœªå¯¾å¿œã§ã™ã€‚**

**ãã®ä»–ã®å„ªã‚ŒãŸ Regex è¨˜äº‹ï¼š**

- [Swift æ­£è¦è¡¨ç¾ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹](https://onevcat.com/2022/11/swift-regex/){:target="_blank"}

- [æ­£è¦è¡¨ç¾ã¯ã©ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã®ã‹ï¼Ÿ](https://mp.weixin.qq.com/s/i_C4ATnajxRDGlTA8dJDHg){:target="_blank"} -> **ä»Šå¾Œã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ­£è¦è¡¨ç¾ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’æ”¹å–„ã™ã‚‹éš›ã«å‚è€ƒã«ã§ãã¾ã™**

- [Regex ã‚¨ãƒ©ãƒ¼ã«ã‚ˆã‚‹ç„¡é™æ¤œç´¢ãŒåŸå› ã§ã‚µãƒ¼ãƒãƒ¼éšœå®³ãŒç™ºç”Ÿã—ãŸäº‹ä¾‹](https://juejin.cn/post/6850418120390082574){:target="_blank"}

- [Regex101 å³ä¸‹ã«ã™ã¹ã¦ã®æ­£è¦è¡¨ç¾ãƒ«ãƒ¼ãƒ«ã‚’ç¢ºèªã§ãã¾ã™](https://regex101.com){:target="_blank"}

#### Swift Package Manager & Cocoapods

ã“ã‚Œã‚‚ç§ã«ã¨ã£ã¦åˆã‚ã¦ã® SPM ã¨ Cocoapods ã®é–‹ç™ºã§ã—ãŸâ€¦ãªã‹ãªã‹é¢ç™½ã„ã§ã™ã€‚SPM ã¯æœ¬å½“ã«ä¾¿åˆ©ã§ã™ãŒã€åŒã˜ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’äºŒã¤ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒåŒæ™‚ã«ä¾å­˜ã—ã¦ã„ã‚‹å ´åˆã€äºŒã¤ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’åŒæ™‚ã«é–‹ãã¨ã€ãã®ã†ã¡ã®ä¸€ã¤ãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œãšãƒ“ãƒ«ãƒ‰ã§ããªããªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã€‚ã€‚

Cocoapods ã¯ ZMarkupParser ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã„ã¾ã™ãŒã€æ­£å¸¸ã«å‹•ä½œã™ã‚‹ã‹ã¯ãƒ†ã‚¹ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚ç§ã¯ SPM ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ ğŸ˜ã€‚

#### ChatGPT

å®Ÿéš›ã®é–‹ç™ºçµŒé¨“ã§ã¯ã€Readme ã®æ ¡æ­£æ”¯æ´ã«ã—ã‹å½¹ç«‹ãŸãªã„ã¨æ„Ÿã˜ã¾ã—ãŸã€‚é–‹ç™ºé¢ã§ã¯ç‰¹ã«åŠ¹æœã‚’å®Ÿæ„Ÿã§ãã¾ã›ã‚“ã§ã—ãŸã€‚mid-senior ä»¥ä¸Šã®ãƒ¬ãƒ™ãƒ«ã«è³ªå•ã—ã¦ã‚‚ã€æ­£ç¢ºãªç­”ãˆãŒå¾—ã‚‰ã‚Œãšã€æ™‚ã«ã¯é–“é•ã£ãŸç­”ãˆãŒè¿”ã£ã¦ãã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã—ãŸï¼ˆæ­£è¦è¡¨ç¾ã®ãƒ«ãƒ¼ãƒ«ã«ã¤ã„ã¦è³ªå•ã—ãŸéš›ã€å›ç­”ãŒã‚ã¾ã‚Šæ­£ç¢ºã§ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼‰ã€‚çµå±€ã¯ Google ã§æ‰‹å‹•ã§æ­£ã—ã„è§£ç­”ã‚’æ¢ã™ã“ã¨ã«ãªã‚Šã¾ã—ãŸã€‚

ã¾ã—ã¦ã‚„ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‹ã›ã‚‹ã“ã¨ã¯é¿ã‘ã‚‹ã¹ãã§ã™ã€‚ç°¡å˜ãªã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãªã„é™ã‚Šã€ãƒ„ãƒ¼ãƒ«å…¨ä½“ã®æ§‹æˆã‚’ç›´æ¥å®Œæˆã•ã›ã‚‹ã“ã¨ã¯æœŸå¾…ã—ãªã„ã§ãã ã•ã„ã€‚  
*(å°‘ãªãã¨ã‚‚ç¾æ™‚ç‚¹ã§ã¯ãã†ã§ã‚ã‚Šã€ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãé¢ã§ã¯Copilotã®æ–¹ãŒå½¹ç«‹ã¤ã¨æ„Ÿã˜ã¦ã„ã¾ã™)*

ã—ã‹ã—ã€çŸ¥è­˜ã®ç›²ç‚¹ã¨ãªã‚‹å¤§ã¾ã‹ãªæ–¹å‘æ€§ã‚’ç¤ºã—ã¦ãã‚Œã‚‹ãŸã‚ã€ã©ã®éƒ¨åˆ†ãŒã©ã†ã™ã¹ãã‹ã‚’ç´ æ—©ãå¤§ã¾ã‹ã«æŠŠæ¡ã§ãã¾ã™ã€‚æ™‚ã«ã¯ç†è§£åº¦ãŒä½ã™ãã¦ã€Googleã§ã¯æ­£ã—ã„æ–¹å‘ã‚’ç´ æ—©ãè¦‹ã¤ã‘ã‚‹ã®ãŒé›£ã—ã„ã“ã¨ãŒã‚ã‚Šã¾ã™ãŒã€ãã‚“ãªæ™‚ã«ChatGPTã¯éå¸¸ã«å½¹ç«‹ã¡ã¾ã™ã€‚

### å£°æ˜

ä¸‰ãƒ¶æœˆä»¥ä¸Šã®ç ”ç©¶ã¨é–‹ç™ºã‚’çµŒã¦ã€éå¸¸ã«ç–²ã‚Œã¾ã—ãŸãŒã€ã“ã®æ–¹æ³•ã¯ç§ã®èª¿æŸ»ã«ã‚ˆã£ã¦å¾—ã‚‰ã‚ŒãŸå®Ÿè¡Œå¯èƒ½ãªçµæœã§ã‚ã‚Šã€å¿…ãšã—ã‚‚æœ€è‰¯ã®è§£æ±ºç­–ã§ã¯ãªãã€ã¾ã æ”¹å–„ã®ä½™åœ°ãŒã‚ã‚‹ã“ã¨ã‚’æ˜è¨€ã—ã¦ãŠãã¾ã™ã€‚ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸€ç¨®ã®ãã£ã‹ã‘ã¨ã—ã¦æ‰ãˆã¦ãŠã‚Šã€Markup Language ã‹ã‚‰ NSAttributedString ã¸ã®å®Œç’§ãªè§£æ±ºç­–ã‚’ç›®æŒ‡ã—ã¦ã„ã¾ã™ã€‚**å¤šãã®æ–¹ã®è²¢çŒ®ã‚’å¤§æ­“è¿ã—ã¾ã™ï¼›å¤šãã®ç‚¹ã§ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®åŠ›ãŒå¿…è¦ã§ã™ã€‚**

### è²¢çŒ®ã«ã¤ã„ã¦

![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} [â­](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*kXjJQnSIJ7x-lSIYtacRrQ.jpeg)

[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} [â­](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

ã“ã“ã§ã¯ã€ç¾æ™‚ç‚¹ï¼ˆ2023/03/12ï¼‰ã§æ€ã„ã¤ã„ãŸæ”¹å–„ç‚¹ã‚’ã„ãã¤ã‹æŒ™ã’ã¾ã™ã€‚ä»Šå¾Œã€ãƒªãƒã‚¸ãƒˆãƒªã«è¨˜éŒ²ã—ã¦ã„ãã¾ã™ï¼š

1. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æœ€é©åŒ–ã¯ã€ãƒã‚¤ãƒ†ã‚£ãƒ–ã® `NSAttributedString.DocumentType.html` ã‚ˆã‚Šã‚‚é«˜é€Ÿã§å®‰å®šã—ã¦ã„ã¾ã™ãŒã€ã¾ã å¤šãã®æ”¹å–„ä½™åœ°ãŒã‚ã‚Šã¾ã™ã€‚ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¯ XMLParser ã«ã¯åŠã°ãªã„ã¨è€ƒãˆã¦ãŠã‚Šã€ã„ã¤ã‹åŒç­‰ã®æ€§èƒ½ã‚’æŒã¡ãªãŒã‚‰ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæ€§ã¨è‡ªå‹•ä¿®æ­£ã®è€éšœå®³æ€§ã‚‚ç¶­æŒã§ãã‚‹ã“ã¨ã‚’æœŸå¾…ã—ã¦ã„ã¾ã™ã€‚

2. ã‚ˆã‚Šå¤šãã®HTMLã‚¿ã‚°ã¨ã‚¹ã‚¿ã‚¤ãƒ«å±æ€§ã®å¤‰æ›è§£æã‚’ã‚µãƒãƒ¼ãƒˆ

3. [ZNSTextAttachment](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"} ã‚’ã•ã‚‰ã«æœ€é©åŒ–ã—ã€å†åˆ©ç”¨å¯èƒ½ã«ã—ã¦ãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾ã™ã‚‹ï¼›CoreTextã®ç ”ç©¶ãŒå¿…è¦ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“

4. Markdown è§£æã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚åŸºç›¤ã®æŠ½è±¡åŒ–ã«ã‚ˆã‚Š HTML ã«é™å®šã•ã‚Œãªã„ãŸã‚ã€å‰æ®µéšã§ Markdown ã‚’ Markup ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã§ãã‚Œã° Markdown è§£æãŒå¯èƒ½ã§ã™ã€‚ãã®ãŸã‚ã€åå‰ã‚’ ZHTMLParser ã§ã¯ãªã ZMarkupParser ã¨ã—ã¾ã—ãŸã€‚å°†æ¥çš„ã« Markdown ã‹ã‚‰ NSAttributedString ã¸ã®å¯¾å¿œã‚‚ç›®æŒ‡ã—ã¦ã„ã¾ã™ã€‚

5. Any to Any ã‚’ã‚µãƒãƒ¼ãƒˆã€ä¾‹ï¼šHTML ã‹ã‚‰ Markdownã€Markdown ã‹ã‚‰ HTMLã€‚å…ƒã® AST ãƒ„ãƒªãƒ¼ï¼ˆMarkup ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ãŒã‚ã‚‹ãŸã‚ã€ä»»æ„ã® Markup é–“ã®å¤‰æ›ãŒå¯èƒ½ã§ã™ã€‚

6. css ã® `!important` æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã€æŠ½è±¡ MarkupStyle ã®ç¶™æ‰¿æˆ¦ç•¥ã‚’å¼·åŒ–ã™ã‚‹

7. HTMLã‚»ãƒ¬ã‚¯ã‚¿æ©Ÿèƒ½ã‚’å¼·åŒ–ã—ã¾ã—ãŸã€‚ç¾åœ¨ã¯æœ€ã‚‚åŸºæœ¬çš„ãªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ã®ã¿ã§ã™ã€‚

8. ãŸãã•ã‚“ã®ã”æ„è¦‹ãŠå¾…ã¡ã—ã¦ãŠã‚Šã¾ã™ã€‚[issue](https://github.com/ZhgChgLi/ZMarkupParser/issues){:target="_blank"}ã‚’é–‹ã„ã¦ãã ã•ã„ã€‚

> [ã‚‚ã—ã”æ”¯æ´ã„ãŸã ã‘ã‚‹ãªã‚‰ã€â­ã‚’æŠ¼ã—ã¦ã„ãŸã ãã“ã¨ã§ãƒªãƒã‚¸ãƒˆãƒªãŒã‚ˆã‚Šå¤šãã®äººã«è¦‹ã‚‰ã‚Œã€GitHubã®é”äººãŸã¡ãŒå”åŠ›ã—ã¦ãã‚Œã‚‹å¯èƒ½æ€§ãŒé«˜ã¾ã‚Šã¾ã™ï¼](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

### ã¾ã¨ã‚

![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*A0yXupXW9-F9ZWe4gp2ObA.jpeg)

[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

ä»¥ä¸ŠãŒç§ãŒé–‹ç™ºã—ãŸ ZMarkupParser ã®ã™ã¹ã¦ã®æŠ€è¡“çš„è©³ç´°ã¨çµŒç·¯ã§ã™ã€‚ç´„3ãƒ¶æœˆã®ä»•äº‹çµ‚ã‚ã‚Šã‚„ä¼‘æ—¥ã®æ™‚é–“ã‚’è²»ã‚„ã—ã€æ•°ãˆåˆ‡ã‚Œãªã„ã»ã©ã®ç ”ç©¶ã¨å®Ÿè·µã‚’é‡ã­ã€ãƒ†ã‚¹ãƒˆä½œæˆã‚„ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®å‘ä¸Šã€CIã®æ§‹ç¯‰ã¾ã§è¡Œã„ã¾ã—ãŸã€‚ã‚ˆã†ã‚„ããã‚Œãªã‚Šã®æˆæœãŒå¾—ã‚‰ã‚Œã¾ã—ãŸã€‚ã“ã®ãƒ„ãƒ¼ãƒ«ãŒåŒã˜æ‚©ã¿ã‚’æŒã¤æ–¹ã€…ã®åŠ©ã‘ã«ãªã‚Œã°å¹¸ã„ã§ã™ã—ã€çš†ã•ã‚“ã¨ä¸€ç·’ã«ã“ã®ãƒ„ãƒ¼ãƒ«ã‚’ã‚ˆã‚Šè‰¯ãã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚

![[pinkoi.com](https://www.pinkoi.com){:target="_blank"}](/assets/2724f02f6e7/0*9YdJaNSQXlAfmT21.jpg)

[pinkoi.com](https://www.pinkoi.com){:target="_blank"}

ç¾åœ¨ã€å¼Šç¤¾ã® [pinkoi.com](https://www.pinkoi.com){:target="_blank"} ã® iOS ã‚¢ãƒ—ãƒªã§ä½¿ç”¨ã—ã¦ãŠã‚Šã€å•é¡Œã¯ç™ºç”Ÿã—ã¦ã„ã¾ã›ã‚“ã€‚ğŸ˜„

#### é–¢é€£è¨˜äº‹

- [ZMarkupParser HTMLæ–‡å­—åˆ—ã‚’NSAttributedStringã«å¤‰æ›ã™ã‚‹ãƒ„ãƒ¼ãƒ«](../a5643de271e4/)

- [String Rendering](https://www.objc.io/issues/9-strings/string-rendering/){:target="_blank"}

- [éåŒæœŸ NSTextAttachments](https://www.cocoanetics.com/2016/09/asynchronous-nstextattachment-1/){:target="_blank"}

ã”è³ªå•ã‚„ã”æ„è¦‹ãŒã‚ã‚Šã¾ã—ãŸã‚‰ã€[ã“ã¡ã‚‰ã‹ã‚‰ã”é€£çµ¡ãã ã•ã„](https://www.zhgchg.li/contact){:target="_blank"} ã€‚

*[Post](https://medium.com/zrealm-ios-dev/%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0-html-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B-2724f02f6e7){:target="_blank"} Mediumã‹ã‚‰[ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}ã§å¤‰æ›ã€‚*