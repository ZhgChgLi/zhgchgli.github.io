---
title: è‡ªè¡Œå¯¦ç¾ iOS NSAttributedString HTML Render
author: ZhgChgLi
date: 2022-06-09T16:11:59.122Z
categories: ZRealm Dev.
tags: [ios-app-development,nsattributedstring,html-parsing,html,markdown]
---

### è‡ªè¡Œå¯¦ç¾ iOS NSAttributedString HTML Render

iOS NSAttributedString DocumentType.html çš„æ›¿ä»£æ–¹æ¡ˆ

![Photo by Florian Olivo](/assets/a8c2d26cc734/1*l93Ay_tGXTRvwS7ofgt5og.jpeg "Photo by Florian Olivo")
Photo by [Florian Olivo](https://unsplash.com/@florianolv?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
### èµ·æº

å¾å»å¹´ iOS 15 ç™¼ä½ˆä»¥ä¾†ï¼ŒApp å§‹çµ‚è¢«ä¸€é … Crash å•é¡Œé•·å¹´éœ¸æ¦œï¼Œå¾æ•¸æ“šä¾†çœ‹ï¼Œè¿‘ 90 å¤© (2022/03/11~2022/06/08) ä¸€å…±é€ æˆ 2.4K+ æ¬¡é–ƒé€€ã€å½±éŸ¿ 1.4K+ ä½ä½¿ç”¨è€…ã€‚

![](/assets/a8c2d26cc734/1*r--z0J1P6t5ECfVyb5_OxQ.png)
> æ­¤å¤§é‡é–ƒé€€å•é¡Œå¾æ•¸æ“šä¸Šçœ‹ï¼Œå®˜æ–¹æ‡‰è©²å·²åœ¨ iOS â‰¥ 15.2 å¾ŒçºŒçš„ç‰ˆæœ¬ä¿®å¾©(æˆ–æ¸›å°‘ç™¼ç”Ÿæ©Ÿç‡)ï¼Œæ•¸æ“šå·²å‘ˆç¾è¶¨å‹¢ä¸‹é™ã€‚


**æœ€å¤§å®—å—å½±éŸ¿ç‰ˆæœ¬ï¼š** iOS 15.0.X ~ iOS 15.X.X

å¦å¤–æœ‰ç™¼ç¾ iOS 12ã€iOS 13 ä¹Ÿæœ‰é›¶æ˜Ÿé–ƒé€€æ•¸ï¼Œæ‰€ä»¥æ­¤å•é¡Œæ‡‰è©²å·²å­˜åœ¨è¨±ä¹…ï¼Œåªæ˜¯ iOS 15 å‰å¹¾ç‰ˆç™¼ç”Ÿçš„æ©Ÿç‡å¹¾ä¹æ˜¯ 100%ã€‚
#### é–ƒé€€åŸå› ï¼š

![](/assets/a8c2d26cc734/1*vKmvralAmDrhWrXYLHpspw.png)
```
<compiler-generated> line 2147483647 specialized @nonobjc NSAttributedString.init(data:options:documentAttributes:)
```

NSAttributedString åœ¨ init æ™‚ç™¼ç”Ÿ `Crashed: com.apple.main-thread EXC_BREAKPOINT 0x00000001de9d4e44` é–ƒé€€å•é¡Œã€‚
> äº¦æœ‰å¯èƒ½æ˜¯æ“ä½œçš„åœ°æ–¹ä¸åœ¨ Main Thread.

#### é‡ç¾æ–¹å¼ï¼š

æ­¤å•é¡Œå¤§é‡æ©«ç©ºå‡ºä¸–æ™‚ï¼Œè®“é–‹ç™¼åœ˜éšŠæƒ³ç ´è…¦è¢‹ï¼›è¤‡æ¸¬ Crash Log ä¸Šçš„é»éƒ½æ²’å•é¡Œï¼Œä¸æ¸…æ¥šä½¿ç”¨è€…æ˜¯åœ¨ä»€éº¼æƒ…æ³ä¸‹ç™¼ç”Ÿçš„ï¼›ç›´åˆ°æœ‰ä¸€æ¬¡å› ç·£å·§åˆä¸‹æˆ‘å‰›å¥½åˆ‡æ›æˆã€Œçœé›»æ¨¡å¼ã€ç„¶å¾Œå°±è§¸ç™¼å•é¡Œäº†!! **WTF !!!**

![](/assets/a8c2d26cc734/1*gVfmnCN7QcHO90Y7HyntbA.gif)
### è§£ç­”

ç¶“éä¸€ç•ªæœç´¢ç™¼ç¾ç¶²è·¯ä¸Šæœ‰è¨±å¤šç›¸åŒæ¡ˆä¾‹ï¼Œä¹Ÿå¾ App Developer Forums æ‰¾åˆ°æœ€æ—©çš„ç›¸åŒ [é–ƒé€€å•é¡Œæå•](https://developer.apple.com/forums/thread/115405) ï¼Œä¸¦ç²å¾—ä¾†è‡ª **å®˜æ–¹** çš„å›ç­”ï¼š

![](/assets/a8c2d26cc734/1*XmZuJf4Rtk4chiBx8_yMXw.png)
- é€™æ˜¯å·²çŸ¥çš„ iOS Foundation Bugï¼šè‡ª iOS 12 å°±å·²å­˜åœ¨
- å¦‚è¦æ¸²æŸ“è¤‡é›œçš„ã€ç„¡ä½¿ç”¨ä¸Šç´„æŸçš„ HTMLï¼šè«‹ä½¿ç”¨ WKWebView
- **æœ‰æ¸²æŸ“ç´„æŸï¼šå¯è‡ªè¡Œæ’°å¯« HTML Parser & Render**
- ç›´æ¥ä½¿ç”¨ Markdown åšç‚ºæ¸²æŸ“ç´„æŸï¼šiOS â‰¥ 15 NSAttributedString å¯ [ç›´æ¥ä½¿ç”¨ Markdown æ ¼å¼æ¸²æŸ“æ–‡å­—](https://developer.apple.com/documentation/foundation/nsattributedstring/3796598-init)

> **æ¸²æŸ“ç´„æŸ** çš„æ„æ€æ˜¯é™å®š App ç«¯èƒ½æ”¯æ´çš„æ¸²æŸ“æ ¼å¼ï¼Œä¾‹å¦‚åªæ”¯æ´ **ç²—é«”** ã€æ–œé«”ã€ [è¶…é€£çµ](https://zhgchg.li) ã€‚

#### è£œå……. æ¸²æŸ“è¤‡é›œçš„ HTML â€” æƒ³è£½ä½œæ–‡é¥’åœ–æ•ˆæœ

å¯èˆ‡å¾Œç«¯å…±åŒå”èª¿ã„§å€‹ä»‹é¢ï¼š
```json
{
  "content":[
    {"type":"text","value":"ç¬¬1æ®µç´”æ–‡å­—"},
    {"type":"text","value":"ç¬¬2æ®µç´”æ–‡å­—"},
    {"type":"text","value":"ç¬¬3æ®µç´”æ–‡å­—"},
    {"type":"text","value":"ç¬¬4æ®µç´”æ–‡å­—"},
    {"type":"image","src":"https://zhgchg.li/logo.png","title":"ZhgChgLi"},
    {"type":"text","value":"ç¬¬5æ®µç´”æ–‡å­—"}
  ]
}
```

å¯èˆ‡ Markdown çµ„åˆåŠ ä¸Šæ”¯æ´æ–‡å­—æ¸²æŸ“ï¼Œæˆ–åƒè€ƒ Medium åšæ³•ï¼š
```json
"Paragraph": {
    "text": "code in text, and link in text, and ZhgChgLi, and bold, and I, only i",
    "markups": [
      {
        "type": "CODE",
        "start": 5,
        "end": 7
      },
      {
        "start": 18,
        "end": 22,
        "href": "http://zhgchg.li",
        "type": "LINK"
      },
      {
        "type": "STRONG",
        "start": 50,
        "end": 63
      },
      {
        "type": "EM",
        "start": 55,
        "end": 69
      }
    ]
}
```

æ„æ€æ˜¯ `code in text, and link in text, and ZhgChgLi, and bold, and I, only i` é€™æ®µæ–‡å­—çš„:
```
- ç¬¬ 5 åˆ°ç¬¬ 7 å­—å…ƒè¦æ¨™ç¤ºç‚º ç¨‹å¼ç¢¼ (ç”¨`Text`æ ¼å¼åŒ…è£)
- ç¬¬ 18 åˆ°ç¬¬ 22 å­—å…ƒè¦æ¨™ç¤ºç‚º é€£çµ (ç”¨[Text](URL)æ ¼å¼åŒ…è£)
- ç¬¬ 50 åˆ°ç¬¬ 63 å­—å…ƒè¦æ¨™ç¤ºç‚º ç²—é«”(ç”¨*Text*æ ¼å¼åŒ…è£)
- ç¬¬ 55 åˆ°ç¬¬ 69 å­—å…ƒè¦æ¨™ç¤ºç‚º æ–œé«”(ç”¨_Text_æ ¼å¼åŒ…è£)
```

æœ‰è¦ç¯„ï¼†å¯æè¿°çš„çµæ§‹å¾Œï¼ŒApp å°±èƒ½è‡ªè¡Œä½¿ç”¨åŸç”Ÿæ–¹å¼æ¸²æŸ“ï¼Œé”åˆ°æ•ˆèƒ½ã€ä½¿ç”¨é«”é©—æœ€ä½³åŒ–ã€‚
> UITextView åšæ–‡é¥’åœ–çš„å‘ï¼Œå¯åƒè€ƒæˆ‘ä¹‹å‰çš„æ–‡ç« ï¼š [iOS UITextView æ–‡ç¹åœ–ç·¨è¼¯å™¨ (Swift)](../e37d66ea1146)

### Why?

åœ¨å¯¦è¸è§£ç­”ä¹‹å‰æˆ‘å€‘å…ˆå›æ­¸æ¢ç©¶å•é¡Œæœ¬èº«ï¼Œå€‹äººèªç‚ºé€™å€‹å•é¡Œä¸»å› ä¸¦éä¾†è‡ª Appleï¼Œå®˜æ–¹çš„ Bug åªæ˜¯é€™å€‹å•é¡Œçš„å¼•çˆ†é»ã€‚

å•é¡Œä¸»è¦ä¾†è‡ª **App ç«¯è¢«ç•¶æˆ Web ä¾†é€²è¡Œæ¸²æŸ“** ï¼Œå„ªé»æ˜¯ Web é–‹ç™¼å¿«é€Ÿï¼ŒåŒå€‹ API Endpoint å¯ä»¥ä¸ç”¨å€åˆ† Client éƒ½çµ¦ HTMLã€å¯ä»¥å½ˆæ€§æ¸²æŸ“ä»»ä½•æƒ³å‘ˆç¾çš„å…§å®¹ï¼›ç¼ºé»æ˜¯ HTML ä¸¦é App çš„å¸¸è¦‹æ¥å£ã€ä¸èƒ½æœŸæœ› App Engineer æ‡‚ HTMLã€ **æ•ˆèƒ½æ¥µå·®** ã€åªèƒ½åœ¨ Main Threadã€é–‹ç™¼éšæ®µç„¡æ³•é æœŸçµæœã€ç„¡æ³•ç¢ºèªæ”¯æ´è¦æ ¼ã€‚

å†å¾€ä¸Šæ‰¾å•é¡Œï¼Œå¤šåŠæ˜¯åŸå§‹éœ€æ±‚ç„¡æ³•ç¢ºå®šã€ä¸èƒ½ç¢ºå®š App éœ€è¦æ”¯æ´å“ªäº›è¦æ ¼ã€ç‚ºäº†æ±‚å¿«ï¼Œæ‰å°è‡´ç›´æ¥ä½¿ç”¨ HTML åšç‚º App èˆ‡ Web çš„æ¥å£ã€‚
#### **æ•ˆèƒ½æ¥µå·®**

è£œå……æ•ˆèƒ½éƒ¨åˆ†ï¼Œå¯¦æ¸¬ç›´æ¥ä½¿ç”¨ `NSAttributedString DocumentType.html` èˆ‡è‡ªè¡Œå¯¦ç¾æ¸²æŸ“çš„æ–¹å¼æœ‰ 5~20 å€çš„é€Ÿåº¦å·®è·ã€‚
#### Better

æ—¢ç„¶æ˜¯ App è¦ç”¨ï¼Œæ›´å¥½çš„åšæ³•è¦ä»¥ App é–‹ç™¼æ–¹å¼ç‚ºå‡ºç™¼é»ï¼Œå° App ä¾†èªªéœ€æ±‚çš„èª¿æ•´æˆæœ¬æ¯” Web é«˜å¾ˆå¤šï¼›æœ‰æ•ˆçš„ App é–‹ç™¼æ‡‰è©²è¦åŸºæ–¼æœ‰è¦æ ¼çš„è¿­ä»£èª¿æ•´ï¼Œç•¶ä¸‹éœ€è¦ç¢ºå®šèƒ½æ”¯æ´çš„è¦æ ¼ï¼Œä¹‹å¾Œå¦‚æœè¦æ”¹æˆ‘å€‘å°±å®‰æ’æ™‚é–“æ“´å……è¦æ ¼ï¼Œç„¡æ³•å¿«é€Ÿçš„æƒ³æ”¹å°±æ”¹ï¼Œå¯ä»¥æ¸›å°‘æºé€šæˆæœ¬ã€å¢åŠ å·¥ä½œæ•ˆç‡ã€‚
- ç¢ºèªéœ€æ±‚ç¯„åœ
- ç¢ºèªæ”¯æ´çš„è¦æ ¼
- ç¢ºèªæ¥å£è¦ç¯„ (Markdown/BBCode/â€¦è¦ç¹¼çºŒç”¨ HTML ä¹Ÿè¡Œï¼Œä½†è¦æ˜¯æœ‰ç´„æŸçš„ï¼Œä¾‹å¦‚åªç”¨ `<b>/<i>/<a>/<u>` ï¼Œè¦åœ¨ç¨‹å¼ **æ˜ç¢ºå‘ŠçŸ¥** é–‹ç™¼è€…)
- è‡ªè¡Œå¯¦ç¾æ¸²æŸ“æ©Ÿåˆ¶
- ç¶­è­·ã€è¿­ä»£æ”¯æ´è¦æ ¼

### How?

æœ¨å·²æˆèˆŸï¼Œå›æ­¸æ­£é¡Œï¼Œç›®å‰å·²ç”¨ HTML åœ¨æ¸²æŸ“ `NSAttributedString` é‚£æˆ‘å€‘è©²å¦‚ä½•è§£æ±ºä¸Šè¿°çš„é–ƒé€€é‚„æœ‰æ•ˆèƒ½å•é¡Œå‘¢ï¼Ÿ
#### Inspired by

[GitHub \- malcommac/SwiftRichString: ğŸ‘©â€ğŸ¨ Elegant Attributed String composition in Swift sauce
Elegant Attributed String composition in Swift sauce SwiftRichString is a lightweight library which allows to createâ€¦github\.com](https://github.com/malcommac/SwiftRichString)
### Strip HTML å»é™¤ HTML

åœ¨è«‡ HTML Render ä¹‹å‰å…ˆè«‡ Strip HTMLï¼Œé‚„æ˜¯å†æä¸€æ¬¡å‰æ–‡ `Why?` ç« ç¯€æ‰€èªªçš„ï¼ŒApp å“ªè£¡æœƒæ‹¿åˆ° HTMLã€æœƒæ‹¿åˆ°å“ªäº› HTML æ‡‰è©²è¦åœ¨è¦æ ¼å”å®šå¥½ï¼›è€Œä¸æ˜¯ App é€™é‚Šã€Œ **å¯èƒ½** ã€æœƒæ‹¿åˆ° HTMLï¼Œéœ€è¦ Strip æ‰ã€‚
> å¥—å¥ä¹‹å‰ä¸»ç®¡çš„åè¨€ï¼šé€™æ¨£å¤ªç˜‹äº†å§ï¼Ÿ

#### Option 1. NSAttributedString
```
let data = "<div>Text</div>".data(using: .unicode)!
let attributed = try NSAttributedString(data: data, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue], documentAttributes: nil)
let string = attributed.string
```
- ä½¿ç”¨ NSAttributedString Render HTML ç„¶å¾Œå†å– string å‡ºä¾†å°±æœƒæ˜¯ä¹¾æ·¨çš„ String äº†
- å•é¡ŒåŒæœ¬ç« å•é¡Œï¼ŒiOS 15 å®¹æ˜“é–ƒé€€ã€æ•ˆèƒ½ä¸å¥½ã€åªèƒ½åœ¨ Main Thread æ“ä½œ

#### Option 2. Regex
```
htmlString = "<div>Test</div>"
htmlString.replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression, range: nil)
```
- æœ€ç°¡å–®æœ‰æ•ˆçš„æ–¹å¼
- Regex ä¸¦ä¸èƒ½ä¿è­‰å®Œå…¨æ­£ç¢º e.g `<p foo=">now what?">Paragraph</p>` æ˜¯åˆæ³•çš„ HTML ä½†æœƒ Strip éŒ¯èª¤

#### Option 3. XMLParser

åƒè€ƒ [SwiftRichString](https://github.com/malcommac/SwiftRichString) çš„åšæ³•ï¼Œä½¿ç”¨ Foundation ä¸­çš„ **[XMLParser](https://developer.apple.com/documentation/foundation/xmlparser)** å°‡ HTML åšç‚º XML è§£æè‡ªè¡Œå¯¦ç¾ HTML Parser & Strip åŠŸèƒ½ã€‚
```swift
import UIKit
// Ref: https://github.com/malcommac/SwiftRichString
final class HTMLStripper: NSObject, XMLParserDelegate {

    private static let topTag = "source"
    private var xmlParser: XMLParser
    
    private(set) var storedString: String
    
    // The XML parser sometimes splits strings, which can break localization-sensitive
    // string transforms. Work around this by using the currentString variable to
    // accumulate partial strings, and then reading them back out as a single string
    // when the current element ends, or when a new one is started.
    private var currentString: String?
    
    // MARK: - Initialization

    init(string: String) throws {
        let xmlString = HTMLStripper.escapeWithUnicodeEntities(string)
        let xml = "<\(HTMLStripper.topTag)>\(xmlString)</\(HTMLStripper.topTag)>"
        guard let data = xml.data(using: String.Encoding.utf8) else {
            throw XMLParserInitError("Unable to convert to UTF8")
        }
        
        self.xmlParser = XMLParser(data: data)
        self.storedString = ""
        
        super.init()
        
        xmlParser.shouldProcessNamespaces = false
        xmlParser.shouldReportNamespacePrefixes = false
        xmlParser.shouldResolveExternalEntities = false
        xmlParser.delegate = self
    }
    
    /// Parse and generate attributed string.
    func parse() throws -> String {
        guard xmlParser.parse() else {
            let line = xmlParser.lineNumber
            let shiftColumn = (line == 1)
            let shiftSize = HTMLStripper.topTag.lengthOfBytes(using: String.Encoding.utf8) + 2
            let column = xmlParser.columnNumber - (shiftColumn ? shiftSize : 0)
            
            throw XMLParserError(parserError: xmlParser.parserError, line: line, column: column)
        }
        
        return storedString
    }
    
    // MARK: XMLParserDelegate
    
    @objc func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String: String]) {
        foundNewString()
    }
    
    @objc func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) {
        foundNewString()
    }
    
    @objc func parser(_ parser: XMLParser, foundCharacters string: String) {
        currentString = (currentString ?? "").appending(string)
    }
    
    // MARK: Support Private Methods
    
    func foundNewString() {
        if let currentString = currentString {
            storedString.append(currentString)
            self.currentString = nil
        }
    }
    
    // handle html entity / html hex
    // Perform string escaping to replace all characters which is not supported by NSXMLParser
    // into the specified encoding with decimal entity.
    // For example if your string contains '&' character parser will break the style.
    // This option is active by default.
    // ref: https://github.com/malcommac/SwiftRichString/blob/e0b72d5c96968d7802856d2be096202c9798e8d1/Sources/SwiftRichString/Support/XMLStringBuilder.swift
    static func escapeWithUnicodeEntities(_ string: String) -> String {
        guard let escapeAmpRegExp = try? NSRegularExpression(pattern: "&(?!(#[0-9]{2,4}|[A-z]{2,6});)", options: NSRegularExpression.Options(rawValue: 0)) else {
            return string
        }
        
        let range = NSRange(location: 0, length: string.count)
        return escapeAmpRegExp.stringByReplacingMatches(in: string,
                                                        options: NSRegularExpression.MatchingOptions(rawValue: 0),
                                                        range: range,
                                                        withTemplate: "&amp;")
    }
}


let test = "æˆ‘<br/><a href=\"http://google.com\">åŒæ„</a>æä¾›<b><i>å€‹</i>äºº</b>èº«åˆ†è­‰å­—è™Ÿï¼è­·ç…§ï¼å±…ç•™<span style=\"color:#FF0000;font-size:20px;word-spacing:10px;line-height:10px\">è­‰è™Ÿç¢¼</span>ï¼Œä»¥ä¾›<i>è·¨å¢ƒç‰©æµ</i>æ–¹é€šé—œ<span style=\"background-color:#00FF00;\">ä½¿ç”¨</span>ï¼Œä¸¦å·²<img src=\"g.png\"/>äº†è§£è·¨å¢ƒ<br/>å•†å“ä¹‹ç‰©<p>æµéœ€</p>æ±‚"

let stripper = try HTMLStripper(string: test)
print(try! stripper.parse())

// æˆ‘åŒæ„æä¾›å€‹äººèº«åˆ†è­‰ å­—è™Ÿï¼è­·ç…§ï¼å±…ç•™è­‰è™Ÿç¢¼ï¼Œä»¥ä¾›è·¨å¢ƒç‰©æµæ–¹é€šé—œä½¿ç”¨ï¼Œä¸¦å·²äº†è§£è·¨å¢ƒå•†å“ä¹‹ç‰©æµéœ€æ±‚

```

ä½¿ç”¨ Foundation XML Parser å»è™•ç† Stringï¼Œå¯¦ç¾ **`XMLParserDelegate`** ç”¨ `currentString` å­˜æ”¾ Stringï¼Œå›  String æœ‰æ™‚æœƒæ‹†æˆå¤šå€‹ String æ‰€ä»¥ `foundCharacters` æ˜¯æœ‰æ©Ÿæœƒè¢«é‡è¤‡å‘¼å«çš„ï¼Œ `didStartElement` ã€ `didEndElement` æ‰¾åˆ°å­—ä¸²é–‹å§‹æ™‚ã€çµæŸæ™‚ï¼Œå°‡ç•¶å‰çµæœå­˜ä¸‹ä¸¦æ¸…ç©º `currentString` ã€‚
- å„ªé»æ˜¯æœƒé€£å¸¶è½‰æ› HTML Entity to å¯¦éš›å­—å…ƒ e.g. `&#103; -> g`
- å„ªé»æ˜¯å¯¦ç¾è¤‡é›œã€é‡åˆ°ä¸åˆè¦æ ¼çš„ HTML æœƒ XMLParser å¤±æ•— e.g. `<br> å¿˜äº†å¯«æˆ <br/>`

> å€‹äººèªç‚ºå–®ç´”è¦ Strip HTML **Option 2. æ˜¯æ¯”è¼ƒå¥½çš„æ–¹æ³•** ï¼Œæœƒä»‹ç´¹æ­¤æ–¹æ³•æ˜¯å› ç‚º Render HTML ä¹Ÿæ˜¯ä½¿ç”¨ç›¸åŒåŸç†ï¼Œå…ˆç”¨é€™å€‹åšç‚ºç°¡å–®ç¯„ä¾‹ :)

### HTML Render
#### option1. SwiftSoup

[GitHub \- scinfu/SwiftSoup: SwiftSoup: Pure Swift HTML Parser, with best of DOM, CSS, and jqueryâ€¦
SwiftSoup: Pure Swift HTML Parser, with best of DOM, CSS, and jquery \(Supports Linux, iOS, Mac, tvOS, watchOS\) \- GitHubâ€¦github\.com](https://github.com/scinfu/SwiftSoup)

ç¾æˆå®Œæ•´è§£æ±ºæ–¹æ¡ˆï¼Œå¯ç›´æ¥æ¡ç”¨ã€‚

è¿½ SourceCode ä½œè€…æ˜¯è‡ªè¡Œå¯¦ç¾ HTML Parser ( [Tokenization](https://www.w3.org/TR/2011/WD-html5-20110113/tokenization.html#tokenization) )ï¼Œä¸¦çµ„åˆå‡ºæ¸²æŸ“çµæœã€‚
#### option2. XMLParser

ä½¿ç”¨ XMLParser è‡ªè¡Œå¯¦ç¾ï¼ŒåŒ Strip åŸç†ï¼Œæˆ‘å€‘å¯ä»¥å¤šåŠ ä¸Šå‰–æåˆ°ä»€éº¼ Tag æ™‚è¦åšå°æ‡‰çš„æ¸²æŸ“æ–¹å¼ã€‚

éœ€æ±‚è¦æ ¼ï¼š
- æ”¯æ´æ“´å……æƒ³å‰–æçš„ Tag
- æ”¯æ´è¨­å®š Tag Default Style e.g <a> Tag å¥—ç”¨é€£çµæ¨£å¼
- æ”¯æ´å‰–æ `style` Attributedï¼Œå›  HTML æœƒåœ¨ `style="color:red"` ä¸Šå»æ˜ç¤ºè¦é¡¯ç¤ºçš„æ¨£å¼
- æ¨£å¼æ”¯æ´æ›´æ”¹æ–‡å­—ç²—ç´°ã€å¤§å°ã€åº•ç·šã€è¡Œè·ã€å­—è·ã€èƒŒæ™¯é¡è‰²ã€å­—é¡è‰²
- ä¸æ”¯æ´ Image Tagã€Table Tagâ€¦ç­‰è¼ƒè¤‡é›œ TAG

> å¤§å®¶å¯ä¾ç…§è‡ªå·±çš„è¦æ ¼éœ€æ±‚å»åˆªæ¸›åŠŸèƒ½ï¼Œä¾‹å¦‚ä¸éœ€æ”¯æ´èƒŒæ™¯é¡è‰²èª¿æ•´ï¼Œå‰‡ä¸éœ€è¦é–‹å‡ºå¯è¨­å®šèƒŒæ™¯é¡è‰²çš„å£ã€‚
> æœ¬æ–‡åªæ˜¯æ¦‚å¿µå¯¦ç¾ï¼Œ **ä¸¦éæ¶æ§‹ä¸Šçš„ Best Practice** ï¼›å¦‚æœ‰æ˜ç¢ºè¦æ ¼ã€ä½¿ç”¨æ–¹å¼ï¼Œå¯è€ƒæ…®å¥—ç”¨äº› Design Pattern ä¾†å¯¦ç¾ï¼Œé”æˆå¥½ç¶­è­·å¥½æ“´å……ã€‚

### âš ï¸âš ï¸âš ï¸ Attention âš ï¸âš ï¸âš ï¸

å†æ¬¡æé†’ï¼Œ **å¦‚æœä½ çš„ App æ˜¯å…¨æ–°çš„æˆ–æœ‰æ©Ÿæœƒç›´æ¥å…¨æ”¹æˆ Markdown æ ¼å¼ï¼Œå»ºè­°é‚„æ˜¯æ¡ç”¨ä»¥ä¸Šæ–¹å¼ï¼Œæœ¬ç¯‡è‡ªè¡Œæ’°å¯« Render å¤ªè¤‡é›œä¸”æ•ˆèƒ½ä¸æœƒæ¯” Markdown å¥½** ã€‚
> å³ä½¿ä½ æ˜¯ iOS < 15 ä¸æ”¯æ´åŸç”Ÿ Markdownï¼Œé‚„æ˜¯å¯ä»¥åœ¨ Github ä¸Šæ‰¾åˆ° [å¤§ç¥åšå¥½çš„ Markdown Parser æ–¹æ¡ˆ](https://github.com/chockenberry/MarkdownAttributedString) ã€‚

#### HTMLTagParser
```swift
protocol HTMLTagParser {
    static var tag: String { get } // å®£å‘Šæƒ³è§£æçš„ Tag Name, e.g. a
    var storedHTMLAttributes: [String: String]? { get set } // Attributed è§£æçµæœå°‡å­˜æ”¾æ–¼æ­¤, e.g. href,style
    var style: AttributedStringStyle? { get } // æ­¤ Tag æƒ³å¥—ç”¨çš„æ¨£å¼
    
    func render(attributedString: inout NSMutableAttributedString) // å¯¦ç¾æ¸²æŸ“ HTML to attributedString çš„é‚è¼¯
}

```

å®£å‘Šå¯å‰–æçš„ HTML Tag å¯¦é«”ï¼Œæ–¹ä¾¿æ“´å……ç®¡ç†ã€‚
#### AttributedStringStyle
```swift
protocol AttributedStringStyle {
    var font: UIFont? { get set }
    var color: UIColor? { get set }
    var backgroundColor: UIColor? { get set }
    var wordSpacing: CGFloat? { get set }
    var paragraphStyle: NSParagraphStyle? { get set }
    var customs: [NSAttributedString.Key: Any]? { get set } // è¬èƒ½è¨­å®šå£ï¼Œå»ºè­°ç¢ºå®šå¯æ”¯æ´è¦æ ¼å¾Œå°‡å…¶æŠ½è±¡å‡ºä¾†ï¼Œä¸¦é—œé–‰æ­¤é–‹å£
    func render(attributedString: inout NSMutableAttributedString)
}


// abstract implement
extension AttributedStringStyle {
    func render(attributedString: inout NSMutableAttributedString) {
        let range = NSMakeRange(0, attributedString.length)
        if let font = font {
            attributedString.addAttribute(NSAttributedString.Key.font, value: font, range: range)
        }
        if let color = color {
            attributedString.addAttribute(NSAttributedString.Key.foregroundColor, value: color, range: range)
        }
        if let backgroundColor = backgroundColor {
            attributedString.addAttribute(NSAttributedString.Key.backgroundColor, value: backgroundColor, range: range)
        }
        if let wordSpacing = wordSpacing {
            attributedString.addAttribute(NSAttributedString.Key.kern, value: wordSpacing as Any, range: range)
        }
        if let paragraphStyle = paragraphStyle {
            attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: range)
        }
        if let customAttributes = customs {
            attributedString.addAttributes(customAttributes, range: range)
        }
    }
}
```

å®£å‘Š Tag å¯ä¾›è¨­å®šçš„æ¨£å¼ã€‚
#### HTMLStyleAttributedParser
```swift
// only support tag attributed down below
// can set color,font seize,line height,word spacing,background color

enum HTMLStyleAttributedParser: String {
    case color = "color"
    case fontSize = "font-size"
    case lineHeight = "line-height"
    case wordSpacing = "word-spacing"
    case backgroundColor = "background-color"
    
    func render(attributedString: inout NSMutableAttributedString, value: String) -> Bool {
        let range = NSMakeRange(0, attributedString.length)
        switch self {
        case .color:
            if let color = convertToiOSColor(value) {
                attributedString.addAttribute(NSAttributedString.Key.foregroundColor, value: color, range: range)
                return true
            }
        case .backgroundColor:
            if let color = convertToiOSColor(value) {
                attributedString.addAttribute(NSAttributedString.Key.backgroundColor, value: color, range: range)
                return true
            }
        case .fontSize:
            if let size = convertToiOSSize(value) {
                attributedString.addAttribute(NSAttributedString.Key.font, value: UIFont.systemFont(ofSize: CGFloat(size)), range: range)
                return true
            }
        case .lineHeight:
            if let size = convertToiOSSize(value) {
                let paragraphStyle = NSMutableParagraphStyle()
                paragraphStyle.lineSpacing = size
                attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: range)
                return true
            }
        case .wordSpacing:
            if let size = convertToiOSSize(value) {
                attributedString.addAttribute(NSAttributedString.Key.kern, value: size, range: range)
                return true
            }
        }
        
        return false
    }
    
    // convert 36px -> 36
    private func convertToiOSSize(_ string: String) -> CGFloat? {
        guard let regex = try? NSRegularExpression(pattern: "^([0-9]+)"),
              let firstMatch = regex.firstMatch(in: string, options: [], range: NSRange(location: 0, length: string.utf16.count)),
              let range = Range(firstMatch.range, in: string),
              let size = Float(String(string[range])) else {
            return nil
        }
        return CGFloat(size)
    }
    
    // convert html hex color #ffffff to UIKit Color
    private func convertToiOSColor(_ hexString: String) -> UIColor? {
        var cString: String = hexString.trimmingCharacters(in: .whitespacesAndNewlines).uppercased()

        if cString.hasPrefix("#") {
            cString.remove(at: cString.startIndex)
        }

        if (cString.count) != 6 {
            return nil
        }

        var rgbValue: UInt64 = 0
        Scanner(string: cString).scanHexInt64(&rgbValue)

        return UIColor(
            red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0,
            green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0,
            blue: CGFloat(rgbValue & 0x0000FF) / 255.0,
            alpha: CGFloat(1.0)
        )
    }
}
```

å¯¦ç¾ Style Attributed Parser è§£æ `style="color:red;font-size:16px"` ä½† CSS Style æœ‰éå¸¸å¤šå¯è¨­å®šæ¨£å¼ï¼Œæ‰€ä»¥éœ€è¦åˆ—èˆ‰å¯æ”¯æ´ç¯„åœã€‚
```swift
extension HTMLTagParser {

    func render(attributedString: inout NSMutableAttributedString) {
        defaultStyleRender(attributedString: &attributedString)
    }
    
    func defaultStyleRender(attributedString: inout NSMutableAttributedString) {
        // setup default style to NSMutableAttributedString
        style?.render(attributedString: &attributedString)
        
        // setup & override HTML style (style="color:red;background-color:black") to NSMutableAttributedString if is exists
        // any html tag can have style attribute
        if let style = storedHTMLAttributes?["style"] {
            let styles = style.split(separator: ";").map { $0.split(separator: ":") }.filter { $0.count == 2 }
            for style in styles {
                let key = String(style[0])
                let value = String(style[1])
                
                if let styleAttributed = HTMLStyleAttributedParser(rawValue: key), styleAttributed.render(attributedString: &attributedString, value: value) {
                    print("Unsupport style attributed or value[\(key):\(value)]")
                }
            }
        }
    }
}

```

å¥—ç”¨ HTMLStyleAttributedParser & HTMLStyleAttributedParser æŠ½è±¡å¯¦ç¾ã€‚
#### ä¸€äº› Tag Parser & AttributedStringStyle çš„å¯¦ç¾ç¯„ä¾‹
```swift
struct LinkStyle: AttributedStringStyle {
   var font: UIFont? = UIFont.systemFont(ofSize: 14)
   var color: UIColor? = UIColor.blue
   var backgroundColor: UIColor? = nil
   var wordSpacing: CGFloat? = nil
   var paragraphStyle: NSParagraphStyle?
   var customs: [NSAttributedString.Key: Any]? = [.underlineStyle: NSUnderlineStyle.single.rawValue]
}

struct ATagParser: HTMLTagParser {
    // <a></a>
    static let tag: String = "a"
    var storedHTMLAttributes: [String: String]? = nil
    let style: AttributedStringStyle? = LinkStyle()
    
    func render(attributedString: inout NSMutableAttributedString) {
        defaultStyleRender(attributedString: &attributedString)
        if let href = storedHTMLAttributes?["href"], let url = URL(string: href) {
            let range = NSMakeRange(0, attributedString.length)
            attributedString.addAttribute(NSAttributedString.Key.link, value: url, range: range)
        }
    }
}
```
```swift
struct BoldStyle: AttributedStringStyle {
   var font: UIFont? = UIFont.systemFont(ofSize: 14, weight: .bold)
   var color: UIColor? = UIColor.black
   var backgroundColor: UIColor? = nil
   var wordSpacing: CGFloat? = nil
   var paragraphStyle: NSParagraphStyle?
   var customs: [NSAttributedString.Key: Any]? = [.underlineStyle: NSUnderlineStyle.single.rawValue]
}

struct BoldTagParser: HTMLTagParser {
    // <b></b>
    static let tag: String = "b"
    var storedHTMLAttributes: [String: String]? = nil
    let style: AttributedStringStyle? = BoldStyle()
}
```
```swift
struct SpanTagParser: HTMLTagParser {
    // <span></span>
    static let tag: String = "span"
    var storedHTMLAttributes: [String: String]? = nil
    var style: AttributedStringStyle? = DefaultTextStyle()
}
```
#### HTMLToAttributedStringParser: XMLParserDelegate æ ¸å¿ƒå¯¦ç¾
```swift
// Ref: https://github.com/malcommac/SwiftRichString
final class HTMLToAttributedStringParser: NSObject {
    
    private static let topTag = "source"
    private var xmlParser: XMLParser?
    
    private(set) var attributedString: NSMutableAttributedString = NSMutableAttributedString()
    private(set) var supportedTagRenders: [HTMLTagParser] = []
    private let defaultStyle: AttributedStringStyle
    
    /// Styles applied at each fragment.
    private var renderingTagRenders: [HTMLTagParser] = []

    // The XML parser sometimes splits strings, which can break localization-sensitive
    // string transforms. Work around this by using the currentString variable to
    // accumulate partial strings, and then reading them back out as a single string
    // when the current element ends, or when a new one is started.
    private var currentString: String?
    
    // MARK: - Initialization

    init(defaultStyle: AttributedStringStyle) {
        self.defaultStyle = defaultStyle
        super.init()
    }
    
    func register(_ tagRender: HTMLTagParser) {
        if let index = supportedTagRenders.firstIndex(where: { type(of: $0).tag == type(of: tagRender).tag }) {
            supportedTagRenders.remove(at: index)
        }
        supportedTagRenders.append(tagRender)
    }
    
    /// Parse and generate attributed string.
    func parse(string: String) throws -> NSAttributedString {
        var xmlString = HTMLToAttributedStringParser.escapeWithUnicodeEntities(string)
        
        // make sure <br/> format is correct XML
        // because Web may use <br> to present <br/>, but <br> is not a vaild XML
        xmlString = xmlString.replacingOccurrences(of: "<br>", with: "<br/>")
        
        let xml = "<\(HTMLToAttributedStringParser.topTag)>\(xmlString)</\(HTMLToAttributedStringParser.topTag)>"
        guard let data = xml.data(using: String.Encoding.utf8) else {
            throw XMLParserInitError("Unable to convert to UTF8")
        }
        
        let xmlParser = XMLParser(data: data)
        xmlParser.shouldProcessNamespaces = false
        xmlParser.shouldReportNamespacePrefixes = false
        xmlParser.shouldResolveExternalEntities = false
        xmlParser.delegate = self
        self.xmlParser = xmlParser
        
        attributedString = NSMutableAttributedString()
        
        guard xmlParser.parse() else {
            let line = xmlParser.lineNumber
            let shiftColumn = (line == 1)
            let shiftSize = HTMLToAttributedStringParser.topTag.lengthOfBytes(using: String.Encoding.utf8) + 2
            let column = xmlParser.columnNumber - (shiftColumn ? shiftSize : 0)
            
            throw XMLParserError(parserError: xmlParser.parserError, line: line, column: column)
        }
        
        return attributedString
    }
}

// MARK: Private Method

private extension HTMLToAttributedStringParser {
    func enter(element elementName: String, attributes: [String: String]) {
        // elementName = tagName, EX: a,span,div...
        guard elementName != HTMLToAttributedStringParser.topTag else {
            return
        }
        
        if let index = supportedTagRenders.firstIndex(where: { type(of: $0).tag == elementName }) {
            var tagRender = supportedTagRenders[index]
            tagRender.storedHTMLAttributes = attributes
            renderingTagRenders.append(tagRender)
        }
    }
    
    func exit(element elementName: String) {
        if !renderingTagRenders.isEmpty {
            renderingTagRenders.removeLast()
        }
    }
    
    func foundNewString() {
        if let currentString = currentString {
            // currentString != nil ,ex: <i>currentString</i>
            var newAttributedString = NSMutableAttributedString(string: currentString)
            if !renderingTagRenders.isEmpty {
                for (key, tagRender) in renderingTagRenders.enumerated() {
                    // Render Style
                    tagRender.render(attributedString: &newAttributedString)
                    renderingTagRenders[key].storedHTMLAttributes = nil
                }
            } else {
                defaultStyle.render(attributedString: &newAttributedString)
            }
            attributedString.append(newAttributedString)
            self.currentString = nil
        } else {
            // currentString == nil ,ex: <br/>
            var newAttributedString = NSMutableAttributedString()
            for (key, tagRender) in renderingTagRenders.enumerated() {
                // Render Style
                tagRender.render(attributedString: &newAttributedString)
                renderingTagRenders[key].storedHTMLAttributes = nil
            }
            attributedString.append(newAttributedString)
        }
    }
}

// MARK: Helper

extension HTMLToAttributedStringParser {
    // handle html entity / html hex
    // Perform string escaping to replace all characters which is not supported by NSXMLParser
    // into the specified encoding with decimal entity.
    // For example if your string contains '&' character parser will break the style.
    // This option is active by default.
    // ref: https://github.com/malcommac/SwiftRichString/blob/e0b72d5c96968d7802856d2be096202c9798e8d1/Sources/SwiftRichString/Support/XMLStringBuilder.swift
    static func escapeWithUnicodeEntities(_ string: String) -> String {
        guard let escapeAmpRegExp = try? NSRegularExpression(pattern: "&(?!(#[0-9]{2,4}|[A-z]{2,6});)", options: NSRegularExpression.Options(rawValue: 0)) else {
            return string
        }
        
        let range = NSRange(location: 0, length: string.count)
        return escapeAmpRegExp.stringByReplacingMatches(in: string,
                                                        options: NSRegularExpression.MatchingOptions(rawValue: 0),
                                                        range: range,
                                                        withTemplate: "&amp;")
    }
}

// MARK: XMLParserDelegate

extension HTMLToAttributedStringParser: XMLParserDelegate {
    func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String: String]) {
        foundNewString()
        enter(element: elementName, attributes: attributeDict)
    }
    
    func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) {
        foundNewString()
        guard elementName != HTMLToAttributedStringParser.topTag else {
            return
        }
        
        exit(element: elementName)
    }
    
    func parser(_ parser: XMLParser, foundCharacters string: String) {
        currentString = (currentString ?? "").appending(string)
    }
}

```

å¥—ç”¨ Strip çš„é‚è¼¯ï¼Œæˆ‘å€‘å¯ä»¥å¹«æ‹†å¥½çš„æ¶æ§‹åœ¨å…¶ä¸­é€²è¡Œçµ„åˆå¾ `elementName` çŸ¥é“ç•¶å‰çš„ Tag ä¸¦å¥—ç”¨ç›¸æ‡‰çš„ Tag Parser åŠå¥—ä¸Šå®šç¾©å¥½çš„ Styleã€‚
#### Test Result
```swift
let test = "æˆ‘<br/><a href=\"http://google.com\">åŒæ„</a>æä¾›<b><i>å€‹</i>äºº</b>èº«åˆ†è­‰å­—è™Ÿï¼è­·ç…§ï¼å±…ç•™<span style=\"color:#FF0000;font-size:20px;word-spacing:10px;line-height:10px\">è­‰è™Ÿç¢¼</span>ï¼Œä»¥ä¾›<i>è·¨å¢ƒç‰©æµ</i>æ–¹é€šé—œ<span style=\"background-color:#00FF00;\">ä½¿ç”¨</span>ï¼Œä¸¦å·²<img src=\"g.png\"/>äº†è§£è·¨å¢ƒ<br/>å•†å“ä¹‹ç‰©<p>æµéœ€</p>æ±‚"
let render = HTMLToAttributedStringParser(defaultStyle: DefaultTextStyle())
render.register(ATagParser())
render.register(BoldTagParser())
render.register(SpanTagParser())
//...
print(try! render.parse(string: test))

// Result:
// æˆ‘{
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// }åŒæ„{
//     NSColor = "UIExtendedSRGBColorSpace 0 0 1 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSLink = "http://google.com";
//     NSUnderline = 1;
// }æä¾›{
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// }å€‹{
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Bold 14.00 pt. P [] (0x13a013870) fobj=0x13a013870, spc=3.46\"";
//     NSUnderline = 1;
// }äººèº«åˆ†è­‰å­—è™Ÿï¼è­·ç…§ï¼å±…ç•™{
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// }è­‰è™Ÿç¢¼{
//     NSColor = "UIExtendedSRGBColorSpace 1 0 0 1";
//     NSFont = "\".SFNS-Regular 20.00 pt. P [] (0x13a015fa0) fobj=0x13a015fa0, spc=4.82\"";
//     NSKern = 10;
//     NSParagraphStyle = "Alignment 4, LineSpacing 10, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// }ï¼Œä»¥ä¾›è·¨å¢ƒç‰©æµæ–¹é€šé—œ{
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// }ä½¿ç”¨{
//     NSBackgroundColor = "UIExtendedSRGBColorSpace 0 1 0 1";
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// }ï¼Œä¸¦å·²äº†è§£è·¨å¢ƒå•†å“ä¹‹ç‰©æµéœ€æ±‚{
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// }
```

**é¡¯ç¤ºçµæœï¼š**

![](/assets/a8c2d26cc734/1*LaKhRLhHm2jfptG4h_jB5Q.png)
### Done!

é€™æ¨£æˆ‘å€‘å°±å®Œæˆäº†é€é XMLParser è‡ªè¡Œå¯¦ç¾ HTML Render åŠŸèƒ½ï¼Œä¸¦ä¸”ä¿ç•™æ“´å……æ€§è·Ÿè¦æ ¼æ€§ï¼Œå¯ä»¥å¾ Code ä¸Šç®¡ç†ã€äº†è§£åˆ°ç›®å‰ App èƒ½æ”¯æ´çš„å­—ä¸²æ¸²æŸ“é¡å‹ã€‚
### å®Œæ•´ Github Repo å¦‚ä¸‹

[GitHub \- zhgchgli0718/HTMLToAttributedStringRednerExample: just demonstrate, not care aboutâ€¦
You can't perform that action at this time\. You signed in with another tab or window\. You signed out in another tab orâ€¦github\.com](https://github.com/zhgchgli0718/HTMLToAttributedStringRednerExample)
[Like Z Realm's work](https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fbutton.like.co%2Fin%2Fembed%2Fzhgchgli%2Fbutton&display_name=LikeCoin&url=https%3A%2F%2Fbutton.like.co%2Fzhgchgli&image=https%3A%2F%2Fstorage.googleapis.com%2Flikecoin-foundation.appspot.com%2Flikecoin_store_user_zhgchgli_main%3FGoogleAccessId%3Dfirebase-adminsdk-eyzut%2540likecoin-foundation.iam.gserviceaccount.com%26Expires%3D2430432000%26Signature%3DgFRSNto%252BjjxXpRoYyuEMD5Ecm7mLK2uVo1vGz4NinmwLnAK0BGjcfKnItFpt%252BcYurx3wiwKTvrxvU019ruiCeNav7s7QUs5lgDDBc7c6zSVRbgcWhnJoKgReRkRu6Gd93WvGf%252BOdm4FPPgvpaJV9UE7h2MySR6%252B%252F4a%252B4kJCspzCTmLgIewm8W99pSbkX%252BQSlZ4t5Pw22SANS%252BlGl1nBCX48fGg%252Btg0vTghBGrAD2%252FMEXpGNJCdTPx8Gd9urOpqtwV4L1I2e2kYSC4YPDBD6pof1O6fKX%252BI8lGLEYiYP1sthjgf8Y4ZbgQr4Kt%252BRYIicx%252Bg6w3YWTg5zgHxAYhOINXw%253D%253D&key=a19fcc184b9711e1b4764040d3dc5c07&type=text%2Fhtml&schema=like)
> _æœ¬æ–‡åŒæ­¥ç™¼è¡¨æ–¼å€‹äºº Blogï¼š [**[é»æˆ‘å‰å¾€]**](https://zhgchg.li/posts/a8c2d26cc734/) ã€‚_
> _æœ‰ä»»ä½•å•é¡ŒåŠæŒ‡æ•™æ­¡è¿ [èˆ‡æˆ‘è¯çµ¡](https://www.zhgchg.li/contact) ã€‚_



+-----------------------------------------------------------------------------------+

| **[View original post on Medium](https://medium.com/zrealm-ios-dev/%E8%87%AA%E8%A1%8C%E5%AF%A6%E7%8F%BE-ios-nsattributedstring-html-render-a8c2d26cc734) - Converted by [ZhgChgLi](https://zhgchg.li)/[ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown)** |

+-----------------------------------------------------------------------------------+
