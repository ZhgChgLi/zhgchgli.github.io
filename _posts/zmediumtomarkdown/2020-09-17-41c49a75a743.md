---
title: Xcode ç›´æ¥ä½¿ç”¨ Swift æ’°å¯« Run Scriptï¼
author: ZhgChgLi
date: 2020-09-17T15:53:20.026+0000
last_modified_at: 2021-02-24T01:42:15.691+0000
categories: ZRealm Dev.
tags: [ios,shell-script,xcode,ios-app-development,toolkit]
description: å°å…¥ Localization å¤šèªç³»åŠ Image Assets ç¼ºæ¼æª¢æŸ¥ã€ä½¿ç”¨ Swift æ‰“é€  Run Script è…³æœ¬
image:
  path: assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg
render_with_liquid: false
---

### Xcode ç›´æ¥ä½¿ç”¨ Swift æ’°å¯« Shell Scriptï¼

å°å…¥ Localization å¤šèªç³»åŠ Image Assets ç¼ºæ¼æª¢æŸ¥ã€ä½¿ç”¨ Swift æ‰“é€  Shell Script è…³æœ¬


![Photo by [Glenn Carstens\-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg)

Photo by [Glenn Carstens\-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### ç·£ç”±

å› ç‚ºè‡ªå·±æ‰‹æ®˜ï¼Œæ™‚å¸¸åœ¨ç·¨è¼¯å¤šèªç³»æª”æ¡ˆæ™‚éºæ¼ã€Œ;ã€å°è‡´ app build å‡ºä¾†èªè¨€é¡¯ç¤ºå‡ºéŒ¯å†åŠ ä¸Šéš¨è‘—é–‹ç™¼çš„æ¨ç§»èªç³»æª”æ¡ˆè¶Šä¾†è¶Šé¾å¤§ï¼Œé‡è¤‡çš„ã€å·²æ²’ç”¨åˆ°çš„èªå¥éƒ½å¤¾é›œå†ä¸€èµ·ï¼Œéå¸¸æ··äº‚ï¼ˆImage Assets åŒæ¨£ç‹€æ³ï¼‰ã€‚

ä¸€ç›´ä»¥ä¾†éƒ½æƒ³æ‰¾å·¥å…·å”åŠ©è™•ç†é€™æ–¹é¢çš„å•é¡Œï¼Œä¹‹å‰æ˜¯ç”¨ [iOSLocalizationEditor](https://github.com/igorkulman/iOSLocalizationEditor){:target="_blank"} é€™å€‹ Mac APPï¼Œä½†å®ƒæ¯”è¼ƒåƒæ˜¯èªç³»æª”æ¡ˆç·¨è¼¯å™¨ï¼Œè®€å–èªç³»æª”æ¡ˆå…§å®¹ï¼†ç·¨è¼¯ï¼Œæ²’æœ‰è‡ªå‹•æª¢æŸ¥çš„åŠŸèƒ½ã€‚
### æœŸæœ›åŠŸèƒ½

build å°ˆæ¡ˆæ™‚èƒ½è‡ªå‹•æª¢æŸ¥å¤šèªç³»æœ‰ç„¡éŒ¯èª¤ã€ç¼ºéœ²ã€é‡è¤‡ã€Image Assets æœ‰ç„¡ç¼ºæ¼ã€‚
### è§£æ±ºæ–¹æ¡ˆ

è¦é”åˆ°æˆ‘å€‘çš„æœŸæœ›åŠŸèƒ½å°±è¦åœ¨ Build Phases åŠ å…¥ Run Script æª¢æŸ¥è…³æœ¬ã€‚

ä½†æª¢æŸ¥è…³æœ¬éœ€è¦ä½¿ç”¨ shell script æ’°å¯«ï¼Œå› è‡ªå·±å° shell script çš„æŒæ¡åº¦ä¸¦ä¸å¤ªé«˜ï¼Œæƒ³èªªç«™åœ¨å·¨äººçš„è‚©è†€ä¸Šå¾ç¶²è·¯æœå°‹ç¾æœ‰è…³æœ¬ä¹Ÿæ‰¾ä¸å¤ªåˆ°å®Œå…¨ç¬¦åˆæœŸæœ›åŠŸèƒ½çš„ scriptï¼Œå†å¿«è¦æ”¾æ£„çš„æ™‚å€™çªç„¶æƒ³åˆ°ï¼š


> **Shell Script å¯ä»¥ç”¨ Swift ä¾†å¯«å•Š** ï¼ 




ç›¸å° shell script ä¾†èªªæ›´ç†Ÿæ‚‰ã€æŒæ¡åº¦æ›´é«˜ï¼ä¾ç…§é€™å€‹æ–¹å‘æœç„¶è®“æˆ‘æ‰¾åˆ°å…©å€‹ç¾æœ‰çš„å·¥å…·è…³æœ¬ï¼

ç”± [freshOS](https://freshos.github.io/){:target="_blank"} é€™å€‹åœ˜éšŠæ’°å¯«çš„å…©å€‹æª¢æŸ¥å·¥å…·ï¼š
- [**Localize ğŸ**](https://github.com/freshOS/Localize){:target="_blank"}
- [**Asset Checker ğŸ‘®**](https://github.com/s4cha/AssetChecker){:target="_blank"}


å®Œå…¨ç¬¦åˆæˆ‘å€‘çš„æœŸæœ›åŠŸèƒ½éœ€æ±‚\!\! ä¸¦ä¸”ä»–å€‘ä½¿ç”¨ swift æ’°å¯«ï¼Œè¦å®¢è£½åŒ–é­”æ”¹éƒ½å¾ˆå®¹æ˜“ã€‚
#### [Localize ğŸ](https://github.com/freshOS/Localize){:target="_blank"} å¤šèªç³»æª”æª¢æŸ¥å·¥å…·

**åŠŸèƒ½ï¼š**
- build æ™‚è‡ªå‹•æª¢æŸ¥
- èªç³»æª”è‡ªå‹•æ’ç‰ˆã€æ•´ç†
- æª¢æŸ¥å¤šèªç³»èˆ‡ä¸»è¦èªç³»ä¹‹ç¼ºæ¼ã€å¤šé¤˜
- æª¢æŸ¥å¤šèªç³»é‡è¤‡èªå¥
- æª¢æŸ¥å¤šèªç³»æœªç¶“ç¿»è­¯èªå¥
- æª¢æŸ¥å¤šèªç³»æœªä½¿ç”¨çš„èªå¥


**å®‰è£æ–¹æ³•ï¼š**
1. [ä¸‹è¼‰å·¥å…·çš„ Swift Script æª”æ¡ˆ](https://github.com/freshOS/Localize/blob/master/Localize.swift){:target="_blank"}
2. æ”¾åˆ°å°ˆæ¡ˆç›®éŒ„ä¸‹ EX: `${SRCROOT}/Localize.swift`
3. æ‰“é–‹å°ˆæ¡ˆè¨­å®š â†’ iOS Target â†’ Build Phases â†’å·¦ä¸Šè§’ã€Œ\+ã€ â†’ New Run Script Phases â†’ åœ¨ Script å…§å®¹è²¼ä¸Šè·¯å¾‘ EX: `${SRCROOT}/Localize.swift`



![](/assets/41c49a75a743/1*k2OHjrcQaQIWLqV7G57TgA.png)


4\. ä½¿ç”¨ Xcode æ‰“é–‹ç·¨è¼¯ `Localize.swift` æª”æ¡ˆé€²è¡Œè¨­å®šï¼Œå¯ä»¥åœ¨æª”æ¡ˆä¸ŠåŠéƒ¨çœ‹åˆ°å¯æ›´å‹•çš„è¨­å®šé …ç›®ï¼š
```swift
//å•Ÿç”¨æª¢æŸ¥è…³æœ¬
let enabled = true

//èªç³»æª”æ¡ˆç›®éŒ„
let relativeLocalizableFolders = "/Resources/Languages"

//å°ˆæ¡ˆç›®éŒ„ï¼ˆç”¨ä¾†æœç´¢èªå¥æœ‰æ²’æœ‰åœ¨ç¨‹å¼ç¢¼ä¸­ä½¿ç”¨åˆ°ï¼‰
let relativeSourceFolder = "/Sources"

//ç¨‹å¼ç¢¼ä¸­çš„ NSLocalized èªç³»æª”æ¡ˆä½¿ç”¨æ­£è¦åŒ¹é…è¡¨ç¤ºæ³•
//å¯è‡ªè¡Œå¢åŠ ã€ç„¡éœ€è®Šå‹•
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\"", // Swift and Objc Native
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine Calls
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen generation
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized pattern
]

//è¦å¿½ç•¥ã€Œèªå¥æœªä½¿ç”¨è­¦å‘Šã€çš„èªå¥
let ignoredFromUnusedKeys: [String] = []
/* example
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

//ä¸»è¦èªç³»
let masterLanguage = "en"

//é–‹å•Ÿèˆ‡ä¿‚æª”æ¡ˆa-zæ’åºã€æ•´ç†åŠŸèƒ½
let sanitizeFiles = false

//å°ˆæ¡ˆæ˜¯å–®ä¸€orå¤šèªç³»
let singleLanguage = false

//å•Ÿç”¨æª¢æŸ¥æœªç¿»è­¯èªå¥åŠŸèƒ½
let checkForUntranslated = true
```

5\. Buildï¼æˆåŠŸï¼


![](/assets/41c49a75a743/1*74osParg9RRi2gcRx9ELuw.png)


**æª¢æŸ¥çµæœæç¤ºé¡å‹ï¼š**
- **Build Error** âŒ **ï¼š** 
\- \[Duplication\] é …ç›®åœ¨èªç³»æª”æ¡ˆå…§å­˜åœ¨é‡è¤‡
\- \[Unused Key\] é …ç›®åœ¨èªç³»æª”æ¡ˆå…§æœ‰å®šç¾©ï¼Œä½†å¯¦éš›ç¨‹å¼ä¸­æœªä½¿ç”¨åˆ°
\- \[Missing\] é …ç›®åœ¨èªç³»æª”æ¡ˆå…§æœªå®šç¾©ï¼Œä½†å¯¦éš›ç¨‹å¼ä¸­æœ‰ä½¿ç”¨åˆ°
\- \[Redundant\] é …ç›®åœ¨æ­¤èªç³»æª”ç›¸è¼ƒæ–¼ä¸»è¦èªç³»æª”æ˜¯å¤šé¤˜çš„
\- \[Missing Translation\] é …ç›®åœ¨ä¸»è¦èªç³»æª”æœ‰ï¼Œä½†åœ¨æ­¤èªç³»æª”ç¼ºæ¼
- **Build Warning** âš ï¸ **ï¼š** 
\- \[Potentially Untranslated\] æ­¤é …ç›®æœªç¶“ç¿»è­¯ï¼ˆèˆ‡ä¸»èªç³»æª”é …ç›®å…§å®¹ç›¸åŒï¼‰

> **_é‚„æ²’çµæŸï¼Œç¾åœ¨è‡ªå‹•æª¢æŸ¥æç¤ºæœ‰äº†ï¼Œä½†æˆ‘å€‘é‚„éœ€è¦è‡ªè¡Œé­”æ”¹ä¸€ä¸‹ã€‚_** 



**å®¢è£½åŒ–åŒ¹é…æ­£è¦è¡¨ç¤ºï¼š**

å›é ­çœ‹æª¢æŸ¥è…³æœ¬ `Localize.swift` é ‚éƒ¨è¨­å®šå€å¡Š patterns éƒ¨åˆ†çš„ç¬¬ä¸€é …ï¼š

`"NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\""`

åŒ¹é… Swift/ObjCçš„ `NSLocalizedString(\)` æ–¹æ³•ï¼Œé€™å€‹æ­£è¦è¡¨ç¤ºå¼åªèƒ½åŒ¹é… `"Home.Title"` é€™ç¨®æ ¼å¼çš„èªå¥ï¼›å‡è¨­æˆ‘å€‘æ˜¯å®Œæ•´å¥å­æˆ–æœ‰å¸¶ Format åƒæ•¸ï¼Œå‰‡æœƒè¢«ç•¶èª¤ç•¶æˆ \[Unused Key\]ã€‚

EX: `"Hi, %@ welcome to my app"ã€"Hello World!"` **&lt;\- é€™äº›èªå¥éƒ½ç„¡æ³•åŒ¹é…**

æˆ‘å€‘å¯ä»¥æ–°å¢ä¸€æ¢ patterns è¨­å®šã€æˆ–æ›´æ”¹åŸæœ¬çš„ patterns æˆï¼š

`"NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\""`

ä¸»è¦æ˜¯èª¿æ•´ `NSLocalizedString` æ–¹æ³•å¾Œçš„åŒ¹é…èªå¥ï¼Œè®Šæˆå–ä»»æ„å­—ä¸²ç›´åˆ° `"` å‡ºç¾å°±ä¸­æ­¢ï¼Œä½ ä¹Ÿå¯ä»¥ [é»æ­¤](https://rubular.com/r/5eXvGy3svsAHyT){:target="_blank"} ä¾ç…§è‡ªå·±çš„éœ€æ±‚é€²è¡Œå®¢è£½ã€‚

**åŠ ä¸Šèªç³»æª”æ¡ˆæ ¼å¼æª¢æŸ¥åŠŸèƒ½ï¼š**

æ­¤è…³æœ¬åƒ…é‡å°èªç³»æª”åšå…§å®¹å°æ‡‰æª¢æŸ¥ï¼Œä¸æœƒæª¢æŸ¥æª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºï¼ˆæ˜¯å¦æœ‰å¿˜è¨˜åŠ ã€Œ **;** ã€ï¼‰ï¼Œå¦‚æœéœ€è¦é€™å€‹åŠŸèƒ½è¦è‡ªå·±åŠ ä¸Šï¼
```swift
//....
let formatResult = shell("plutil -lint \(location)")
guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
  let str = "\(path)/\(name).lproj"
            + "/Localizable.strings:1: "
            + "error: [File Invaild] "
            + "This Localizable.strings file format is invalid."
  print(str)
  numberOfErrors += 1
  return
}
//....

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```

å¢åŠ  `shell(\)` åŸ·è¡Œ shell scriptï¼Œä½¿ç”¨ `plutil -lint` æª¢æŸ¥ plist èªç³»æª”æ¡ˆæ ¼å¼æ­£ç¢ºæ€§ï¼Œæœ‰éŒ¯ã€å°‘ã€Œ;ã€æœƒå›å‚³éŒ¯èª¤ï¼Œæ²’éŒ¯æœƒå›å‚³ `OK` ä»¥æ­¤ä½œç‚ºåˆ¤æ–·ï¼

æª¢æŸ¥çš„åœ°æ–¹å¯åŠ åœ¨ LocalizationFiles\-&gt;process\(\)\-&gt; `let location = singleLanguageâ€¦` å¾Œï¼Œç´„ 135 è¡Œçš„åœ°æ–¹æˆ–åƒè€ƒæˆ‘æœ€å¾Œæä¾›çš„å®Œæ•´é­”æ”¹ç‰ˆã€‚

**å…¶ä»–å®¢è£½åŒ–ï¼š**

æˆ‘å€‘å¯ä»¥ä¾ç…§è‡ªå·±çš„éœ€æ±‚é€²è¡Œå®¢è£½ï¼Œä¾‹å¦‚æŠŠ error æ›æˆ warning æˆ–æ˜¯æ‹”æ‰æŸå€‹æª¢æŸ¥åŠŸèƒ½ \(EX: Potentially Untranslatedã€Unused Key\)ï¼›è…³æœ¬å°±æ˜¯ swift æˆ‘å€‘éƒ½å¾ˆç†Ÿæ‚‰ï¼ä¸æ€•æ”¹å£æ”¹éŒ¯ï¼

è¦è®“ build æ™‚å‡ºç¾ Error âŒï¼š
```
print("Projectæª”æ¡ˆ.lproj" + "/æª”æ¡ˆ:è¡Œ: " + "error: éŒ¯èª¤è¨Šæ¯")
```

è¦è®“ build æ™‚å‡ºç¾ Warning âš ï¸ï¼š
```
print("Projectæª”æ¡ˆ.lproj" + "/æª”æ¡ˆ:è¡Œ: " + "warning: è­¦å‘Šè¨Šæ¯")
```

**æœ€çµ‚é­”æ”¹ç‰ˆï¼š**
```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// WHAT
// 1. Find Missing keys in other Localisation files
// 2. Find potentially untranslated keys
// 3. Find Duplicate keys
// 4. Find Unused keys and generate script to delete them all at once

// MARK: Start Of Configurable Section

/*
 You can enable or disable the script whenever you want
 */
let enabled = true

/*
 Put your path here, example ->  Resources/Localizations/Languages
 */
let relativeLocalizableFolders = "/streetvoice/SupportingFiles"

/*
 This is the path of your source folder which will be used in searching
 for the localization keys you actually use in your project
 */
let relativeSourceFolder = "/streetvoice"

/*
 Those are the regex patterns to recognize localizations.
 */
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\"", // Swift and Objc Native
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine Calls
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen generation
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized pattern
]

/*
 Those are the keys you don't want to be recognized as "unused"
 For instance, Keys that you concatenate will not be detected by the parsing
 so you want to add them here in order not to create false positives :)
 */
let ignoredFromUnusedKeys: [String] = []
/* example
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

let masterLanguage = "base"

/*
 Sanitizing files will remove comments, empty lines and order your keys alphabetically.
 */
let sanitizeFiles = false

/*
 Determines if there are multiple localizations or not.
 */
let singleLanguage = false

/*
 Determines if we should show errors if there's a key within the app
 that does not appear in master translations.
*/
let checkForUntranslated = false

// MARK: End Of Configurable Section
// MARK: -











if enabled == false {
    print("Localization check cancelled")
    exit(000)
}

// Detect list of supported languages automatically
func listSupportedLanguages() -> [String] {
    var sl: [String] = []
    let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
    if !FileManager.default.fileExists(atPath: path) {
        print("Invalid configuration: \(path) does not exist.")
        exit(1)
    }
    let enumerator = FileManager.default.enumerator(atPath: path)
    let extensionName = "lproj"
    print("Found these languages:")
    while let element = enumerator?.nextObject() as? String {
        if element.hasSuffix(extensionName) {
            print(element)
            let name = element.replacingOccurrences(of: ".\(extensionName)", with: "")
            sl.append(name)
        }
    }
    return sl
}

let supportedLanguages = listSupportedLanguages()
var ignoredFromSameTranslation: [String: [String]] = [:]
let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
var numberOfWarnings = 0
var numberOfErrors = 0

struct LocalizationFiles {
    var name = ""
    var keyValue: [String: String] = [:]
    var linesNumbers: [String: Int] = [:]

    init(name: String) {
        self.name = name
        process()
    }

    mutating func process() {
        if sanitizeFiles {
            removeCommentsFromFile()
            removeEmptyLinesFromFile()
            sortLinesAlphabetically()
        }
        let location = singleLanguage ? "\(path)/Localizable.strings" : "\(path)/\(name).lproj/Localizable.strings"
        
        let formatResult = shell("plutil -lint \(location)")
        guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
            let str = "\(path)/\(name).lproj"
                + "/Localizable.strings:1: "
                + "error: [File Invaild] "
                + "This Localizable.strings file format is invalid."
            print(str)
            numberOfErrors += 1
            return
        }
        
        guard let string = try? String(contentsOfFile: location, encoding: .utf8) else {
            return
        }

        let lines = string.components(separatedBy: .newlines)
        keyValue = [:]

        let pattern = "\"(.*)\" = \"(.+)\";"
        let regex = try? NSRegularExpression(pattern: pattern, options: [])
        var ignoredTranslation: [String] = []

        for (lineNumber, line) in lines.enumerated() {
            let range = NSRange(location: 0, length: (line as NSString).length)

            // Ignored pattern
            let ignoredPattern = "\"(.*)\" = \"(.+)\"; *\\/\\/ *ignore-same-translation-warning"
            let ignoredRegex = try? NSRegularExpression(pattern: ignoredPattern, options: [])
            if let ignoredMatch = ignoredRegex?.firstMatch(in: line,
                                                           options: [],
                                                           range: range) {
                let key = (line as NSString).substring(with: ignoredMatch.range(at: 1))
                ignoredTranslation.append(key)
            }

            if let firstMatch = regex?.firstMatch(in: line, options: [], range: range) {
                let key = (line as NSString).substring(with: firstMatch.range(at: 1))
                let value = (line as NSString).substring(with: firstMatch.range(at: 2))

                if keyValue[key] != nil {
                    let str = "\(path)/\(name).lproj"
                        + "/Localizable.strings:\(linesNumbers[key]!): "
                        + "error: [Duplication] \"\(key)\" "
                        + "is duplicated in \(name.uppercased()) file"
                    print(str)
                    numberOfErrors += 1
                } else {
                    keyValue[key] = value
                    linesNumbers[key] = lineNumber + 1
                }
            }
        }
        print(ignoredFromSameTranslation)
        ignoredFromSameTranslation[name] = ignoredTranslation
    }

    func rebuildFileString(from lines: [String]) -> String {
        return lines.reduce("") { (r: String, s: String) -> String in
            (r == "") ? (r + s) : (r + "\n" + s)
        }
    }

    func removeEmptyLinesFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeCommentsFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { !$0.hasPrefix("//") }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func sortLinesAlphabetically() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            let lines = string.components(separatedBy: .newlines)

            var s = ""
            for (i, l) in sortAlphabetically(lines).enumerated() {
                s += l
                if i != lines.count - 1 {
                    s += "\n"
                }
            }
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeEmptyLinesFromLines(_ lines: [String]) -> [String] {
        return lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
    }

    func sortAlphabetically(_ lines: [String]) -> [String] {
        return lines.sorted()
    }
}

// MARK: - Load Localisation Files in memory

let masterLocalizationFile = LocalizationFiles(name: masterLanguage)
let localizationFiles = supportedLanguages
    .filter { $0 != masterLanguage }
    .map { LocalizationFiles(name: $0) }

// MARK: - Detect Unused Keys

let sourcesPath = FileManager.default.currentDirectoryPath + relativeSourceFolder
let fileManager = FileManager.default
let enumerator = fileManager.enumerator(atPath: sourcesPath)
var localizedStrings: [String] = []
while let swiftFileLocation = enumerator?.nextObject() as? String {
    // checks the extension
    if swiftFileLocation.hasSuffix(".swift") || swiftFileLocation.hasSuffix(".m") || swiftFileLocation.hasSuffix(".mm") {
        let location = "\(sourcesPath)/\(swiftFileLocation)"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            for p in patterns {
                let regex = try? NSRegularExpression(pattern: p, options: [])
                let range = NSRange(location: 0, length: (string as NSString).length) // Obj c wa
                regex?.enumerateMatches(in: string,
                                        options: [],
                                        range: range,
                                        using: { result, _, _ in
                                            if let r = result {
                                                let value = (string as NSString).substring(with: r.range(at: r.numberOfRanges - 1))
                                                localizedStrings.append(value)
                                            }
                })
            }
        }
    }
}

var masterKeys = Set(masterLocalizationFile.keyValue.keys)
let usedKeys = Set(localizedStrings)
let ignored = Set(ignoredFromUnusedKeys)
let unused = masterKeys.subtracting(usedKeys).subtracting(ignored)
let untranslated = usedKeys.subtracting(masterKeys)

// Here generate Xcode regex Find and replace script to remove dead keys all at once!
var replaceCommand = "\"("
var counter = 0
for v in unused {
    var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[v]!): "
    str += "error: [Unused Key] \"\(v)\" is never used"
    print(str)
    numberOfErrors += 1
    if counter != 0 {
        replaceCommand += "|"
    }
    replaceCommand += v
    if counter == unused.count - 1 {
        replaceCommand += ")\" = \".*\";"
    }
    counter += 1
}

print(replaceCommand)

// MARK: - Compare each translation file against master (en)

for file in localizationFiles {
    for k in masterLocalizationFile.keyValue.keys {
        if file.keyValue[k] == nil {
            var str = "\(path)/\(file.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[k]!): "
            str += "error: [Missing] \"\(k)\" missing from \(file.name.uppercased()) file"
            print(str)
            numberOfErrors += 1
        }
    }

    let redundantKeys = file.keyValue.keys.filter { !masterLocalizationFile.keyValue.keys.contains($0) }

    for k in redundantKeys {
        let str = "\(path)/\(file.name).lproj/Localizable.strings:\(file.linesNumbers[k]!): "
            + "error: [Redundant key] \"\(k)\" redundant in \(file.name.uppercased()) file"

        print(str)
    }
}

if checkForUntranslated {
    for key in untranslated {
        var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:1: "
        str += "error: [Missing Translation] \(key) is not translated"

        print(str)
        numberOfErrors += 1
    }
}

print("Number of warnings : \(numberOfWarnings)")
print("Number of errors : \(numberOfErrors)")

if numberOfErrors > 0 {
    exit(1)
}

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```
> **_æœ€å¾Œæœ€å¾Œï¼Œé‚„æ²’çµæŸï¼_** 



ç•¶æˆ‘å€‘çš„ swift æª¢æŸ¥å·¥å…·è…³æœ¬éƒ½èª¿è©¦å®Œæˆä¹‹å¾Œï¼Œè¦å°‡å…¶ **compile æˆåŸ·è¡Œæª”æ¸›å°‘ build èŠ±è²»æ™‚é–“** ï¼Œå¦å‰‡æ¯æ¬¡ build éƒ½è¦é‡æ–° compile ä¸€æ¬¡ï¼ˆç´„èƒ½æ¸›å°‘ 90% çš„æ™‚é–“ï¼‰ã€‚

æ‰“é–‹ terminal ï¼Œå‰å¾€å°ˆæ¡ˆä¸­æª¢æŸ¥å·¥å…·è…³æœ¬æ‰€åœ¨ç›®éŒ„ä¸‹åŸ·è¡Œï¼š
```
swiftc -o Localize Localize.swift
```


![](/assets/41c49a75a743/1*rwq_KZIDW-Lvtpd2xmgjDw.png)



![](/assets/41c49a75a743/1*BCKtqshZxHH17j3nBGtNlg.png)


ç„¶å¾Œå†å›é ­åˆ° Build Phases æ›´æ”¹ Script å…§å®¹è·¯å¾‘æˆåŸ·è¡Œæª”

EX: `${SRCROOT}/Localize`


![](/assets/41c49a75a743/1*ewhCXzXNuS0MCTMCuINWng.png)


**å®Œå·¥ï¼**
#### å·¥å…· 2\. [**Asset Checker ğŸ‘®**](https://github.com/s4cha/AssetChecker){:target="_blank"} **åœ–ç‰‡è³‡æºæª¢æŸ¥å·¥å…·**

**åŠŸèƒ½ï¼š**
- build æ™‚è‡ªå‹•æª¢æŸ¥
- æª¢æŸ¥åœ–ç‰‡ç¼ºæ¼ï¼šåç¨±æœ‰å‘¼å«ï¼Œä½†åœ–ç‰‡è³‡æºç›®éŒ„å…§æ²’æœ‰å‡ºç¾
- æª¢æŸ¥åœ–ç‰‡å¤šé¤˜ï¼šåç¨±æœªä½¿ç”¨ï¼Œä½†åœ–ç‰‡è³‡æºç›®éŒ„å­˜åœ¨çš„


**å®‰è£æ–¹æ³•ï¼š**
1. [ä¸‹è¼‰å·¥å…·çš„ Swift Script æª”æ¡ˆ](https://github.com/freshOS/AssetChecker/blob/master/Classes/main.swift){:target="_blank"}
2. æ”¾åˆ°å°ˆæ¡ˆç›®éŒ„ä¸‹ EX: `${SRCROOT}/AssetChecker.swift`
3. æ‰“é–‹å°ˆæ¡ˆè¨­å®š â†’ iOS Target â†’ Build Phases â†’å·¦ä¸Šè§’ã€Œ\+ã€ â†’ New Run Script Phases â†’ åœ¨ Script å…§å®¹è²¼ä¸Šè·¯å¾‘

```
${SRCROOT}/AssetChecker.swift ${SRCROOT}/å°ˆæ¡ˆç›®éŒ„ ${SRCROOT}/Resources/Images.xcassets
//${SRCROOT}/Resources/Images.xcassets = ä½  .xcassets çš„ä½ç½®
```


![](/assets/41c49a75a743/1*TPLS60W1iQiGFzU-inf3aA.png)


å¯ç›´æ¥å°‡è¨­å®šåƒæ•¸å¸¶åœ¨è·¯å¾‘ä¸Šï¼Œåƒæ•¸1:å°ˆæ¡ˆç›®éŒ„ä½ç½®ã€åƒæ•¸2:åœ–ç‰‡è³‡æºç›®éŒ„ä½ç½®ï¼›æˆ–è·Ÿèªç³»æª¢æŸ¥å·¥å…·ä¸€æ¨£ç·¨è¼¯ `AssetChecker.swift` é ‚éƒ¨åƒæ•¸è¨­å®šå€å¡Šï¼š
```swift
// Configure me \o/

// å°ˆæ¡ˆç›®éŒ„ä½ç½®ï¼ˆç”¨ä¾†æœç´¢åœ–ç‰‡æœ‰æ²’æœ‰åœ¨ç¨‹å¼ç¢¼ä¸­ä½¿ç”¨åˆ°ï¼‰
var sourcePathOption:String? = nil

// .xcassets ç›®éŒ„ä½ç½®
var assetCatalogPathOption:String? = nil

// Unused è­¦å‘Šå¿½ç•¥é …ç›®
let ignoredUnusedNames = [String]()
```

4\. Buildï¼ æˆåŠŸï¼

**æª¢æŸ¥çµæœæç¤ºé¡å‹ï¼š**
- **Build Error** âŒ **ï¼š** 
\- \[Asset Missing\] é …ç›®åœ¨ç¨‹å¼å…§æœ‰å‘¼å«ä½¿ç”¨ï¼Œä½†åœ–ç‰‡è³‡æºç›®éŒ„å…§æ²’æœ‰å‡ºç¾
- **Build Warning** âš ï¸ **ï¼š** 
\- \[Asset Unused\] é …ç›®åœ¨ç¨‹å¼å…§æœªä½¿ç”¨ï¼Œä½†åœ–ç‰‡è³‡æºç›®éŒ„å…§æœ‰å‡ºç¾
_p\.s å‡è¨­åœ–ç‰‡æ˜¯å‹•æ…‹è®Šæ•¸æä¾›ï¼Œæª¢æŸ¥å·¥å…·å°‡ç„¡æ³•è­˜åˆ¥ï¼Œå¯å°‡å…¶åŠ å…¥ `ignoredUnusedNames` ä¸­è¨­ç‚ºä¾‹å¤–ã€‚_


å…¶ä»–æ“ä½œåŒèªç³»æª¢æŸ¥å·¥å…·ï¼Œé€™é‚Šå°±ä¸åšè´…è¿°ï¼›æœ€é‡è¦çš„äº‹æ˜¯ä¹Ÿè¦ **è¨˜å¾—èª¿é©å®Œå¾Œè¦ compile æˆåŸ·è¡Œæª”ï¼Œä¸¦æ›´æ”¹ run script å…§å®¹ç‚ºåŸ·è¡Œæª”ï¼**
#### é–‹ç™¼è‡ªå·±çš„å·¥å…·ï¼
> **_æˆ‘å€‘å¯ä»¥åƒè€ƒåœ–ç‰‡è³‡æºæª¢æŸ¥å·¥å…·è…³æœ¬ï¼š_** 


```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// Configure me \o/
var sourcePathOption:String? = nil
var assetCatalogPathOption:String? = nil
let ignoredUnusedNames = [String]()

for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        sourcePathOption = arg
    case 2:
        assetCatalogPathOption = arg
    default:
        break
    }
}

guard let sourcePath = sourcePathOption else {
    print("AssetChecker:: error: Source path was missing!")
    exit(0)
}

guard let assetCatalogAbsolutePath = assetCatalogPathOption else {
    print("AssetChecker:: error: Asset Catalog path was missing!")
    exit(0)
}

print("Searching sources in \(sourcePath) for assets in \(assetCatalogAbsolutePath)")

/* Put here the asset generating false positives, 
 For instance whne you build asset names at runtime
let ignoredUnusedNames = [
    "IconArticle",
    "IconMedia",
    "voteEN",
    "voteES",
    "voteFR"
] 
*/


// MARK : - End Of Configurable Section
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}


// MARK: - List Assets
func listAssets() -> [String] {
    let extensionName = "imageset"
    let enumerator = FileManager.default.enumerator(atPath: assetCatalogAbsolutePath)
    return elementsInEnumerator(enumerator)
        .filter { $0.hasSuffix(extensionName) }                             // Is Asset
        .map { $0.replacingOccurrences(of: ".\(extensionName)", with: "") } // Remove extension
        .map { $0.components(separatedBy: "/").last ?? $0 }                 // Remove folder path
}


// MARK: - List Used Assets in the codebase
func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // Image Literal
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // Default UIImage call (Swift)
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // Default UIImage call 
        "\\<image name=\"\(namePattern)\".*", // Storyboard resources
        "R.image.\(namePattern)\\(\\)" //R.swift support
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") || $0.hasSuffix(".swift") || $0.hasSuffix(".xib") || $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .compactMap{$0}
            .compactMap{$0}                                             // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings ocurrences
            .flatMap{$0}                                                // Flatten
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") || $0.hasSuffix(".swift") || $0.hasSuffix(".xib") || $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .flatMap{$0}
            .flatMap{$0}                                                // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings ocurrences
            .flatMap{$0}                                                // Flatten
    #endif
}


// MARK: - Begining of script
let assets = Set(listAssets())
let used = Set(listUsedAssetLiterals() + ignoredUnusedNames)


// Generate Warnings for Unused Assets
let unused = assets.subtracting(used)
unused.forEach { print("\(assetCatalogAbsolutePath):: warning: [Asset Unused] \($0)") }


// Generate Error for broken Assets
let broken = used.subtracting(assets)
broken.forEach { print("\(assetCatalogAbsolutePath):: error: [Asset Missing] \($0)") }

if broken.count > 0 {
    exit(1)
}
```

ç›¸è¼ƒæ–¼èªç³»æª¢æŸ¥è…³æœ¬ï¼Œé€™å€‹è…³æœ¬ç°¡æ½”ä¸”é‡è¦çš„åŠŸèƒ½éƒ½æœ‰ï¼Œå¾ˆæœ‰åƒè€ƒåƒ¹å€¼ï¼

_P\.S å¯ä»¥çœ‹åˆ°ç¨‹å¼ç¢¼å‡ºç¾ `localizedStrings(\)` å‘½åï¼Œæ‡·ç–‘ä½œè€…æ˜¯å¾èªç³»æª¢æŸ¥å·¥å…·çš„é‚è¼¯æ¬ä¾†ç”¨ï¼Œå¿˜äº†æ”¹æ–¹æ³•åç¨±ï¼¸ï¼¤_

**ä¾‹å¦‚ï¼š**
```swift
for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        //åƒæ•¸1
    case 2:
        //åƒæ•¸2
    default:
        break
    }
}
```
```swift
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}

func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // Image Literal
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // Default UIImage call (Swift)
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // Default UIImage call 
        "\\<image name=\"\(namePattern)\".*", // Storyboard resources
        "R.image.\(namePattern)\\(\\)" //R.swift support
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") || $0.hasSuffix(".swift") || $0.hasSuffix(".xib") || $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .compactMap{$0}
            .compactMap{$0}                                             // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings ocurrences
            .flatMap{$0}                                                // Flatten
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") || $0.hasSuffix(".swift") || $0.hasSuffix(".xib") || $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .flatMap{$0}
            .flatMap{$0}                                                // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings ocurrences
            .flatMap{$0}                                                // Flatten
    #endif
}
```
```swift
//è¦è®“ build æ™‚å‡ºç¾ Error âŒï¼š
print("Projectæª”æ¡ˆ.lproj" + "/æª”æ¡ˆ:è¡Œ: " + "error: éŒ¯èª¤è¨Šæ¯")
//è¦è®“ build æ™‚å‡ºç¾ Warning âš ï¸ï¼š
print("Projectæª”æ¡ˆ.lproj" + "/æª”æ¡ˆ:è¡Œ: " + "warning: è­¦å‘Šè¨Šæ¯")
```

å¯ä»¥ç¶œåˆåƒè€ƒä»¥ä¸Šçš„ç¨‹å¼æ–¹æ³•ï¼Œè‡ªå·±æ‰“é€ æƒ³è¦çš„å·¥å…·ã€‚
### ç¸½çµ

é€™å…©å€‹æª¢æŸ¥å·¥å…·å°å…¥ä¹‹å¾Œï¼Œæˆ‘å€‘åœ¨é–‹ç™¼ä¸Šå°±èƒ½æ›´å®‰å¿ƒã€æ›´æœ‰æ•ˆç‡ä¸¦ä¸”æ¸›å°‘å†—é¤˜ï¼›ä¹Ÿå› ç‚ºé€™æ¬¡ç¶“é©—å¤§é–‹çœ¼ç•Œï¼Œæ—¥å¾Œå¦‚æœæœ‰ä»€éº¼æ–°çš„ build run script éœ€æ±‚éƒ½èƒ½ç›´æ¥ä½¿ç”¨æœ€ç†Ÿæ‚‰çš„èªè¨€ swift ä¾†é€²è¡Œè£½ä½œï¼


[![Like Z Realm's work](https://button.like.co/images/og/likebutton.png "Like Z Realm's work")](https://button.like.co/zhgchgli){:target="_blank"}


æœ‰ä»»ä½•å•é¡ŒåŠæŒ‡æ•™æ­¡è¿ [èˆ‡æˆ‘è¯çµ¡](https://www.zhgchg.li/contact){:target="_blank"} ã€‚



_Converted [Medium Post](https://medium.com/zrealm-ios-dev/xcode-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-swift-%E6%92%B0%E5%AF%AB-run-script-41c49a75a743){:target="_blank"} by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
