---
title: "æ‰‹å·¥æ‰“é€  HTML è§£æå™¨çš„é‚£äº›äº‹"
author: "ZhgChgLi"
date: 2023-03-11T17:09:22.165+0000
last_modified_at: 2023-08-05T16:15:39.420+0000
categories: "ZRealm Dev."
tags: ["ios-app-development","html-parsing","nsattributedstring","html","rendering"]
description: "ZMarkupParser HTML to NSAttributedString æ¸²æŸ“å¼•æ“çš„é–‹ç™¼å¯¦éŒ„"
image:
  path: /assets/2724f02f6e7/1*A0yXupXW9-F9ZWe4gp2ObA.jpeg
render_with_liquid: false
---

### æ‰‹å·¥æ‰“é€  HTML è§£æå™¨çš„é‚£äº›äº‹

ZMarkupParser HTML to NSAttributedString æ¸²æŸ“å¼•æ“çš„é–‹ç™¼å¯¦éŒ„


HTML String çš„ Tokenization è½‰æ›ã€Normalization è™•ç†ã€Abstract Syntax Tree çš„ç”¢ç”Ÿã€Visitor Pattern / Builder Pattern çš„æ‡‰ç”¨, é‚„æœ‰ä¸€äº›é›œè«‡â€¦
#### æ¥çºŒ

å»å¹´ç™¼è¡¨äº†ç¯‡ã€Œ\[ **TL;DR\]** [è‡ªè¡Œå¯¦ç¾ iOS NSAttributedString HTML Render](../a8c2d26cc734/) ã€çš„æ–‡ç« ï¼Œç²—æ·ºçš„ä»‹ç´¹å¯ä»¥ä½¿ç”¨ XMLParser å»å‰–æ HTML å†å°‡å…¶è½‰æ›æˆ NSAttributedString\.Keyï¼Œæ–‡ä¸­çš„ç¨‹å¼æ¶æ§‹åŠæ€è·¯éƒ½å¾ˆé›¶äº‚ï¼Œå› æ˜¯éæ°´ç´€éŒ„ä¸€ä¸‹ä¹‹å‰é‡åˆ°çš„å•é¡ŒåŠç•¶åˆä¸¦æ²’æœ‰èŠ±å¤ªå¤šæ™‚é–“ç ”ç©¶æ­¤è­°é¡Œã€‚
### Convert HTML String to NSAttributedString

å†æ¬¡é‡æ–°æ¢è¨æ­¤è­°é¡Œï¼Œæˆ‘å€‘éœ€è¦èƒ½å°‡ API çµ¦çš„ HTML å­—ä¸²è½‰æ›æˆ NSAttributedString ï¼Œä¸¦å¥—ç”¨å°æ‡‰æ¨£å¼æ”¾åˆ° UITextView/UILabel ä¸­é¡¯ç¤ºã€‚

e\.g\. `&lt;b&gt;Test&lt;a&gt;Link&lt;/a&gt;&lt;/b&gt;` è¦èƒ½é¡¯ç¤ºæˆ **Test [Link](https://blog.zhgchg.li){:target="_blank"}**
- è¨»1
ä¸å»ºè­°ä½¿ç”¨ HTML åšç‚º App èˆ‡è³‡æ–™é–“çš„æºé€šæ¸²æŸ“åª’ä»‹ï¼Œå›  HTML è¦æ ¼éæ–¼å½ˆæ€§ï¼ŒApp ç„¡æ³•æ”¯æ´æ‰€æœ‰ HTML æ¨£å¼ï¼Œä¹Ÿæ²’æœ‰å®˜æ–¹çš„ HTML è½‰æ›æ¸²æŸ“å¼•æ“ã€‚
- è¨»2
iOS 14 é–‹å§‹å¯ä½¿ç”¨å®˜æ–¹åŸç”Ÿçš„ AttributedString è§£æ Markdownæˆ–å¼•å…¥ apple/swift\-markdown Swift Package è§£æ Markdownã€‚
- è¨»3
å› æ•å¸å°ˆæ¡ˆé¾å¤§ä¸”å·²æ‡‰ç”¨ HTML åšç‚ºåª’ä»‹å¤šå¹´ï¼Œæ‰€ä»¥æš«æ™‚ç„¡æ³•å…¨é¢æ›´æ›ç‚º Markdown æˆ–å…¶ä»– Markupã€‚
- **è¨»4** 
**é€™é‚Šçš„ HTML ä¸¦ä¸æ˜¯è¦ç”¨ä¾†é¡¯ç¤ºæ•´å€‹ HTML ç¶²é ï¼Œåªæ˜¯æŠŠ HTML åšç‚ºæ¨£å¼ Markdown æ¸²æŸ“å­—ä¸²æ¨£å¼ã€‚** 
**\(è¦æ¸²æŸ“æ•´é ã€è¤‡é›œåŒ…å«åœ–ç‰‡è¡¨æ ¼çš„ HTMLï¼Œä¾ç„¶è¦ä½¿ç”¨ WevView loadHTML\)**



> å¼·çƒˆå»ºè­°ä½¿ç”¨ Markdown åšç‚ºå­—ä¸²æ¸²æŸ“åª’ä»‹èªè¨€ï¼Œå¦‚æœæ‚¨çš„å°ˆæ¡ˆè·Ÿæˆ‘æœ‰ä¸€æ¨£å›°æ“¾ä¸å¾—ä¸ä½¿ç”¨ HTML ä¸¦è‹¦ç„¡å„ªé›…çš„ to NSAttributedString è½‰æ›å·¥å…·ï¼Œ å†è«‹ä½¿ç”¨ã€‚ 





> é‚„è¨˜å¾—ä¸Šä¸€ç¯‡æ–‡ç« çš„æœ‹å‹ä¹Ÿå¯ä»¥ç›´æ¥è·³åˆ° ZhgChgLi / ZMarkupParser ç« ç¯€ã€‚ 




#### NSAttributedString\.DocumentType\.html

ç¶²è·¯ä¸Šèƒ½æ‰¾åˆ°çš„ HTML to NSAttributedString çš„åšæ³•éƒ½æ˜¯è¦æˆ‘å€‘ç›´æ¥ä½¿ç”¨ NSAttributedString è‡ªå¸¶çš„ options æ¸²æŸ“ HTMLï¼Œç¯„ä¾‹å¦‚ä¸‹ï¼š
```swift
let htmlString = "<b>Test<a>Link</a></b>"
let data = htmlString.data(using: String.Encoding.utf8)!
let attributedOptions:[NSAttributedString.DocumentReadingOptionKey: Any] = [
  .documentType :NSAttributedString.DocumentType.html,
  .characterEncoding: String.Encoding.utf8.rawValue
]
let attributedString = try! NSAttributedString(data: data, options: attributedOptions, documentAttributes: nil)
```

**æ­¤åšæ³•çš„å•é¡Œï¼š**
- æ•ˆèƒ½å·®ï¼šæ­¤æ–¹æ³•æ˜¯é€é WebView Core å»æ¸²æŸ“å‡ºæ¨£å¼ï¼Œå†åˆ‡å› Main Thread çµ¦ UI é¡¯ç¤ºï¼›æ¸²æŸ“ 300 å¤šå€‹å­—å…ƒå°±éœ€ 0\.03 Secã€‚
- æœƒåƒå­—ï¼šä¾‹å¦‚è¡ŒéŠ·æ–‡æ¡ˆå¯èƒ½æœƒä½¿ç”¨ `&lt;Congratulation!&gt;` æœƒè¢«ç•¶æˆ HTML Tag è¢«å»é™¤æ‰ã€‚
- ç„¡æ³•å®¢è£½åŒ–ï¼šä¾‹å¦‚ç„¡æ³•æŒ‡å®š HTML çš„ç²—é«”åœ¨ NSAttributedString ä¸­å°æ‡‰çš„ç²—é«”ç¨‹åº¦ã€‚
- [iOS â‰¥ 12 é–‹å§‹æœƒé›¶æ˜Ÿé–ƒé€€çš„å•é¡Œä¸”å®˜æ–¹ç„¡è§£](https://developer.apple.com/forums/thread/115405){:target="_blank"}
- åœ¨ iOS 15 å‡ºç¾ [å¤§é‡é–ƒé€€](../a8c2d26cc734/) ï¼Œæ¸¬è©¦ç™¼ç¾ä½é›»é‡æƒ…æ³ä¸‹æœƒ 100% é–ƒé€€ \(iOS â‰¥ 15\.2 å·²ä¿®æ­£\)
- å­—ä¸²å¤ªé•·æœƒé–ƒé€€ï¼Œå¯¦æ¸¬è¼¸å…¥è¶…é 54,600\+ é•·åº¦å­—ä¸²å°±æœƒ 100% é–ƒé€€ \(EXC\_BAD\_ACCESS\)


å°èˆ‡æˆ‘å€‘æœ€ç—›çš„é‚„æ˜¯é–ƒé€€å•é¡Œï¼ŒiOS 15 ç™¼ä½ˆåˆ° 15\.2 ä¿®æ­£ä¹‹å‰ï¼ŒApp å§‹çµ‚è¢«æ­¤å•é¡Œéœ¸æ¦œï¼Œå¾æ•¸æ“šä¾†çœ‹ï¼Œ2022/03/11~2022/06/08 å°±é€ æˆäº† 2\.4K\+ æ¬¡é–ƒé€€ã€å½±éŸ¿ 1\.4K\+ ä½ä½¿ç”¨è€…ã€‚

æ­¤é–ƒé€€å•é¡Œè‡ª iOS 12 é–‹å§‹å°±æœ‰ï¼ŒiOS 15 åªæ˜¯è¸©åˆ°æ›´å¤§çš„å‘ï¼Œä½†æˆ‘çŒœ iOS 15\.2 çš„ä¿®æ­£ä¹Ÿåªæ˜¯è£œæ´ï¼Œå®˜æ–¹ç„¡æ³•æ ¹é™¤ã€‚

å…¶æ¬¡å•é¡Œæ˜¯æ•ˆèƒ½ï¼Œå› ç‚ºåšç‚ºå­—ä¸²æ¨£å¼ Markup Languageï¼Œæœƒå¤§é‡æ‡‰ç”¨åœ¨ App ä¸Šçš„ UILabel/UITextViewï¼Œå¦‚åŒå‰è¿°ä¸€å€‹ Label å°±éœ€è¦ 0\.03 Secï¼Œåˆ—è¡¨\*UILabel/UITextView ä¹˜ä¸‹ä¾†å°±æœƒå°ä½¿ç”¨è€…æ“ä½œæ‰‹æ„Ÿä¸Šç”¢ç”Ÿå¡é “ã€‚
#### XMLParser

ç¬¬äºŒå€‹æ–¹æ¡ˆæ˜¯ [ä¸Šç¯‡æ–‡ç« ](../a8c2d26cc734/) ä»‹ç´¹çš„ï¼Œä½¿ç”¨ XMLParser è§£ææˆå°æ‡‰çš„ NSAttributedString Key ä¸¦å¥—ç”¨æ¨£å¼ã€‚

å¯åƒè€ƒ [SwiftRichString](https://github.com/malcommac/SwiftRichString){:target="_blank"} çš„å¯¦ç¾åŠ [ä¸Šä¸€ç¯‡æ–‡ç« å…§å®¹](../a8c2d26cc734/) ã€‚


> ä¸Šä¸€ç¯‡ä¹Ÿåªæ˜¯æ¢ç©¶å‡ºå¯ä»¥ä½¿ç”¨ XMLParser è§£æ HTML ä¸¦åšå°æ‡‰è½‰æ›ï¼Œç„¶å¾Œå®Œæˆå¯¦é©—æ€§çš„å¯¦ä½œï¼Œä½†ä¸¦æ²’æœ‰æŠŠå®ƒè¨­è¨ˆæˆä¸€å€‹æœ‰æ¶æ§‹å¥½æ“´å……çš„ã€Œå·¥å…·ã€ã€‚ 





**æ­¤åšæ³•çš„å•é¡Œï¼š**
- å®¹éŒ¯ç‡ 0ï¼š `&lt;br&gt;` / `&lt;Congratulation!&gt;` / `&lt;b&gt;Bold&lt;i&gt;Bold+Italic&lt;/b&gt;Italic&lt;/i&gt;` 
ä»¥ä¸Šä¸‰ç¨® HTML æœ‰å¯èƒ½å‡ºç¾çš„æƒ…å¢ƒï¼Œåœ¨ XMLParser è§£æéƒ½æœƒå‡ºéŒ¯ç›´æ¥ Throw Error é¡¯ç¤ºç©ºç™½ã€‚
- ä½¿ç”¨ XMLParserï¼ŒHTML å­—ä¸²å¿…é ˆå®Œå…¨ç¬¦åˆ XML è¦å‰‡ï¼Œç„¡æ³•åƒç€è¦½å™¨æˆ– NSAttributedString\.DocumentType\.html å®¹éŒ¯æ­£å¸¸é¡¯ç¤ºã€‚

#### ç«™åœ¨å·¨äººçš„è‚©è†€ä¸Š

ä»¥ä¸Šå…©å€‹æ–¹æ¡ˆéƒ½ä¸èƒ½å®Œç¾å„ªé›…çš„è§£æ±º HTML å•é¡Œï¼Œæ–¼æ˜¯é–‹å§‹æœå°‹æœ‰ç„¡ç¾æˆçš„è§£æ±ºæ–¹æ¡ˆã€‚
- [johnxnguyen](https://github.com/johnxnguyen){:target="_blank"} / [Down](https://github.com/johnxnguyen/Down){:target="_blank"} 
åªæ”¯æ´è¼¸å…¥ Markdown è½‰æ›æˆ Any \(XML/NSAttributedStringâ€¦\)ï¼Œä½†ä¸æ”¯æ´è¼¸å…¥ HTML è½‰æ›ã€‚
- [malcommac](https://github.com/malcommac){:target="_blank"} / [SwiftRichString](https://github.com/malcommac/SwiftRichString){:target="_blank"} 
åº•å±¤æ˜¯ä½¿ç”¨ XMLParserï¼Œå¯¦æ¸¬å‰è¿°æ¡ˆä¾‹ä¹Ÿæœƒæœ‰ä¸€æ¨£å®¹éŒ¯ç‡ 0 çš„å•é¡Œã€‚
- [scinfu](https://github.com/scinfu){:target="_blank"} / [SwiftSoup](https://github.com/scinfu/SwiftSoup){:target="_blank"} 
åªæ”¯æ´ HTML Parser\(Selector\) [ä¸æ”¯æ´è½‰æ›æˆ NSAttributedString](https://github.com/scinfu/SwiftSoup/issues/127){:target="_blank"} ã€‚



> æ‰¾äº†ä¸€å¤§åœˆçµæœéƒ½é¡ä¼¼ä¸Šæ–¹çš„å°ˆæ¡ˆ Orzï¼Œæ²’æœ‰å·¨äººçš„è‚©è†€å¯ä»¥ç«™ã€‚ 




### ZhgChgLi/ZMarkupParser


[![](https://repository-images.githubusercontent.com/602927147/57ce75c1-8548-449c-b44a-f4b0451ed5ea)](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}


æ²’æœ‰å·¨äººçš„è‚©è†€ï¼Œåªå¥½è‡ªå·±ç•¶å·¨äººäº†ï¼Œæ–¼æ˜¯è‡ªè¡Œé–‹ç™¼äº† HTML String to NSAttributedString å·¥å…·ã€‚

ä½¿ç”¨ç´” Swift é–‹ç™¼ï¼Œé€é Regex å‰–æå‡º HTML Tag ä¸¦ç¶“é Tokenizationï¼Œåˆ†æä¿®æ­£ Tag æ­£ç¢ºæ€§\(ä¿®æ­£æ²’æœ‰ end çš„ tag & éŒ¯ä½ tag\)ï¼Œå†è½‰æ›æˆ abstract syntax treeï¼Œæœ€çµ‚ä½¿ç”¨ Visitor Pattern å°‡ HTML Tag èˆ‡æŠ½è±¡æ¨£å¼å°æ‡‰ï¼Œå¾—åˆ°æœ€çµ‚ NSAttributedString çµæœï¼›å…¶ä¸­ä¸ä¾è³´ä»»ä½• Parser Libã€‚
#### ç‰¹è‰²
- æ”¯æ´ HTML Render \(to NSAttributedString\) / Stripper \(å‰é›¢ HTML Tag\) / Selector åŠŸèƒ½
- æ¯” `NSAttributedString.DocumentType.html` æ›´é«˜çš„æ•ˆèƒ½
- è‡ªå‹•åˆ†æä¿®æ­£ Tag æ­£ç¢ºæ€§\(ä¿®æ­£æ²’æœ‰ end çš„ tag & éŒ¯ä½ tag\)
- æ”¯æ´å¾ `style=â€color:redâ€¦â€` å‹•æ…‹è¨­å®šæ¨£å¼
- æ”¯æ´å®¢è£½åŒ–æ¨£å¼æŒ‡å®šï¼Œä¾‹å¦‚ç²—é«”è¦å¤š **ç²—**
- æ”¯æ´å½ˆæ€§å¯æ“´å……æ¨™ç±¤æˆ–è‡ªè¨‚æ¨™ç±¤åŠå±¬æ€§



> è©³ç´°ä»‹ç´¹ã€å®‰è£ä½¿ç”¨å¯åƒè€ƒæ­¤ç¯‡æ–‡ç« ï¼šã€Œ [**ZMarkupParser HTML String è½‰æ› NSAttributedString å·¥å…·**](../a5643de271e4/) ã€ 





å¯ç›´æ¥ [git clone å°ˆæ¡ˆ](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} å¾Œï¼Œæ‰“é–‹ `ZMarkupParser.xcworkspace` Project é¸æ“‡ `ZMarkupParser-Demo` Target ç›´æ¥ Build & Run èµ·ä¾†ç©ç©ã€‚


![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*PzYcnSkW7qKeJBkaiNTKjQ.gif)

[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}
### æŠ€è¡“ç´°ç¯€

å†ä¾†æ‰æ˜¯æœ¬ç¯‡æ–‡ç« æƒ³åˆ†äº«çš„ï¼Œé—œæ–¼é–‹ç™¼é€™å€‹å·¥å…·ä¸Šçš„æŠ€è¡“ç´°ç¯€ã€‚


![é‹ä½œæµç¨‹ç¸½è¦½](/assets/2724f02f6e7/1*YF5L7gefMCMwU1wmnGgy6A.png)

é‹ä½œæµç¨‹ç¸½è¦½

ä¸Šåœ–ç‚ºå¤§æ¦‚çš„é‹ä½œæµç¨‹ï¼Œå¾Œé¢æ–‡ç« æœƒä¸€æ­¥ä¸€æ­¥ä»‹ç´¹åŠé™„ä¸Šç¨‹å¼ç¢¼ã€‚


> âš ï¸ï¸ï¸ï¸ï¸ï¸ æœ¬æ–‡æœƒç›¡é‡ç°¡åŒ– Demo Codeã€æ¸›å°‘æŠ½è±¡è·Ÿæ•ˆèƒ½è€ƒé‡ï¼Œç›¡é‡æŠŠé‡å¿ƒæ”¾åœ¨è§£é‡‹é‹ä½œåŸç†ä¸Šï¼›å¦‚éœ€äº†è§£æœ€çµ‚çµæœè«‹åƒè€ƒå°ˆæ¡ˆ [Source Code](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} ã€‚ 




### ç¨‹å¼ç¢¼åŒ– â€” Tokenization


> a\.k\.a parser, è§£æ 





è«‡åˆ° HTML æ¸²æŸ“æœ€é‡è¦çš„å°±æ˜¯è§£æçš„ç’°ç¯€ï¼Œä»¥å¾€æ˜¯é€é XMLParser å°‡ HTML åšç‚º XML è§£æï¼›ä½†æ˜¯ç„¡æ³•å…‹æœ HTML æ—¥å¸¸ç”¨æ³•ä¸¦ä¸æ˜¯ 100% çš„ XML æœƒé€ æˆè§£æå™¨éŒ¯èª¤ï¼Œä¸”ç„¡æ³•å‹•æ…‹ä¿®æ­£ã€‚

æ’é™¤æ‰ä½¿ç”¨ XMLParser é€™æ¢è·¯ä¹‹å¾Œï¼Œåœ¨ Swift ä¸Šç•™çµ¦æˆ‘å€‘çš„å°±åªå‰©ä½¿ç”¨ Regex æ­£å‰‡ä¾†åšåŒ¹é…è§£æäº†ã€‚

æœ€ä¸€é–‹å§‹æ²’æƒ³å¤ªå¤šï¼Œæƒ³èªªå¯ä»¥ç›´æ¥ç”¨æ­£å‰‡æŒ–å‡ºã€Œæˆå°ã€çš„ HTML Tagï¼Œå†éè¿´å¾€è£¡é¢ä¸€å±¤ä¸€å±¤æ‰¾ HTML Tagï¼Œç›´åˆ°çµæŸï¼›ä½†æ˜¯é€™æ¨£æ²’æœ‰è¾¦æ³•è§£æ±º HTML Tag å¯ä»¥åµŒå¥—ï¼Œæˆ–æƒ³æ”¯æ´éŒ¯ä½å®¹éŒ¯çš„å•é¡Œï¼Œå› æ­¤æˆ‘å€‘æŠŠç­–ç•¥æ”¹æˆæŒ–æˆå‡ºã€Œå–®å€‹ã€ HTML Tagï¼Œä¸¦è¨˜éŒ„æ˜¯ Start Tag, Close Tag or Self\-Closing Tagï¼ŒåŠå…¶ä»–å­—ä¸²çµ„åˆæˆè§£æçµæœé™£åˆ—ã€‚

**Tokenization çµæ§‹å¦‚ä¸‹ï¼š**
```swift
enum HTMLParsedResult {
    case start(StartItem) // <a>
    case close(CloseItem) // </a>
    case selfClosing(SelfClosingItem) // <br/>
    case rawString(NSAttributedString)
}

extension HTMLParsedResult {
    class SelfClosingItem {
        let tagName: String
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?
        
        init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) {
            self.tagName = tagName
            self.tagAttributedString = tagAttributedString
            self.attributes = attributes
        }
    }
    
    class StartItem {
        let tagName: String
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?

        // Start Tag æœ‰å¯èƒ½æ˜¯ç•°å¸¸ HTML Tag ä¹Ÿæœ‰å¯èƒ½æ˜¯æ­£å¸¸æ–‡å­— e.g. <Congratulation!>, å¾ŒçºŒ Normalization å¾Œå¦‚æœç™¼ç¾æ˜¯å­¤ç«‹ Start Tag å‰‡æ¨™è¨˜ç‚º Trueã€‚
        var isIsolated: Bool = false
        
        init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) {
            self.tagName = tagName
            self.tagAttributedString = tagAttributedString
            self.attributes = attributes
        }
        
        // å¾ŒçºŒ Normalization è‡ªå‹•è£œä½ä¿®æ­£ä½¿ç”¨
        func convertToCloseParsedItem() -> CloseItem {
            return CloseItem(tagName: self.tagName)
        }
        
        // å¾ŒçºŒ Normalization è‡ªå‹•è£œä½ä¿®æ­£ä½¿ç”¨
        func convertToSelfClosingParsedItem() -> SelfClosingItem {
            return SelfClosingItem(tagName: self.tagName, tagAttributedString: self.tagAttributedString, attributes: self.attributes)
        }
    }
    
    class CloseItem {
        let tagName: String
        init(tagName: String) {
            self.tagName = tagName
        }
    }
}
```

**ä½¿ç”¨çš„æ­£å‰‡å¦‚ä¸‹ï¼š**
```ruby
<(?:(?<closeTag>\/)?(?<tagName>[A-Za-z0-9]+)(?<tagAttributes>(?:\s*(\w+)\s*=\s*(["|']).*?\5)*)\s*(?<selfClosingTag>\/)?>)
```

\-&gt; [Online Regex101 Playground](https://regex101.com/r/aBrID8/1){:target="_blank"}
- closeTag: åŒ¹é… &lt; `/` a&gt;
- tagName: åŒ¹é… &lt; `a` &gt; or , &lt;/ `a` &gt;
- tagAttributes: åŒ¹é… &lt;a `href=â€https://zhgchg.liâ€ style=â€color:redâ€` &gt;
- selfClosingTag: åŒ¹é… &lt;br `/` &gt;



> \*æ­¤æ­£å‰‡é‚„å¯ä»¥å†å„ªåŒ–ï¼Œä¹‹å¾Œå†ä¾†åš
 

> æ–‡ç« å¾ŒåŠæ®µæœ‰æä¾›é—œæ–¼æ­£å‰‡çš„é™„åŠ è³‡æ–™ï¼Œæœ‰èˆˆè¶£çš„æœ‹å‹å¯ä»¥åƒè€ƒã€‚ 





**çµ„åˆèµ·ä¾†å°±æ˜¯ï¼š**
```swift
var tokenizationResult: [HTMLParsedResult] = []

let expression = try? NSRegularExpression(pattern: pattern, options: expressionOptions)
let attributedString = NSAttributedString(string: "<a>Li<b>nk</a>Bold</b>")
let totalLength = attributedString.string.utf16.count // utf-16 support emoji
var lastMatch: NSTextCheckingResult?

// Start Tags Stack, å…ˆé€²å¾Œå‡º(FILO First In Last Out)
// æª¢æ¸¬ HTML å­—ä¸²æ˜¯å¦éœ€è¦å¾ŒçºŒ Normalization ä¿®æ­£éŒ¯ä½æˆ–è£œ Self-Closing Tag
var stackStartItems: [HTMLParsedResult.StartItem] = []
var needForamatter: Bool = false

expression.enumerateMatches(in: attributedString.string, range: NSMakeRange(0, totoalLength)) { match, _, _ in
  if let match = match {
    // æª¢æŸ¥ Tag ä¹‹é–“æˆ–æ˜¯åˆ°ç¬¬ä¸€å€‹ Tag ä¹‹é–“çš„å­—ä¸²
    // e.g. Test<a>Link</a>zzz<b>bold</b>Test2 - > Test,zzz
    let lastMatchEnd = lastMatch?.range.upperBound ?? 0
    let currentMatchStart = match.range.lowerBound
    if currentMatchStart > lastMatchEnd {
      let rawStringBetweenTag = attributedString.attributedSubstring(from: NSMakeRange(lastMatchEnd, (currentMatchStart - lastMatchEnd)))
      tokenizationResult.append(.rawString(rawStringBetweenTag))
    }

    // <a href="https://zhgchg.li">, </a>
    let matchAttributedString = attributedString.attributedSubstring(from: match.range)
    // a, a
    let matchTag = attributedString.attributedSubstring(from: match.range(withName: "tagName"))?.string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    // false, true
    let matchIsEndTag = matchResult.attributedString(from: match.range(withName: "closeTag"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == "/"
    // href="https://zhgchg.li", nil
    // ç”¨æ­£å‰‡å†æ‹†å‡º HTML Attribute, to [String: String], è«‹åƒè€ƒ Source Code
    let matchTagAttributes = parseAttributes(matchResult.attributedString(from: match.range(withName: "tagAttributes")))
    // false, false
    let matchIsSelfClosingTag = matchResult.attributedString(from: match.range(withName: "selfClosingTag"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == "/"

    if let matchAttributedString = matchAttributedString,
       let matchTag = matchTag {
        if matchIsSelfClosingTag {
          // e.g. <br/>
          tokenizationResult.append(.selfClosing(.init(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes)))
        } else {
          // e.g. <a> or </a>
          if matchIsEndTag {
            // e.g. </a>
            // å¾ Stack å–å‡ºå‡ºç¾ç›¸åŒ TagName çš„ä½ç½®ï¼Œå¾æœ€å¾Œé–‹å§‹
            if let index = stackStartItems.lastIndex(where: { $0.tagName == matchTag }) {
              // å¦‚æœä¸æ˜¯æœ€å¾Œä¸€å€‹ï¼Œä»£è¡¨æœ‰éŒ¯ä½æˆ–éºæ¼é—œé–‰çš„ Tag
              if index != stackStartItems.count - 1 {
                  needForamatter = true
              }
              tokenizationResult.append(.close(.init(tagName: matchTag)))
              stackStartItems.remove(at: index)
            } else {
              // å¤šé¤˜çš„ close tag e.g </a>
              // ä¸å½±éŸ¿å¾ŒçºŒï¼Œç›´æ¥å¿½ç•¥
            }
          } else {
            // e.g. <a>
            let startItem: HTMLParsedResult.StartItem = HTMLParsedResult.StartItem(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes)
            tokenizationResult.append(.start(startItem))
            // å¡åˆ° Stack
            stackStartItems.append(startItem)
          }
        }
     }

    lastMatch = match
  }
}

// æª¢æŸ¥çµå°¾çš„ RawString
// e.g. Test<a>Link</a>Test2 - > Test2
if let lastMatch = lastMatch {
  let currentIndex = lastMatch.range.upperBound
  if totoalLength > currentIndex {
    // é‚„æœ‰å‰©é¤˜å­—ä¸²
    let resetString = attributedString.attributedSubstring(from: NSMakeRange(currentIndex, (totoalLength - currentIndex)))
    tokenizationResult.append(.rawString(resetString))
  }
} else {
  // lastMatch = nil, ä»£è¡¨æ²’æ‰¾åˆ°ä»»ä½•æ¨™ç±¤ï¼Œå…¨éƒ½æ˜¯ç´”æ–‡å­—
  let resetString = attributedString.attributedSubstring(from: NSMakeRange(0, totoalLength))
  tokenizationResult.append(.rawString(resetString))
}

// æª¢æŸ¥ Stack æ˜¯å¦å·²ç¶“æ¸…ç©ºï¼Œå¦‚æœé‚„æœ‰ä»£è¡¨æœ‰ Start Tag æ²’æœ‰å°æ‡‰çš„ End
// æ¨™è¨˜æˆå­¤ç«‹ Start Tag
for stackStartItem in stackStartItems {
  stackStartItem.isIsolated = true
  needForamatter = true
}

print(tokenizationResult)
// [
//    .start("a",["href":"https://zhgchg.li"])
//    .rawString("Li")
//    .start("b",nil)
//    .rawString("nk")
//    .close("a")
//    .rawString("Bold")
//    .close("b")
// ]
```


![é‹ä½œæµç¨‹å¦‚ä¸Šåœ–](/assets/2724f02f6e7/1*U50CX56M_xy1EXZKb69YeA.png)

é‹ä½œæµç¨‹å¦‚ä¸Šåœ–

æœ€çµ‚æœƒå¾—åˆ°ä¸€å€‹ Tokenization çµæœé™£åˆ—ã€‚


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLStringToParsedResultProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLStringToParsedResultProcessor.swift){:target="_blank"} å¯¦ä½œ 




### æ¨™æº–åŒ– â€” Normalization


> a\.k\.a Formatter, æ­£è¦åŒ– 





ç¹¼ä¸Šä¸€æ­¥å–å¾—åˆæ­¥è§£æçµæœå¾Œï¼Œè§£æä¸­å¦‚æœç™¼ç¾é‚„éœ€è¦ Normalizationï¼Œå‰‡éœ€è¦æ­¤æ­¥é©Ÿï¼Œè‡ªå‹•ä¿®æ­£ HTML Tag å•é¡Œã€‚

**HTML Tag å•é¡Œæœ‰ä»¥ä¸‹ä¸‰ç¨®ï¼š**
- HTML Tag ä½†éºæ¼ Close Tag: ä¾‹å¦‚ `&lt;br&gt;`
- ä¸€èˆ¬æ–‡å­—è¢«ç•¶æˆ HTML Tag: ä¾‹å¦‚ `&lt;Congratulation!&gt;`
- HTML Tag å­˜åœ¨éŒ¯ä½å•é¡Œ: ä¾‹å¦‚ `&lt;a&gt;Li&lt;b&gt;nk&lt;/a&gt;Bold&lt;/b&gt;`


ä¿®æ­£æ–¹å¼ä¹Ÿå¾ˆç°¡å–®ï¼Œæˆ‘å€‘éœ€è¦éæ­· Tokenization çµæœçš„å…ƒç´ ï¼Œå˜—è©¦è£œé½Šç¼ºæ¼ã€‚


![é‹ä½œæµç¨‹å¦‚ä¸Šåœ–](/assets/2724f02f6e7/1*Wk-U_sQuvLo1OJhcE1BQPQ.png)

é‹ä½œæµç¨‹å¦‚ä¸Šåœ–
```swift
var normalizationResult = tokenizationResult

// Start Tags Stack, å…ˆé€²å¾Œå‡º(FILO First In Last Out)
var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []
var itemIndex = 0
while itemIndex < newItems.count {
    switch newItems[itemIndex] {
    case .start(let item):
        if item.isIsolated {
            // å¦‚æœç‚ºå­¤ç«‹ Start Tag
            if WC3HTMLTagName(rawValue: item.tagName) == nil && (item.attributes?.isEmpty ?? true) {
                // å¦‚æœä¸æ˜¯ WCS å®šç¾©çš„ HTML Tag & æ²’æœ‰ä»»ä½• HTML Attribute
                // WC3HTMLTagName Enum å¯åƒè€ƒ Source Code
                // åˆ¤å®šç‚º ä¸€èˆ¬æ–‡å­—è¢«ç•¶æˆ HTML Tag
                // æ”¹æˆ raw string type
                normalizationResult[itemIndex] = .rawString(item.tagAttributedString)
            } else {
                // å¦å‰‡ï¼Œæ”¹æˆ self-closing tag, e.g. <br> -> <br/>
                normalizationResult[itemIndex] = .selfClosing(item.convertToSelfClosingParsedItem())
            }
            itemIndex += 1
        } else {
            // æ­£å¸¸ Start Tag, åŠ å…¥ Stack
            stackExpectedStartItems.append(item)
            itemIndex += 1
        }
    case .close(let item):
        // é‡åˆ° Close Tag
        // å–å¾— Start Stack Tag åˆ°æ­¤ Close Tag ä¸­é–“éš”çš„ Tags
        // e.g <a><u><b>[CurrentIndex]</a></u></b> -> é–“éš” 0
        // e.g <a><u><b>[CurrentIndex]</a></u></b> -> é–“éš” b,u

        let reversedStackExpectedStartItems = Array(stackExpectedStartItems.reversed())
        guard let reversedStackExpectedStartItemsOccurredIndex = reversedStackExpectedStartItems.firstIndex(where: { $0.tagName == item.tagName }) else {
            itemIndex += 1
            continue
        }
        
        let reversedStackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItems.prefix(upTo: reversedStackExpectedStartItemsOccurredIndex))
        
        // é–“éš” 0, ä»£è¡¨ tag æ²’éŒ¯ä½
        guard reversedStackExpectedStartItemsOccurred.count != 0 else {
            // is pair, pop
            stackExpectedStartItems.removeLast()
            itemIndex += 1
            continue
        }
        
        // æœ‰å…¶ä»–é–“éš”ï¼Œè‡ªå‹•åœ¨å‰å€™è£œæœŸé–“æ ¼ Tag
        // e.g <a><u><b>[CurrentIndex]</a></u></b> ->
        // e.g <a><u><b>[CurrentIndex]</b></u></a><b></u></u></b>
        let stackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItemsOccurred.reversed())
        let afterItems = stackExpectedStartItemsOccurred.map({ HTMLParsedResult.start($0) })
        let beforeItems = reversedStackExpectedStartItemsOccurred.map({ HTMLParsedResult.close($0.convertToCloseParsedItem()) })
        normalizationResult.insert(contentsOf: afterItems, at: newItems.index(after: itemIndex))
        normalizationResult.insert(contentsOf: beforeItems, at: itemIndex)
        
        itemIndex = newItems.index(after: itemIndex) + stackExpectedStartItemsOccurred.count
        
        // æ›´æ–° Start Stack Tags
        // e.g. -> b,u
        stackExpectedStartItems.removeAll { startItem in
            return reversedStackExpectedStartItems.prefix(through: reversedStackExpectedStartItemsOccurredIndex).contains(where: { $0 === startItem })
        }
    case .selfClosing, .rawString:
        itemIndex += 1
    }
}

print(normalizationResult)
// [
//    .start("a",["href":"https://zhgchg.li"])
//    .rawString("Li")
//    .start("b",nil)
//    .rawString("nk")
//    .close("b")
//    .close("a")
//    .start("b",nil)
//    .rawString("Bold")
//    .close("b")
// ]
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLParsedResultFormatterProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLParsedResultFormatterProcessor.swift){:target="_blank"} å¯¦ä½œ 




### Abstract Syntax Tree


> a\.k\.a AST, æŠ½è±¡æ¨¹ 





ç¶“é Tokenization & Normalization è³‡æ–™é è™•ç†å®Œæˆå¾Œï¼Œå†ä¾†è¦å°‡çµæœè½‰æ›æˆæŠ½è±¡æ¨¹ğŸŒ²ã€‚


![å¦‚ä¸Šåœ–](/assets/2724f02f6e7/1*40z0o7R0OROURWCQVDmKrw.png)

å¦‚ä¸Šåœ–

è½‰æ›æˆæŠ½è±¡æ¨¹å¯ä»¥æ–¹ä¾¿æˆ‘å€‘æ—¥å¾Œçš„æ“ä½œåŠæ“´å……ï¼Œä¾‹å¦‚å¯¦ç¾ Selector åŠŸèƒ½æˆ–æ˜¯åšå…¶ä»–è½‰æ›ï¼Œä¾‹å¦‚ HTML To Markdownï¼›äº¦æˆ–æ˜¯æ—¥å¾Œæƒ³å¢åŠ  Markdown to NSAttributedStringï¼Œåªéœ€å¯¦ç¾ Markdown çš„ Tokenization & Normalization å°±èƒ½å®Œæˆã€‚

**é¦–å…ˆæˆ‘å€‘å®šç¾©ä¸€å€‹ Markup Protocolï¼Œæœ‰ Child & Parent å±¬æ€§ï¼Œç´€éŒ„è‘‰å­è·Ÿæ¨¹æçš„è³‡è¨Š:**
```swift
protocol Markup: AnyObject {
    var parentMarkup: Markup? { get set }
    var childMarkups: [Markup] { get set }
    
    func appendChild(markup: Markup)
    func prependChild(markup: Markup)
    func accept<V: MarkupVisitor>(_ visitor: V) -> V.Result
}

extension Markup {
    func appendChild(markup: Markup) {
        markup.parentMarkup = self
        childMarkups.append(markup)
    }
    
    func prependChild(markup: Markup) {
        markup.parentMarkup = self
        childMarkups.insert(markup, at: 0)
    }
}
```

å¦å¤–æ­é…ä½¿ç”¨ [Visitor Pattern](../ba5773a7bfea/) ï¼Œå°‡æ¯ç¨®æ¨£å¼å±¬æ€§éƒ½å®šç¾©æˆä¸€å€‹ç‰©ä»¶ Elementï¼Œå†é€éä¸åŒçš„ Visit ç­–ç•¥å–å¾—å€‹åˆ¥çš„å¥—ç”¨çµæœã€‚
```swift
protocol MarkupVisitor {
    associatedtype Result
        
    func visit(markup: Markup) -> Result
    
    func visit(_ markup: RootMarkup) -> Result
    func visit(_ markup: RawStringMarkup) -> Result
    
    func visit(_ markup: BoldMarkup) -> Result
    func visit(_ markup: LinkMarkup) -> Result
    //...
}

extension MarkupVisitor {
    func visit(markup: Markup) -> Result {
        return markup.accept(self)
    }
}
```

**åŸºæœ¬ Markup ç¯€é»ï¼š**
```swift
// æ ¹ç¯€é»
final class RootMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

// è‘‰ç¯€é»
final class RawStringMarkup: Markup {
    let attributedString: NSAttributedString
    
    init(attributedString: NSAttributedString) {
        self.attributedString = attributedString
    }
    
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}
```

**å®šç¾© Markup æ¨£å¼ç¯€é»ï¼š**
```swift
// æ¨¹æç¯€é»:

// é€£çµæ¨£å¼
final class LinkMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

// ç²—é«”æ¨£å¼
final class BoldMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [Markup](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/Markup){:target="_blank"} å¯¦ä½œ 





è½‰æ›æˆæŠ½è±¡æ¨¹ä¹‹å‰æˆ‘å€‘é‚„éœ€è¦â€¦
#### MarkupComponent

**å› ç‚ºæˆ‘å€‘çš„æ¨¹çµæ§‹ä¸èˆ‡ä»»ä½•è³‡æ–™çµæ§‹æœ‰ä¾è³´\(ä¾‹å¦‚ a ç¯€é»/LinkMarkupï¼Œæ‡‰è©²è¦æœ‰ url è³‡è¨Šæ‰èƒ½åšå¾ŒçºŒ Render\)ã€‚** 
**å°æ­¤æˆ‘å€‘å¦å¤–å®šç¾©ä¸€å€‹å®¹å™¨å­˜æ”¾æ¨¹ç¯€é»èˆ‡ç¯€é»ç›¸é—œçš„è³‡æ–™è³‡è¨Š:**
```swift
protocol MarkupComponent {
    associatedtype T
    var markup: Markup { get }
    var value: T { get }
    
    init(markup: Markup, value: T)
}

extension Sequence where Iterator.Element: MarkupComponent {
    func value(markup: Markup) -> Element.T? {
        return self.first(where:{ $0.markup === markup })?.value as? Element.T
    }
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [MarkupComponent](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/MarkupComponent){:target="_blank"} å¯¦ä½œ 





ä¹Ÿå¯å°‡ Markup å®£å‘Š `Hashable` ï¼Œç›´æ¥ä½¿ç”¨ Dictionary å­˜æ”¾å€¼ `[Markup: Any]` ï¼Œä½†æ˜¯é€™æ¨£ Markup å°±ä¸èƒ½è¢«ç•¶ä¸€èˆ¬ type ä½¿ç”¨ï¼Œè¦åŠ ä¸Š `any Markup` ã€‚
#### HTMLTag & HTMLTagName & HTMLTagNameVisitor

HTML Tag Name éƒ¨åˆ†æˆ‘å€‘ä¹Ÿåšäº†ä¸€å±¤çš„æŠ½è±¡ï¼Œè®“ä½¿ç”¨è€…èƒ½è‡ªè¡Œæ±ºå®šæœ‰å“ªäº› Tag éœ€è¦è¢«è™•ç†ï¼Œä¹Ÿèƒ½æ–¹ä¾¿æ—¥å¾Œçš„æ“´å……ï¼Œä¾‹å¦‚: `&lt;strong&gt;` Tag Name åŒæ¨£å¯å°æ‡‰åˆ° `BoldMarkup` ã€‚
```
public protocol HTMLTagName {
    var string: String { get }
    func accept<V: HTMLTagNameVisitor>(_ visitor: V) -> V.Result
}

public struct A_HTMLTagName: HTMLTagName {
    public let string: String = WC3HTMLTagName.a.rawValue
    
    public init() {
        
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}

public struct B_HTMLTagName: HTMLTagName {
    public let string: String = WC3HTMLTagName.b.rawValue
    
    public init() {
        
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLTagNameVisitor](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTagNameVisitor.swift){:target="_blank"} å¯¦ä½œ 





> å¦å¤–åƒè€ƒ W3C wiki åˆ—èˆ‰äº† HTML tag name enum: [WC3HTMLTagName\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/WC3HTMLTagName.swift){:target="_blank"} 





**HTMLTag å‰‡æ˜¯å–®ç´”ä¸€å€‹å®¹å™¨ç‰©ä»¶ï¼Œå› ç‚ºæˆ‘å€‘å¸Œæœ›èƒ½è®“å¤–éƒ¨æŒ‡å®š HTML Tag å°æ‡‰åˆ°çš„æ¨£å¼ï¼Œæ‰€ä»¥å®£å‘Šä¸€å€‹å®¹å™¨æ”¾åœ¨ä¸€èµ·:**
```swift
struct HTMLTag {
    let tagName: HTMLTagName
    let customStyle: MarkupStyle? // å¾Œé¢ä»‹ç´¹ Render æœƒè§£é‡‹
    
    init(tagName: HTMLTagName, customStyle: MarkupStyle? = nil) {
        self.tagName = tagName
        self.customStyle = customStyle
    }
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLTag](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTag.swift3){:target="_blank"} å¯¦ä½œ 




#### HTMLTagNameToHTMLMarkupVisitor
```swift
struct HTMLTagNameToMarkupVisitor: HTMLTagNameVisitor {
    typealias Result = Markup
    
    let attributes: [String: String]?
    
    func visit(_ tagName: A_HTMLTagName) -> Result {
        return LinkMarkup()
    }
    
    func visit(_ tagName: B_HTMLTagName) -> Result {
        return BoldMarkup()
    }
    //...
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLTagNameToHTMLMarkupVisitor](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagNameToHTMLMarkupVisitor.swift){:target="_blank"} å¯¦ä½œ 




#### è½‰æ›æˆæŠ½è±¡æ¨¹ with HTML è³‡æ–™

æˆ‘å€‘è¦å°‡ Normalization å¾Œçš„ HTML è³‡æ–™çµæœè½‰æ›æˆæŠ½è±¡æ¨¹ï¼Œé¦–å…ˆå®£å‘Šä¸€å€‹èƒ½å­˜æ”¾ HTML è³‡æ–™çš„ MarkupComponent è³‡æ–™çµæ§‹:
```swift
struct HTMLElementMarkupComponent: MarkupComponent {
    struct HTMLElement {
        let tag: HTMLTag
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?
    }
    
    typealias T = HTMLElement
    
    let markup: Markup
    let value: HTMLElement
    init(markup: Markup, value: HTMLElement) {
        self.markup = markup
        self.value = value
    }
}
```

**è½‰æ›æˆ Markup æŠ½è±¡æ¨¹:**
```swift
var htmlElementComponents: [HTMLElementMarkupComponent] = []
let rootMarkup = RootMarkup()
var currentMarkup: Markup = rootMarkup

let htmlTags: [String: HTMLTag]
init(htmlTags: [HTMLTag]) {
  self.htmlTags = Dictionary(uniqueKeysWithValues: htmlTags.map{ ($0.tagName.string, $0) })
}

// Start Tags Stack, ç¢ºä¿æœ‰æ­£ç¢º pop tag
// å‰é¢å·²ç¶“åšé Normalization äº†, æ‡‰è©²ä¸æœƒå‡ºéŒ¯, åªæ˜¯ç¢ºä¿è€Œå·²
var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []
for thisItem in from {
    switch thisItem {
    case .start(let item):
        let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes)
        let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName))
        // ç”¨ Visitor å•å°æ‡‰çš„ Markup
        let markup = visitor.visit(tagName: htmlTag.tagName)
        
        // æŠŠè‡ªå·±åŠ å…¥ç•¶å‰æçš„è‘‰ç¯€é»
        // è‡ªå·±è®Šæˆç•¶å‰æç¯€é»
        htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes)))
        currentMarkup.appendChild(markup: markup)
        currentMarkup = markup
        
        stackExpectedStartItems.append(item)
    case .selfClosing(let item):
        // ç›´æ¥åŠ å…¥ç•¶å‰æçš„è‘‰ç¯€é»
        let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes)
        let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName))
        let markup = visitor.visit(tagName: htmlTag.tagName)
        htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes)))
        currentMarkup.appendChild(markup: markup)
    case .close(let item):
        if let lastTagName = stackExpectedStartItems.popLast()?.tagName,
           lastTagName == item.tagName {
            // é‡åˆ° Close Tag, å°±å›åˆ°ä¸Šä¸€å±¤
            currentMarkup = currentMarkup.parentMarkup ?? currentMarkup
        }
    case .rawString(let attributedString):
        // ç›´æ¥åŠ å…¥ç•¶å‰æçš„è‘‰ç¯€é»
        currentMarkup.appendChild(markup: RawStringMarkup(attributedString: attributedString))
    }
}

// print(htmlElementComponents)
// [(markup: LinkMarkup, (tag: a, attributes: ["href":"zhgchg.li"]...)]
```


![é‹ä½œçµæœå¦‚ä¸Šåœ–](/assets/2724f02f6e7/1*D-oMszCDzsBpUYnCEWGKHQ.png)

é‹ä½œçµæœå¦‚ä¸Šåœ–


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLParsedResultToHTMLElementWithRootMarkupProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLParsedResultToHTMLElementWithRootMarkupProcessor.swift){:target="_blank"} å¯¦ä½œ 




#### æ­¤æ™‚ï¼Œå…¶å¯¦æˆ‘å€‘å°±å®Œæˆ Selector çš„åŠŸèƒ½äº† ğŸ‰
```swift
public class HTMLSelector: CustomStringConvertible {
    
    let markup: Markup
    let componets: [HTMLElementMarkupComponent]
    init(markup: Markup, componets: [HTMLElementMarkupComponent]) {
        self.markup = markup
        self.componets = componets
    }
    
    public func filter(_ htmlTagName: String) -> [HTMLSelector] {
        let result = markup.childMarkups.filter({ componets.value(markup: $0)?.tag.tagName.isEqualTo(htmlTagName) ?? false })
        return result.map({ .init(markup: $0, componets: componets) })
    }

    //...
}
```

æˆ‘å€‘å¯ä»¥ä¸€å±¤ä¸€å±¤ Filter è‘‰ç¯€é»ç‰©ä»¶ã€‚


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLSelector](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLSelector.swift){:target="_blank"} å¯¦ä½œ 




### Parser â€” HTML to MarkupSyle \(Abstract of NSAttributedString\.Key\)

å†ä¾†æˆ‘å€‘è¦å…ˆå®Œæˆå°‡ HTML è½‰æ›æˆ MarkupStyle \(NSAttributedString\.Key\)ã€‚

NSAttributedString æ˜¯é€é NSAttributedString\.Key Attributes ä¾†è¨­å®šå­—çš„æ¨£å¼ï¼Œæˆ‘å€‘æŠ½è±¡å‡º NSAttributedString\.Key çš„æ‰€æœ‰æ¬„ä½å°æ‡‰åˆ° MarkupStyle,MarkupStyleColor,MarkupStyleFont,MarkupStyleParagraphStyleã€‚

**ç›®çš„ï¼š**
- åŸæœ¬çš„ Attributes çš„è³‡æ–™çµæ§‹æ˜¯ `[NSAttributedString.Key: Any?]` ï¼Œå¦‚æœç›´æ¥æš´éœ²å‡ºå»ï¼Œæˆ‘å€‘å¾ˆé›£æ§åˆ¶ä½¿ç”¨è€…å¸¶å…¥çš„å€¼ï¼Œå¦‚æœå¸¶éŒ¯é‚„æœƒé€ æˆé–ƒé€€ï¼Œä¾‹å¦‚ `.font: 123`
- æ¨£å¼éœ€è¦å¯ç¹¼æ‰¿ï¼Œä¾‹å¦‚ `&lt;a&gt;&lt;b&gt;test&lt;/b&gt;&lt;/a&gt;` ï¼Œtest å­—ä¸²çš„æ¨£å¼å°±æ˜¯ç¹¼æ‰¿è‡ª link çš„ bold \(bold\+linke\)ï¼›å¦‚æœç›´æ¥æš´éœ² Dictionary å‡ºå»å¾ˆé›£æ§åˆ¶å¥½ç¹¼æ‰¿è¦
- å°è£ iOS/macOS \(UIKit/Appkit\) æ‰€å±¬ç‰©ä»¶

#### MarkupStyle Struct
```swift
public struct MarkupStyle {
    public var font:MarkupStyleFont
    public var paragraphStyle:MarkupStyleParagraphStyle
    public var foregroundColor:MarkupStyleColor? = nil
    public var backgroundColor:MarkupStyleColor? = nil
    public var ligature:NSNumber? = nil
    public var kern:NSNumber? = nil
    public var tracking:NSNumber? = nil
    public var strikethroughStyle:NSUnderlineStyle? = nil
    public var underlineStyle:NSUnderlineStyle? = nil
    public var strokeColor:MarkupStyleColor? = nil
    public var strokeWidth:NSNumber? = nil
    public var shadow:NSShadow? = nil
    public var textEffect:String? = nil
    public var attachment:NSTextAttachment? = nil
    public var link:URL? = nil
    public var baselineOffset:NSNumber? = nil
    public var underlineColor:MarkupStyleColor? = nil
    public var strikethroughColor:MarkupStyleColor? = nil
    public var obliqueness:NSNumber? = nil
    public var expansion:NSNumber? = nil
    public var writingDirection:NSNumber? = nil
    public var verticalGlyphForm:NSNumber? = nil
    //...

    // ç¹¼æ‰¿è‡ª...
    // é è¨­: æ¬„ä½ç‚º nil æ™‚ï¼Œå¾ from å¡«å…¥ç•¶å‰è³‡æ–™ç‰©ä»¶
    mutating func fillIfNil(from: MarkupStyle?) {
        guard let from = from else { return }
        
        var currentFont = self.font
        currentFont.fillIfNil(from: from.font)
        self.font = currentFont
        
        var currentParagraphStyle = self.paragraphStyle
        currentParagraphStyle.fillIfNil(from: from.paragraphStyle)
        self.paragraphStyle = currentParagraphStyle
        //..
    }

    // MarkupStyle to NSAttributedString.Key: Any
    func render() -> [NSAttributedString.Key: Any] {
        var data: [NSAttributedString.Key: Any] = [:]
        
        if let font = font.getFont() {
            data[.font] = font
        }

        if let ligature = self.ligature {
            data[.ligature] = ligature
        }
        //...
        return data
    }
}

public struct MarkupStyleFont: MarkupStyleItem {
    public enum FontWeight {
        case style(FontWeightStyle)
        case rawValue(CGFloat)
    }
    public enum FontWeightStyle: String {
        case ultraLight, light, thin, regular, medium, semibold, bold, heavy, black
        // ...
    }
    
    public var size: CGFloat?
    public var weight: FontWeight?
    public var italic: Bool?
    //...
}

public struct MarkupStyleParagraphStyle: MarkupStyleItem {
    public var lineSpacing:CGFloat? = nil
    public var paragraphSpacing:CGFloat? = nil
    public var alignment:NSTextAlignment? = nil
    public var headIndent:CGFloat? = nil
    public var tailIndent:CGFloat? = nil
    public var firstLineHeadIndent:CGFloat? = nil
    public var minimumLineHeight:CGFloat? = nil
    public var maximumLineHeight:CGFloat? = nil
    public var lineBreakMode:NSLineBreakMode? = nil
    public var baseWritingDirection:NSWritingDirection? = nil
    public var lineHeightMultiple:CGFloat? = nil
    public var paragraphSpacingBefore:CGFloat? = nil
    public var hyphenationFactor:Float? = nil
    public var usesDefaultHyphenation:Bool? = nil
    public var tabStops: [NSTextTab]? = nil
    public var defaultTabInterval:CGFloat? = nil
    public var textLists: [NSTextList]? = nil
    public var allowsDefaultTighteningForTruncation:Bool? = nil
    public var lineBreakStrategy: NSParagraphStyle.LineBreakStrategy? = nil
    //...
}

public struct MarkupStyleColor {
    let red: Int
    let green: Int
    let blue: Int
    let alpha: CGFloat
    //...
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [MarkupStyle](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/MarkupStyle){:target="_blank"} å¯¦ä½œ 





> å¦å¤–ä¹Ÿåƒè€ƒ W3c wiki, browser predefined color name åˆ—èˆ‰äº†å°æ‡‰ color name text & color R,G,B enum: [MarkupStyleColorName\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyleColorName.swift){:target="_blank"} 




#### HTMLTagStyleAttribute & HTMLTagStyleAttributeVisitor

é€™é‚Šå¤šæä¸€ä¸‹é€™å…©å€‹ç‰©ä»¶ï¼Œå› ç‚º HTML Tag æ˜¯å…è¨±æ­é…å¾ CSS è¨­å®šæ¨£å¼çš„ï¼›å°æ­¤æˆ‘å€‘åŒ HTMLTagName çš„æŠ½è±¡ï¼Œå†å¥—ç”¨ä¸€æ¬¡åœ¨ HTML Style Attribute ä¸Šã€‚

ä¾‹å¦‚ HTML å¯èƒ½æœƒçµ¦ï¼š `&lt;a style=â€color:red;font-size:14pxâ€&gt;RedLink&lt;/a&gt;` ï¼Œä»£è¡¨é€™å€‹é€£çµè¦è¨­å®šæˆç´…è‰²ã€å¤§å° 14pxã€‚
```
public protocol HTMLTagStyleAttribute {
    var styleName: String { get }
    
    func accept<V: HTMLTagStyleAttributeVisitor>(_ visitor: V) -> V.Result
}

public protocol HTMLTagStyleAttributeVisitor {
    associatedtype Result
    
    func visit(styleAttribute: HTMLTagStyleAttribute) -> Result
    func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -> Result
    func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -> Result
    //...
}

public extension HTMLTagStyleAttributeVisitor {
    func visit(styleAttribute: HTMLTagStyleAttribute) -> Result {
        return styleAttribute.accept(self)
    }
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLTagStyleAttribute](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTagStyleAttribute){:target="_blank"} å¯¦ä½œ 




#### HTMLTagStyleAttributeToMarkupStyleVisitor
```swift
struct HTMLTagStyleAttributeToMarkupStyleVisitor: HTMLTagStyleAttributeVisitor {
    typealias Result = MarkupStyle?
    
    let value: String
    
    func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -> Result {
        // æ­£å‰‡æŒ–å– Color Hex or Mapping from HTML Pre-defined Color Name, è«‹åƒè€ƒ Source Code
        guard let color = MarkupStyleColor(string: value) else { return nil }
        return MarkupStyle(foregroundColor: color)
    }
    
    func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -> Result {
        // æ­£å‰‡æŒ–å– 10px -> 10, è«‹åƒè€ƒ Source Code
        guard let size = self.convert(fromPX: value) else { return nil }
        return MarkupStyle(font: MarkupStyleFont(size: CGFloat(size)))
    }
    // ...
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLTagAttributeToMarkupStyleVisitor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagAttributeToMarkupStyleVisitor.swift){:target="_blank"} å¯¦ä½œ 





init çš„ value = attribute çš„å€¼ï¼Œä¾ç…§ visit é¡å‹è½‰æ›åˆ°å°æ‡‰ MarkupStyle æ¬„ä½ã€‚
#### HTMLElementMarkupComponentMarkupStyleVisitor

ä»‹ç´¹å®Œ MarkupStyle ç‰©ä»¶å¾Œï¼Œæˆ‘å€‘è¦å¾ Normalization çš„ HTMLElementComponents çµæœè½‰æ›æˆ MarkupStyleã€‚
```swift
// MarkupStyle ç­–ç•¥
public enum MarkupStylePolicy {
    case respectMarkupStyleFromCode // å¾ Code ä¾†çš„ç‚ºä¸», ç”¨ HTML Style Attribute ä¾†çš„å¡«ç©º
    case respectMarkupStyleFromHTMLStyleAttribute // å¾ HTML Style Attribute ä¾†çš„ç‚ºä¸», ç”¨ Code ä¾†çš„å¡«ç©º
}

struct HTMLElementMarkupComponentMarkupStyleVisitor: MarkupVisitor {

    typealias Result = MarkupStyle?
    
    let policy: MarkupStylePolicy
    let components: [HTMLElementMarkupComponent]
    let styleAttributes: [HTMLTagStyleAttribute]

    func visit(_ markup: BoldMarkup) -> Result {
        // .bold åªæ˜¯å®šç¾©åœ¨ MarkupStyle ä¸­çš„é è¨­æ¨£å¼, è«‹åƒè€ƒ Source Code
        return defaultVisit(components.value(markup: markup), defaultStyle: .bold)
    }
    
    func visit(_ markup: LinkMarkup) -> Result {
        // .link åªæ˜¯å®šç¾©åœ¨ MarkupStyle ä¸­çš„é è¨­æ¨£å¼, è«‹åƒè€ƒ Source Code
        var markupStyle = defaultVisit(components.value(markup: markup), defaultStyle: .link) ?? .link
        
        // å¾ HtmlElementComponents å–å¾— LinkMarkup å°æ‡‰çš„ HtmlElement
        // å¾ HtmlElement ä¸­çš„ attributes æ‰¾ href åƒæ•¸ (HTML å¸¶ URL String çš„æ–¹å¼)
        if let href = components.value(markup: markup)?.attributes?["href"] as? String,
           let url = URL(string: href) {
            markupStyle.link = url
        }
        return markupStyle
    }

    // ...
}

extension HTMLElementMarkupComponentMarkupStyleVisitor {
    // å–å¾— HTMLTag å®¹å™¨ä¸­æŒ‡å®šæƒ³å®¢è£½åŒ–çš„ MarkupStyle
    private func customStyle(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?) -> MarkupStyle? {
        guard let customStyle = htmlElement?.tag.customStyle else {
            return nil
        }
        return customStyle
    }
    
    // é è¨­å‹•ä½œ
    func defaultVisit(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?, defaultStyle: MarkupStyle? = nil) -> Result {
        var markupStyle: MarkupStyle? = customStyle(htmlElement) ?? defaultStyle
        // å¾ HtmlElementComponents å–å¾— LinkMarkup å°æ‡‰çš„ HtmlElement
        // çœ‹çœ‹ HtmlElement ä¸­çš„ attributes æœ‰æ²’æœ‰ `Style` Attribute
        guard let styleString = htmlElement?.attributes?["style"],
              styleAttributes.count > 0 else {
            // æ²’æœ‰
            return markupStyle
        }

        // æœ‰ Style Attributes
        // åˆ‡å‰² Style Value å­—ä¸²æˆé™£åˆ—
        // font-size:14px;color:red -> ["font-size":"14px","color":"red"]
        let styles = styleString.split(separator: ";").filter { $0.trimmingCharacters(in: .whitespacesAndNewlines) != "" }.map { $0.split(separator: ":") }
        
        for style in styles {
            guard style.count == 2 else {
                continue
            }
            // e.g font-szie
            let key = style[0].trimmingCharacters(in: .whitespacesAndNewlines)
            // e.g. 14px
            let value = style[1].trimmingCharacters(in: .whitespacesAndNewlines)
            
            if let styleAttribute = styleAttributes.first(where: { $0.isEqualTo(styleName: key) }) {
                // ä½¿ç”¨ä¸Šæ–‡ä¸­çš„ HTMLTagStyleAttributeToMarkupStyleVisitor æ›å› MarkupStyle
                let visitor = HTMLTagStyleAttributeToMarkupStyleVisitor(value: value)
                if var thisMarkupStyle = visitor.visit(styleAttribute: styleAttribute) {
                    // Style Attribute æœ‰æ›å›å€¼æ™‚..
                    // åˆä½µä¸Šä¸€å€‹ MarkupStyle çµæœ
                    thisMarkupStyle.fillIfNil(from: markupStyle)
                    markupStyle = thisMarkupStyle
                }
            }
        }
        
        // å¦‚æœæœ‰é è¨­ Style
        if var defaultStyle = defaultStyle {
            switch policy {
                case .respectMarkupStyleFromHTMLStyleAttribute:
                  // Style Attribute MarkupStyle ç‚ºä¸»ï¼Œç„¶å¾Œ
                  // åˆä½µ defaultStyle çµæœ
                    markupStyle?.fillIfNil(from: defaultStyle)
                case .respectMarkupStyleFromCode:
                  // defaultStyle ç‚ºä¸»ï¼Œç„¶å¾Œ
                  // åˆä½µ Style Attribute MarkupStyle çµæœ
                  defaultStyle.fillIfNil(from: markupStyle)
                  markupStyle = defaultStyle
            }
        }
        
        return markupStyle
    }
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLTagAttributeToMarkupStyleVisitor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagAttributeToMarkupStyleVisitor.swift){:target="_blank"} å¯¦ä½œ 





æˆ‘å€‘æœƒå®šç¾©éƒ¨åˆ†é è¨­æ¨£å¼åœ¨ [MarkupStyle](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyle%2BExtension.swift){:target="_blank"} ä¸­ï¼Œéƒ¨åˆ† Markup å¦‚æœæ²’æœ‰å¾ Code å¤–éƒ¨æŒ‡å®š Tag æƒ³è¦çš„æ¨£å¼æ™‚æœƒä½¿ç”¨é è¨­æ¨£å¼ã€‚

**æ¨£å¼ç¹¼æ‰¿ç­–ç•¥æœ‰å…©ç¨®ï¼š**
- respectMarkupStyleFromCode:
ä½¿ç”¨é è¨­æ¨£å¼ç‚ºä¸»ï¼›å†çœ‹ Style Attributes ä¸­èƒ½è£œä¸Šä»€éº¼æ¨£å¼ï¼Œå¦‚æœæœ¬ä¾†å°±æœ‰å€¼å‰‡å¿½ç•¥ã€‚
- respectMarkupStyleFromHTMLStyleAttribute:
çœ‹ Style Attributes ç‚ºä¸»ï¼›å†çœ‹ é è¨­æ¨£å¼ ä¸­èƒ½è£œä¸Šä»€éº¼æ¨£å¼ï¼Œå¦‚æœæœ¬ä¾†å°±æœ‰å€¼å‰‡å¿½ç•¥ã€‚

#### HTMLElementWithMarkupToMarkupStyleProcessor

å°‡ Normalization çµæœè½‰æ›æˆ AST & MarkupStyleComponentã€‚

**æ–°å®£å‘Šä¸€å€‹ MarkupComponent é€™æ¬¡è¦å­˜æ”¾å°æ‡‰ MarkupStyle:**
```swift
struct MarkupStyleComponent: MarkupComponent {
    typealias T = MarkupStyle
    
    let markup: Markup
    let value: MarkupStyle
    init(markup: Markup, value: MarkupStyle) {
        self.markup = markup
        self.value = value
    }
}
```

**ç°¡å–®éæ­·å€‹ Markup Tree & HTMLElementMarkupComponent çµæ§‹:**
```swift
let styleAttributes: [HTMLTagStyleAttribute]
let policy: MarkupStylePolicy
    
func process(from: (Markup, [HTMLElementMarkupComponent])) -> [MarkupStyleComponent] {
  var components: [MarkupStyleComponent] = []
  let visitor = HTMLElementMarkupComponentMarkupStyleVisitor(policy: policy, components: from.1, styleAttributes: styleAttributes)
  walk(markup: from.0, visitor: visitor, components: &components)
  return components
}
    
func walk(markup: Markup, visitor: HTMLElementMarkupComponentMarkupStyleVisitor, components: inout [MarkupStyleComponent]) {
        
  if let markupStyle = visitor.visit(markup: markup) {
    components.append(.init(markup: markup, value: markupStyle))
  }
        
  for markup in markup.childMarkups {
    walk(markup: markup, visitor: visitor, components: &components)
  }
}

// print(components)
// [(markup: LinkMarkup, MarkupStyle(link: https://zhgchg.li, color: .blue)]
// [(markup: BoldMarkup, MarkupStyle(font: .init(weight: .bold))]
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [HTMLElementWithMarkupToMarkupStyleProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLElementWithMarkupToMarkupStyleProcessor.swift){:target="_blank"} å¯¦ä½œ 






![æµç¨‹çµæœå¦‚ä¸Šåœ–](/assets/2724f02f6e7/1*JEMBNdbQcBgDQ49jFw4ePQ.png)

æµç¨‹çµæœå¦‚ä¸Šåœ–
### Render â€” Convert To NSAttributedString

ç¾åœ¨æˆ‘å€‘æœ‰äº† HTML Tag æŠ½è±¡æ¨¹çµæ§‹ã€HTML Tag å°æ‡‰çš„ MarkupStyle å¾Œï¼›æœ€å¾Œä¸€æ­¥æˆ‘å€‘å°±èƒ½ä¾†ç”¢å‡ºæœ€å¾Œçš„ NSAttributedString æ¸²æŸ“çµæœã€‚
#### MarkupNSAttributedStringVisitor

visit markup to NSAttributedString
```swift
struct MarkupNSAttributedStringVisitor: MarkupVisitor {
    typealias Result = NSAttributedString
    
    let components: [MarkupStyleComponent]
    // root / base çš„ MarkupStyle, å¤–éƒ¨æŒ‡å®šï¼Œä¾‹å¦‚å¯æŒ‡å®šæ•´ä¸²å­—çš„å¤§å°
    let rootStyle: MarkupStyle?
    
    func visit(_ markup: RootMarkup) -> Result {
        // å¾€ä¸‹çœ‹ RawString ç‰©ä»¶
        return collectAttributedString(markup)
    }
    
    func visit(_ markup: RawStringMarkup) -> Result {
        // å›å‚³ Raw String
        // æœé›†éˆä¸Šçš„æ‰€æœ‰ MarkupStyle
        // å¥—ç”¨ Style åˆ° NSAttributedString
        return applyMarkupStyle(markup.attributedString, with: collectMarkupStyle(markup))
    }
    
    func visit(_ markup: BoldMarkup) -> Result {
        // å¾€ä¸‹çœ‹ RawString ç‰©ä»¶
        return collectAttributedString(markup)
    }
    
    func visit(_ markup: LinkMarkup) -> Result {
        // å¾€ä¸‹çœ‹ RawString ç‰©ä»¶
        return collectAttributedString(markup)
    }
    // ...
}

private extension MarkupNSAttributedStringVisitor {
    // å¥—ç”¨ Style åˆ° NSAttributedString
    func applyMarkupStyle(_ attributedString: NSAttributedString, with markupStyle: MarkupStyle?) -> NSAttributedString {
        guard let markupStyle = markupStyle else { return attributedString }
        let mutableAttributedString = NSMutableAttributedString(attributedString: attributedString)
        mutableAttributedString.addAttributes(markupStyle.render(), range: NSMakeRange(0, mutableAttributedString.string.utf16.count))
        return mutableAttributedString
    }

    func collectAttributedString(_ markup: Markup) -> NSMutableAttributedString {
        // collect from downstream
        // Root -> Bold -> String("Bold")
        //      \
        //       > String("Test")
        // Result: Bold Test
        // ä¸€å±¤ä¸€å±¤å¾€ä¸‹æ‰¾ raw string, éè¿´ visit ä¸¦çµ„åˆå‡ºæœ€çµ‚ NSAttributedString
        return markup.childMarkups.compactMap({ visit(markup: $0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in
            partialResult.append(attributedString)
            return partialResult
        }
    }
    
    func collectMarkupStyle(_ markup: Markup) -> MarkupStyle? {
        // collect from upstream
        // String("Test") -> Bold -> Italic -> Root
        // Result: style: Bold+Italic
        // ä¸€å±¤ä¸€å±¤ç¶²ä¸Šæ‰¾ parent tag çš„ markupstyle
        // ç„¶å¾Œä¸€å±¤ä¸€å±¤ç¹¼æ‰¿æ¨£å¼
        var currentMarkup: Markup? = markup.parentMarkup
        var currentStyle = components.value(markup: markup)
        while let thisMarkup = currentMarkup {
            guard let thisMarkupStyle = components.value(markup: thisMarkup) else {
                currentMarkup = thisMarkup.parentMarkup
                continue
            }

            if var thisCurrentStyle = currentStyle {
                thisCurrentStyle.fillIfNil(from: thisMarkupStyle)
                currentStyle = thisCurrentStyle
            } else {
                currentStyle = thisMarkupStyle
            }

            currentMarkup = thisMarkup.parentMarkup
        }
        
        if var currentStyle = currentStyle {
            currentStyle.fillIfNil(from: rootStyle)
            return currentStyle
        } else {
            return rootStyle
        }
    }
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [MarkupNSAttributedStringVisitor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/Processor/MarkupNSAttributedStringVisitor.swift){:target="_blank"} å¯¦ä½œ 






![é‹ä½œæµç¨‹åŠçµæœå¦‚ä¸Šåœ–](/assets/2724f02f6e7/1*gJA_6uM5tQw2kUJsqIssuw.png)

é‹ä½œæµç¨‹åŠçµæœå¦‚ä¸Šåœ–

**æœ€çµ‚æˆ‘å€‘å¯ä»¥å¾—åˆ°:**


![](/assets/2724f02f6e7/1*LOXfC8yYg2JCeoCH5m7kGA.png)

```swift
Li{
    NSColor = "Blue";
    NSFont = "<UICTFont: 0x145d17600> font-family: \".SFUI-Regular\"; font-weight: normal; font-style: normal; font-size: 13.00pt";
    NSLink = "https://zhgchg.li";
}nk{
    NSColor = "Blue";
    NSFont = "<UICTFont: 0x145d18710> font-family: \".SFUI-Semibold\"; font-weight: bold; font-style: normal; font-size: 13.00pt";
    NSLink = "https://zhgchg.li";
}Bold{
    NSFont = "<UICTFont: 0x145d18710> font-family: \".SFUI-Semibold\"; font-weight: bold; font-style: normal; font-size: 13.00pt";
}
```


> ğŸ‰ğŸ‰ğŸ‰ğŸ‰å®ŒæˆğŸ‰ğŸ‰ğŸ‰ğŸ‰ 




åˆ°æ­¤æˆ‘å€‘å°±å®Œæˆäº† HTML String to NSAttributedString çš„æ•´å€‹è½‰æ›éç¨‹ã€‚
#### Stripper â€” å‰é›¢ HTML Tag

å‰é›¢ HTML Tag çš„éƒ¨åˆ†ç›¸å°ç°¡å–®ï¼Œåªéœ€è¦:
```swift
func attributedString(_ markup: Markup) -> NSAttributedString {
  if let rawStringMarkup = markup as? RawStringMarkup {
    return rawStringMarkup.attributedString
  } else {
    return markup.childMarkups.compactMap({ attributedString($0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in
      partialResult.append(attributedString)
      return partialResult
    }
  }
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [MarkupStripperProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/Processor/MarkupStripperProcessor.swift){:target="_blank"} å¯¦ä½œ 





é¡ä¼¼ Renderï¼Œä½†ç´”ç²¹æ‰¾åˆ° RawStringMarkup å¾Œè¿”å›å…§å®¹ã€‚
#### Extend â€” å‹•æ…‹æ“´å……

ç‚ºäº†èƒ½æ“´å……æ¶µè“‹æ‰€æœ‰ HTMLTag/Style Attribute æ‰€ä»¥é–‹äº†ä¸€å€‹å‹•æ…‹æ“´å……çš„å£ï¼Œæ–¹ä¾¿ç›´æ¥å¾ Code å‹•æ…‹æ“´å……ç‰©ä»¶ã€‚
```swift
public struct ExtendTagName: HTMLTagName {
    public let string: String
    
    public init(_ w3cHTMLTagName: WC3HTMLTagName) {
        self.string = w3cHTMLTagName.rawValue
    }
    
    public init(_ string: String) {
        self.string = string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}
// to
final class ExtendMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []

    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

//----

public struct ExtendHTMLTagStyleAttribute: HTMLTagStyleAttribute {
    public let styleName: String
    public let render: ((String) -> (MarkupStyle?)) // å‹•æ…‹ç”¨ clourse è®Šæ›´ MarkupStyle
    
    public init(styleName: String, render: @escaping ((String) -> (MarkupStyle?))) {
        self.styleName = styleName
        self.render = render
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagStyleAttributeVisitor {
        return visitor.visit(self)
    }
}
```
#### ZHTMLParserBuilder

æœ€å¾Œæˆ‘å€‘ä½¿ç”¨ Builder Pattern è®“å¤–éƒ¨ Module å¯ä»¥å¿«é€Ÿæ§‹å»º ZMarkupParser æ‰€éœ€çš„ç‰©ä»¶ï¼Œä¸¦åšå¥½ Access Level Controlã€‚
```swift
public final class ZHTMLParserBuilder {
    
    private(set) var htmlTags: [HTMLTag] = []
    private(set) var styleAttributes: [HTMLTagStyleAttribute] = []
    private(set) var rootStyle: MarkupStyle?
    private(set) var policy: MarkupStylePolicy = .respectMarkupStyleFromCode
    
    public init() {
        
    }
    
    public static func initWithDefault() -> Self {
        var builder = Self.init()
        for htmlTagName in ZHTMLParserBuilder.htmlTagNames {
            builder = builder.add(htmlTagName)
        }
        for styleAttribute in ZHTMLParserBuilder.styleAttributes {
            builder = builder.add(styleAttribute)
        }
        return builder
    }
    
    public func set(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle?) -> Self {
        return self.add(htmlTagName, withCustomStyle: markupStyle)
    }
    
    public func add(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle? = nil) -> Self {
        // åŒå€‹ tagName åªèƒ½å­˜åœ¨ä¸€å€‹
        htmlTags.removeAll { htmlTag in
            return htmlTag.tagName.string == htmlTagName.string
        }
        
        htmlTags.append(HTMLTag(tagName: htmlTagName, customStyle: markupStyle))
        
        return self
    }
    
    public func add(_ styleAttribute: HTMLTagStyleAttribute) -> Self {
        styleAttributes.removeAll { thisStyleAttribute in
            return thisStyleAttribute.styleName == styleAttribute.styleName
        }
        
        styleAttributes.append(styleAttribute)
        
        return self
    }
    
    public func set(rootStyle: MarkupStyle) -> Self {
        self.rootStyle = rootStyle
        return self
    }
    
    public func set(policy: MarkupStylePolicy) -> Self {
        self.policy = policy
        return self
    }
    
    public func build() -> ZHTMLParser {
        // ZHTMLParser init åªé–‹æ”¾ internal, å¤–éƒ¨ç„¡æ³•ç›´æ¥ init
        // åªèƒ½é€é ZHTMLParserBuilder init
        return ZHTMLParser(htmlTags: htmlTags, styleAttributes: styleAttributes, policy: policy, rootStyle: rootStyle)
    }
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [ZHTMLParserBuilder\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/ZHTMLParserBuilder.swift){:target="_blank"} å¯¦ä½œ 





**initWithDefault é è¨­æœƒåŠ å…¥æ‰€æœ‰å·²ç¶“å¯¦ç¾çš„ HTMLTagName/Style Attribute**
```swift
public extension ZHTMLParserBuilder {
    static var htmlTagNames: [HTMLTagName] {
        return [
            A_HTMLTagName(),
            B_HTMLTagName(),
            BR_HTMLTagName(),
            DIV_HTMLTagName(),
            HR_HTMLTagName(),
            I_HTMLTagName(),
            LI_HTMLTagName(),
            OL_HTMLTagName(),
            P_HTMLTagName(),
            SPAN_HTMLTagName(),
            STRONG_HTMLTagName(),
            U_HTMLTagName(),
            UL_HTMLTagName(),
            DEL_HTMLTagName(),
            TR_HTMLTagName(),
            TD_HTMLTagName(),
            TH_HTMLTagName(),
            TABLE_HTMLTagName(),
            IMG_HTMLTagName(handler: nil),
            // ...
        ]
    }
}

public extension ZHTMLParserBuilder {
    static var styleAttributes: [HTMLTagStyleAttribute] {
        return [
            ColorHTMLTagStyleAttribute(),
            BackgroundColorHTMLTagStyleAttribute(),
            FontSizeHTMLTagStyleAttribute(),
            FontWeightHTMLTagStyleAttribute(),
            LineHeightHTMLTagStyleAttribute(),
            WordSpacingHTMLTagStyleAttribute(),
            // ...
        ]
    }
}
```

ZHTMLParser init åªé–‹æ”¾ internalï¼Œå¤–éƒ¨ç„¡æ³•ç›´æ¥ initï¼Œåªèƒ½é€é ZHTMLParserBuilder initã€‚

**ZHTMLParser å°è£äº† Render/Selector/Stripper æ“ä½œ:**
```swift
public final class ZHTMLParser: ZMarkupParser {
    let htmlTags: [HTMLTag]
    let styleAttributes: [HTMLTagStyleAttribute]
    let rootStyle: MarkupStyle?

    internal init(...) {
    }
    
    // å–å¾— link style attributes
    public var linkTextAttributes: [NSAttributedString.Key: Any] {
        // ...
    }
    
    public func selector(_ string: String) -> HTMLSelector {
        // ...
    }
    
    public func selector(_ attributedString: NSAttributedString) -> HTMLSelector {
        // ...
    }
    
    public func render(_ string: String) -> NSAttributedString {
        // ...
    }
    
    // å…è¨±ä½¿ç”¨ HTMLSelector çµæœæ¸²æŸ“å‡ºç¯€é»å…§çš„ NSAttributedString
    public func render(_ selector: HTMLSelector) -> NSAttributedString {
        // ...
    }
    
    public func render(_ attributedString: NSAttributedString) -> NSAttributedString {
        // ...
    }
    
    public func stripper(_ string: String) -> String {
        // ...
    }
    
    public func stripper(_ attributedString: NSAttributedString) -> NSAttributedString {
        // ...
    }
    
  // ...
}
```


> å°æ‡‰åŸå§‹ç¢¼ä¸­çš„ [ZHTMLParser\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/ZHTMLParser.swift){:target="_blank"} å¯¦ä½œ 




#### UIKit å•é¡Œ

NSAttributedString çš„çµæœæˆ‘å€‘æœ€å¸¸çš„å°±æ˜¯æ”¾åˆ° UITextView ä¸­é¡¯ç¤ºï¼Œä½†æ˜¯è¦æ³¨æ„:
- UITextView è£¡çš„é€£çµæ¨£å¼æ˜¯çµ±ä¸€çœ‹ `linkTextAttributes` è¨­å®šé€£çµæ¨£å¼ï¼Œä¸æœƒçœ‹ NSAttributedString\.Key çš„è¨­å®šï¼Œä¸”ç„¡æ³•å€‹åˆ¥è¨­å®šæ¨£å¼ï¼›å› æ­¤æ‰æœƒæœ‰ `ZMarkupParser.linkTextAttributes` é€™å€‹é–‹å£ã€‚
- UILabel æš«æ™‚æ²’æœ‰æ–¹å¼æ”¹è®Šé€£çµæ¨£å¼ï¼Œä¸”å›  UILabel æ²’æœ‰ TextStroageï¼Œè‹¥è¦æ‹¿ä¾†è¼‰å…¥ NSTextAttachment åœ–ç‰‡ï¼›éœ€è¦å¦å¤–æŠ“ä½ UILabelã€‚

```swift
public extension UITextView {
    func setHtmlString(_ string: String, with parser: ZHTMLParser) {
        self.setHtmlString(NSAttributedString(string: string), with: parser)
    }
    
    func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) {
        self.attributedText = parser.render(string)
        self.linkTextAttributes = parser.linkTextAttributes
    }
}
public extension UILabel {
    func setHtmlString(_ string: String, with parser: ZHTMLParser) {
        self.setHtmlString(NSAttributedString(string: string), with: parser)
    }
    
    func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) {
        let attributedString = parser.render(string)
        attributedString.enumerateAttribute(NSAttributedString.Key.attachment, in: NSMakeRange(0, attributedString.string.utf16.count), options: []) { (value, effectiveRange, nil) in
            guard let attachment = value as? ZNSTextAttachment else {
                return
            }
            
            attachment.register(self)
        }
        
        self.attributedText = attributedString
    }
}
```

å› æ­¤å¤š Extension äº† UIKitï¼Œå¤–éƒ¨åªéœ€ç„¡è…¦ `setHTMLString()` å³å¯å®Œæˆç¶å®šã€‚
#### è¤‡é›œçš„æ¸²æŸ“é …ç›®â€” é …ç›®æ¸…å–®

é—œæ–¼é …ç›®æ¸…å–®çš„å¯¦ç¾ç´€éŒ„ã€‚

**åœ¨ HTML ä¸­ä½¿ç”¨ `&lt;ol&gt;` / `&lt;ul&gt;` åŒ…è£ `&lt;li&gt;` è¡¨ç¤ºé …ç›®æ¸…å–®:**
```xml
<ul>
    <li>ItemA</li>
    <li>ItemB</li>
    <li>ItemC</li>
    //...
</ul>
```

ä½¿ç”¨åŒå‰æ–‡è§£ææ–¹å¼ï¼Œæˆ‘å€‘å¯ä»¥åœ¨ `visit(_ markup: ListItemMarkup)` å–å¾—å…¶ä»– list item çŸ¥é“ç•¶å‰ list index \(å¾—åˆ©æ–¼æœ‰è½‰æ›æˆ AST\)ã€‚
```swift
func visit(_ markup: ListItemMarkup) -> Result {
  let siblingListItems = markup.parentMarkup?.childMarkups.filter({ $0 is ListItemMarkup }) ?? []
  let position = (siblingListItems.firstIndex(where: { $0 === markup }) ?? 0)
}
```

NSParagraphStyle æœ‰ä¸€å€‹ NSTextList ç‰©ä»¶å¯ä»¥ç”¨ä¾†é¡¯ç¤º list itemï¼Œä½†æ˜¯åœ¨å¯¦ä½œä¸Šç„¡æ³•å®¢è£½åŒ–ç©ºç™½çš„å¯¬åº¦ \(å€‹äººè¦ºå¾—ç©ºç™½å¤ªå¤§\)ï¼Œå¦‚æœé …ç›®ç¬¦è™Ÿèˆ‡å­—ä¸²ä¸­é–“æœ‰ç©ºç™½æœƒè®“æ›è¡Œè§¸ç™¼åœ¨æ­¤ï¼Œé¡¯ç¤ºæœƒæœ‰é»å¥‡æ€ªï¼Œå¦‚ä¸‹åœ–:


![](/assets/2724f02f6e7/1*jvIgDjO4DNAKpPZF1balmw.png)


Beter éƒ¨åˆ†æœ‰æ©Ÿæœƒé€é [è¨­å®š headIndent, firstLineHeadIndent, NSTextTab](https://www.objc.io/issues/9-strings/string-rendering/){:target="_blank"} å¯¦ç¾ï¼Œä½†æ˜¯æ¸¬è©¦ç™¼ç¾å­—ä¸²å¤ªé•·ã€å¤§å°æœ‰è®Šé‚„æ˜¯ç„¡æ³•å®Œç¾å‘ˆç¾çµæœã€‚

ç›®å‰åªåšåˆ° Acceptableï¼Œè‡ªå·±çµ„åˆé …ç›®æ¸…å–®å­—ä¸² insert åˆ°å­—ä¸²å‰ã€‚

æˆ‘å€‘åªä½¿ç”¨åˆ° NSTextList\.MarkerFormat ç”¨ä¾†ç”¢é …ç›®æ¸…å–®ç¬¦è™Ÿï¼Œè€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨ NSTextListã€‚

**æ¸…å–®ç¬¦è™Ÿæ”¯æ´åˆ—è¡¨å¯åƒè€ƒï¼š** [MarkupStyleList\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyleList.swift){:target="_blank"}

**æœ€çµ‚é¡¯ç¤ºçµæœï¼š\(** `&lt;ol&gt;&lt;li&gt;` **\)**


![](/assets/2724f02f6e7/1*yM3VROfUNgnEBfIYwYwPnQ.png)

#### è¤‡é›œçš„æ¸²æŸ“é …ç›® â€” Table

é¡ä¼¼ æ¸…å–®é …ç›®çš„å¯¦ç¾ï¼Œä½†æ˜¯æ˜¯è¡¨æ ¼ã€‚

**åœ¨ HTML ä¸­ä½¿ç”¨ `&lt;table&gt;` è¡¨æ ¼\-&gt;åŒ…è£ `&lt;tr&gt;` è¡¨æ ¼åˆ—\-&gt;åŒ…è£ `&lt;td&gt;/&lt;th&gt;` è¡¨ç¤ºè¡¨æ ¼æ¬„ä½:**
```xml
<table>
  <tr>
    <th>Company</th>
    <th>Contact</th>
    <th>Country</th>
  </tr>
  <tr>
    <td>Alfreds Futterkiste</td>
    <td>Maria Anders</td>
    <td>Germany</td>
  </tr>
  <tr>
    <td>Centro comercial Moctezuma</td>
    <td>Francisco Chang</td>
    <td>Mexico</td>
  </tr>
</table>
```

å¯¦æ¸¬åŸç”Ÿçš„ `NSAttributedString.DocumentType.html` æ˜¯ç”¨ Private macOS API `NSTextBlock` ä¾†å®Œæˆé¡¯ç¤ºï¼Œå› æ­¤èƒ½å®Œæ•´é¡¯ç¤º HTML è¡¨æ ¼æ¨£å¼åŠå…§å®¹ã€‚


> æœ‰é»ä½œå¼Šï¼æˆ‘å€‘ç„¡æ³•ç”¨ Private API ğŸ¥² 




```swift
    func visit(_ markup: TableColumnMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        let siblingColumns = markup.parentMarkup?.childMarkups.filter({ $0 is TableColumnMarkup }) ?? []
        let position = (siblingColumns.firstIndex(where: { $0 === markup }) ?? 0)
        
        // æœ‰ç„¡å¾å¤–éƒ¨æŒ‡å®šæƒ³è¦çš„å¯¬åº¦, å¯è¨­ .max ä¸ truncated string
        var maxLength: Int? = markup.fixedMaxLength
        if maxLength == nil {
            // æ²’æŒ‡å®šå‰‡æ‰¾åˆ°ç¬¬ä¸€è¡ŒåŒä¸€æ¬„çš„ String length åšç‚º max length
            if let tableRowMarkup = markup.parentMarkup as? TableRowMarkup,
               let firstTableRow = tableRowMarkup.parentMarkup?.childMarkups.first(where: { $0 is TableRowMarkup }) as? TableRowMarkup {
                let firstTableRowColumns = firstTableRow.childMarkups.filter({ $0 is TableColumnMarkup })
                if firstTableRowColumns.indices.contains(position) {
                    let firstTableRowColumnAttributedString = collectAttributedString(firstTableRowColumns[position])
                    let length = firstTableRowColumnAttributedString.string.utf16.count
                    maxLength = length
                }
            }
        }
        
        if let maxLength = maxLength {
            // æ¬„ä½è¶…é maxLength å‰‡ truncated string
            if attributedString.string.utf16.count > maxLength {
                attributedString.mutableString.setString(String(attributedString.string.prefix(maxLength))+"...")
            } else {
                attributedString.mutableString.setString(attributedString.string.padding(toLength: maxLength, withPad: " ", startingAt: 0))
            }
        }
        
        if position < siblingColumns.count - 1 {
            // æ–°å¢ç©ºç™½åšç‚º spacing, å¤–éƒ¨å¯æŒ‡å®š spacing å¯¬åº¦å¹¾å€‹ç©ºç™½å­—
            attributedString.append(makeString(in: markup, string: String(repeating: " ", count: markup.spacing)))
        }
        
        return attributedString
    }
    
    func visit(_ markup: TableRowMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        attributedString.append(makeBreakLine(in: markup)) // æ–°å¢æ›è¡Œ, è©³ç´°è«‹åƒè€ƒ Source Code
        return attributedString
    }
    
    func visit(_ markup: TableMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        attributedString.append(makeBreakLine(in: markup)) // æ–°å¢æ›è¡Œ, è©³ç´°è«‹åƒè€ƒ Source Code
        attributedString.insert(makeBreakLine(in: markup), at: 0) // æ–°å¢æ›è¡Œ, è©³ç´°è«‹åƒè€ƒ Source Code
        return attributedString
    }
```

**æœ€çµ‚å‘ˆç¾æ•ˆæœå¦‚ä¸‹åœ–ï¼š**


![](/assets/2724f02f6e7/1*Dft7H2BbeyWIO-dH4QpuSw.png)


not perfect, but acceptable\.
#### è¤‡é›œçš„æ¸²æŸ“é …ç›® â€” Image

æœ€çµ‚ä¾†è¬›ä¸€å€‹æœ€å¤§çš„é­”ç‹ï¼Œè¼‰å…¥é ç«¯åœ–ç‰‡åˆ° NSAttributedStringã€‚

**åœ¨ HTML ä¸­ä½¿ç”¨ `&lt;img&gt;` è¡¨ç¤ºåœ–ç‰‡:**
```xml
<img src="https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg" width="300" height="125"/>
```

ä¸¦å¯é€é `width` / `height` HTML Attribute æŒ‡å®šæƒ³è¦çš„é¡¯ç¤ºå¤§å°ã€‚

åœ¨ NSAttributedString ä¸­é¡¯ç¤ºåœ–ç‰‡ï¼Œæ¯”æƒ³åƒä¸­è¤‡é›œå¾ˆå¤šï¼›ä¸”æ²’æœ‰å¾ˆå¥½çš„å¯¦ç¾ï¼Œä¹‹å‰åš [UITextView æ–‡ç¹åœ–](../e37d66ea1146/) æ™‚æœ‰ç¨å¾®è¸©éå‘ï¼Œä½†é€™æ¬¡åœ¨ç ”ç©¶ä¸€è¼ªç™¼ç¾é‚„æ˜¯æ²’æœ‰ä¸€å€‹å®Œç¾çš„è§£æ±ºæ–¹æ¡ˆã€‚

ç›®å‰å…ˆå¿½ç•¥ NSTextAttachment åŸç”Ÿä¸èƒ½ reuse é‡‹æ”¾è¨˜æ†¶é«”çš„å•é¡Œï¼Œå…ˆåªå¯¦ç¾å¾é ç«¯ä¸‹è¼‰åœ–ç‰‡æ”¾åˆ° NSTextAttachment åœ¨æ”¾åˆ° NSAttributedString ä¸­ï¼Œä¸¦å¯¦ç¾è‡ªå‹•æ›´æ–°å…§å®¹ã€‚

**æ­¤ç³»åˆ—æ“ä½œåˆå†æ‹†åˆ°å¦ä¸€å€‹å°çš„ Project å¯¦ç¾ï¼Œæƒ³èªªæ—¥å¾Œæ¯”è¼ƒå¥½å„ªåŒ–è·Ÿå¾©ç”¨åˆ°å…¶ä»– Project:**


[![](https://opengraph.githubassets.com/8c6e5c65e1680e6f15b82933cd4644097aa50e057ee17f392aa6a68f442be71b/ZhgChgLi/ZNSTextAttachment)](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"}


ä¸»è¦æ˜¯åƒè€ƒ [Asynchronous NSTextAttachments](https://www.cocoanetics.com/2016/09/asynchronous-nstextattachment-1/){:target="_blank"} é€™ç³»åˆ—æ–‡ç« å¯¦ç¾ï¼Œä½†æ˜¯æ›¿æ›äº†æœ€å¾Œçš„æ›´æ–°å…§å®¹éƒ¨åˆ†\(ä¸‹è¼‰å®Œå¾Œè¦åˆ·æ–° UI æ‰æœƒå‘ˆç¾\)é‚„æœ‰å¢åŠ  Delegate/DataSource çµ¦å¤–éƒ¨æ“´å……ä½¿ç”¨ã€‚


![é‹åšæµç¨‹èˆ‡é—œä¿‚å¦‚ä¸Šåœ–](/assets/2724f02f6e7/1*JZ8IVVNj9B2l-UBemGbAig.png)

é‹åšæµç¨‹èˆ‡é—œä¿‚å¦‚ä¸Šåœ–
- å®£å‘Š ZNSTextAttachmentable ç‰©ä»¶ï¼Œå°è£ NSTextStorage ç‰©ä»¶\(UITextViewè‡ªå¸¶\)åŠ UILabel æœ¬èº« \(UILabel ç„¡ NSTextStorage\)
æ“ä½œæ–¹æ³•åƒ…ç‚ºå¯¦ç¾ replace attributedString from NSRange\. \( `func replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment)` \)
- å¯¦ç¾åŸç†æ˜¯å…ˆä½¿ç”¨ `ZNSTextAttachment` åŒ…è£ imageURLã€PlaceholderImageã€é¡¯è¦é¡¯ç¤ºçš„å¤§å°è³‡è¨Šï¼Œç„¶å¾Œå…ˆç”¨ placeHolder ç›´æ¥é¡¯ç¤ºåœ–ç‰‡
- ç•¶ ç³»çµ±éœ€è¦æ­¤åœ–ç‰‡åœ¨ç•«é¢æ™‚æœƒå‘¼å« `image(forBoundsâ€¦` æ–¹æ³•ï¼Œæ­¤æ™‚æˆ‘å€‘é–‹å§‹ä¸‹è¼‰ Image Data
- DataSource å‡ºå»è®“å¤–éƒ¨å¯æ±ºå®šæ€éº¼ä¸‹è¼‰æˆ–å¯¦ç¾ Image Cache Policyï¼Œé è¨­ç›´æ¥ä½¿ç”¨ URLSession è«‹æ±‚åœ–ç‰‡ Data
- ä¸‹è¼‰å®Œæˆå¾Œ new ä¸€å€‹æ–°çš„ `ZResizableNSTextAttachment` ä¸¦åœ¨ `attachmentBounds(forâ€¦` å¯¦ç¾è‡ªå®šåœ–ç‰‡å¤§å°çš„é‚è¼¯
- å‘¼å« `replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment)` æ–¹æ³•ï¼Œå°‡ `ZNSTextAttachment` ä½ç½®æ›¿æ›ç‚º `ZResizableNSTextAttachment`
- ç™¼å‡º didLoad Delegate é€šçŸ¥ï¼Œè®“å¤–éƒ¨æœ‰éœ€è¦æ™‚å¯ä¸²æ¥
- å®Œæˆ



> **è©³ç´°ç¨‹å¼ç¢¼å¯åƒè€ƒ [Source Code](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"}** ã€‚ 





ä¸ä½¿ç”¨ `NSLayoutManager.invalidateLayout(forCharacterRange: range, actualCharacterRange: nil)` ã€ `NSLayoutManager.invalidateDisplay(forCharacterRange: range)` åˆ·æ–° UI çš„åŸå› æ˜¯ç™¼ç¾ UI æ²’æœ‰æ­£ç¢ºçš„é¡¯ç¤ºæ›´æ–°ï¼›æ—¢ç„¶éƒ½çŸ¥é“æ‰€åœ¨ Range äº†ï¼Œç›´æ¥è§¸ç™¼å–ä»£ NSAttributedStringï¼Œèƒ½ç¢ºä¿ UI æ­£ç¢ºæ›´æ–°ã€‚

æœ€çµ‚é¡¯ç¤ºçµæœå¦‚ä¸‹ï¼š
```xml
<span style="color:red">ã“ã‚“ã«ã¡ã¯</span>ã“ã‚“ã«ã¡ã¯ã“ã‚“ã«ã¡ã¯ <br />
<img src="https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg"/>
```


![](/assets/2724f02f6e7/1*bl65v-SVOK3H9ajR-Ksg6w.png)

### Testing & Continuous Integration

é€™æ¬¡å°ˆæ¡ˆé™¤äº†æ’°å¯« Unit Test å–®å…ƒæ¸¬è©¦ä¹‹å¤–é‚„å»ºç«‹äº† Snapshot Test åšæ•´åˆæ¸¬è©¦æ–¹ä¾¿å°æœ€çµ‚çš„ NSAttributedString åšç¶œè§€çš„æ¸¬è©¦æ¯”è¼ƒã€‚

ä¸»è¦åŠŸèƒ½é‚è¼¯éƒ½æœ‰ UnitTests ä¸¦åŠ ä¸Šæ•´åˆæ¸¬è©¦ï¼Œæœ€çµ‚ [Test Coverage](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"} åœ¨ **85%** å·¦å³ã€‚


![[ZMarkupParser â€” codecov](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*wV6BZcEGYuT9B9Xy4QzI0w.png)

[ZMarkupParser â€” codecov](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}
#### Snapshot Test


[![](https://opengraph.githubassets.com/7c5a38af06926868299786524e9d13ef41313a1a2dbcacfc896aaa95eb49e4b5/pointfreeco/swift-snapshot-testing)](https://github.com/pointfreeco/swift-snapshot-testing){:target="_blank"}


**ç›´æ¥å¼•å…¥æ¡†æ¶ä½¿ç”¨:**
```swift
import SnapshotTesting
// ...
func testShouldKeppNSAttributedString() {
  let parser = ZHTMLParserBuilder.initWithDefault().build()
  let textView = UITextView()
  textView.frame.size.width = 390
  textView.isScrollEnabled = false
  textView.backgroundColor = .white
  textView.setHtmlString("html string...", with: parser)
  textView.layoutIfNeeded()
  assertSnapshot(matching: textView, as: .image, record: false)
}
// ...
```


![](/assets/2724f02f6e7/1*hLPeaOTOviA0jTPNOPu1hg.png)


ç›´æ¥æ¯”å°æœ€çµ‚çµæœæ˜¯å¦ç¬¦åˆé æœŸï¼Œç¢ºä¿èª¿æ•´æ•´åˆèµ·ä¾†æ²’æœ‰ç•°å¸¸ã€‚
#### Codecov Test Coverage

ä¸²æ¥ [Codecov\.io](https://about.codecov.io){:target="_blank"} \(free for Public Repo\) è©•ä¼° Test Coverageï¼Œåªéœ€å®‰è£ Codecov Github App & è¨­è¨ˆå³å¯ã€‚


[![](https://storage.googleapis.com/codecov-cdn/static/Codecov-icon-600x600.png)](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}


Codecov &lt;\-&gt; Github Repo è¨­å®šå¥½å¾Œï¼Œä¹Ÿå¯ä»¥åœ¨å°ˆæ¡ˆæ ¹ç›®éŒ„åŠ ä¸Š `codecov.yml`
```yaml
comment:                  # this is a top-level key
  layout: "reach, diff, flags, files"
  behavior: default
  require_changes: false  # if true: only post the comment if coverage changes
  require_base: no        # [yes :: must have a base report to post]
  require_head: yes       # [yes :: must have a head report to post]
```

è¨­å®šæª”ï¼Œé€™æ¨£å¯ä»¥å•Ÿç”¨æ¯å€‹ PR ç™¼å‡ºå¾Œï¼Œè‡ªå‹•æŠŠ CI è·‘çš„çµæœ Comment åˆ°å…§å®¹ã€‚


![](/assets/2724f02f6e7/1*AcKpF4dijglahV-iVYLvvA.png)

#### Continuous Integration

Github Action, CI æ•´åˆ: `ci.yml`
```yaml
name: CI

on:
  workflow_dispatch:
  pull_request:
    types: [opened, reopened]
  push:
    branches:
    - main

jobs:
  build:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v3
      - name: spm build and test
        run: |
          set -o pipefail
          xcodebuild test -workspace ZMarkupParser.xcworkspace -testPlan ZMarkupParser -scheme ZMarkupParser -enableCodeCoverage YES -resultBundlePath './scripts/TestResult.xcresult' -destination 'platform=iOS Simulator,name=iPhone 14,OS=16.1' build test | xcpretty
      - name: Codecov
        uses: codecov/codecov-action@v3.1.1
        with:
          xcode: true
          xcode_archive_path: './scripts/TestResult.xcresult'
```

æ­¤è¨­å®šæ˜¯åœ¨ PR opened/reopend or push main branch æ™‚è·‘ build and test æœ€å¾ŒæŠŠ test coverage å ±å‘Šä¸Šå‚³åˆ° codecov\.
#### Regex

é—œæ–¼æ­£è¦è¡¨ç¤ºæ³•ï¼Œæ¯ç”¨åˆ°ä¸€æ¬¡å°±åˆå†ç²¾é€²ä¸€æ¬¡ï¼›é€™æ¬¡å¯¦éš›æ²’ç”¨åˆ°å¤ªå¤šï¼Œä½†æ˜¯å› ç‚ºæœ¬ä¾†æƒ³ç”¨ä¸€å€‹æ­£å‰‡æŒ–å‡ºæˆå°çš„ HTML Tag æ‰€ä»¥ä¹Ÿå¤šç ”ç©¶éè¦æ€éº¼æ’°å¯«ã€‚

ä¸€äº›é€™æ¬¡æ–°å­¸ç¿’çš„ cheat sheet ç­†è¨˜â€¦
- `?:` å¯ä»¥è®“ \( \) åŒ¹é… group çµæœï¼Œä½†ä¸æœƒæ•ç²è¿”å›
e\.g\. `(?:https?:\/\/)?(?:www\.)?example\.com` åœ¨ `https://www,example.com` æœƒè¿”å›æ•´å€‹ç¶²å€è€Œä¸æ˜¯ `https://` , `www`
- `.+?` éè²ªå©ªçš„åŒ¹é… \(æ‰¾åˆ°æœ€è¿‘çš„å°±è¿”å›\)
e\.g\. `&lt;.+?&gt;` åœ¨ `&lt;a&gt;test&lt;/a&gt;` æœƒè¿”å› `&lt;a&gt;` , `&lt;/a&gt;` è€Œéæ•´å€‹å­—ä¸²
- `(?=XYZ)` ä»»ä½•å­—ä¸²ç›´åˆ° `XYZ` å­—ä¸²å‡ºç¾ï¼›è¦æ³¨æ„ï¼Œå¦ä¸€å€‹èˆ‡ä¹‹ç›¸ä¼¼çš„ `[^XYZ]` æ˜¯ä»£è¡¨ä»»ä½•å­—ä¸²ç›´åˆ° `X or Y or Z` å­—å…ƒå‡ºç¾
e\.g\. `(?:__)(.+?(?=__))(?:__)` \(ä»»ä½•å­—ä¸²ç›´åˆ° `__` \) æœƒåŒ¹é…å‡º `test`
- `?R` éè¿´å¾€å…§æ‰¾ä¸€æ¨£è¦å‰‡çš„å€¼
e\.g\. `\((?:[^()]|((?R)))+\)` åœ¨ `(simple) (and(nested))` æœƒåŒ¹é…å‡º `(simple)` , `(and(nested))` , `(nested)`
- `?&lt;GroupName&gt;` â€¦ `\k&lt;GroupName&gt;` åŒ¹é…å‰é¢çš„ Group Name
e\.g\. `(?&lt;tagName&gt;&lt;a&gt;).*(\k&lt;GroupName&gt;)`
- `(?(X)yes|no)` ç¬¬ `X` å€‹åŒ¹é…çµæœæœ‰å€¼\(ä¹Ÿå¯ä»¥ç”¨ Group Name\)æ™‚å‰‡åŒ¹é…å¾Œé¢æ¢ä»¶ `yes` å¦å‰‡åŒ¹é… `no` 
**Swift æš«æ™‚ä¸æ”¯æ´**


**å…¶ä»– Regex å¥½æ–‡ï¼š**
- [Swift æ­£åˆ™é€ŸæŸ¥æ‰‹å†Œ](https://onevcat.com/2022/11/swift-regex/){:target="_blank"}
- [æ­£åˆ™è¡¨è¾¾å¼æ˜¯å¦‚ä½•è¿ä½œçš„ï¼Ÿ](https://mp.weixin.qq.com/s/i_C4ATnajxRDGlTA8dJDHg){:target="_blank"} \-&gt; **å¾ŒçºŒå„ªåŒ–æ­¤å°ˆæ¡ˆçš„æ­£å‰‡æ•ˆèƒ½æ™‚å¯åƒè€ƒ**
- [Regex éŒ¯èª¤å°è‡´ç„¡çª®å°‹æ‰¾ï¼Œæœ€çµ‚å¼•ç™¼ä¼ºæœå™¨æ•…éšœçš„æ¡ˆä¾‹](https://juejin.cn/post/6850418120390082574){:target="_blank"}
- [Regex101 å³ä¸‹æ–¹å¯æŸ¥è©¢æ‰€æœ‰æ­£å‰‡è¦å‰‡](https://regex101.com){:target="_blank"}

#### Swift Package Manager & Cocoapods

é€™ä¹Ÿæ˜¯æˆ‘ç¬¬ä¸€æ¬¡é–‹ç™¼ SPM & Cocoapodsâ€¦è »æœ‰è¶£çš„ï¼ŒSPM çœŸçš„æ–¹ä¾¿ï¼›ä½†æ˜¯è¸©åˆ°åŒæ™‚å…©å€‹å°ˆæ¡ˆä¾è³´åŒå€‹å¥—ä»¶çš„è©±ï¼ŒåŒæ™‚é–‹å…©å€‹å°ˆæ¡ˆæœƒæœ‰å…¶ä¸­ä¸€å€‹æ‰¾ä¸åˆ°è©²å¥—ä»¶ç„¶å¾Œ Build ä¸èµ·ä¾†ã€‚ã€‚ã€‚

Cocoapods æœ‰ä¸Šå‚³ ZMarkupParser ä½†æ²’æ¸¬è©¦æ­£ä¸æ­£å¸¸ï¼Œå› ç‚ºæˆ‘æ˜¯ç”¨ SPM ğŸ˜ã€‚
#### ChatGPT

å¯¦éš›æ­é…é–‹ç™¼é«”é©—ä¸‹ä¾†ï¼Œè¦ºå¾—åªæœ‰åœ¨å”åŠ©æ½¤ç¨¿ Readme æ™‚æœ€æœ‰ç”¨ï¼›åœ¨é–‹ç™¼ä¸Šç›®å‰æ²’é«”æœƒåˆ°æœ‰æ„Ÿçš„åœ°æ–¹ï¼›å› ç‚ºè©¢å• mid\-senior ä»¥ä¸Šçš„å•é¡Œï¼Œä»–ä¹Ÿçµ¦ä¸å‡ºå€‹ç¢ºåˆ‡ç­”æ¡ˆç”šæ˜¯æ˜¯éŒ¯èª¤çš„ç­”æ¡ˆ \(æœ‰é‡åˆ°å•ä»–ä¸€äº›æ­£å‰‡è¦å‰‡ï¼Œç­”æ¡ˆä¸å¤ªæ­£ç¢º\)ï¼Œæ‰€ä»¥æœ€å¾Œé‚„æ˜¯å›åˆ° Google äººå·¥æ‰¾æ­£ç¢ºè§£ç­”ã€‚

æ›´ä¸è¦èªªè«‹ä»–å¯« Code äº†ï¼Œé™¤éæ˜¯ç°¡å–®çš„ Code Gen Objectï¼›ä¸ç„¶ä¸è¦å¹»æƒ³ä»–èƒ½ç›´æ¥å®Œæˆæ•´å€‹å·¥å…·æ¶æ§‹ã€‚ _\(è‡³å°‘ç›®å‰æ˜¯é€™æ¨£ï¼Œæ„Ÿè¦ºå¯« Code é€™å¡Š Copilot å¯èƒ½æ›´æœ‰å¹«åŠ©\)_

ä½†ä»–å¯ä»¥çµ¦ä¸€äº›çŸ¥è­˜ç›²å€çš„å¤§æ–¹å‘ï¼Œè®“æˆ‘å€‘èƒ½å¿«é€Ÿå¤§ç•¥çŸ¥é“æŸäº›åœ°æ–¹æ‡‰è©²æœƒæ€éº¼åšï¼›æœ‰çš„æ™‚å€™æŒæ¡åº¦å¤ªä½ï¼Œåœ¨ Google åè€Œå¾ˆé›£å¿«é€Ÿå®šä½åˆ°æ­£ç¢ºçš„æ–¹å‘ï¼Œé€™æ™‚å€™ ChatGPT å°±è »æœ‰å¹«åŠ©çš„ã€‚
### è²æ˜

æ­·ç¶“ä¸‰å€‹å¤šæœˆçš„ç ”ç©¶åŠé–‹ç™¼ï¼Œå·²ç–²æ†Šä¸å ªï¼Œä½†é‚„æ˜¯è¦è²æ˜ä¸€ä¸‹æ­¤åšæ³•åƒ…ç‚ºæˆ‘ç ”ç©¶å¾Œå¾—åˆ°çš„å¯è¡Œçµæœï¼Œä¸ä¸€å®šæ˜¯æœ€ä½³è§£ï¼Œæˆ–é‚„æœ‰å¯å„ªåŒ–çš„åœ°æ–¹ï¼Œé€™å°ˆæ¡ˆæ›´åƒæ˜¯ä¸€å€‹æ‹‹ç£šå¼•ç‰ï¼Œå¸Œæœ›èƒ½å¾—åˆ°ä¸€å€‹ Markup Language to NSAttributedString çš„å®Œç¾è§£ç­”ï¼Œ **éå¸¸æ­¡è¿å¤§å®¶è²¢ç»ï¼›æœ‰è¨±å¤šäº‹é …é‚„éœ€è¦ç¾¤çœ¾çš„åŠ›é‡æ‰èƒ½å®Œå–„** ã€‚
### Contributing


![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} [â­](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*kXjJQnSIJ7x-lSIYtacRrQ.jpeg)

[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} [â­](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

é€™é‚Šå…ˆåˆ—ä¸€äº›æ­¤æ™‚æ­¤åˆ»\(2023/03/12\)æƒ³åˆ°èƒ½æ›´å¥½çš„åœ°æ–¹ï¼Œä¹‹å¾Œæœƒåœ¨ Repo ä¸Šç´€éŒ„ï¼š
1. æ•ˆèƒ½/ç®—æ³•çš„å„ªåŒ–ï¼Œé›–ç„¶æ¯”åŸç”Ÿ `NSAttributedString.DocumentType.html` å¿«é€Ÿä¸”ç©©å®šï¼›ä½†é‚„æœ‰éœ€å¤šå„ªåŒ–ç©ºé–“ï¼Œæˆ‘ç›¸ä¿¡æ•ˆèƒ½çµ•å°ä¸å¦‚ XMLParserï¼›å¸Œæœ›æœ‰æœä¸€æ—¥èƒ½æœ‰åŒæ¨£çš„æ•ˆèƒ½ä½†åˆèƒ½ä¿æŒå®¢è£½åŒ–åŠè‡ªå‹•ä¿®æ­£å®¹éŒ¯
2. æ”¯æ´æ›´å¤š HTML Tagã€Style Attribute è½‰æ›è§£æ
3. [ZNSTextAttachment](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"} å†å„ªåŒ–ï¼Œå¯¦ç¾ reuse èƒ½ï¼Œé‡‹æ”¾è¨˜æ†¶é«”ï¼›å¯èƒ½è¦ç ”ç©¶ CoreText
4. æ”¯æ´ Markdown è§£æï¼Œå› åº•å±¤æŠ½è±¡å…¶å¯¦ä¸å±€é™æ–¼ HTMLï¼›æ‰€ä»¥åªè¦å»ºå¥½å‰é¢çš„ Markdown è½‰ Markup ç‰©ä»¶å°±èƒ½å®Œæˆ Markdown è§£æï¼›å› æ­¤æˆ‘å–åå« ZMarkupParserï¼Œè€Œä¸æ˜¯ ZHTMLParserï¼Œå°±æ˜¯å¸Œæœ›æœ‰æœä¸€æ—¥ä¹Ÿèƒ½æ”¯æ´ Markdown to NSAttributedString
5. æ”¯æ´ Any to Any, e\.g\. HTML To Markdown, Markdown To HTMLï¼Œå› æˆ‘å€‘æœ‰åŸå§‹çš„ AST æ¨¹\(Markup ç‰©ä»¶\)ï¼Œæ‰€ä»¥å¯¦ç¾ä»»æ„ Markup é–“çš„è½‰æ›æ˜¯æœ‰æ©Ÿæœƒçš„
6. å¯¦ç¾ css `!important` åŠŸèƒ½ï¼ŒåŠ å¼·æŠ½è±¡ MarkupStyle çš„ç¹¼æ‰¿ç­–ç•¥
7. åŠ å¼· HTML Selector åŠŸèƒ½ï¼Œç›®å‰åªæ˜¯æœ€ç²—æ·ºçš„ filter åŠŸèƒ½
8. å¥½å¤šå¥½å¤š, æ­¡è¿é–‹ [issue](https://github.com/ZhgChgLi/ZMarkupParser/issues){:target="_blank"}



> [å¦‚æœæ‚¨å¿ƒæœ‰é¤˜è€ŒåŠ›ä¸è¶³ï¼Œä¹Ÿå¯ä»¥é€éçµ¦æˆ‘ä¸€é¡† â­ è®“ Repo å¯ä»¥è¢«æ›´å¤šäººçœ‹è¦‹ï¼Œé€²è€Œè®“ Github å¤§ç¥æœ‰æ©Ÿæœƒå”åŠ©è²¢ç»ï¼](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} 




### ç¸½çµ


![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*A0yXupXW9-F9ZWe4gp2ObA.jpeg)

[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

ä»¥ä¸Šå°±æ˜¯æˆ‘é–‹ç™¼ ZMarkupParser çš„æ‰€æœ‰æŠ€è¡“ç´°ç¯€åŠå¿ƒè·¯æ­·ç¨‹ï¼ŒèŠ±è²»äº†æˆ‘å¿«ä¸‰å€‹æœˆçš„ä¸‹ç­åŠå‡æ—¥æ™‚é–“ï¼Œç„¡æ•¸çš„ç ”ç©¶åŠå¯¦è¸éç¨‹ï¼Œåˆ°æ’°å¯«æ¸¬è©¦ã€æå‡ Test Coverageã€å»ºç«‹ CIï¼›æœ€å¾Œæ‰æœ‰ä¸€å€‹çœ‹èµ·ä¾†æœ‰é»æ¨£å­çš„æˆæœï¼›å¸Œæœ›é€™å€‹å·¥å…·æœ‰è§£æ±ºæ‰æœ‰ç›¸åŒå›°æ“¾çš„æœ‹å‹ï¼Œä¹Ÿå¸Œæœ›å¤§å®¶èƒ½ä¸€èµ·è®“é€™å€‹å·¥å…·è®Šå¾—æ›´å¥½ã€‚


![[pinkoi\.com](https://www.pinkoi.com){:target="_blank"}](/assets/2724f02f6e7/0*9YdJaNSQXlAfmT21.jpg)

[pinkoi\.com](https://www.pinkoi.com){:target="_blank"}

ç›®å‰æœ‰æ‡‰ç”¨åœ¨æ•å¸ [pinkoi\.com](https://www.pinkoi.com){:target="_blank"} çš„ iOS ç‰ˆ App ä¸Šï¼Œæ²’æœ‰ç™¼ç¾å•é¡Œã€‚ğŸ˜„
#### å»¶ä¼¸é–±è®€
- [ZMarkupParser HTML String è½‰æ› NSAttributedString å·¥å…·](../a5643de271e4/)
- [String Rendering](https://www.objc.io/issues/9-strings/string-rendering/){:target="_blank"}
- [Asynchronous NSTextAttachments](https://www.cocoanetics.com/2016/09/asynchronous-nstextattachment-1/){:target="_blank"}



æœ‰ä»»ä½•å•é¡ŒåŠæŒ‡æ•™æ­¡è¿ [èˆ‡æˆ‘è¯çµ¡](https://www.zhgchg.li/contact){:target="_blank"} ã€‚



_[Post](https://medium.com/zrealm-ios-dev/%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0-html-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B-2724f02f6e7){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
