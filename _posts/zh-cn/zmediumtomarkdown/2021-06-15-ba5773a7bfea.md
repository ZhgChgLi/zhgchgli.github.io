---
author: ZhgChgLi
categories:
- ZRealm Dev.
date: 2021-06-15T15:58:36.329+0000
description: Design Pattern Visitor 在 iOS 开发的实际应用场景分析
image:
  path: /assets/ba5773a7bfea/1*Q1BLU8QHVBLEMx6KlMSHWQ.jpeg
last_modified_at: 2024-09-06T05:58:52.296+0000
render_with_liquid: false
tags:
- simplified-chinese
- ios-app-development
- swift
- design-patterns
- visitor-pattern
- double-dispatch
title: Visitor Pattern in iOS (Swift)
---

### Visitor Pattern in Swift (Share Object to XXX Example)



Visitor Pattern 的实际应用场景分析 (在分享 商品、歌曲、文章… 到 Facebook, Line, Linkedin. . 场景)



![Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/ba5773a7bfea/1*Q1BLU8QHVBLEMx6KlMSHWQ.jpeg)



Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}



#### 前言



「Design Pattern」从知道有这个东西到现在也超过 10 年了依然没办法有自信的说能完全掌握，一直以来都是蒙蒙懂懂的，也好几次从头到尾把所有模式都看过一遍，但看了没内化、没在实务上应用很快就忘了。



> *我真的废。*



#### 内功与招式



曾经看到的一个很好的比喻 ，招式部分如：PHP、Laravel、iOS、Swift、SwiftUI…之类的应用，其实在其中切换学习门槛都不算高；但内功部分如：演算法、资料结构、设计模式…等等都属于内功；内功与招式之间有著相辅相成的效果；但是招式好学，内功难练；招式厉害的内功不一定厉害，内功厉害的也可以很快学会招式，所以与其说相辅相成不如说内功才是基础，搭配招式才能所向披靡。



#### 找到适合自己的学习方式



基于之前的学习经验，我认为适合我自己的学习 Design Pattern 方式是 — 先精再通；先著重于精通几个模式，要能内化跟灵活运用，还要培养出嗅觉，能判断什么场景适合什么场景不适合；再一步一步的累积新模式，直到全部掌握；我觉得最好的方式就是多找实务场境，从应用中学习。



#### 学习资源



推荐两个免费的学习资源



- <https://refactoringguru.cn/>{:target="_blank"} ：完整介绍所有模式结构、场景、相互关系


- <https://shirazian.wordpress.com/2016/04/11/design-patterns-in-swift/>{:target="_blank"} ：作者以实际开发 iOS 的场景介绍更个模式的应用，本文也会以这个方向撰写



### Visitor — Behavioral Patterns



第一章纪录的是 Visitor Pattern，这也是在街声工作一年挖到的金矿之一，在 StreetVoice App 中有诸多善用 Visitor 解决架构问题的地方；我也在这段经历之中席的了 Visitor 的原理精髓；所以第一章就来写它！



#### Visitor 是什么



首先请先了解 Visitor 是什么？想要解决什么问题？组成结构是什么？



![图片取自 [refactoringguru](https://refactoringguru.cn/design-patterns/visitor){:target="_blank"}](/assets/ba5773a7bfea/1*rbswlsges8_oS3pNI1-WKA.png)



图片取自 [refactoringguru](https://refactoringguru.cn/design-patterns/visitor){:target="_blank"}



详细内容这边不再重复赘述，请先直接参考 [refactoringguru 对于 Visitor 的讲解](https://refactoringguru.cn/design-patterns/visitor){:target="_blank"} 。



### iOS 实务场景 — 分享功能



假设今天我们有以下几个 Model：UserModel、SongModel、PlaylistModel 这三个 Model，现在我们要实作分享功能，可以分享到：Facebook、Line、Instagram，这三个平台；每个 Model 需要呈现的分享讯息皆为不同、每个平台需要的资料也各有不同：



![](/assets/ba5773a7bfea/1*ad2ijo5Bvm9_wnM1g2LNog.png)



组合场景如上图，第一个表格显示各 Model 的客制化内容、第二个表格显示各分享平台需要的资料。



> ***尤其 Instagram 在分享 Playlist 时要多张图片，跟其他分享要的 source 不一样。***



#### 定义 Model



首先把各个 Model 有哪些 Property 定义完成：



```swift
// Model
struct UserModel {
    let id: String
    let name: String
    let profileImageURLString: String
}

struct SongModel {
    let id: String
    let name: String
    let user: UserModel
    let coverImageURLString: String
}

struct PlaylistModel {
    let id: String
    let name: String
    let user: UserModel
    let songs: [SongModel]
    let coverImageURLString: String
}

// Data

let user = UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png")

let song = SongModel(id: "1",
                     name: "Wake me up",
                     user: user,
                     coverImageURLString: "https://zhgchg.li/cover/1.png")

let playlist = PlaylistModel(id: "1",
                            name: "Avicii Tribute Concert",
                            user: user,
                            songs: [
                                song,
                                SongModel(id: "2", name: "Waiting for love", user: UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png"), coverImageURLString: "https://zhgchg.li/cover/3.png"),
                                SongModel(id: "3", name: "Lonely Together", user: UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png"), coverImageURLString: "https://zhgchg.li/cover/1.png"),
                                SongModel(id: "4", name: "Heaven", user: UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png"), coverImageURLString: "https://zhgchg.li/cover/4.png"),
                                SongModel(id: "5", name: "S.O.S", user: UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png"), coverImageURLString: "https://zhgchg.li/cover/5.png")],
                            coverImageURLString: "https://zhgchg.li/playlist/1.png")
```



#### 什么都没想的做法



完全不考虑架构，先上一个什么都没想的最脏做法。



![周星驰 — 食神](/assets/ba5773a7bfea/1*5kBPDRNpaHNyW4u4YEsOGA.png)



周星驰 — 食神



```swift
class ShareManager {
    private let title: String
    private let urlString: String
    private let imageURLStrings: [String]

    init(user: UserModel) {
        self.title = "Hi 跟你分享一位很赞的艺人\(user.name)。"
        self.urlString = "https://zhgchg.li/user/\(user.id)"
        self.imageURLStrings = [user.profileImageURLString]
    }

    init(song: SongModel) {
        self.title = "Hi 与你分享刚刚听到一首很赞的歌，\(song.user.name) 的 \(song.name)。"
        self.urlString = "https://zhgchg.li/user/\(song.user.id)/song/\(song.id)"
        self.imageURLStrings = [song.coverImageURLString]
    }

    init(playlist: PlaylistModel) {
        self.title = "Hi 这个歌单我听个不停 \(playlist.name)。"
        self.urlString = "https://zhgchg.li/user/\(playlist.user.id)/playlist/\(playlist.id)"
        self.imageURLStrings = playlist.songs.map({ $0.coverImageURLString })
    }

    func shareToFacebook() {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![\(self.title)](\(String(describing: self.imageURLStrings.first))](\(self.urlString))")
    }

    func shareToInstagram() {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(self.imageURLStrings.joined(separator: ","))
    }

    func shareToLine() {
        // call Line share sdk...
        print("Share to Line...")
        print("[\(self.title)](\(self.urlString))")
    }
}
```



没啥好说的，就是 0 架构全搅和在一起，如果今天要新加一个分享平台、更改某个平台的分享资讯、增加一个可分享的 Model 都要动到 ShareManager；另外 imageURLStrings 的设计因是考量到 Instagram 在分享歌单时需要图片组资料所以才宣告成阵列，这有点倒因为果变成照需求去设计架构，其他不需要图片组的类型也遭到污染。



#### 优化一下



稍微分离一下逻辑。



```swift
protocol Shareable {
    func getShareText() -> String
    func getShareURLString() -> String
    func getShareImageURLStrings() -> [String]
}

extension UserModel: Shareable {
    func getShareText() -> String {
        return "Hi 跟你分享一位很赞的艺人\(self.name)。"
    }

    func getShareURLString() -> String {
        return "https://zhgchg.li/user/\(self.id)"
    }

    func getShareImageURLStrings() -> [String] {
        return [self.profileImageURLString]
    }
}

extension SongModel: Shareable {
    func getShareText() -> String {
        return "Hi 与你分享刚刚听到一首很赞的歌，\(self.user.name) 的 \(self.name)。"
    }

    func getShareURLString() -> String {
        return "https://zhgchg.li/user/\(self.user.id)/song/\(self.id)"
    }

    func getShareImageURLStrings() -> [String] {
        return [self.coverImageURLString]
    }
}

extension PlaylistModel: Shareable {
    func getShareText() -> String {
        return "Hi 这个歌单我听个不停 \(self.name)。"
    }

    func getShareURLString() -> String {
        return "https://zhgchg.li/user/\(self.user.id)/playlist/\(self.id)"
    }

    func getShareImageURLStrings() -> [String] {
        return [self.coverImageURLString]
    }
}

protocol ShareManagerProtocol {
    var model: Shareable { get }
    init(model: Shareable)
    func share()
}

class FacebookShare: ShareManagerProtocol {
    let model: Shareable

    required init(model: Shareable) {
        self.model = model
    }

    func share() {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![\(model.getShareText())](\(String(describing: model.getShareImageURLStrings().first))](\(model.getShareURLString())")
    }
}

class InstagramShare: ShareManagerProtocol {
    let model: Shareable

    required init(model: Shareable) {
        self.model = model
    }

    func share() {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(model.getShareImageURLStrings().joined(separator: ","))
    }
}

class LineShare: ShareManagerProtocol {
    let model: Shareable

    required init(model: Shareable) {
        self.model = model
    }

    func share() {
        // call Line share sdk...
        print("Share to Line...")
        print("[\(model.getShareText())](\(model.getShareURLString())")
    }
}
```



我们抽离出一个 CanShare Protocol，凡是 Model 有遵循这个协议都能支援分享；分享的部分也抽离出 ShareManagerProtocol，有新的分享只要实现协议内容即可、要修改删除也都不会影响其他 ShareManager。



但 getShareImageURLStrings 依然诡异，另外假设今天新增的分享平台需求的 Model 资料天壤之别，例如微信分享还需要播放次数、创建日期…等资讯，只有他要，这时候就会开始变得混乱。



#### Visitor



使用 Visitor Pattern 的解法。



```swift
// Visitor Version
protocol Shareable {
    func accept(visitor: SharePolicy)
}

extension UserModel: Shareable {
    func accept(visitor: SharePolicy) {
        visitor.visit(model: self)
    }
}

extension SongModel: Shareable {
    func accept(visitor: SharePolicy) {
        visitor.visit(model: self)
    }
}

extension PlaylistModel: Shareable {
    func accept(visitor: SharePolicy) {
        visitor.visit(model: self)
    }
}

protocol SharePolicy {
    func visit(model: UserModel)
    func visit(model: SongModel)
    func visit(model: PlaylistModel)
}

class ShareToFacebookVisitor: SharePolicy {
    func visit(model: UserModel) {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![Hi 跟你分享一位很赞的艺人\(model.name)。](\(model.profileImageURLString)](https://zhgchg.li/user/\(model.id)")
    }
    
    func visit(model: SongModel) {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![Hi 与你分享刚刚听到一首很赞的歌，\(model.user.name) 的 \(model.name)，他被播方式。](\(model.coverImageURLString))](https://zhgchg.li/user/\(model.user.id)/song/\(model.id)")
    }
    
    func visit(model: PlaylistModel) {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![Hi 这个歌单我听个不停 \(model.name)。](\(model.coverImageURLString))](https://zhgchg.li/user/\(model.user.id)/playlist/\(model.id)")
    }
}

class ShareToLineVisitor: SharePolicy {
    func visit(model: UserModel) {
        // call Line share sdk...
        print("Share to Line...")
        print("[Hi 跟你分享一位很赞的艺人\(model.name)。](https://zhgchg.li/user/\(model.id)")
    }
    
    func visit(model: SongModel) {
        // call Line share sdk...
        print("Share to Line...")
        print("[Hi 与你分享刚刚听到一首很赞的歌，\(model.user.name) 的 \(model.name)，他被播方式。]](https://zhgchg.li/user/\(model.user.id)/song/\(model.id)")
    }
    
    func visit(model: PlaylistModel) {
        // call Line share sdk...
        print("Share to Line...")
        print("[Hi 这个歌单我听个不停 \(model.name)。](https://zhgchg.li/user/\(model.user.id)/playlist/\(model.id)")
    }
}

class ShareToInstagramVisitor: SharePolicy {
    func visit(model: UserModel) {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(model.profileImageURLString)
    }
    
    func visit(model: SongModel) {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(model.coverImageURLString)
    }
    
    func visit(model: PlaylistModel) {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(model.songs.map({ $0.coverImageURLString }).joined(separator: ","))
    }
}

// Use case
let shareToInstagramVisitor = ShareToInstagramVisitor()
user.accept(visitor: shareToInstagramVisitor)
playlist.accept(visitor: shareToInstagramVisitor)
```



我们逐行来看做了什么：



- 首先我们创建了一个 Shareable 的 Protocol，其目的只是方便我们管理 Model 支援分享 Visitor 有统一的接口 (不定义也行)。


- UserModel/SongModel/PlaylistModel 实现 Shareable `func accept(visitor: SharePolicy)` ，之后如果有新增支援分享的 Model 也只需实现协议


- 定义出 SharePolicy 列出所支援的 Model
  `(must be concrete type)` 或许你会想为何不定义成 `visit(model: Shareable)` 如果是这样就重蹈上一版的问题了


- 各个 Share 方法实现 SharePolicy，各自依照 source 去组合需要的资源


- 假设今天多一个微信分享，他要的资料比较特别(播放次数、创建日期)，也不会影响现有程式码，因为他能从 concrete model 拿到他自己需要的资讯。



达成低耦合、高聚合的程式开发目标。



以上是经典的 [Visitor Double Dispatch](https://refactoringguru.cn/design-patterns/visitor-double-dispatch){:target="_blank"} 实现，但我们日常开发上比较少会遇到这种状况，一般常见的状况可能只会有一个 Visitor，但我觉得也很适合使用这套模式组合，例如今天有一个 SaveToCoreData 的需求，我们也可以直接定义 `accept(visitor: SaveToCoreDataVisitor)` ，不多宣告出 Policy Protocol，也是个很好的使用架构。



```swift
protocol Saveable {
  func accept(visitor: SaveToCoreDataVisitor)
}

class SaveToCoreDataVisitor {
    func visit(model: UserModel) {
        // map UserModel to coredata
    }
    
    func visit(model: SongModel) {
        // map SongModel to coredata
    }
    
    func visit(model: PlaylistModel) {
        // map PlaylistModel to coredata
    }
}
```



其他应用：Save、Like、tableview/collectionview cellforrow….



### 原则



最后讲一下一些共通原则



- Code 是给人读的，切勿 Over Designed


- 统一很重要，同样的场境同个 Codebase 应该使用同个架构方法


- 如果范围是可控的或不可能出现其他状况，这时候如果还继续往下拆分就可以认为是 Over Designed


- 多应用、少发明；Design Pattern 已经在软体设计领域好几十年，他所考量到的场景一定比我们创造一个新的架构还来的完善


- 看不懂 Design Pattern 可以学，但如果是自己创造的架构就比较难说服别人学，因为学了可能也只能用在这个 Case 上，他就不是一个 Common sense


- 程式码重复不代表不好，如果一昧追求封装可能导致 Over Designed；一样回到前面几点，程式是给人读的，所以只要是好读加上低耦合高聚合都是好的 Code


- 勿魔改 Pattern，人家设计一定有他的道理，如果乱魔改可能导致某些场景出现问题


- 只要开始绕路就会越绕越远，程式会越来越脏



> *inspired by [＠saiday](https://twitter.com/saiday){:target="_blank"}*



#### 参考资料



- [Design Patterns in Swift: Visitor](https://shirazian.wordpress.com/2016/04/22/design-patterns-in-swift-visitor/){:target="_blank"}
  (另一个使用 Visitor 的场景应用)


- <https://github.com/kingreza/Swift-Visitor>{:target="_blank"}


- [Deep Linking at Scale on iOS](https://medium.com/@albertodebo/deep-linking-at-scale-on-ios-1dd8789c389f){:target="_blank"} (State Pattern)



### 延伸阅读



- Design Patterns 的实战应用纪录 — In WKWebView with Builder, Strategy & Chain of Responsibility Pattern


- [Design Patterns 的实战应用纪录](../78507a8de6a5/)


- [Visitor Pattern in TableView](../60473cb47550/)



有任何问题及指教欢迎 [与我联络](https://www.zhgchg.li/contact){:target="_blank"} 。



*[Post](https://medium.com/zrealm-ios-dev/visitor-pattern-in-ios-swift-ba5773a7bfea){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*