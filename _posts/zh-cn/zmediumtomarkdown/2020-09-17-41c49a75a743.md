---
author: ZhgChgLi
categories:
- ZRealm Dev.
date: 2020-09-17T15:53:20.026+0000
description: å¯¼å…¥ Localization å¤šè¯­ç³»åŠ Image Assets ç¼ºæ¼æ£€æŸ¥ã€ä½¿ç”¨ Swift æ‰“é€  Run Script è„šæœ¬
image:
  path: /assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg
last_modified_at: 2024-04-13T08:35:25.885+0000
render_with_liquid: false
tags:
- ios
- shell-script
- xcode
- ios-app-development
- toolkit
title: Xcode ç›´æ¥ä½¿ç”¨ Swift æ’°å†™ Run Scriptï¼
---

### Xcode ç›´æ¥ä½¿ç”¨ Swift æ’°å†™ Shell Scriptï¼



å¯¼å…¥ Localization å¤šè¯­ç³»åŠ Image Assets ç¼ºæ¼æ£€æŸ¥ã€ä½¿ç”¨ Swift æ‰“é€  Shell Script è„šæœ¬



![Photo by [Glenn Carstens-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg)



Photo by [Glenn Carstens-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}



### ç¼˜ç”±



å› ä¸ºè‡ªå·±æ‰‹æ®‹ï¼Œæ—¶å¸¸åœ¨ç¼–è¾‘å¤šè¯­ç³»æ¡£æ¡ˆæ—¶é—æ¼ã€Œ;ã€å¯¼è‡´ app build å‡ºæ¥è¯­è¨€æ˜¾ç¤ºå‡ºé”™å†åŠ ä¸Šéšè‘—å¼€å‘çš„æ¨ç§»è¯­ç³»æ¡£æ¡ˆè¶Šæ¥è¶Šåºå¤§ï¼Œé‡å¤çš„ã€å·²æ²¡ç”¨åˆ°çš„è¯­å¥éƒ½å¤¹æ‚å†ä¸€èµ·ï¼Œéå¸¸æ··ä¹±ï¼ˆImage Assets åŒæ ·çŠ¶å†µï¼‰ã€‚



ä¸€ç›´ä»¥æ¥éƒ½æƒ³æ‰¾å·¥å…·ååŠ©å¤„ç†è¿™æ–¹é¢çš„é—®é¢˜ï¼Œä¹‹å‰æ˜¯ç”¨ [iOSLocalizationEditor](https://github.com/igorkulman/iOSLocalizationEditor){:target="_blank"} è¿™ä¸ª Mac APPï¼Œä½†å®ƒæ¯”è¾ƒåƒæ˜¯è¯­ç³»æ¡£æ¡ˆç¼–è¾‘å™¨ï¼Œè¯»å–è¯­ç³»æ¡£æ¡ˆå†…å®¹ï¼†ç¼–è¾‘ï¼Œæ²¡æœ‰è‡ªåŠ¨æ£€æŸ¥çš„åŠŸèƒ½ã€‚



### æœŸæœ›åŠŸèƒ½



build ä¸“æ¡ˆæ—¶èƒ½è‡ªåŠ¨æ£€æŸ¥å¤šè¯­ç³»æœ‰æ— é”™è¯¯ã€ç¼ºéœ²ã€é‡å¤ã€Image Assets æœ‰æ— ç¼ºæ¼ã€‚



### è§£å†³æ–¹æ¡ˆ



è¦è¾¾åˆ°æˆ‘ä»¬çš„æœŸæœ›åŠŸèƒ½å°±è¦åœ¨ Build Phases åŠ å…¥ Run Script æ£€æŸ¥è„šæœ¬ã€‚



ä½†æ£€æŸ¥è„šæœ¬éœ€è¦ä½¿ç”¨ shell script æ’°å†™ï¼Œå› è‡ªå·±å¯¹ shell script çš„æŒæ¡åº¦å¹¶ä¸å¤ªé«˜ï¼Œæƒ³è¯´ç«™åœ¨å·¨äººçš„è‚©è†€ä¸Šä»ç½‘è·¯æœå¯»ç°æœ‰è„šæœ¬ä¹Ÿæ‰¾ä¸å¤ªåˆ°å®Œå…¨ç¬¦åˆæœŸæœ›åŠŸèƒ½çš„ scriptï¼Œå†å¿«è¦æ”¾å¼ƒçš„æ—¶å€™çªç„¶æƒ³åˆ°ï¼š



> **Shell Script å¯ä»¥ç”¨ Swift æ¥å†™å•Š** ï¼



ç›¸å¯¹ shell script æ¥è¯´æ›´ç†Ÿæ‚‰ã€æŒæ¡åº¦æ›´é«˜ï¼ä¾ç…§è¿™ä¸ªæ–¹å‘æœç„¶è®©æˆ‘æ‰¾åˆ°ä¸¤ä¸ªç°æœ‰çš„å·¥å…·è„šæœ¬ï¼



ç”± [freshOS](https://freshos.github.io/){:target="_blank"} è¿™ä¸ªå›¢é˜Ÿæ’°å†™çš„ä¸¤ä¸ªæ£€æŸ¥å·¥å…·ï¼š



- [**Localize ğŸ**](https://github.com/freshOS/Localize){:target="_blank"}


- [**Asset Checker ğŸ‘®**](https://github.com/s4cha/AssetChecker){:target="_blank"}



å®Œå…¨ç¬¦åˆæˆ‘ä»¬çš„æœŸæœ›åŠŸèƒ½éœ€æ±‚! ! å¹¶ä¸”ä»–ä»¬ä½¿ç”¨ swift æ’°å†™ï¼Œè¦å®¢åˆ¶åŒ–é­”æ”¹éƒ½å¾ˆå®¹æ˜“ã€‚



#### [Localize ğŸ](https://github.com/freshOS/Localize){:target="_blank"} å¤šè¯­ç³»æ¡£æ£€æŸ¥å·¥å…·



**åŠŸèƒ½ï¼š**



- build æ—¶è‡ªåŠ¨æ£€æŸ¥


- è¯­ç³»æ¡£è‡ªåŠ¨æ’ç‰ˆã€æ•´ç†


- æ£€æŸ¥å¤šè¯­ç³»ä¸ä¸»è¦è¯­ç³»ä¹‹ç¼ºæ¼ã€å¤šä½™


- æ£€æŸ¥å¤šè¯­ç³»é‡å¤è¯­å¥


- æ£€æŸ¥å¤šè¯­ç³»æœªç»ç¿»è¯‘è¯­å¥


- æ£€æŸ¥å¤šè¯­ç³»æœªä½¿ç”¨çš„è¯­å¥



**å®‰è£…æ–¹æ³•ï¼š**



1. [ä¸‹è½½å·¥å…·çš„ Swift Script æ¡£æ¡ˆ](https://github.com/freshOS/Localize/blob/master/Localize.swift){:target="_blank"}


2. æ”¾åˆ°ä¸“æ¡ˆç›®å½•ä¸‹ EX: `${SRCROOT}/Localize.swift`


3. æ‰“å¼€ä¸“æ¡ˆè®¾å®š â†’ iOS Target â†’ Build Phases â†’å·¦ä¸Šè§’ã€Œ+ã€ â†’ New Run Script Phases â†’ åœ¨ Script å†…å®¹è´´ä¸Šè·¯å¾„ EX: `${SRCROOT}/Localize.swift`



![](/assets/41c49a75a743/1*k2OHjrcQaQIWLqV7G57TgA.png)



4. ä½¿ç”¨ Xcode æ‰“å¼€ç¼–è¾‘ `Localize.swift` æ¡£æ¡ˆè¿›è¡Œè®¾å®šï¼Œå¯ä»¥åœ¨æ¡£æ¡ˆä¸ŠåŠéƒ¨çœ‹åˆ°å¯æ›´åŠ¨çš„è®¾å®šé¡¹ç›®ï¼š



```swift
//å¯ç”¨æ£€æŸ¥è„šæœ¬
let enabled = true

//è¯­ç³»æ¡£æ¡ˆç›®å½•
let relativeLocalizableFolders = "/Resources/Languages"

//ä¸“æ¡ˆç›®å½•ï¼ˆç”¨æ¥æœç´¢è¯­å¥æœ‰æ²¡æœ‰åœ¨ç¨‹å¼ç ä¸­ä½¿ç”¨åˆ°ï¼‰
let relativeSourceFolder = "/Sources"

//ç¨‹å¼ç ä¸­çš„ NSLocalized è¯­ç³»æ¡£æ¡ˆä½¿ç”¨æ­£è§„åŒ¹é…è¡¨ç¤ºæ³•
//å¯è‡ªè¡Œå¢åŠ ã€æ— éœ€å˜åŠ¨
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\"", // Swift and Objc Native
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine Calls
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen generation
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized pattern
]

//è¦å¿½ç•¥ã€Œè¯­å¥æœªä½¿ç”¨è­¦å‘Šã€çš„è¯­å¥
let ignoredFromUnusedKeys: [String] = []
/* example
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

//ä¸»è¦è¯­ç³»
let masterLanguage = "en"

//å¼€å¯ä¸ç³»æ¡£æ¡ˆa-zæ’åºã€æ•´ç†åŠŸèƒ½
let sanitizeFiles = false

//ä¸“æ¡ˆæ˜¯å•ä¸€orå¤šè¯­ç³»
let singleLanguage = false

//å¯ç”¨æ£€æŸ¥æœªç¿»è¯‘è¯­å¥åŠŸèƒ½
let checkForUntranslated = true
```



5. Buildï¼æˆåŠŸï¼



![](/assets/41c49a75a743/1*74osParg9RRi2gcRx9ELuw.png)



**æ£€æŸ¥ç»“æœæç¤ºç±»å‹ï¼š**



- **Build Error** âŒ **ï¼š**
  - [Duplication] é¡¹ç›®åœ¨è¯­ç³»æ¡£æ¡ˆå†…å­˜åœ¨é‡å¤
  - [Unused Key] é¡¹ç›®åœ¨è¯­ç³»æ¡£æ¡ˆå†…æœ‰å®šä¹‰ï¼Œä½†å®é™…ç¨‹å¼ä¸­æœªä½¿ç”¨åˆ°
  - [Missing] é¡¹ç›®åœ¨è¯­ç³»æ¡£æ¡ˆå†…æœªå®šä¹‰ï¼Œä½†å®é™…ç¨‹å¼ä¸­æœ‰ä½¿ç”¨åˆ°
  - [Redundant] é¡¹ç›®åœ¨æ­¤è¯­ç³»æ¡£ç›¸è¾ƒäºä¸»è¦è¯­ç³»æ¡£æ˜¯å¤šä½™çš„
  - [Missing Translation] é¡¹ç›®åœ¨ä¸»è¦è¯­ç³»æ¡£æœ‰ï¼Œä½†åœ¨æ­¤è¯­ç³»æ¡£ç¼ºæ¼


- **Build Warning** âš ï¸ **ï¼š**
  - [Potentially Untranslated] æ­¤é¡¹ç›®æœªç»ç¿»è¯‘ï¼ˆä¸ä¸»è¯­ç³»æ¡£é¡¹ç›®å†…å®¹ç›¸åŒï¼‰



> ***è¿˜æ²¡ç»“æŸï¼Œç°åœ¨è‡ªåŠ¨æ£€æŸ¥æç¤ºæœ‰äº†ï¼Œä½†æˆ‘ä»¬è¿˜éœ€è¦è‡ªè¡Œé­”æ”¹ä¸€ä¸‹ã€‚***



**å®¢åˆ¶åŒ–åŒ¹é…æ­£è§„è¡¨ç¤ºï¼š**



å›å¤´çœ‹æ£€æŸ¥è„šæœ¬ `Localize.swift` é¡¶éƒ¨è®¾å®šåŒºå— patterns éƒ¨åˆ†çš„ç¬¬ä¸€é¡¹ï¼š



`"NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\""`



åŒ¹é… Swift/ObjCçš„ `NSLocalizedString()` æ–¹æ³•ï¼Œè¿™ä¸ªæ­£è§„è¡¨ç¤ºå¼åªèƒ½åŒ¹é… `"Home.Title"` è¿™ç§æ ¼å¼çš„è¯­å¥ï¼›å‡è®¾æˆ‘ä»¬æ˜¯å®Œæ•´å¥å­æˆ–æœ‰å¸¦ Format å‚æ•°ï¼Œåˆ™ä¼šè¢«å½“è¯¯å½“æˆ [Unused Key]ã€‚



EX: `"Hi, %@ welcome to my app"ã€"Hello World!"` **&lt;- è¿™äº›è¯­å¥éƒ½æ— æ³•åŒ¹é…**



æˆ‘ä»¬å¯ä»¥æ–°å¢ä¸€æ¡ patterns è®¾å®šã€æˆ–æ›´æ”¹åŸæœ¬çš„ patterns æˆï¼š



`"NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\""`



ä¸»è¦æ˜¯è°ƒæ•´ `NSLocalizedString` æ–¹æ³•åçš„åŒ¹é…è¯­å¥ï¼Œå˜æˆå–ä»»æ„å­—ä¸²ç›´åˆ° `"` å‡ºç°å°±ä¸­æ­¢ï¼Œä½ ä¹Ÿå¯ä»¥ [ç‚¹æ­¤](https://rubular.com/r/5eXvGy3svsAHyT){:target="_blank"} ä¾ç…§è‡ªå·±çš„éœ€æ±‚è¿›è¡Œå®¢åˆ¶ã€‚



**åŠ ä¸Šè¯­ç³»æ¡£æ¡ˆæ ¼å¼æ£€æŸ¥åŠŸèƒ½ï¼š**



æ­¤è„šæœ¬ä»…é’ˆå¯¹è¯­ç³»æ¡£åšå†…å®¹å¯¹åº”æ£€æŸ¥ï¼Œä¸ä¼šæ£€æŸ¥æ¡£æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¡®ï¼ˆæ˜¯å¦æœ‰å¿˜è®°åŠ ã€Œ **;** ã€ï¼‰ï¼Œå¦‚æœéœ€è¦è¿™ä¸ªåŠŸèƒ½è¦è‡ªå·±åŠ ä¸Šï¼



```swift
//....
let formatResult = shell("plutil -lint \(location)")
guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
  let str = "\(path)/\(name).lproj"
            + "/Localizable.strings:1: "
            + "error: [File Invaild] "
            + "This Localizable.strings file format is invalid."
  print(str)
  numberOfErrors += 1
  return
}
//....

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```



å¢åŠ  `shell()` æ‰§è¡Œ shell scriptï¼Œä½¿ç”¨ `plutil -lint` æ£€æŸ¥ plist è¯­ç³»æ¡£æ¡ˆæ ¼å¼æ­£ç¡®æ€§ï¼Œæœ‰é”™ã€å°‘ã€Œ;ã€ä¼šå›ä¼ é”™è¯¯ï¼Œæ²¡é”™ä¼šå›ä¼  `OK` ä»¥æ­¤ä½œä¸ºåˆ¤æ–­ï¼



æ£€æŸ¥çš„åœ°æ–¹å¯åŠ åœ¨ LocalizationFiles-&gt;process( ) -&gt; `let location = singleLanguageâ€¦` åï¼Œçº¦ 135 è¡Œçš„åœ°æ–¹æˆ–å‚è€ƒæˆ‘æœ€åæä¾›çš„å®Œæ•´é­”æ”¹ç‰ˆã€‚



**å…¶ä»–å®¢åˆ¶åŒ–ï¼š**



æˆ‘ä»¬å¯ä»¥ä¾ç…§è‡ªå·±çš„éœ€æ±‚è¿›è¡Œå®¢åˆ¶ï¼Œä¾‹å¦‚æŠŠ error æ¢æˆ warning æˆ–æ˜¯æ‹”æ‰æŸä¸ªæ£€æŸ¥åŠŸèƒ½ (EX: Potentially Untranslatedã€Unused Key)ï¼›è„šæœ¬å°±æ˜¯ swift æˆ‘ä»¬éƒ½å¾ˆç†Ÿæ‚‰ï¼ä¸æ€•æ”¹åæ”¹é”™ï¼



è¦è®© build æ—¶å‡ºç° Error âŒï¼š



```
print("Projectæ¡£æ¡ˆ.lproj" + "/æ¡£æ¡ˆ:è¡Œ: " + "error: é”™è¯¯è®¯æ¯")
```



è¦è®© build æ—¶å‡ºç° Warning âš ï¸ï¼š



```
print("Projectæ¡£æ¡ˆ.lproj" + "/æ¡£æ¡ˆ:è¡Œ: " + "warning: è­¦å‘Šè®¯æ¯")
```



**æœ€ç»ˆé­”æ”¹ç‰ˆï¼š**



```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// WHAT
// 1. Find Missing keys in other Localisation files
// 2. Find potentially untranslated keys
// 3. Find Duplicate keys
// 4. Find Unused keys and generate script to delete them all at once

// MARK: Start Of Configurable Section

/*
 You can enable or disable the script whenever you want
 */
let enabled = true

/*
 Put your path here, example ->  Resources/Localizations/Languages
 */
let relativeLocalizableFolders = "/streetvoice/SupportingFiles"

/*
 This is the path of your source folder which will be used in searching
 for the localization keys you actually use in your project
 */
let relativeSourceFolder = "/streetvoice"

/*
 Those are the regex patterns to recognize localizations.
 */
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\"", // Swift and Objc Native
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine Calls
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen generation
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized pattern
]

/*
 Those are the keys you don't want to be recognized as "unused"
 For instance, Keys that you concatenate will not be detected by the parsing
 so you want to add them here in order not to create false positives :)
 */
let ignoredFromUnusedKeys: [String] = []
/* example
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

let masterLanguage = "base"

/*
 Sanitizing files will remove comments, empty lines and order your keys alphabetically.
 */
let sanitizeFiles = false

/*
 Determines if there are multiple localizations or not.
 */
let singleLanguage = false

/*
 Determines if we should show errors if there's a key within the app
 that does not appear in master translations.
*/
let checkForUntranslated = false

// MARK: End Of Configurable Section

if enabled == false {
    print("Localization check cancelled")
    exit(000)
}

// Detect list of supported languages automatically
func listSupportedLanguages() -> [String] {
    var sl: [String] = []
    let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
    if !FileManager.default.fileExists(atPath: path) {
        print("Invalid configuration: \(path) does not exist.")
        exit(1)
    }
    let enumerator = FileManager.default.enumerator(atPath: path)
    let extensionName = "lproj"
    print("Found these languages:")
    while let element = enumerator?.nextObject() as? String {
        if element.hasSuffix(extensionName) {
            print(element)
            let name = element.replacingOccurrences(of: ".\(extensionName)", with: "")
            sl.append(name)
        }
    }
    return sl
}

let supportedLanguages = listSupportedLanguages()
var ignoredFromSameTranslation: [String: [String]] = [:]
let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
var numberOfWarnings = 0
var numberOfErrors = 0

struct LocalizationFiles {
    var name = ""
    var keyValue: [String: String] = [:]
    var linesNumbers: [String: Int] = [:]

    init(name: String) {
        self.name = name
        process()
    }

    mutating func process() {
        if sanitizeFiles {
            removeCommentsFromFile()
            removeEmptyLinesFromFile()
            sortLinesAlphabetically()
        }
        let location = singleLanguage ? "\(path)/Localizable.strings" : "\(path)/\(name).lproj/Localizable.strings"
        
        let formatResult = shell("plutil -lint \(location)")
        guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
            let str = "\(path)/\(name).lproj"
                + "/Localizable.strings:1: "
                + "error: [File Invaild] "
                + "This Localizable.strings file format is invalid."
            print(str)
            numberOfErrors += 1
            return
        }
        
        guard let string = try? String(contentsOfFile: location, encoding: .utf8) else {
            return
        }

        let lines = string.components(separatedBy: .newlines)
        keyValue = [:]

        let pattern = "\"(.*)\" = \"(.+)\";"
        let regex = try? NSRegularExpression(pattern: pattern, options: [])
        var ignoredTranslation: [String] = []

        for (lineNumber, line) in lines.enumerated() {
            let range = NSRange(location: 0, length: (line as NSString).length)

            // Ignored pattern
            let ignoredPattern = "\"(.*)\" = \"(.+)\"; *\\/\\/ *ignore-same-translation-warning"
            let ignoredRegex = try? NSRegularExpression(pattern: ignoredPattern, options: [])
            if let ignoredMatch = ignoredRegex?.firstMatch(in: line,
                                                           options: [],
                                                           range: range) {
                let key = (line as NSString).substring(with: ignoredMatch.range(at: 1))
                ignoredTranslation.append(key)
            }

            if let firstMatch = regex?.firstMatch(in: line, options: [], range: range) {
                let key = (line as NSString).substring(with: firstMatch.range(at: 1))
                let value = (line as NSString).substring(with: firstMatch.range(at: 2))

                if keyValue[key] != nil {
                    let str = "\(path)/\(name).lproj"
                        + "/Localizable.strings:\(linesNumbers[key]!): "
                        + "error: [Duplication] \"\(key)\" "
                        + "is duplicated in \(name.uppercased()) file"
                    print(str)
                    numberOfErrors += 1
                } else {
                    keyValue[key] = value
                    linesNumbers[key] = lineNumber + 1
                }
            }
        }
        print(ignoredFromSameTranslation)
        ignoredFromSameTranslation[name] = ignoredTranslation
    }

    func rebuildFileString(from lines: [String]) -> String {
        return lines.reduce("") { (r: String, s: String) -> String in
            (r == "") ? (r + s) : (r + "\n" + s)
        }
    }

    func removeEmptyLinesFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeCommentsFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { !$0.hasPrefix("//") }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func sortLinesAlphabetically() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            let lines = string.components(separatedBy: .newlines)

            var s = ""
            for (i, l) in sortAlphabetically(lines).enumerated() {
                s += l
                if i != lines.count - 1 {
                    s += "\n"
                }
            }
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeEmptyLinesFromLines(_ lines: [String]) -> [String] {
        return lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
    }

    func sortAlphabetically(_ lines: [String]) -> [String] {
        return lines.sorted()
    }
}

// MARK: - Load Localisation Files in memory

let masterLocalizationFile = LocalizationFiles(name: masterLanguage)
let localizationFiles = supportedLanguages
    .filter { $0 != masterLanguage }
    .map { LocalizationFiles(name: $0) }

// MARK: - Detect Unused Keys

let sourcesPath = FileManager.default.currentDirectoryPath + relativeSourceFolder
let fileManager = FileManager.default
let enumerator = fileManager.enumerator(atPath: sourcesPath)
var localizedStrings: [String] = []
while let swiftFileLocation = enumerator?.nextObject() as? String {
    // checks the extension
    if swiftFileLocation.hasSuffix(".swift") \\|\\| swiftFileLocation.hasSuffix(".m") \\|\\| swiftFileLocation.hasSuffix(".mm") {
        let location = "\(sourcesPath)/\(swiftFileLocation)"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            for p in patterns {
                let regex = try? NSRegularExpression(pattern: p, options: [])
                let range = NSRange(location: 0, length: (string as NSString).length) // Obj c wa
                regex?.enumerateMatches(in: string,
                                        options: [],
                                        range: range,
                                        using: { result, _, _ in
                                            if let r = result {
                                                let value = (string as NSString).substring(with: r.range(at: r.numberOfRanges - 1))
                                                localizedStrings.append(value)
                                            }
                })
            }
        }
    }
}

var masterKeys = Set(masterLocalizationFile.keyValue.keys)
let usedKeys = Set(localizedStrings)
let ignored = Set(ignoredFromUnusedKeys)
let unused = masterKeys.subtracting(usedKeys).subtracting(ignored)
let untranslated = usedKeys.subtracting(masterKeys)

// Here generate Xcode regex Find and replace script to remove dead keys all at once!
var replaceCommand = "\"("
var counter = 0
for v in unused {
    var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[v]!): "
    str += "error: [Unused Key] \"\(v)\" is never used"
    print(str)
    numberOfErrors += 1
    if counter != 0 {
        replaceCommand += "\\|"
    }
    replaceCommand += v
    if counter == unused.count - 1 {
        replaceCommand += ")\" = \".*\";"
    }
    counter += 1
}

print(replaceCommand)

// MARK: - Compare each translation file against master (en)

for file in localizationFiles {
    for k in masterLocalizationFile.keyValue.keys {
        if file.keyValue[k] == nil {
            var str = "\(path)/\(file.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[k]!): "
            str += "error: [Missing] \"\(k)\" missing from \(file.name.uppercased()) file"
            print(str)
            numberOfErrors += 1
        }
    }

    let redundantKeys = file.keyValue.keys.filter { !masterLocalizationFile.keyValue.keys.contains($0) }

    for k in redundantKeys {
        let str = "\(path)/\(file.name).lproj/Localizable.strings:\(file.linesNumbers[k]!): "
            + "error: [Redundant key] \"\(k)\" redundant in \(file.name.uppercased()) file"

        print(str)
    }
}

if checkForUntranslated {
    for key in untranslated {
        var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:1: "
        str += "error: [Missing Translation] \(key) is not translated"

        print(str)
        numberOfErrors += 1
    }
}

print("Number of warnings : \(numberOfWarnings)")
print("Number of errors : \(numberOfErrors)")

if numberOfErrors > 0 {
    exit(1)
}

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```



> ***æœ€åæœ€åï¼Œè¿˜æ²¡ç»“æŸï¼***



å½“æˆ‘ä»¬çš„ swift æ£€æŸ¥å·¥å…·è„šæœ¬éƒ½è°ƒè¯•å®Œæˆä¹‹åï¼Œè¦å°†å…¶ **compile æˆæ‰§è¡Œæ¡£å‡å°‘ build èŠ±è´¹æ—¶é—´** ï¼Œå¦åˆ™æ¯æ¬¡ build éƒ½è¦é‡æ–° compile ä¸€æ¬¡ï¼ˆçº¦èƒ½å‡å°‘ 90% çš„æ—¶é—´ï¼‰ã€‚



æ‰“å¼€ terminal ï¼Œå‰å¾€ä¸“æ¡ˆä¸­æ£€æŸ¥å·¥å…·è„šæœ¬æ‰€åœ¨ç›®å½•ä¸‹æ‰§è¡Œï¼š



```bash
swiftc -o Localize Localize.swift
```



![](/assets/41c49a75a743/1*rwq_KZIDW-Lvtpd2xmgjDw.png)



![](/assets/41c49a75a743/1*BCKtqshZxHH17j3nBGtNlg.png)



ç„¶åå†å›å¤´åˆ° Build Phases æ›´æ”¹ Script å†…å®¹è·¯å¾„æˆæ‰§è¡Œæ¡£



EX: `${SRCROOT}/Localize`



![](/assets/41c49a75a743/1*ewhCXzXNuS0MCTMCuINWng.png)



**å®Œå·¥ï¼**



#### å·¥å…· 2. [**Asset Checker ğŸ‘®**](https://github.com/s4cha/AssetChecker){:target="_blank"} **å›¾ç‰‡èµ„æºæ£€æŸ¥å·¥å…·**



**åŠŸèƒ½ï¼š**



- build æ—¶è‡ªåŠ¨æ£€æŸ¥


- æ£€æŸ¥å›¾ç‰‡ç¼ºæ¼ï¼šåç§°æœ‰å‘¼å«ï¼Œä½†å›¾ç‰‡èµ„æºç›®å½•å†…æ²¡æœ‰å‡ºç°


- æ£€æŸ¥å›¾ç‰‡å¤šä½™ï¼šåç§°æœªä½¿ç”¨ï¼Œä½†å›¾ç‰‡èµ„æºç›®å½•å­˜åœ¨çš„



**å®‰è£…æ–¹æ³•ï¼š**



1. [ä¸‹è½½å·¥å…·çš„ Swift Script æ¡£æ¡ˆ](https://github.com/freshOS/AssetChecker/blob/master/Classes/main.swift){:target="_blank"}


2. æ”¾åˆ°ä¸“æ¡ˆç›®å½•ä¸‹ EX: `${SRCROOT}/AssetChecker.swift`


3. æ‰“å¼€ä¸“æ¡ˆè®¾å®š â†’ iOS Target â†’ Build Phases â†’å·¦ä¸Šè§’ã€Œ+ã€ â†’ New Run Script Phases â†’ åœ¨ Script å†…å®¹è´´ä¸Šè·¯å¾„



```bash
${SRCROOT}/AssetChecker.swift ${SRCROOT}/ä¸“æ¡ˆç›®å½• ${SRCROOT}/Resources/Images.xcassets
//${SRCROOT}/Resources/Images.xcassets = ä½  .xcassets çš„ä½ç½®
```



![](/assets/41c49a75a743/1*TPLS60W1iQiGFzU-inf3aA.png)



å¯ç›´æ¥å°†è®¾å®šå‚æ•°å¸¦åœ¨è·¯å¾„ä¸Šï¼Œå‚æ•°1:ä¸“æ¡ˆç›®å½•ä½ç½®ã€å‚æ•°2:å›¾ç‰‡èµ„æºç›®å½•ä½ç½®ï¼›æˆ–è·Ÿè¯­ç³»æ£€æŸ¥å·¥å…·ä¸€æ ·ç¼–è¾‘ `AssetChecker.swift` é¡¶éƒ¨å‚æ•°è®¾å®šåŒºå—ï¼š



```swift
// Configure me \o/

// ä¸“æ¡ˆç›®å½•ä½ç½®ï¼ˆç”¨æ¥æœç´¢å›¾ç‰‡æœ‰æ²¡æœ‰åœ¨ç¨‹å¼ç ä¸­ä½¿ç”¨åˆ°ï¼‰
var sourcePathOption:String? = nil

// .xcassets ç›®å½•ä½ç½®
var assetCatalogPathOption:String? = nil

// Unused è­¦å‘Šå¿½ç•¥é¡¹ç›®
let ignoredUnusedNames = [String]()
```



4. Buildï¼ æˆåŠŸï¼



**æ£€æŸ¥ç»“æœæç¤ºç±»å‹ï¼š**



- **Build Error** âŒ **ï¼š**
  - [Asset Missing] é¡¹ç›®åœ¨ç¨‹å¼å†…æœ‰å‘¼å«ä½¿ç”¨ï¼Œä½†å›¾ç‰‡èµ„æºç›®å½•å†…æ²¡æœ‰å‡ºç°


- **Build Warning** âš ï¸ **ï¼š**
  - [Asset Unused] é¡¹ç›®åœ¨ç¨‹å¼å†…æœªä½¿ç”¨ï¼Œä½†å›¾ç‰‡èµ„æºç›®å½•å†…æœ‰å‡ºç°
  *p.s å‡è®¾å›¾ç‰‡æ˜¯åŠ¨æ€å˜æ•°æä¾›ï¼Œæ£€æŸ¥å·¥å…·å°†æ— æ³•è¯†åˆ«ï¼Œå¯å°†å…¶åŠ å…¥ `ignoredUnusedNames` ä¸­è®¾ä¸ºä¾‹å¤–ã€‚*



å…¶ä»–æ“ä½œåŒè¯­ç³»æ£€æŸ¥å·¥å…·ï¼Œè¿™è¾¹å°±ä¸åšèµ˜è¿°ï¼›æœ€é‡è¦çš„äº‹æ˜¯ä¹Ÿè¦ **è®°å¾—è°ƒé€‚å®Œåè¦ compile æˆæ‰§è¡Œæ¡£ï¼Œå¹¶æ›´æ”¹ run script å†…å®¹ä¸ºæ‰§è¡Œæ¡£ï¼**



#### å¼€å‘è‡ªå·±çš„å·¥å…·ï¼



> ***æˆ‘ä»¬å¯ä»¥å‚è€ƒå›¾ç‰‡èµ„æºæ£€æŸ¥å·¥å…·è„šæœ¬ï¼š***



```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// Configure me \o/
var sourcePathOption:String? = nil
var assetCatalogPathOption:String? = nil
let ignoredUnusedNames = [String]()

for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        sourcePathOption = arg
    case 2:
        assetCatalogPathOption = arg
    default:
        break
    }
}

guard let sourcePath = sourcePathOption else {
    print("AssetChecker:: error: Source path was missing!")
    exit(0)
}

guard let assetCatalogAbsolutePath = assetCatalogPathOption else {
    print("AssetChecker:: error: Asset Catalog path was missing!")
    exit(0)
}

print("Searching sources in \(sourcePath) for assets in \(assetCatalogAbsolutePath)")

/* Put here the asset generating false positives, 
 For instance whne you build asset names at runtime
let ignoredUnusedNames = [
    "IconArticle",
    "IconMedia",
    "voteEN",
    "voteES",
    "voteFR"
] 
*/


// MARK : - End Of Configurable Section
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}


// MARK: - List Assets
func listAssets() -> [String] {
    let extensionName = "imageset"
    let enumerator = FileManager.default.enumerator(atPath: assetCatalogAbsolutePath)
    return elementsInEnumerator(enumerator)
        .filter { $0.hasSuffix(extensionName) }                             // Is Asset
        .map { $0.replacingOccurrences(of: ".\(extensionName)", with: "") } // Remove extension
        .map { $0.components(separatedBy: "/").last ?? $0 }                 // Remove folder path
}


// MARK: - List Used Assets in the codebase
func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // Image Literal
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // Default UIImage call (Swift)
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // Default UIImage call 
        "\\<image name=\"\(namePattern)\".*", // Storyboard resources
        "R.image.\(namePattern)\\(\\)" //R.swift support
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .compactMap{$0}
            .compactMap{$0}                                             // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings ocurrences
            .flatMap{$0}                                                // Flatten
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .flatMap{$0}
            .flatMap{$0}                                                // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings ocurrences
            .flatMap{$0}                                                // Flatten
    #endif
}


// MARK: - Begining of script
let assets = Set(listAssets())
let used = Set(listUsedAssetLiterals() + ignoredUnusedNames)


// Generate Warnings for Unused Assets
let unused = assets.subtracting(used)
unused.forEach { print("\(assetCatalogAbsolutePath):: warning: [Asset Unused] \($0)") }


// Generate Error for broken Assets
let broken = used.subtracting(assets)
broken.forEach { print("\(assetCatalogAbsolutePath):: error: [Asset Missing] \($0)") }

if broken.count > 0 {
    exit(1)
}
```



ç›¸è¾ƒäºè¯­ç³»æ£€æŸ¥è„šæœ¬ï¼Œè¿™ä¸ªè„šæœ¬ç®€æ´ä¸”é‡è¦çš„åŠŸèƒ½éƒ½æœ‰ï¼Œå¾ˆæœ‰å‚è€ƒä»·å€¼ï¼



*P.S å¯ä»¥çœ‹åˆ°ç¨‹å¼ç å‡ºç° `localizedStrings()` å‘½åï¼Œæ€€ç–‘ä½œè€…æ˜¯ä»è¯­ç³»æ£€æŸ¥å·¥å…·çš„é€»è¾‘æ¬æ¥ç”¨ï¼Œå¿˜äº†æ”¹æ–¹æ³•åç§°ï¼¸ï¼¤*



**ä¾‹å¦‚ï¼š**



```swift
for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        //å‚æ•°1
    case 2:
        //å‚æ•°2
    default:
        break
    }
}
```



^æ¥æ”¶å¤–éƒ¨å‚æ•°çš„æ–¹æ³•



```swift
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}

func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // Image Literal
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // Default UIImage call (Swift)
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // Default UIImage call 
        "\\<image name=\"\(namePattern)\".*", // Storyboard resources
        "R.image.\(namePattern)\\(\\)" //R.swift support
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .compactMap{$0}
            .compactMap{$0}                                             // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings ocurrences
            .flatMap{$0}                                                // Flatten
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .flatMap{$0}
            .flatMap{$0}                                                // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings ocurrences
            .flatMap{$0}                                                // Flatten
    #endif
}
```



^éå†æ‰€æœ‰ä¸“æ¡ˆæ¡£æ¡ˆå¹¶è¿›è¡Œæ­£åˆ™åŒ¹é…çš„æ–¹æ³•



```swift
//è¦è®© build æ—¶å‡ºç° Error âŒï¼š
print("Projectæ¡£æ¡ˆ.lproj" + "/æ¡£æ¡ˆ:è¡Œ: " + "error: é”™è¯¯è®¯æ¯")
//è¦è®© build æ—¶å‡ºç° Warning âš ï¸ï¼š
print("Projectæ¡£æ¡ˆ.lproj" + "/æ¡£æ¡ˆ:è¡Œ: " + "warning: è­¦å‘Šè®¯æ¯")
```



^print error or warning



å¯ä»¥ç»¼åˆå‚è€ƒä»¥ä¸Šçš„ç¨‹å¼æ–¹æ³•ï¼Œè‡ªå·±æ‰“é€ æƒ³è¦çš„å·¥å…·ã€‚



### æ€»ç»“



è¿™ä¸¤ä¸ªæ£€æŸ¥å·¥å…·å¯¼å…¥ä¹‹åï¼Œæˆ‘ä»¬åœ¨å¼€å‘ä¸Šå°±èƒ½æ›´å®‰å¿ƒã€æ›´æœ‰æ•ˆç‡å¹¶ä¸”å‡å°‘å†—ä½™ï¼›ä¹Ÿå› ä¸ºè¿™æ¬¡ç»éªŒå¤§å¼€çœ¼ç•Œï¼Œæ—¥åå¦‚æœæœ‰ä»€ä¹ˆæ–°çš„ build run script éœ€æ±‚éƒ½èƒ½ç›´æ¥ä½¿ç”¨æœ€ç†Ÿæ‚‰çš„è¯­è¨€ swift æ¥è¿›è¡Œåˆ¶ä½œï¼



æœ‰ä»»ä½•é—®é¢˜åŠæŒ‡æ•™æ¬¢è¿ [ä¸æˆ‘è”ç»œ](https://www.zhgchg.li/contact){:target="_blank"} ã€‚



*[Post](https://medium.com/zrealm-ios-dev/xcode-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-swift-%E6%92%B0%E5%AF%AB-run-script-41c49a75a743){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*