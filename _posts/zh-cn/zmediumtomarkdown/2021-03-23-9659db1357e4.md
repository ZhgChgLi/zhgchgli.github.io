---
author: ZhgChgLi
categories:
- ZRealm Dev.
date: 2021-03-23T17:09:34.747+0000
description: 当推播统计遇上 Firebase Firestore + Functions
image:
  path: /assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg
last_modified_at: 2024-04-13T16:34:17.362+0000
render_with_liquid: false
tags:
- ios-app-development
- firebase
- google-cloud-platform
- notifications
- ios
title: 使用 Firebase Firestore + Functions 快速搭建可供测试的 API 服务
---

### 使用 Firebase Firestore + Functions 快速搭建可供测试的 API 服务



当推播统计遇上 Firebase Firestore + Functions



![Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg)



Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}



### 前言



#### 推播精确统计功能



最近想为 APP 导入的功能，未实作前我们只能从后端 Post 资料给 APNS/FCM 的成功与否当作推播基数并记录推播点击，计算出「点击率」；但此方法其实非常不准确，基数包含许多无效装置，APP 已删除的（不一定会马上失效）、关闭推播权限的在后端 Post 时都还是会得到成功的回传。



在 iOS 10 之后可以透过实践 Notification Service Extension 在推播横幅出现时的时机点偷偷 Call API 回传做统计；好处是非常精准，只有在使用者推播横幅有出现才会 Call；如果 APP 删除、关闭通知、通知没开横幅，都不会有动作，横幅等于有出现推播讯息，用此当推播基数然后再算上点击数就能得到「精确的点击率」。



> *详细原理及实作方式可参考之前的文章：「 [i **OS ≥ 10 Notification Service Extension 应用 (Swift)**](../cb6eba52a342/) 」*



> *目前测试下来 APP 的 Loss 率应该是 0%，实际常见应用像是 Line 的讯息点对点加解密（推播的讯息是加密过的，在手机收到才解密然后显示出来）。*



#### 问题



APP 端的功其实不大，iOS/Android 都只要实作类似的功能（但 Android 如果要考虑中国市场就比较麻烦，要为更平台实作推播框架内容）；比较大的功是后端还有 Server 的压力处理，因为推播一次出去会同时 Call API 回传纪录，可能会塞爆 Server 的 max connection 如果又是使用 RDBMS 储存记录可能会更严重，如果发现统计数有 Loss 多半发生在此环节。



> *这边可以以 log 写档案方式做纪录，要查询时在自行做统计显示。*



> *另外，后来想想一次出去同时回来的情境，数量可能没有想像中的大；因为发推播也不会一口气发个十万百万笔，也是几笔几笔批次发送；只要能扛住批次发出去同时回来的数量即可！*



### Prototype



因原先有问题中的考量，后端需要花功力研究修改且市场也不一定在意做出来的成效；所以想说先用能使用的资源弄个 Prototype 出来试试水温。



这边选择的是 APP 几乎都会使用的 Firebase 服务，其中的 Functions 和 Firestore 功能。



#### Firebase Functions



[Functions](https://developers.google.com/learn/topics/functions){:target="_blank"} 是 Google 提供的 serverless 服务，只需撰写好程式逻辑，Google 自动帮你弄好伺服器、执行环境，也不用去管伺服器扩充及流量的问题。



[Firebase Functions](https://firebase.google.com/docs/functions){:target="_blank"} 其实就是 Google Cloud Functions 但只能使用 JavaScript (node.js) 撰写，没试过但如果用 Google Cloud Functions 选择用其他语言撰写然后同样 import Firebase 服务我想应该也能用。



用在 API 就是我可以写一个 node.js 档案，得到一个实体 URL (ex: my-project.cloudfunctions.net/getUser)，自行撰写取得 Request 资讯和给予相应的 Response 逻辑。



> *之前写过一篇关于 Google Functions 的文章「 [使用 Python+Google Cloud Platform+Line Bot 自动执行例行琐事](../70a1409b149a/) 」*



> *Firebase Functions 必须启用 Blaze 专案（用多少、付多少）才能使用。*



![](/assets/9659db1357e4/1*YqIJ1tr2Ay-oLVjSSU0zUg.png)



#### Firebase Firestore



[Firebase Firestore](https://firebase.google.com/docs/firestore){:target="_blank"} ，NoSql 资料库，用来存放、管理数据。



结合 Firebase Functions 可在 Request 时 import Firestore 进来操作资料库，然后Response 给使用者，就能搭建简单的 Restful API 服务！



> 动手实作开始！



### 安装 node.js 环境



这边建议使用 NVM，node.js 版本管理工具进行安装管理（像 python 用 pyenv）。



到 NVM Github 专案复制安装 shell script：



[![](https://repository-images.githubusercontent.com/612230/53a0c44a-1f6e-4f8d-918f-89762fafe369)](https://github.com/nvm-sh/nvm#installing-and-updating){:target="_blank"}



```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh \\| bash
```



如果安装过程出现错误，请确认有 `~/.bashrc` 或 `~/.zshrc` 档案，没有可用 `touch ~/.bashrc` 或 `touch ~/.zshrc` 建立档案然后再跑一下 install script。



再来就可以使用 `nvm install node` 安装最新版的 node.js。



![](/assets/9659db1357e4/1*5fxz4HD9q4feAqO0zXbojg.png)



可下 `npm --version` 确认 npm 安装成功、安装版本：



![](/assets/9659db1357e4/1*VHZMRFIDzFA9AxmsDNqNlA.png)



### 部署 Firebase Functions



#### 安装 Firebase-tools：



```bash
npm install -g firebase-tools
```



![](/assets/9659db1357e4/1*POfMR0p1600iYqy8rzQkTQ.png)



安装成功后，第一次使用请先输入：



```bash
firebase login
```



![](/assets/9659db1357e4/1*kqeECyXVPOq1cpKvcdOBeA.png)



完成 Firebase 登入验证。



启动专案：



```bash
firebase init
```



![](/assets/9659db1357e4/1*Xx2grpX2PZb3wEFt9mQbNw.png)



记下 Firebase init 所在路径：



```
You're about to initialize a Firebase project in this directory:
```



这边可以选择要安装的 Firebase CLI 工具，按 「↑」「↓」进行选择，「空白键」进行选择；这边可以只选择「Functions」或连「Firestore」一起选择安装。



**=== Functions Setup**



![](/assets/9659db1357e4/1*2gd9pAIdLAkJRhROpJtPKA.png)



- 语言选择「 **JavaScript** 」


- 关于「use ESLint to catch probable bugs and enforce style」语法 style 检查 ， **YES / NO 都可** 。


- install dependencies with npm? **YES**



**===Emulators Setup**



![](/assets/9659db1357e4/1*xHWp195BZIZdXyUd-ub78g.png)



可在本地环境测试 Functions、Firestore 功能及设定，不会算在使用度且不需等到部署上线才能测试。



> *依个人需求安装，我有装但没有用．．．因为只是小功能而已。*



### Coding!



前往上述记下的路径，找到 `functions 资料夹` ，用编辑器打开里面的 `index.js` 档案。



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
admin.initializeApp();

exports.hello = functions.https.onRequest((req, res) => {
    const targetID = req.query.targetID
    const action = req.body.action
    const name = req.body.name

    res.send({"targetID": targetID, "action": action, "name": name});
    return
})
```



贴上以上内容，我们定义了一个路径接口 `/hello` 然后会回传 URL **Query** `?targetID=` 、 **POST** `action` 、 `name` 参数资讯。



修改＆储存完成后回到 console 下：



```bash
firebase deploy
```



> ***以后的每次修改都记得要回来下 `firebase deploy` 指令，才会生效。***



开始验证＆部署到 Firebase…



![](/assets/9659db1357e4/1*hUdvD4ANKD3s73mLWNZZOQ.png)



可能需要稍等一下， `Deploy complete!` 后你的第一个 Request & Response 网页就完成了！



这时候可以回到 Firebase -&gt; Functions 页面：



![](/assets/9659db1357e4/1*SY4iJZL6gDEZ5AEcepIpMA.png)



就会看到刚刚撰写的接口和网址位置。



复制下方网址贴到 PostMan 测试：



![](/assets/9659db1357e4/1*OMfLkdg12QHsp-yc9RkKvA.png)



> *POST Body 记得选择 `x-www-form-urlencoded` 。*



**成功！**



### Log



我们可以在程式码中使用：



```javascript
functions.logger.log("log:", value);
```



进行 Log 纪录。



并可在 Firebase -&gt; Functions -&gt; 纪录中查看 log 结果：



![](/assets/9659db1357e4/1*Wi-4MbPh2tVJ_utdhzN4_A.png)



### Example Goal



> 建立一个可新增、修改、删除、查询文章和按赞的 API



我们希望能达成 Restful API 的功能设计，所以不能再使用上面范例的纯 Path 方式，要改藉用 `Express` 框架达成。



#### POST 新增文章



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Insert
app.post('/', async (req, res) => { // 这边的 POST 指的是 HTTP Method POST
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null \\|\\| content == null \\|\\| author == null) {
        return res.status(400).send({"message":"参数错误！"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"新增成功！"});
});

exports.post= functions.https.onRequest(app); // 这边的 POST 指的是 /post 路径
```



现在我们改用 Express 来处理网路请求，这边先新增一个 路径 `/ 的 POST` 方法，最后一行表示路径都在 `/post` 之下，再来我们会加上修改、删除的 API。



下 `firebase deploy` 部署成功后，回到 Post Man 测试：



![](/assets/9659db1357e4/1*yVAjhlr6wLdONeG7nY0VEw.png)



Post Man 打成功后可以再到 Firebase -&gt; Firestore 检查一下资料是否有正确写入：



![](/assets/9659db1357e4/1*xYVrRdFro3bQVHx05JUaTw.png)



#### PUT 修改文章



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Update
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"}); 
    } else if (title == null \\|\\| content == null \\|\\| author == null) {
        return res.status(400).send({"message":"参数错误！"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"修改成功！"});
});

exports.post= functions.https.onRequest(app);
```



部署＆测试方式如新增，Post Man Http Method 记得改成 `PUT` 。



#### DELETE 删除文章



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Delete
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"文章成功！"});
})

exports.post= functions.https.onRequest(app);
```



部署＆测试方式如新增，Post Man Http Method 记得改成 `DELETE` 。



新增、修改、删除做完了，来做查询！



#### SELECT 查询文章



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Select List
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// Select One
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

exports.post= functions.https.onRequest(app);
```



![](/assets/9659db1357e4/1*n_mI4l1EmhpWK8M_FbrzbQ.png)



部署＆测试方式如新增，Post Man Http Method 记得改成 `GET` 还有将 `Body` 切回 `none` 。



#### InsertOrUpdate?



有时候我们需要当值存在时做更新，当值不存在时新增，这时候可以用 `set` 搭配 `merge: true` ：



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// InsertOrUpdate
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"参数错误！"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"新增成功！"});
});

exports.post= functions.https.onRequest(app);
```



这边以新增 tag 为例，部署＆测试方式如新增，可以看到 Firestore 不会一直重复新增新资料。



![](/assets/9659db1357e4/1*qkTMGjC0EkrMO85-6pQFwg.png)



#### 文章按赞计数器



假设我们的文章资料现在多一个 `likeCount` 栏位纪录按赞数量，那我们该怎么做呢？



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Like Post
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"按赞成功！"});
});

exports.post= functions.https.onRequest(app);
```



运用 `increment` 这个变数就能直接做到取出值 +1 的动作。



#### 大流量文章按赞计数器



因为 Firestore 有 [写入速度限制](https://cloud.google.com/firestore/quotas?hl=zh-tw#soft_limits){:target="_blank"} 的：



![](/assets/9659db1357e4/1*U9ubGe3M8XEdx9XGAV8nfA.png)



**一个文档一秒只能写入一次** ，所以当按赞的人一多；同时请求下可能会变得很慢。



官方给的解决方法「 [Distributed counters](https://cloud.google.com/firestore/docs/solutions/counters#node.js_2){:target="_blank"} 」其实也没什么高深的技术，就是多用几个分散的 likeCount 栏位来统计，然后读取的时候再加总起来。



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Distributed counters Like Post
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"按赞成功！"});
});


exports.post= functions.https.onRequest(app);
```



![](/assets/9659db1357e4/1*GhNEcWUjgvYRYCMBk1DayA.png)



以上就是分散出栏位来纪录 Count 避免写入太慢；但如果分散的栏位太多会增加读取成本($$)，但应该还是比每次按赞都 add 一笔新纪录还便宜。



#### 使用 Siege 工具进行压力测试



使用 `brew` 安装 `siege`



```bash
brew install siege
```



*p.s 如果你出现 brew: command not found 请先安装 [brew](https://brew.sh/index_zh-tw){:target="_blank"} 套件管理工具* ：



```bash
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
```



安装完成后可下：



```bash
siege -c 100 -r 1 -H 'Content-Type: application/json' 'https://us-central1-project.cloudfunctions.net/post/like/id POST {}'
```



进行压力测试：



- `-c 100` ：100 个任务同步执行


- `-r 1` ：每个任务执行 1 次请求


- `-H ‘Content-Type: application/json’` ：如果是 POST 时需加上


- `‘https://us-central1-project.cloudfunctions.net/post/like/id POST {}’` ：POST 网址、Post Body (ex: `{“name”:”1234”}` )



执行完成后可看到执行结果：



![](/assets/9659db1357e4/1*BUcMfJJ4x_mgK0HHLc6C4g.png)



`successful_transactions: 100` 表示 100 次都执行成功。



**可以回 Firebase -&gt; Firestore 查看结果是否有 Loss Data：**



![](/assets/9659db1357e4/1*wd5z743Zp9xtjKhhcMaVOg.png)



> 成功！



#### 完整 Example Code



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Insert
app.post('/', async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null \\|\\| content == null \\|\\| author == null) {
        return res.status(400).send({"message":"参数错误！"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"新增成功！"});
});

// Update
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"}); 
    } else if (title == null \\|\\| content == null \\|\\| author == null) {
        return res.status(400).send({"message":"参数错误！"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"修改成功！"});
});

// Delete
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"文章成功！"});
});

// Select List
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// Select One
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

// InsertOrUpdate
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"参数错误！"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"新增成功！"});
});

// Like Post
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"按赞成功！"});
});

// Distributed counters Like Post
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"找不到文章！"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"按赞成功！"});
});


exports.post= functions.https.onRequest(app);
```



### 回归主题，推播统计



回到一开始我们想做的，推播统计功能。



index.js:



```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

const vaildPlatformTypes = ["iOS","Android"]
const vaildActionTypes = ["clicked","received"]

// Insert Log
app.post('/', async (req, res) => {
    const increment = admin.firestore.FieldValue.increment(1);
    const platformType = req.body.platformType;
    const pushID = req.body.pushID;
    const actionType =  req.body.actionType;

    if (!vaildPlatformTypes.includes(platformType) \\|\\| pushID == undefined \\|\\| !vaildActionTypes.includes(actionType)) {
        return res.status(400).send({"message":"参数错误！"});
    } else {
        await admin.firestore().collection(platformType).doc(actionType+"_"+pushID).collection("shards").doc((Math.floor(Math.random()*10)+1).toString())
        .set({count: increment}, {merge: true})
        res.status(201).send({"message":"纪录成功！"});
    }
});

// View Log
app.get('/:type/:id', async (req, res) => {
    // received
    const receivedDocs = await admin.firestore().collection(req.params.type).doc("received_"+req.params.id).collection("shards").get();
    var received = 0;
    receivedDocs.forEach(doc => {
      received += doc.data().count;
    });

    // clicked
    const clickedDocs = await admin.firestore().collection(req.params.type).doc("clicked_"+req.params.id).collection("shards").get();
    var clicked = 0;
    clickedDocs.forEach(doc => {
        clicked += doc.data().count;
    });
    
    res.status(200).send({"received":received,"clicked":clicked});
});

exports.notification = functions.https.onRequest(app);
```



#### 新增推播纪录



![](/assets/9659db1357e4/1*3koe6QBxF9oOhBDqjF5mhA.png)



#### 检视推播统计数字



```
https://us-centra1-xxx.cloudfunctions.net/notification/iOS/1
```



![](/assets/9659db1357e4/1*SStEkNoDjiL7pffC2pHDkQ.png)



另外也做了个介面统计推播数字。



#### 踩坑



> *因为对 node.js 用法不太熟悉，一开始摸索的时候在 add 资料时没加上 `await` 再加上写入速度限制，导致在大流量情况下会 Data Loss…*



![](/assets/9659db1357e4/1*dVsBhKJQ3qqxlSvv-mCENA.png)



### Pricing



别忘了参考 Firebase Functions & Firestore 的定价策略。



#### Functions



- <https://cloud.google.com/functions/pricing?hl=zh-tw>{:target="_blank"}



![](/assets/9659db1357e4/1*76yRqeDyrp0kFmGHN4ZNXg.png)



![运算时间](/assets/9659db1357e4/1*G_At8v80BQl81EUqPuUIbQ.png)



运算时间



![网路](/assets/9659db1357e4/1*iXk7oKFidHfzRVwrDvKX0A.png)



网路



> *Cloud Functions 针对运算时间资源提供永久免费方案，当中包含 GB/秒和 GHz/秒的运算时间。除了 200 万次叫用以外，免费方案也提供 400,000 GB/秒和 200,000 GHz/秒的运算时间，以及每月 5 GB 的网际网路输出流量。*



#### Firestore



- <https://cloud.google.com/firestore/pricing?hl=zh-tw>{:target="_blank"}



![](/assets/9659db1357e4/1*ylduiqevk4WH-eNc8EOpvQ.png)



- [计算范例](https://cloud.google.com/firestore/docs/billing-example?hl=zh-tw){:target="_blank"}



> ***价格可能随时更改，请以官网最新资讯为准。***



### 结论



如同标题所写「可供测试」、「可供测试」、「可供测试」不太建议将以上服务用于正式环境，甚至当作产品的核心上线。



#### 收费贵、难迁移



之前曾听说某个蛮大的服务就是使用 Firebase 服务搭建起家，结果后期资料、流量大，收费爆贵；要转移也很困难，程式还好但资料非常难搬；只能说是初期省了小钱却造成后期巨大的亏损，不值得。



#### 仅供测试



因为以上原因，使用 Firebase Functions + Firestore 搭建的 API 服务个人建议仅供测试或是 Prototype 产品展示。



#### 更多功能



Functions 还可以串 Authentication(身份验证)、Storage(档案上传)，但这部分我就没研究了。



### 参考资料



- <https://firebase.google.com/docs/firestore/query-data/queries>{:target="_blank"}


- <https://coder.tw/?p=7198>{:target="_blank"}


- <https://firebase.google.com/docs/firestore/solutions/counters#node.js_1>{:target="_blank"}


- <https://javascript.plainenglish.io/firebase-cloud-functions-tutorial-creating-a-rest-api-8cbc51479f80>{:target="_blank"}



### 延伸阅读



- [使用 Python+Google Cloud Platform+Line Bot 自动执行例行琐事](../70a1409b149a/)


- [i **OS ≥ 10 Notification Service Extension 应用 (Swift)**](../cb6eba52a342/)


- [运用 Google Apps Script 转发 Gmail 信件到 Slack](../d414bdbdb8c9/)



有任何问题及指教欢迎 [与我联络](https://www.zhgchg.li/contact){:target="_blank"} 。



*[Post](https://medium.com/zrealm-ios-dev/%E4%BD%BF%E7%94%A8-firebase-firestore-functions-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8F%AF%E4%BE%9B%E6%B8%AC%E8%A9%A6%E7%9A%84-api-%E6%9C%8D%E5%8B%99-9659db1357e4){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*