---
title: "Complete Guide to Implementing Local Cache Functionality with AVPlayer"
author: "ZhgChgLi"
date: 2021-01-31T10:41:42.622+0000
last_modified_at: 2024-04-13T08:45:21.565+0000
categories: ["ZRealm Dev."]
tags: ["ios","ios-app-development","cache","avplayer","music-player-app"]
description: "Implementing AVPlayer/AVQueuePlayer with AVURLAsset and AVAssetResourceLoaderDelegate"
image:
  path: /assets/6ce488898003/1*lAGpCiT80GFIQ2adYworVw.jpeg
render_with_liquid: false
---

### Complete Guide to Implementing Local Cache Functionality with AVPlayer

Implementing AVPlayer/AVQueuePlayer with AVURLAsset and AVAssetResourceLoaderDelegate



![Photo by [Tyler Lastovich](https://unsplash.com/@lastly?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/6ce488898003/1*lAGpCiT80GFIQ2adYworVw.jpeg)

Photo by [Tyler Lastovich](https://unsplash.com/@lastly?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
#### \[2023/03/12\] Update


[![](https://repository-images.githubusercontent.com/612890185/346ae563-7278-4518-a19b-f5d367e60adc)](https://github.com/ZhgChgLi/ZPlayerCacher){:target="_blank"}


I have open-sourced the previous implementation, and friends in need can use it directly.
- Customizable cache strategies, can use PINCache or others…
- Externally, just call the make AVAsset factory with the URL, and the AVAsset will support caching.
- Implemented data flow strategy using Combine.
- Wrote some tests.

### Introduction

It has been over half a year since the last article, "[Exploring iOS HLS Cache Implementation Methods](../d796bf8e661e/)," and the team has been eager to implement the functionality of streaming while caching due to its significant impact on costs. We are a music streaming platform, and if we have to retrieve the entire file every time we play the same song, it is detrimental to both us and users who do not have unlimited data. Although music files are only a few MB at most, every bit adds up!

Additionally, since Android has already implemented the streaming while caching feature, we previously compared costs, and the Android side has significantly saved data after going live; consequently, more iOS users should experience better data savings.

Based on the experience from the [previous article](../d796bf8e661e/), if we continue to use HLS (\ .m3u8/\ .ts) to achieve our goal, things will become very complicated and may even be unachievable. We have opted to revert to using mp3 files, which allows us to directly implement `AVAssetResourceLoaderDelegate`.
### Goals
- Music that has been played will generate a local cache backup.
- When playing music, first check if there is a cache locally; if so, do not request the file from the server again.
- Cache strategies can be set; total capacity limits, and when exceeded, the oldest cache files will start to be deleted.
- Do not interfere with the original AVPlayer playback mechanism.
(Otherwise, the fastest method would be to use URLSession to download the mp3 and feed it to AVPlayer, but this would lose the original functionality of streaming as needed, requiring users to wait longer and consuming more data.)

### Preliminary Knowledge (1) — HTTP/1.1 Range Requests, Connection Keep-Alive
#### HTTP/1.1 Range Requests

First, we need to understand how data is requested from the server when playing videos or music. Generally, video and music files are large, and it is not feasible to wait until everything is downloaded before starting playback. The common approach is to play as data is received; as long as there is data for the currently playing segment, it can function.

The way to achieve this functionality is through HTTP/1.1 Range, which only returns data for the specified byte range. For example, specifying 0–100 will only return the 100 bytes of data from 0 to 100. Using this method, data can be obtained in segments sequentially, and then compiled into a complete file. This method can also be applied to file download resumption functionality.
#### How to Apply?

We will first use HEAD to check the Response Header to understand whether the server supports Range requests, the total length of the resource, and the file type:
```bash
curl -i -X HEAD http://zhgchg.li/music.mp3
```

**Using HEAD, we can obtain the following information from the Response Header:**
- **Accept-Ranges: bytes** indicates that the server supports Range requests. If this value is absent or if it is Accept-Ranges: none, it means that Range requests are not supported.
- **Content-Length:** the total length of the resource; we need to know the total length to segment the data requests.
- **Content-Type:** the file type, which is information needed by AVPlayer during playback.

However, sometimes we also use GET `Range: bytes=0–1`, which means I request the data in the range of 0–1, but in reality, I don't care what the content of 0–1 is; I just want to see the information in the Response Header; **the native AVPlayer uses GET to check, so this article will also follow suit.**

> _However, it is generally recommended to use HEAD for this purpose, as it is a more accurate method. On the other hand, if the server does not support Range functionality, using GET will force the download of the entire file._

```bash
curl -i -X GET http://zhgchg.li/music.mp3 -H "Range: bytes=0–1"
```

**Using GET, we can obtain the following information from the Response Header:**
- **Accept-Ranges: bytes** indicates that the server supports Range requests. If this value is absent or if it is Accept-Ranges: none, it means that Range requests are not supported.
- **Content-Range: bytes 0–1/total length of the resource**, the number after the “/” indicates the total length of the resource; we need to know the total length to segment the data requests.
- **Content-Type:** the file type, which is information needed by AVPlayer during playback.

![](/assets/6ce488898003/1*IP55kaFB3NES3QWZ7Mf-aw.jpeg)

**Once we know that the server supports Range requests, we can initiate segmented Range requests:**
```bash
curl -i -X GET http://zhgchg.li/music.mp3 -H "Range: bytes=0–100"
```

**The server will return 206 Partial Content:**
```
Content-Range: bytes 0-100/total length
Content-Length: 100
...
(binary content)
```

At this point, we have obtained the data for Range 0–100 and can continue to send new requests for Range 100–200, 200–300, and so on until completion.

If the requested Range exceeds the total length of the resource, it will return 416 Range Not Satisfiable.

Additionally, to obtain the complete file data, you can request Range 0–total length, or you can simply use 0–:
```bash
curl -i -X GET http://zhgchg.li/music.mp3 -H "Range: bytes=0–"
```

You can also request multiple Range data in a single request and set conditions, but we won't be using that. For more details, you can [refer to this](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests){:target="_blank"}.

#### Connection Keep-Alive

HTTP 1.1 is enabled by default, **this feature allows for real-time retrieval of downloaded data**. For example, for a 5 MB file, it can retrieve in chunks of 16 KB, 16 KB, 16 KB, and so on, without having to wait for the entire 5 MB to be downloaded first.
```
Connection: Keep-Alive
```

#### **_What if the server does not support Range or Keep-Alive?_**

> _In that case, there's no need to complicate things; just use URLSession to download the mp3 file and feed it to the player. However, this is not the result we want, so we can ask the backend to help modify the server settings._

### Preliminary Knowledge (2) — How does AVPlayer natively handle AVURLAsset resources?

![](/assets/6ce488898003/1*iLE51pGNDl_5Jwp8cTM6HQ.jpeg)

When we use AVURLAsset init with URL to create a resource and assign it to AVPlayer/AVQueuePlayer to start playback, as mentioned above, it will first use GET Range 0–1 to check whether Range requests are supported, the total length of the resource, and the file type.


After obtaining the file information, a second request will be initiated to request data from 0 to the total length.


> _⚠️ **AVPlayer requests data from 0 to the total length and retrieves the downloaded data characteristics in real-time (e.g., **16 kb, 16 kb, 16 kb…**) until it deems the data sufficient, at which point it will initiate a Cancel to cancel this network request** (so it won't actually fetch everything unless the file is very small)._ 


> _Data will be requested subsequently through Range after continuing playback._ 


> _（This part is different from what I previously thought; I assumed it would request in ranges like 0–100, 100–200, etc.）_ 




**AVPlayer Request Example:**
```
1. GET Range 0-1 => Response: Total Length 150000 / public.mp3 / true
2. GET 0-150000...
3. 16 kb receive
4. 16 kb receive...
5. cancel() // current offset is 700
6. Continue playback
7. GET 700-150000...
8. 16 kb receive
9. 16 kb receive...
10. cancel() // current offset is 1500
11. Continue playback
12. GET 1500-150000...
13. 16 kb receive
14. 16 kb receive...
16. If seek to...5000
17. cancel(12.) // current offset is 2000
18. GET 5000-150000...
19. 16 kb receive
20. 16 kb receive...
...
```


> _⚠️ **In the case of iOS ≤12, several shorter requests will be made first to test the waters (?), and only then will a request for the total length be made; iOS ≥ 13 will directly send a request for the total length.**_ 




Another side issue is that while observing how resources are fetched, I used the [mitmproxy](../46410aaada00/) tool to sniff, and found that it displayed an error, showing the response only after everything had returned, rather than displaying in segments and using persistent connections for continued downloads; it startled me! I thought iOS was so dumb that it had to wait for the entire file to come back each time! Next time I use a tool, I need to maintain a bit of skepticism. Orz
#### Timing of Cancel Initiation
1. The second request mentioned earlier requests resources starting from 0 to the total length, and after sufficient data is obtained, a Cancel request will be initiated.
2. A Cancel will be initiated for the previous request during a seek operation.



> _⚠️ Switching to the next resource in AVQueuePlayer or changing the playback resource in AVPlayer will not initiate a Cancel for the previous request._ 




#### AVQueue Pre-buffering

It actually also calls the Resource Loader for processing, but the range of data it requests will be smaller.
### Implementation

With the above preliminary knowledge, let's look at how to implement the local cache functionality of AVPlayer.

This involves the previously mentioned `AVAssetResourceLoaderDelegate`, which allows us to **implement our own Resource Loader** for the Asset.

The Resource Loader is essentially a worker; whether the player needs file information or file data, and the range, it tells us, and we handle it accordingly.


> _I saw an example where a **Resource Loader serves all AVURLAssets**, which I think is incorrect; it should be one Resource Loader serving one AVURLAsset, following the lifecycle of the AVURLAsset, as it inherently belongs to the AVURLAsset._ 




> _Having one Resource Loader serve all AVURLAssets in AVQueuePlayer would become very complex and difficult to manage._ 




#### Timing for Entering Custom Resource Loader

It is important to note that just because you implement your own Resource Loader, it doesn't mean it will be used; it will only be invoked when the system cannot recognize or handle the resource.

Therefore, before providing the URL resource to AVURLAsset, we need to change the Scheme to our custom Scheme, which cannot be http/https or any other Scheme that the system can handle.
```
http://zhgchg.li/music.mp3 => cacheable://zhgchg.li/music.mp3
```
#### `AVAssetResourceLoaderDelegate`

**Only two methods need to be implemented:**
- func resourceLoader\( \_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource **loadingRequest** : AVAssetResourceLoadingRequest\) \-&gt; Bool :

```markdown
This method asks whether we can handle this resource; return true if we can, return false if we cannot (unsupported URL).

We can extract what to request from `loadingRequest` (whether it is the first request for file information or a data request, and if it is a data request, what the Range is); after knowing the request, we initiate the request ourselves to fetch the data, **here we can decide whether to initiate a URLSession or return Data from local storage**.

Additionally, we can perform data encryption and decryption operations here to protect the original data.
- func resourceLoader\( \_ resourceLoader: AVAssetResourceLoader, didCancel **loadingRequest** : AVAssetResourceLoadingRequest\) :

As mentioned earlier, the **timing of the Cancel initiation** occurs when we…

We can cancel the ongoing URLSession request here.

![](/assets/6ce488898003/1*widvJqzE-HtG32B-6ZiFhw.jpeg)

#### Local Cache Implementation

For caching, I directly use [PINCache](https://github.com/pinterest/PINCache){:target="_blank"}, delegating cache management to it, which saves us from dealing with cache read/write deadlocks and the implementation issues of clearing cache with LRU strategies.

> **_️️⚠️️️️️️️️️️️OOM Warning!_** 

> _Since this is for music, the cache file size is at most around 10 MB, so we can use PINCache as a local cache tool; if it were for video, this method would not work (as it might need to load several GB of data into memory at once)_

If there is such a requirement, you can refer to the approach of others, using FileHandle seek read/write characteristics for processing.
### Let's Get Started!

No more talking, here’s the complete project:

[![](https://opengraph.githubassets.com/b43d0ddf4687cf5a04d6bbc68e4bfd24a9d5067fe04e2e198a676aff746de403/zhgchgli0718/resourceLoaderDemo)](https://github.com/zhgchgli0718/resourceLoaderDemo){:target="_blank"}

#### AssetData

The local cache data object implements NSCoding, as PINCache relies on the archivedData method for encoding/decoding.
```swift
import Foundation
import CryptoKit

class AssetDataContentInformation: NSObject, NSCoding {
    @objc var contentLength: Int64 = 0
    @objc var contentType: String = ""
    @objc var isByteRangeAccessSupported: Bool = false
    
    func encode(with coder: NSCoder) {
        coder.encode(self.contentLength, forKey: #keyPath(AssetDataContentInformation.contentLength))
        coder.encode(self.contentType, forKey: #keyPath(AssetDataContentInformation.contentType))
        coder.encode(self.isByteRangeAccessSupported, forKey: #keyPath(AssetDataContentInformation.isByteRangeAccessSupported))
    }
    
    override init() {
        super.init()
    }
    
    required init?(coder: NSCoder) {
        super.init()
        self.contentLength = coder.decodeInt64(forKey: #keyPath(AssetDataContentInformation.contentLength))
        self.contentType = coder.decodeObject(forKey: #keyPath(AssetDataContentInformation.contentType)) as? String ?? ""
        self.isByteRangeAccessSupported = coder.decodeObject(forKey: #keyPath(AssetDataContentInformation.isByteRangeAccessSupported)) as? Bool ?? false
    }
}

class AssetData: NSObject, NSCoding {
    @objc var contentInformation: AssetDataContentInformation = AssetDataContentInformation()
    @objc var mediaData: Data = Data()
    
    override init() {
        super.init()
    }

    func encode(with coder: NSCoder) {
        coder.encode(self.contentInformation, forKey: #keyPath(AssetData.contentInformation))
        coder.encode(self.mediaData, forKey: #keyPath(AssetData.mediaData))
    }
    
    required init?(coder: NSCoder) {
        super.init()
        self.contentInformation = coder.decodeObject(forKey: #keyPath(AssetData.contentInformation)) as? AssetDataContentInformation ?? AssetDataContentInformation()
        self.mediaData = coder.decodeObject(forKey: #keyPath(AssetData.mediaData)) as? Data ?? Data()
    }
}
```

```markdown
`AssetData` **Storage:**
- `contentInformation` : AssetDataContentInformation
`AssetDataContentInformation` :
Stores whether Range requests are supported (isByteRangeAccessSupported), total length of the resource (contentLength), and file type (contentType)
- `mediaData` : Raw audio Data **(this file may cause OOM if too large)**


#### PINCacheAssetDataManager

Encapsulates the logic for storing and retrieving data from PINCache.
```swift
import PINCache
import Foundation

protocol AssetDataManager: NSObject {
    func retrieveAssetData() -> AssetData?
    func saveContentInformation(_ contentInformation: AssetDataContentInformation)
    func saveDownloadedData(_ data: Data, offset: Int)
    func mergeDownloadedDataIfIsContinuted(from: Data, with: Data, offset: Int) -> Data?
}

extension AssetDataManager {
    func mergeDownloadedDataIfIsContinuted(from: Data, with: Data, offset: Int) -> Data? {
        if offset <= from.count && (offset + with.count) > from.count {
            let start = from.count - offset
            var data = from
            data.append(with.subdata(in: start..<with.count))
            return data
        }
        return nil
    }
}

//

class PINCacheAssetDataManager: NSObject, AssetDataManager {
    
    static let Cache: PINCache = PINCache(name: "ResourceLoader")
    let cacheKey: String
    
    init(cacheKey: String) {
        self.cacheKey = cacheKey
        super.init()
    }
    
    func saveContentInformation(_ contentInformation: AssetDataContentInformation) {
        let assetData = AssetData()
        assetData.contentInformation = contentInformation
        PINCacheAssetDataManager.Cache.setObjectAsync(assetData, forKey: cacheKey, completion: nil)
    }
    
    func saveDownloadedData(_ data: Data, offset: Int) {
        guard let assetData = self.retrieveAssetData() else {
            return
        }
        
        if let mediaData = self.mergeDownloadedDataIfIsContinuted(from: assetData.mediaData, with: data, offset: offset) {
            assetData.mediaData = mediaData
            
            PINCacheAssetDataManager.Cache.setObjectAsync(assetData, forKey: cacheKey, completion: nil)
        }
    }
    
    func retrieveAssetData() -> AssetData? {
        guard let assetData = PINCacheAssetDataManager.Cache.object(forKey: cacheKey) as? AssetData else {
            return nil
        }
        return assetData
    }
}
```

Here is the translated text while preserving the original Markdown format:

---

This section extracts the Protocol because in the future, other storage methods may replace PINCache, so other programs rely on the Protocol rather than the Class instance.

> _⚠️ `mergeDownloadedDataIfIsContinuted` **This method is extremely important.**_

Linear playback simply requires continuously appending new Data to the Cache Data, but the reality is much more complex. Users may play from Range 0~100 and then directly Seek to Range 200–500; how to merge the existing 0-100 Data with the new 200-500 Data is a significant issue.

> _⚠️ Problems with Data merging can lead to terrifying playback glitches…_

The answer here is, **we do not handle non-continuous data**; because our project only deals with audio, and the files are only a few MB (≤ 10MB), we decided not to implement it considering development costs. I only handle merging continuous data (for example, if we already have 0~100 and the new data is 75~200, after merging it becomes 0~200; if the new data is 150~200, I will ignore it and not merge).

![](/assets/6ce488898003/1*Cyfusv16pk1AtpGAjJlMMQ.jpeg)

If we need to consider non-continuous merging, in addition to using other methods for storage (to identify the missing parts), we also need to be able to query which segments require network requests and which segments can be retrieved locally; implementing this situation would be very complex.

![Image source: [iOS AVPlayer Video Caching Design and Implementation](http://chuquan.me/2019/12/03/ios-avplayer-support-cache/){:target="_blank"}](/assets/6ce488898003/1*XgMZGKMb-YNCFnS9MbiZhw.png)

Image source: [iOS AVPlayer Video Caching Design and Implementation](http://chuquan.me/2019/12/03/ios-avplayer-support-cache/){:target="_blank"}
#### CachingAVURLAsset

AVURLAsset holds the ResourceLoader Delegate weakly, so it is recommended to create a custom AVURLAsset Class that inherits from AVURLAsset, internally creating, assigning, and holding the ResourceLoader, allowing it to follow the lifecycle of AVURLAsset; additionally, it can also store the original URL, CacheKey, and other information...
```swift
class CachingAVURLAsset: AVURLAsset {
    static let customScheme = "cacheable"
    let originalURL: URL
    private var _resourceLoader: ResourceLoader?
    
    var cacheKey: String {
        return self.url.lastPathComponent
    }
    
    static func isSchemeSupport(_ url: URL) -> Bool {
        guard let components = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
            return false
        }
        
        return ["http", "https"].contains(components.scheme)
    }
    
    override init(url URL: URL, options: [String: Any]? = nil) {
        self.originalURL = URL
        
        guard var components = URLComponents(url: URL, resolvingAgainstBaseURL: false) else {
            super.init(url: URL, options: options)
            return
        }
        
        components.scheme = CachingAVURLAsset.customScheme
        guard let url = components.url else {
            super.init(url: URL, options: options)
            return
        }
        
        super.init(url: url, options: options)
        
        let resourceLoader = ResourceLoader(asset: self)
        self.resourceLoader.setDelegate(resourceLoader, queue: resourceLoader.loaderQueue)
        self._resourceLoader = resourceLoader
    }
}
```

**Usage:**
```swift
if CachingAVURLAsset.isSchemeSupport(url) {
  let asset = CachingAVURLAsset(url: url)
  let avplayer = AVPlayer(asset)
  avplayer.play()
}
```

The `isSchemeSupport()` function is used to determine whether the URL supports our Resource Loader (excluding file://).

`originalURL` stores the original resource URL.

`cacheKey` stores the Cache Key for this resource, which is directly set to the file name as the Cache Key.

Please adjust the `cacheKey` according to real-world scenarios. If the file name is not hashed and may be duplicated, it is recommended to hash it first to avoid collisions; if you want to hash the entire URL as the key, be aware of whether the URL may change (e.g., when using a CDN).

Hashing can use md5...sha... For iOS ≥ 13, you can directly use Apple's [CryptoKit](https://developer.apple.com/documentation/cryptokit/){:target="_blank"}, and for others, you can find options on GitHub!
#### ResourceLoaderRequest
```swift
import Foundation
import CoreServices

protocol ResourceLoaderRequestDelegate: AnyObject {
    func dataRequestDidReceive(_ resourceLoaderRequest: ResourceLoaderRequest, _ data: Data)
    func dataRequestDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ error: Error?, _ downloadedData: Data)
    func contentInformationDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ result: Result<AssetDataContentInformation, Error>)
}

class ResourceLoaderRequest: NSObject, URLSessionDataDelegate {
    struct RequestRange {
        var start: Int64
        var end: RequestRangeEnd
        
        enum RequestRangeEnd {
            case requestTo(Int64)
            case requestToEnd
        }
    }
    
    enum RequestType {
        case contentInformation
        case dataRequest
    }
    
    struct ResponseUnExpectedError: Error { }
    
    private let loaderQueue: DispatchQueue
    
    let originalURL: URL
    let type: RequestType
    
    private var session: URLSession?
    private var dataTask: URLSessionDataTask?
    private var assetDataManager: AssetDataManager?
    
    private(set) var requestRange: RequestRange?
    private(set) var response: URLResponse?
    private(set) var downloadedData: Data = Data()
    
    private(set) var isCancelled: Bool = false {
        didSet {
            if isCancelled {
                self.dataTask?.cancel()
                self.session?.invalidateAndCancel()
            }
        }
    }
    private(set) var isFinished: Bool = false {
        didSet {
            if isFinished {
                self.session?.finishTasksAndInvalidate()
            }
        }
    }
    
    weak var delegate: ResourceLoaderRequestDelegate?
    
    init(originalURL: URL, type: RequestType, loaderQueue: DispatchQueue, assetDataManager: AssetDataManager?) {
        self.originalURL = originalURL
        self.type = type
        self.loaderQueue = loaderQueue
        self.assetDataManager = assetDataManager
        super.init()
    }
    
    func start(requestRange: RequestRange) {
        guard isCancelled == false, isFinished == false else {
            return
        }
        
        self.loaderQueue.async { [weak self] in
            guard let self = self else {
                return
            }
            
            var request = URLRequest(url: self.originalURL)
            self.requestRange = requestRange
            let start = String(requestRange.start)
            let end: String
            switch requestRange.end {
            case .requestTo(let rangeEnd):
                end = String(rangeEnd)
            case .requestToEnd:
                end = ""
            }
            
            let rangeHeader = "bytes=\(start)-\(end)"
            request.setValue(rangeHeader, forHTTPHeaderField: "Range")
            
            let session = URLSession(configuration: .default, delegate: self, delegateQueue: nil)
            self.session = session
            let dataTask = session.dataTask(with: request)
            self.dataTask = dataTask
            dataTask.resume()
        }
    }
    
    func cancel() {
        self.isCancelled = true
    }
    
    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
        guard self.type == .dataRequest else {
            return
        }
        
        self.loaderQueue.async {
            self.delegate?.dataRequestDidReceive(self, data)
            self.downloadedData.append(data)
        }
    }
    
    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {
        self.response = response
        completionHandler(.allow)
    }
    
    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        self.isFinished = true
        self.loaderQueue.async {
            if self.type == .contentInformation {
                guard error == nil,
                      let response = self.response as? HTTPURLResponse else {
                    let responseError = error ?? ResponseUnExpectedError()
                    self.delegate?.contentInformationDidComplete(self, .failure(responseError))
                    return
                }
                
                let contentInformation = AssetDataContentInformation()
                
                if let rangeString = response.allHeaderFields["Content-Range"] as? String,
                   let bytesString = rangeString.split(separator: "/").map({String($0)}).last,
                   let bytes = Int64(bytesString) {
                    contentInformation.contentLength = bytes
                }
                
                if let mimeType = response.mimeType,
                   let contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, mimeType as CFString, nil)?.takeRetainedValue() {
                    contentInformation.contentType = contentType as String
                }
                
                if let value = response.allHeaderFields["Accept-Ranges"] as? String,
                   value == "bytes" {
                    contentInformation.isByteRangeAccessSupported = true
                } else {
                    contentInformation.isByteRangeAccessSupported = false
                }
                
                self.assetDataManager?.saveContentInformation(contentInformation)
                self.delegate?.contentInformationDidComplete(self, .success(contentInformation))
            } else {
                if let offset = self.requestRange?.start, self.downloadedData.count > 0 {
                    self.assetDataManager?.saveDownloadedData(self.downloadedData, offset: Int(offset))
                }
                self.delegate?.dataRequestDidComplete(self, error, self.downloadedData)
            }
        }
    }
}
```


The encapsulation of Remote Request mainly serves the data requests initiated by ResourceLoader.

`RequestType`: Used to distinguish whether this Request is the first request for file information (contentInformation) or a data request (dataRequest).

`RequestRange`: The range of the request, where end can specify to which point (requestTo(Int64)) or all (requestToEnd).

File information can be obtained from:
```less
func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Void)
```

The Response Header can be obtained here. Additionally, note that if you want to modify HEAD, you won't enter this; you need to use other methods.
- `isByteRangeAccessSupported`: Check if **Accept-Ranges == bytes** in the Response Header.
- `contentType`: The file type information required by the player, formatted as a uniform type identifier, not audio/mpeg, but written as public.mp3.
- `contentLength`: Check **Content-Range** in the Response Header: bytes 0–1/ **total length of the resource**.

> _⚠️ Note that the case of the format provided by the server may vary; it may not always be written as Accept-Ranges/Content-Range; some servers may use lowercase accept-ranges, Accept-ranges…_

**Supplement: If you want to consider case sensitivity, you can write an HTTPURLResponse Extension.**
```swift
import CoreServices

extension HTTPURLResponse {
    func parseContentLengthFromContentRange() -> Int64? {
        let contentRangeKeys: [String] = [
            "Content-Range",
            "content-range",
            "Content-range",
            "content-Range"
        ]
        
        var rangeString: String?
        for key in contentRangeKeys {
            if let value = self.allHeaderFields[key] as? String {
                rangeString = value
                break
            }
        }
        
        guard let rangeString = rangeString,
              let contentLengthString = rangeString.split(separator: "/").map({String($0)}).last,
              let contentLength = Int64(contentLengthString) else {
            return nil
        }
        
        return contentLength
    }
    
    func parseAcceptRanges() -> Bool? {
        let contentRangeKeys: [String] = [
            "Accept-Ranges",
            "accept-ranges",
            "Accept-ranges",
            "accept-Ranges"
        ]
        
        var rangeString: String?
        for key in contentRangeKeys {
            if let value = self.allHeaderFields[key] as? String {
                rangeString = value
                break
            }
        }
        
        guard let rangeString = rangeString else {
            return nil
        }
        
        return rangeString == "bytes" || rangeString == "Bytes"
    }
    
    func mimeTypeUTI() -> String? {
        guard let mimeType = self.mimeType,
           let contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, mimeType as CFString, nil)?.takeRetainedValue() else {
            return nil
        }
        
        return contentType as String
    }
}
```

```markdown
Usage:
- contentLength = response\.parseContentLengthFromContentRange\( \)
- isByteRangeAccessSupported = response\.parseAcceptRanges\( \)
- contentType = response\.mimeTypeUTI\( \)

```swift
func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)
```

As mentioned in the previous introductory knowledge, this method will continuously receive the downloaded data in chunks; we will append it to `downloadedData` for storage.
```swift
func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)
```

This method will be called when the task is canceled or completed, where we will save the downloaded data.

As mentioned in the introductory knowledge, the Cancel mechanism means that the player will initiate a Cancel Request after receiving enough data; therefore, when entering this method, the actual `error` will be `NSURLErrorCancelled`. Thus, regardless of the error, we will attempt to save the data we have received.

> _⚠️ Since URLSession requests data in parallel, please keep operations within a DispatchQueue to avoid data corruption (data corruption can lead to terrifying playback glitches)._ 

> _️️⚠️ If neither `finishTasksAndInvalidate` nor `invalidateAndCancel` is called, URLSession will hold onto objects, causing a Memory Leak; therefore, whether canceling or completing, we must call these methods to release the Request at the end of the task._ 

> _️️⚠️️️️️️️️️️️ If you are concerned about `downloadedData` OOM, you can save it locally in didReceive Data._ 

#### ResourceLoader
```swift
import AVFoundation
import Foundation

class ResourceLoader: NSObject {
    
    let loaderQueue = DispatchQueue(label: "li.zhgchg.resourceLoader.queue")
    
    private var requests: [AVAssetResourceLoadingRequest: ResourceLoaderRequest] = [:]
    private let cacheKey: String
    private let originalURL: URL
    
    init(asset: CachingAVURLAsset) {
        self.cacheKey = asset.cacheKey
        self.originalURL = asset.originalURL
        super.init()
    }

    deinit {
        self.requests.forEach { (request) in
            request.value.cancel()
        }
    }
}

extension ResourceLoader: AVAssetResourceLoaderDelegate {
    func resourceLoader(_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest: AVAssetResourceLoadingRequest) -> Bool {
        
        let type = ResourceLoader.resourceLoaderRequestType(loadingRequest)
        let assetDataManager = PINCacheAssetDataManager(cacheKey: self.cacheKey)

        if let assetData = assetDataManager.retrieveAssetData() {
            if type == .contentInformation {
                loadingRequest.contentInformationRequest?.contentLength = assetData.contentInformation.contentLength
                loadingRequest.contentInformationRequest?.contentType = assetData.contentInformation.contentType
                loadingRequest.contentInformationRequest?.isByteRangeAccessSupported = assetData.contentInformation.isByteRangeAccessSupported
                loadingRequest.finishLoading()
                return true
            } else {
                let range = ResourceLoader.resourceLoaderRequestRange(type, loadingRequest)
                if assetData.mediaData.count > 0 {
                    let end: Int64
                    switch range.end {
                    case .requestTo(let rangeEnd):
                        end = rangeEnd
                    case .requestToEnd:
                        end = assetData.contentInformation.contentLength
                    }
                    
                    if assetData.mediaData.count >= end {
                        let subData = assetData.mediaData.subdata(in: Int(range.start)..<Int(end))
                        loadingRequest.dataRequest?.respond(with: subData)
                        loadingRequest.finishLoading()
                       return true
                    } else if range.start <= assetData.mediaData.count {
                        // has cache data...but not enough
                        let subEnd = (assetData.mediaData.count > end) ? Int((end)) : (assetData.mediaData.count)
                        let subData = assetData.mediaData.subdata(in: Int(range.start)..<subEnd)
                        loadingRequest.dataRequest?.respond(with: subData)
                    }
                }
            }
        }
        
        let range = ResourceLoader.resourceLoaderRequestRange(type, loadingRequest)
        let resourceLoaderRequest = ResourceLoaderRequest(originalURL: self.originalURL, type: type, loaderQueue: self.loaderQueue, assetDataManager: assetDataManager)
        resourceLoaderRequest.delegate = self
        self.requests[loadingRequest]?.cancel()
        self.requests[loadingRequest] = resourceLoaderRequest
        resourceLoaderRequest.start(requestRange: range)
        
        return true
    }
    
    func resourceLoader(_ resourceLoader: AVAssetResourceLoader, didCancel loadingRequest: AVAssetResourceLoadingRequest) {
        guard let resourceLoaderRequest = self.requests[loadingRequest] else {
            return
        }
        
        resourceLoaderRequest.cancel()
        requests.removeValue(forKey: loadingRequest)
    }
}

extension ResourceLoader: ResourceLoaderRequestDelegate {
    func contentInformationDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ result: Result<AssetDataContentInformation, Error>) {
        guard let loadingRequest = self.requests.first(where: { $0.value == resourceLoaderRequest })?.key else {
            return
        }
        
        switch result {
        case .success(let contentInformation):
            loadingRequest.contentInformationRequest?.contentType = contentInformation.contentType
            loadingRequest.contentInformationRequest?.contentLength = contentInformation.contentLength
            loadingRequest.contentInformationRequest?.isByteRangeAccessSupported = contentInformation.isByteRangeAccessSupported
            loadingRequest.finishLoading()
        case .failure(let error):
            loadingRequest.finishLoading(with: error)
        }
    }
    
    func dataRequestDidReceive(_ resourceLoaderRequest: ResourceLoaderRequest, _ data: Data) {
        guard let loadingRequest = self.requests.first(where: { $0.value == resourceLoaderRequest })?.key else {
            return
        }
        
        loadingRequest.dataRequest?.respond(with: data)
    }
    
    func dataRequestDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ error: Error?, _ downloadedData: Data) {
        guard let loadingRequest = self.requests.first(where: { $0.value == resourceLoaderRequest })?.key else {
            return
        }
        
        loadingRequest.finishLoading(with: error)
        requests.removeValue(forKey: loadingRequest)
    }
}

extension ResourceLoader {
    static func resourceLoaderRequestType(_ loadingRequest: AVAssetResourceLoadingRequest) -> ResourceLoaderRequest.RequestType {
        if let _ = loadingRequest.contentInformationRequest {
            return .contentInformation
        } else {
            return .dataRequest
        }
    }
    
    static func resourceLoaderRequestRange(_ type: ResourceLoaderRequest.RequestType, _ loadingRequest: AVAssetResourceLoadingRequest) -> ResourceLoaderRequest.RequestRange {
        if type == .contentInformation {
            return ResourceLoaderRequest.RequestRange(start: 0, end: .requestTo(1))
        } else {
            if loadingRequest.dataRequest?.requestsAllDataToEndOfResource == true {
                let lowerBound = loadingRequest.dataRequest?.currentOffset ?? 0
                return ResourceLoaderRequest.RequestRange(start: lowerBound, end: .requestToEnd)
            } else {
                let lowerBound = loadingRequest.dataRequest?.currentOffset ?? 0
                let length = Int64(loadingRequest.dataRequest?.requestedLength ?? 1)
                let upperBound = lowerBound + length
                return ResourceLoaderRequest.RequestRange(start: lowerBound, end: .requestTo(upperBound))
            }
        }
    }
}
```

```swift
`loadingRequest.contentInformationRequest` != nil indicates that this is the first request, and the player is asking for file information first.

When requesting file information, we need to provide these three pieces of information:
- `loadingRequest.contentInformationRequest?.isByteRangeAccessSupported`: Whether byte range access for data is supported.
- `loadingRequest.contentInformationRequest?.contentType`: Uniform Resource Identifier (URI).
- `loadingRequest.contentInformationRequest?.contentLength`: Total length of the file in Int64.

`loadingRequest.dataRequest?.requestedOffset` can be used to obtain the starting offset of the requested range.

`loadingRequest.dataRequest?.requestedLength` can be used to obtain the length of the requested range.

If `loadingRequest.dataRequest?.requestsAllDataToEndOfResource` == true, regardless of the requested range length, the entire resource will be fetched.

`loadingRequest.dataRequest?.respond(with: Data)` returns the loaded data to the player.

`loadingRequest.dataRequest?.currentOffset` can be used to obtain the current data offset; after `dataRequest?.respond(with: Data)`, `currentOffset` will be updated accordingly.

`loadingRequest.finishLoading()` indicates that all data has been loaded and informs the player.
```swift
func resourceLoader(_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest: AVAssetResourceLoadingRequest) -> Bool
```

When the player requests data, we first check if there is any data in the local cache. If there is, we return it; if only part of the data is available, we return that part. For example, if I have 0–100 in the local cache and the player requests 0–200, we will return 0–100 first.

If there is no local cache or the returned data is insufficient, a ResourceLoaderRequest will be initiated to fetch data from the network.
```swift
func resourceLoader(_ resourceLoader: AVAssetResourceLoader, didCancel loadingRequest: AVAssetResourceLoadingRequest)
```

The player cancels the request, canceling the ResourceLoaderRequest.

> _You may have noticed that the offset of `resourceLoaderRequestRange` looks at `currentOffset`, because we will first respond with the already downloaded data from the local `dataRequest?.respond(with: Data)`; thus, we can directly look at the updated offset._

```swift
func private var requests: [AVAssetResourceLoadingRequest: ResourceLoaderRequest] = [:]
```

> _⚠️ Some examples of requests only use `currentRequest: ResourceLoaderRequest` to store, which can lead to issues. This is because the current request may be fetching data while the user seeks, causing the old request to be canceled and a new one to be initiated; however, this may not happen in order, potentially leading to a new request being made before the cancellation occurs. Therefore, using a Dictionary for storage and operations is safer!_

> _⚠️ Ensure all operations are performed on the same DispatchQueue to prevent data inconsistencies._

**Cancel all ongoing requests during deinit**  
Resource Loader deinit indicates that AVURLAsset deinit has occurred, meaning the player no longer needs this resource; thus, we can cancel any ongoing data requests, while already loaded data will still be written to the cache.
### Supplement and Acknowledgments

Thanks to [Lex Tang](https://medium.com/u/2d01a2439753){:target="_blank"} for the guidance.

Thanks to [Granddaughter](https://medium.com/u/aab116fd9d4d){:target="_blank"} for providing development insights and support.
#### This article only addresses small music files.


Large video files may encounter Out Of Memory issues in downloadedData and AssetData/PINCacheAssetDataManager.

As mentioned earlier, to resolve this issue, please use fileHandler seek read/write to operate local Cache for reading and writing (instead of AssetData/PINCacheAssetDataManager); or check if there are any GitHub projects available for large data write/read to file.

#### Canceling Downloads of Current Items When Switching Playback Items in AVQueuePlayer

As stated in the previous knowledge, when changing the playback target, a Cancel will not be initiated; if it is AVPlayer, it will go through AVURLAsset Deinit, thus interrupting the download; however, AVQueuePlayer will not, as it is still in the Queue, just switching the playback target to the next song.

The only approach here is to receive notifications for changing playback targets and then cancel the loading of the previous AVURLAsset upon receiving the notification.
```swift
asset.cancelLoading()
```
#### Audio Data Encryption and Decryption

Audio encryption and decryption can be performed using the Data obtained from ResourceLoaderRequest, and when storing, encryption and decryption can be applied to the local Data in AssetData's encode/decode.

**CryptoKit SHA Usage Example:**
```swift
class AssetData: NSObject, NSCoding {
    static let encryptionKeyString = "encryptionKeyExzhgchgli"
    ...
    func encode(with coder: NSCoder) {
        coder.encode(self.contentInformation, forKey: #keyPath(AssetData.contentInformation))
        
        if #available(iOS 13.0, *),
           let encryptionData = try? ChaChaPoly.seal(self.mediaData, using: AssetData.encryptionKey).combined {
            coder.encode(encryptionData, forKey: #keyPath(AssetData.mediaData))
        } else {
          //
        }
    }
    
    required init?(coder: NSCoder) {
        super.init()
        ...
        if let mediaData = coder.decodeObject(forKey: #keyPath(AssetData.mediaData)) as? Data {
            if #available(iOS 13.0, *),
               let sealedBox = try? ChaChaPoly.SealedBox(combined: mediaData),
               let decryptedData = try? ChaChaPoly.open(sealedBox, using: AssetData.encryptionKey) {
                self.mediaData = decryptedData
            } else {
              //
            }
        } else {
            //
        }
    }
}
```
#### Operations Related to PINCache

PINCache includes PINMemoryCache and PINDiskCache, which handle the tasks of reading from files to Memory or writing from Memory to files; we only need to operate on PINCache.

To find the Cache file location in the simulator:


![](/assets/6ce488898003/1*dUWZRwGTRhOAuxnqWJBvog.png)


Use `NSHomeDirectory()` to obtain the file path of the simulator.


![](/assets/6ce488898003/1*qXzny7KAwK20E6ma8zJUnw.png)


Finder -> Go -> Paste the path


![](/assets/6ce488898003/1*IcyAHKsTgaG-xqu1QzQq6Q.png)

In the Library -> Caches -> com.pinterest.PINDiskCache.ResourceLoader is the directory for the Resource Loader Cache we created.

`PINCache(name: “ResourceLoader”)` where the name is the directory name.

You can also specify rootPath, and the directory can be moved under Documents (without fear of being cleared by the system).

**Set the maximum limit for PINCache:**
```swift
 PINCacheAssetDataManager.Cache.diskCache.byteCount = 300 * 1024 * 1024 // max: 300mb
 PINCacheAssetDataManager.Cache.diskCache.byteLimit = 90 * 60 * 60 * 24 // 90 days
```

![System Default Limit](/assets/6ce488898003/1*kjZWSBU__E-2jTYyyjWZEA.png)

System default limit

Setting it to 0 will prevent files from being deleted proactively.
### Postscript

Initially underestimated the difficulty of this feature, thinking it could be handled easily; however, it turned out to be quite challenging, and I spent about two more weeks dealing with data storage issues. Nevertheless, I gained a thorough understanding of the entire Resource Loader operation mechanism, GCD, and Data.
### References

Finally, here are some references for studying how to implement it:
1. [Design and Implementation of iOS AVPlayer Video Caching](http://chuquan.me/2019/12/03/ios-avplayer-support-cache/){:target="_blank"} only discusses the principles.
2. [Implementing Audio and Video Playback and Caching Based on AVPlayer, Supporting Synchronized Output of Video Frames](https://caisanze.com/post/swift-avplayer/){:target="_blank"} \[ [SZAVPlayer](https://github.com/eroscai/SZAVPlayer){:target="_blank"} \] includes code (very complete but quite complex).
3. [CachingPlayerItem](https://github.com/neekeetab/CachingPlayerItem/blob/7d998b8561693cf51077f0891ed240e92bec415e/CachingPlayerItem.swift){:target="_blank"} (simple implementation, easier to understand but incomplete).
4. [Possibly the Best AVPlayer Audio and Video Caching Solution AVAssetResourceLoaderDelegate](https://www.jianshu.com/p/28157247d6a7){:target="_blank"}.
5. [Swift Version of Douyin](https://sshiqiao.github.io/document/douyin-swift.html#1){:target="_blank"} \[ [Github](https://github.com/sshiqiao/douyin-ios-swift){:target="_blank"} \] (an interesting project that replicates the Douyin APP; it also uses Resource Loader).
6. [Exploration Journey of iOS HLS Cache Implementation Methods](../d796bf8e661e/)

### Extension
- [DLCachePlayer](https://github.com/dminoror/DLCachePlayer){:target="_blank"} \(Objective-C version\)

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/avplayer-%E5%AF%A6%E8%B8%90%E6%9C%AC%E5%9C%B0-cache-%E5%8A%9F%E8%83%BD%E5%A4%A7%E5%85%A8-6ce488898003){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
