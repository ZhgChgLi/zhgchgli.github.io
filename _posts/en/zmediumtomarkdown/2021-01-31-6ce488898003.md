---
title: "Comprehensive Guide to Implementing Local Cache Functionality with AVPlayer"
author: "ZhgChgLi"
date: 2021-01-31T10:41:42.622+0000
last_modified_at: 2024-04-13T08:45:21.565+0000
categories: ["ZRealm Dev."]
tags: ["ios","ios-app-development","cache","avplayer","music-player-app"]
description: "Implementing AVPlayer/AVQueuePlayer with AVURLAsset and AVAssetResourceLoaderDelegate"
image:
  path: /assets/6ce488898003/1*lAGpCiT80GFIQ2adYworVw.jpeg
render_with_liquid: false
---

### Comprehensive Guide to Implementing Local Cache Functionality with AVPlayer

Implementing AVPlayer/AVQueuePlayer with AVURLAsset and AVAssetResourceLoaderDelegate

![Photo by [Tyler Lastovich](https://unsplash.com/@lastly?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/6ce488898003/1*lAGpCiT80GFIQ2adYworVw.jpeg)

Photo by [Tyler Lastovich](https://unsplash.com/@lastly?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
#### \[2023/03/12\] Update

[![](https://repository-images.githubusercontent.com/612890185/346ae563-7278-4518-a19b-f5d367e60adc)](https://github.com/ZhgChgLi/ZPlayerCacher){:target="_blank"}

I have open-sourced my previous implementation, so friends in need can use it directly.
- Customizable cache strategies, can use PINCache or others...
- Externally, just call the make AVAsset factory with the URL, and the AVAsset will support caching.
- Implemented data flow strategies using Combine.
- Wrote some tests.

### Introduction

It has been over half a year since the previous article "[Exploring iOS HLS Cache Implementation Methods](../d796bf8e661e/)," and the team has still been eager to implement the functionality of streaming while caching due to its significant impact on costs. We are a music streaming platform, and if we have to retrieve the entire file every time the same song is played, it can be very costly for us and for users who do not have unlimited data plans. Although music files are usually just a few MB, every little bit adds up!

Additionally, since Android has already implemented the streaming while caching feature, we have compared costs, and it is evident that the Android version has saved a lot of data after going live; consequently, the larger user base on iOS should also benefit from better data savings.

Based on the experience from the [previous article](../d796bf8e661e/), if we continue to use HLS (\ .m3u8/\ .ts) to achieve our goal, things will become very complicated and may even be unachievable. Therefore, we have opted to revert to using mp3 files, which allows us to directly implement `AVAssetResourceLoaderDelegate`.

### Goals
- Music that has been played will generate a local cache backup.
- When playing music, first check if there is a cache locally; if so, do not request the file from the server again.
- Cache strategies can be set; a maximum total capacity can be defined, and when exceeded, the oldest cache files will start to be deleted.
- Do not interfere with the original AVPlayer playback mechanism.
(Otherwise, the fastest method would be to download the mp3 file using URLSession and feed it to AVPlayer, but this would lose the ability to stream as needed, requiring users to wait longer and consume more data.)

### Prerequisite Knowledge \(1\)— HTTP/1\.1 Range Requests, Connection Keep-Alive
#### HTTP/1\.1 Range Requests

First, we need to understand how data is requested from the server when playing videos or music. Generally, video and music files are large, and it is not feasible to wait until the entire file is downloaded before starting playback. The common approach is to stream data as it is received; as long as there is data in the playback segment, it can function.

The way to achieve this functionality is through HTTP/1\.1 Range requests, which only return data for specified byte ranges. For example, requesting bytes 0–100 will only return 100 bytes of data from 0 to 100. This method allows for sequentially obtaining data in segments, which can then be assembled into a complete file. This method can also be applied to file download resumption functionality.
#### How to Apply?

We will first use HEAD to check the response header to determine whether the server supports range requests, the total length of the resource, and the file type:
```bash
curl -i -X HEAD http://zhgchg.li/music.mp3
```

**Using HEAD, we can obtain the following information from the response header:**
- **Accept-Ranges: bytes** indicates that the server supports range requests. If this value is absent or if it is Accept-Ranges: none, it means that range requests are not supported.
- **Content-Length:** the total length of the resource; we need to know the total length to segment the data requests.
- **Content-Type:** the file type, which is necessary information for AVPlayer during playback.

However, sometimes we also use GET with `Range: bytes=0–1`, meaning we request data in the range of 0–1, but we do not actually care about the content of 0–1; we just want to see the information in the response header. **The native AVPlayer uses GET to check, so this article will also follow suit.**

> _However, it is recommended to use HEAD for checking, as it is a more accurate method. On the other hand, if the server does not support range functionality, using GET will force a complete download of the file._

```bash
curl -i -X GET http://zhgchg.li/music.mp3 -H "Range: bytes=0–1"
```

**Using GET, we can obtain the following information from the response header:**
- **Accept-Ranges: bytes** indicates that the server supports range requests. If this value is absent or if it is Accept-Ranges: none, it means that range requests are not supported.
- **Content-Range: bytes 0–1/total length** indicates the total length of the resource after the "/" character; we need to know the total length to segment the data requests.
- **Content-Type:** the file type, which is necessary information for AVPlayer during playback.

![](/assets/6ce488898003/1*IP55kaFB3NES3QWZ7Mf-aw.jpeg)

**Once we know that the server supports range requests, we can start making segmented range requests:**
```bash
curl -i -X GET http://zhgchg.li/music.mp3 -H "Range: bytes=0–100"
```

**The server will return 206 Partial Content:**
```
Content-Range: bytes 0-100/total length
Content-Length: 100
...
(binary content)
```

At this point, we have obtained the data for range 0–100 and can continue to make new requests for ranges 100–200, 200–300, and so on until completion.

If the requested range exceeds the total length of the resource, a 416 Range Not Satisfiable response will be returned.

Additionally, to obtain the complete file data, we can request the range 0–total length or simply use 0–:
```bash
curl -i -X GET http://zhgchg.li/music.mp3 -H "Range: bytes=0–"
```

It is also possible to request multiple ranges in a single request and set conditional expressions, but we do not need that here. For more details, please [refer to this](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests){:target="_blank"}.
#### Connection Keep-Alive

HTTP/1\.1 is enabled by default, and **this feature allows for real-time retrieval of already downloaded data**. For example, for a 5 MB file, data can be retrieved in chunks of 16 KB, 16 KB, 16 KB, etc., without having to wait for the entire 5 MB to be ready.
```
Connection: Keep-Alive
```
#### **_What if the server does not support Range or Keep-Alive?_**

> _In that case, there is no need to complicate things; you can simply use URLSession to download the mp3 file and feed it to the player... But this is not the result we want, so we can ask the backend to modify the server settings._

### Prerequisite Knowledge \(2\) — How does AVPlayer natively handle AVURLAsset resources?

![](/assets/6ce488898003/1*iLE51pGNDl_5Jwp8cTM6HQ.jpeg)

When we use AVURLAsset initialized with a URL resource and assign it to AVPlayer/AVQueuePlayer to start playback, as mentioned above, it will first use GET with Range 0–1 to obtain whether range requests are supported, the total length of the resource, and the file type.

After obtaining the file information, a second request will be made to request data from 0 to total length.

> _⚠️ **AVPlayer will request data from 0 to total length and will utilize the real-time retrieval of already downloaded data feature (16 KB, 16 KB, 16 KB...) to obtain enough data before initiating a cancel to terminate this network request** (so it will not actually retrieve everything unless the file is very small)._

> _Subsequent playback will then request data further along using range requests._

> _(This part differs from what I previously thought; I assumed it would request in increments of 0–100, 100–200, etc.)_

**AVPlayer Request Example:**
```
1. GET Range 0-1 => Response: total length 150000 / public.mp3 / true
2. GET 0-150000...
3. 16 KB received
4. 16 KB received...
5. cancel() // current offset is 700
6. Continue playback
7. GET 700-150000...
8. 16 KB received
9. 16 KB received...
10. cancel() // current offset is 1500
11. Continue playback
12. GET 1500-150000...
13. 16 KB received
14. 16 KB received...
16. If seek to...5000
17. cancel(12.) // current offset is 2000
18. GET 5000-150000...
19. 16 KB received
20. 16 KB received...
...
```

> _⚠️ **In iOS ≤12, it will first send a few shorter requests to probe (?), and then it will send a request for the total length; in iOS ≥ 13, it will directly send a request for the total length.**_

There is also an unrelated pitfall; while observing how resources are fetched, I used the [mitmproxy](../46410aaada00/) tool to sniff traffic, and I found that it displayed errors, waiting until the entire response returned before showing it, rather than displaying it in segments and using persistent connections to continue downloading. This startled me! I thought iOS was so inefficient that it had to download the entire file each time! Next time I use a tool, I need to maintain a bit of skepticism. 
#### Timing of Cancel Requests
1. The second request mentioned earlier, which requests the resource from 0 to total length, will initiate a cancel request once sufficient data has been received.
2. When seeking, a cancel request will be initiated for the previous request.

> _⚠️ In AVQueuePlayer, switching to the next resource or changing the playback resource in AVPlayer will not initiate a cancel request for the previous track._

#### AVQueue Pre-buffering

This also calls the Resource Loader for processing, but the requested data range will be smaller.
### Implementation

With the prerequisite knowledge established, let's look at how to implement the local cache functionality for AVPlayer.

This involves the previously mentioned `AVAssetResourceLoaderDelegate`, which allows us to **implement our own Resource Loader** for the asset.

The Resource Loader essentially acts as a worker; whether the player needs file information or file data, and whatever range is needed, it informs us, and we handle it.

> _I have seen examples where a **Resource Loader serves all AVURLAssets**; I believe this is incorrect. There should be one Resource Loader serving one AVURLAsset, following the lifecycle of that AVURLAsset, as it inherently belongs to that AVURLAsset._

> _Having one Resource Loader serve all AVURLAssets would become very complex and difficult to manage in AVQueuePlayer._

#### Timing for Entering Custom Resource Loader

It is important to note that simply implementing your own Resource Loader does not guarantee it will be used; it will only be invoked when the system cannot recognize or handle the resource.

Therefore, before assigning the URL resource to AVURLAsset, we need to change the scheme to our custom scheme, which cannot be http/https or any other scheme that the system can handle.
```
http://zhgchg.li/music.mp3 => cacheable://zhgchg.li/music.mp3
```
#### `AVAssetResourceLoaderDelegate`

**Only two methods need to be implemented:**
- func resourceLoader\( \_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource **loadingRequest** : AVAssetResourceLoadingRequest\) \-&gt; Bool :

This method asks us whether we can handle this resource; returning true means we can, while returning false means we will not handle it (unsupported URL).

From `loadingRequest`, we can extract what is being requested (whether it is the first request for file information or a request for data, and if it is a data request, what the range is); once we know the request, we can initiate our own request to fetch the data. **At this point, we can decide whether to initiate a URLSession request or return data from local storage.**

We can also perform data encryption and decryption operations here to protect the original data.
- func resourceLoader\( \_ resourceLoader: AVAssetResourceLoader, didCancel **loadingRequest** : AVAssetResourceLoadingRequest\) :

This is where we handle the cancellation of requests as previously mentioned...

We can cancel any ongoing URLSession requests here.

![](/assets/6ce488898003/1*widvJqzE-HtG32B-6ZiFhw.jpeg)

#### Local Cache Implementation

For caching, I directly use [PINCache](https://github.com/pinterest/PINCache){:target="_blank"} to handle cache operations, which saves us from dealing with cache read/write deadlocks and implementing LRU cache clearing strategies.

> **_️️⚠️️️️️️️️️️️OOM Warning!_** 

> _Since this is for caching music files, which are typically around 10 MB, we can use PINCache as a local caching tool; however, this method cannot be used for video services (which may require loading several GB of data into memory)._

For those with similar needs, you can refer to the approach of using FileHandle seek read/write features for processing.
### Let's Get Started!

Without further ado, here is the complete project:

[![](https://opengraph.githubassets.com/b43d0ddf4687cf5a04d6bbc68e4bfd24a9d5067fe04e2e198a676aff746de403/zhgchgli0718/resourceLoaderDemo)](https://github.com/zhgchgli0718/resourceLoaderDemo){:target="_blank"}

#### AssetData

The local cache data object implements NSCoding, as PINCache relies on the archivedData method for encoding/decoding.
```swift
import Foundation
import CryptoKit

class AssetDataContentInformation: NSObject, NSCoding {
    @objc var contentLength: Int64 = 0
    @objc var contentType: String = ""
    @objc var isByteRangeAccessSupported: Bool = false
    
    func encode(with coder: NSCoder) {
        coder.encode(self.contentLength, forKey: #keyPath(AssetDataContentInformation.contentLength))
        coder.encode(self.contentType, forKey: #keyPath(AssetDataContentInformation.contentType))
        coder.encode(self.isByteRangeAccessSupported, forKey: #keyPath(AssetDataContentInformation.isByteRangeAccessSupported))
    }
    
    override init() {
        super.init()
    }
    
    required init?(coder: NSCoder) {
        super.init()
        self.contentLength = coder.decodeInt64(forKey: #keyPath(AssetDataContentInformation.contentLength))
        self.contentType = coder.decodeObject(forKey: #keyPath(AssetDataContentInformation.contentType)) as? String ?? ""
        self.isByteRangeAccessSupported = coder.decodeObject(forKey: #keyPath(AssetDataContentInformation.isByteRangeAccessSupported)) as? Bool ?? false
    }
}

class AssetData: NSObject, NSCoding {
    @objc var contentInformation: AssetDataContentInformation = AssetDataContentInformation()
    @objc var mediaData: Data = Data()
    
    override init() {
        super.init()
    }

    func encode(with coder: NSCoder) {
        coder.encode(self.contentInformation, forKey: #keyPath(AssetData.contentInformation))
        coder.encode(self.mediaData, forKey: #keyPath(AssetData.mediaData))
    }
    
    required init?(coder: NSCoder) {
        super.init()
        self.contentInformation = coder.decodeObject(forKey: #keyPath(AssetData.contentInformation)) as? AssetDataContentInformation ?? AssetDataContentInformation()
        self.mediaData = coder.decodeObject(forKey: #keyPath(AssetData.mediaData)) as? Data ?? Data()
    }
}
```

`AssetData` **stores:**
- `contentInformation`: AssetDataContentInformation
`AssetDataContentInformation`: 
stores whether range requests are supported (isByteRangeAccessSupported), the total length of the resource (contentLength), and the file type (contentType).
- `mediaData`: Raw audio Data **(this may cause OOM if the file is too large)**

#### PINCacheAssetDataManager

```markdown
Encapsulating the logic for storing and retrieving data in PINCache.
```swift
import PINCache
import Foundation

protocol AssetDataManager: NSObject {
    func retrieveAssetData() -> AssetData?
    func saveContentInformation(_ contentInformation: AssetDataContentInformation)
    func saveDownloadedData(_ data: Data, offset: Int)
    func mergeDownloadedDataIfIsContinuted(from: Data, with: Data, offset: Int) -> Data?
}

extension AssetDataManager {
    func mergeDownloadedDataIfIsContinuted(from: Data, with: Data, offset: Int) -> Data? {
        if offset <= from.count && (offset + with.count) > from.count {
            let start = from.count - offset
            var data = from
            data.append(with.subdata(in: start..<with.count))
            return data
        }
        return nil
    }
}

//

class PINCacheAssetDataManager: NSObject, AssetDataManager {
    
    static let Cache: PINCache = PINCache(name: "ResourceLoader")
    let cacheKey: String
    
    init(cacheKey: String) {
        self.cacheKey = cacheKey
        super.init()
    }
    
    func saveContentInformation(_ contentInformation: AssetDataContentInformation) {
        let assetData = AssetData()
        assetData.contentInformation = contentInformation
        PINCacheAssetDataManager.Cache.setObjectAsync(assetData, forKey: cacheKey, completion: nil)
    }
    
    func saveDownloadedData(_ data: Data, offset: Int) {
        guard let assetData = self.retrieveAssetData() else {
            return
        }
        
        if let mediaData = self.mergeDownloadedDataIfIsContinuted(from: assetData.mediaData, with: data, offset: offset) {
            assetData.mediaData = mediaData
            
            PINCacheAssetDataManager.Cache.setObjectAsync(assetData, forKey: cacheKey, completion: nil)
        }
    }
    
    func retrieveAssetData() -> AssetData? {
        guard let assetData = PINCacheAssetDataManager.Cache.object(forKey: cacheKey) as? AssetData else {
            return nil
        }
        return assetData
    }
}
```

Here, we have extracted the Protocol because in the future, we may use other storage methods instead of PINCache, allowing other programs to rely on the Protocol rather than the Class instance.

> _⚠️ `mergeDownloadedDataIfIsContinuted` **This method is extremely important.**_

For linear playback, you can simply keep appending new Data to the Cache Data, but the reality is much more complex. Users might play from Range 0–100 and then directly seek to Range 200–500; how to merge the existing 0-100 Data with the new 200-500 Data is a significant challenge.

> _⚠️ Issues with data merging can lead to terrifying playback glitches…_

The answer here is, **we do not handle non-continuous data**; since our project only deals with audio and the files are just a few MB (≤ 10MB), we decided not to implement this due to development costs. I only handle merging continuous data (for example, if we already have 0–100 and the new data is 75–200, it merges to 0–200; if the new data is 150–200, I will ignore it and not merge).

![](/assets/6ce488898003/1*Cyfusv16pk1AtpGAjJlMMQ.jpeg)

If we need to consider non-continuous merging, we would have to use other methods for storage (to identify the missing parts); during the Request, we would also need to query which segments require a network request and which segments can be retrieved locally. Implementing this would be very complex.

![Image source: [Design and Implementation of iOS AVPlayer Video Caching](http://chuquan.me/2019/12/03/ios-avplayer-support-cache/){:target="_blank"}](/assets/6ce488898003/1*XgMZGKMb-YNCFnS9MbiZhw.png)

Image source: [Design and Implementation of iOS AVPlayer Video Caching](http://chuquan.me/2019/12/03/ios-avplayer-support-cache/){:target="_blank"}
#### CachingAVURLAsset

AVURLAsset weakly holds the ResourceLoader Delegate, so it is recommended to create your own AVURLAsset Class that inherits from AVURLAsset, internally creating, assigning, and holding the ResourceLoader, allowing it to follow the lifecycle of AVURLAsset; additionally, you can store the original URL, CacheKey, and other information...
```swift
class CachingAVURLAsset: AVURLAsset {
    static let customScheme = "cacheable"
    let originalURL: URL
    private var _resourceLoader: ResourceLoader?
    
    var cacheKey: String {
        return self.url.lastPathComponent
    }
    
    static func isSchemeSupport(_ url: URL) -> Bool {
        guard let components = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
            return false
        }
        
        return ["http", "https"].contains(components.scheme)
    }
    
    override init(url URL: URL, options: [String: Any]? = nil) {
        self.originalURL = URL
        
        guard var components = URLComponents(url: URL, resolvingAgainstBaseURL: false) else {
            super.init(url: URL, options: options)
            return
        }
        
        components.scheme = CachingAVURLAsset.customScheme
        guard let url = components.url else {
            super.init(url: URL, options: options)
            return
        }
        
        super.init(url: url, options: options)
        
        let resourceLoader = ResourceLoader(asset: self)
        self.resourceLoader.setDelegate(resourceLoader, queue: resourceLoader.loaderQueue)
        self._resourceLoader = resourceLoader
    }
}
```

**Usage:**
```swift
if CachingAVURLAsset.isSchemeSupport(url) {
  let asset = CachingAVURLAsset(url: url)
  let avplayer = AVPlayer(asset)
  avplayer.play()
}
```

The `isSchemeSupport()` function is used to determine if the URL supports our Resource Loader (excluding file://).

`originalURL` stores the original resource URL.

`cacheKey` stores the Cache Key for this resource, using the file name as the Cache Key.

Please adjust the `cacheKey` according to real-world scenarios; if the file name is not hashed and may duplicate, it is recommended to hash it first to avoid collisions; if you want to hash the entire URL as the key, be mindful of whether the URL may change (e.g., if using a CDN).

Hashing can be done using md5...sha... For iOS ≥ 13, you can directly use Apple's [CryptoKit](https://developer.apple.com/documentation/cryptokit/){:target="_blank"}, or find alternatives on GitHub!
#### ResourceLoaderRequest
```swift
import Foundation
import CoreServices

protocol ResourceLoaderRequestDelegate: AnyObject {
    func dataRequestDidReceive(_ resourceLoaderRequest: ResourceLoaderRequest, _ data: Data)
    func dataRequestDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ error: Error?, _ downloadedData: Data)
    func contentInformationDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ result: Result<AssetDataContentInformation, Error>)
}

class ResourceLoaderRequest: NSObject, URLSessionDataDelegate {
    struct RequestRange {
        var start: Int64
        var end: RequestRangeEnd
        
        enum RequestRangeEnd {
            case requestTo(Int64)
            case requestToEnd
        }
    }
    
    enum RequestType {
        case contentInformation
        case dataRequest
    }
    
    struct ResponseUnExpectedError: Error { }
    
    private let loaderQueue: DispatchQueue
    
    let originalURL: URL
    let type: RequestType
    
    private var session: URLSession?
    private var dataTask: URLSessionDataTask?
    private var assetDataManager: AssetDataManager?
    
    private(set) var requestRange: RequestRange?
    private(set) var response: URLResponse?
    private(set) var downloadedData: Data = Data()
    
    private(set) var isCancelled: Bool = false {
        didSet {
            if isCancelled {
                self.dataTask?.cancel()
                self.session?.invalidateAndCancel()
            }
        }
    }
    private(set) var isFinished: Bool = false {
        didSet {
            if isFinished {
                self.session?.finishTasksAndInvalidate()
            }
        }
    }
    
    weak var delegate: ResourceLoaderRequestDelegate?
    
    init(originalURL: URL, type: RequestType, loaderQueue: DispatchQueue, assetDataManager: AssetDataManager?) {
        self.originalURL = originalURL
        self.type = type
        self.loaderQueue = loaderQueue
        self.assetDataManager = assetDataManager
        super.init()
    }
    
    func start(requestRange: RequestRange) {
        guard isCancelled == false, isFinished == false else {
            return
        }
        
        self.loaderQueue.async { [weak self] in
            guard let self = self else {
                return
            }
            
            var request = URLRequest(url: self.originalURL)
            self.requestRange = requestRange
            let start = String(requestRange.start)
            let end: String
            switch requestRange.end {
            case .requestTo(let rangeEnd):
                end = String(rangeEnd)
            case .requestToEnd:
                end = ""
            }
            
            let rangeHeader = "bytes=\(start)-\(end)"
            request.setValue(rangeHeader, forHTTPHeaderField: "Range")
            
            let session = URLSession(configuration: .default, delegate: self, delegateQueue: nil)
            self.session = session
            let dataTask = session.dataTask(with: request)
            self.dataTask = dataTask
            dataTask.resume()
        }
    }
    
    func cancel() {
        self.isCancelled = true
    }
    
    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
        guard self.type == .dataRequest else {
            return
        }
        
        self.loaderQueue.async {
            self.delegate?.dataRequestDidReceive(self, data)
            self.downloadedData.append(data)
        }
    }
    
    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {
        self.response = response
        completionHandler(.allow)
    }
    
    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        self.isFinished = true
        self.loaderQueue.async {
            if self.type == .contentInformation {
                guard error == nil,
                      let response = self.response as? HTTPURLResponse else {
                    let responseError = error ?? ResponseUnExpectedError()
                    self.delegate?.contentInformationDidComplete(self, .failure(responseError))
                    return
                }
                
                let contentInformation = AssetDataContentInformation()
                
                if let rangeString = response.allHeaderFields["Content-Range"] as? String,
                   let bytesString = rangeString.split(separator: "/").map({String($0)}).last,
                   let bytes = Int64(bytesString) {
                    contentInformation.contentLength = bytes
                }
                
                if let mimeType = response.mimeType,
                   let contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, mimeType as CFString, nil)?.takeRetainedValue() {
                    contentInformation.contentType = contentType as String
                }
                
                if let value = response.allHeaderFields["Accept-Ranges"] as? String,
                   value == "bytes" {
                    contentInformation.isByteRangeAccessSupported = true
                } else {
                    contentInformation.isByteRangeAccessSupported = false
                }
                
                self.assetDataManager?.saveContentInformation(contentInformation)
                self.delegate?.contentInformationDidComplete(self, .success(contentInformation))
            } else {
                if let offset = self.requestRange?.start, self.downloadedData.count > 0 {
                    self.assetDataManager?.saveDownloadedData(self.downloadedData, offset: Int(offset))
                }
                self.delegate?.dataRequestDidComplete(self, error, self.downloadedData)
            }
        }
    }
}
```

This encapsulates the remote request, primarily serving the data requests initiated by the ResourceLoader.

`RequestType`: Used to distinguish whether this Request is the first request for file information (contentInformation) or a data request (dataRequest).

`RequestRange`: The range of the request, where the end can specify where to request (requestTo(Int64)) or all (requestToEnd).

File information can be obtained from:
```less
func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Void)
```

Additionally, note that if you want to modify HEAD requests, you won't enter this method and will need to use other methods to handle it.
- `isByteRangeAccessSupported`: Checks if the Response Header contains **Accept-Ranges == bytes**
- `contentType`: The file type information required by the player, formatted as a uniform type identifier, not audio/mpeg, but as public.mp3
- `contentLength`: Checks the Response Header for **Content-Range**: bytes 0–1/ **total length of the resource**

> _⚠️ Be cautious of the case sensitivity of the format provided by the server; it may not always be written as Accept-Ranges/Content-Range; some servers may use lowercase accept-ranges, Accept-ranges…_

**Supplement: If you want to consider case sensitivity, you can write an HTTPURLResponse Extension**
```swift
import CoreServices

extension HTTPURLResponse {
    func parseContentLengthFromContentRange() -> Int64? {
        let contentRangeKeys: [String] = [
            "Content-Range",
            "content-range",
            "Content-range",
            "content-Range"
        ]
        
        var rangeString: String?
        for key in contentRangeKeys {
            if let value = self.allHeaderFields[key] as? String {
                rangeString = value
                break
            }
        }
        
        guard let rangeString = rangeString,
              let contentLengthString = rangeString.split(separator: "/").map({String($0)}).last,
              let contentLength = Int64(contentLengthString) else {
            return nil
        }
        
        return contentLength
    }
    
    func parseAcceptRanges() -> Bool? {
        let contentRangeKeys: [String] = [
            "Accept-Ranges",
            "accept-ranges",
            "Accept-ranges",
            "accept-Ranges"
        ]
        
        var rangeString: String?
        for key in contentRangeKeys {
            if let value = self.allHeaderFields[key] as? String {
                rangeString = value
                break
            }
        }
        
        guard let rangeString = rangeString else {
            return nil
        }
        
        return rangeString == "bytes" || rangeString == "Bytes"
    }
    
    func mimeTypeUTI() -> String? {
        guard let mimeType = self.mimeType,
           let contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, mimeType as CFString, nil)?.takeRetainedValue() else {
            return nil
        }
        
        return contentType as String
    }
}
```

Usage:
- contentLength = response.parseContentLengthFromContentRange()
- isByteRangeAccessSupported = response.parseAcceptRanges()
- contentType = response.mimeTypeUTI()

```swift
func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)
```

As mentioned in the preliminary knowledge, this method will continuously receive the downloaded data, so it will keep getting called, receiving Data in chunks; we will append it to `downloadedData` for storage.
```swift
func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)
```

This method will be called when the task is canceled or completed, at which point we will save the downloaded data.

As mentioned in the preliminary knowledge regarding the Cancel mechanism, since the player will issue a Cancel Request after receiving enough data, when entering this method, the actual `error` will be `NSURLErrorCancelled`, so regardless of the error, we will attempt to save the data we have received.

> _⚠️ Since URLSession will request data in parallel, please keep operations within the DispatchQueue to avoid data corruption (data corruption can also lead to terrifying playback glitches)._

> _⚠️️ URLSession does not call `finishTasksAndInvalidate` or `invalidateAndCancel`; both methods will strongly hold objects, causing Memory Leaks; therefore, whether canceling or completing, we must call them to release the Request at the end of the task._

> _⚠️️️️️️️️️️️ If you are concerned about `downloadedData` causing OOM, you can save it locally in didReceive Data._

#### ResourceLoader
```swift
import AVFoundation
import Foundation

class ResourceLoader: NSObject {
    
    let loaderQueue = DispatchQueue(label: "li.zhgchg.resourceLoader.queue")
    
    private var requests: [AVAssetResourceLoadingRequest: ResourceLoaderRequest] = [:]
    private let cacheKey: String
    private let originalURL: URL
    
    init(asset: CachingAVURLAsset) {
        self.cacheKey = asset.cacheKey
        self.originalURL = asset.originalURL
        super.init()
    }

    deinit {
        self.requests.forEach { (request) in
            request.value.cancel()
        }
    }
}
```

```swift
extension ResourceLoader: AVAssetResourceLoaderDelegate {
    func resourceLoader(_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest: AVAssetResourceLoadingRequest) -> Bool {
        
        let type = ResourceLoader.resourceLoaderRequestType(loadingRequest)
        let assetDataManager = PINCacheAssetDataManager(cacheKey: self.cacheKey)

        if let assetData = assetDataManager.retrieveAssetData() {
            if type == .contentInformation {
                loadingRequest.contentInformationRequest?.contentLength = assetData.contentInformation.contentLength
                loadingRequest.contentInformationRequest?.contentType = assetData.contentInformation.contentType
                loadingRequest.contentInformationRequest?.isByteRangeAccessSupported = assetData.contentInformation.isByteRangeAccessSupported
                loadingRequest.finishLoading()
                return true
            } else {
                let range = ResourceLoader.resourceLoaderRequestRange(type, loadingRequest)
                if assetData.mediaData.count > 0 {
                    let end: Int64
                    switch range.end {
                    case .requestTo(let rangeEnd):
                        end = rangeEnd
                    case .requestToEnd:
                        end = assetData.contentInformation.contentLength
                    }
                    
                    if assetData.mediaData.count >= end {
                        let subData = assetData.mediaData.subdata(in: Int(range.start)..<Int(end))
                        loadingRequest.dataRequest?.respond(with: subData)
                        loadingRequest.finishLoading()
                        return true
                    } else if range.start <= assetData.mediaData.count {
                        // has cache data...but not enough
                        let subEnd = (assetData.mediaData.count > end) ? Int((end)) : (assetData.mediaData.count)
                        let subData = assetData.mediaData.subdata(in: Int(range.start)..<subEnd)
                        loadingRequest.dataRequest?.respond(with: subData)
                    }
                }
            }
        }
        
        let range = ResourceLoader.resourceLoaderRequestRange(type, loadingRequest)
        let resourceLoaderRequest = ResourceLoaderRequest(originalURL: self.originalURL, type: type, loaderQueue: self.loaderQueue, assetDataManager: assetDataManager)
        resourceLoaderRequest.delegate = self
        self.requests[loadingRequest]?.cancel()
        self.requests[loadingRequest] = resourceLoaderRequest
        resourceLoaderRequest.start(requestRange: range)
        
        return true
    }
    
    func resourceLoader(_ resourceLoader: AVAssetResourceLoader, didCancel loadingRequest: AVAssetResourceLoadingRequest) {
        guard let resourceLoaderRequest = self.requests[loadingRequest] else {
            return
        }
        
        resourceLoaderRequest.cancel()
        requests.removeValue(forKey: loadingRequest)
    }
}

extension ResourceLoader: ResourceLoaderRequestDelegate {
    func contentInformationDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ result: Result<AssetDataContentInformation, Error>) {
        guard let loadingRequest = self.requests.first(where: { $0.value == resourceLoaderRequest })?.key else {
            return
        }
        
        switch result {
        case .success(let contentInformation):
            loadingRequest.contentInformationRequest?.contentType = contentInformation.contentType
            loadingRequest.contentInformationRequest?.contentLength = contentInformation.contentLength
            loadingRequest.contentInformationRequest?.isByteRangeAccessSupported = contentInformation.isByteRangeAccessSupported
            loadingRequest.finishLoading()
        case .failure(let error):
            loadingRequest.finishLoading(with: error)
        }
    }
    
    func dataRequestDidReceive(_ resourceLoaderRequest: ResourceLoaderRequest, _ data: Data) {
        guard let loadingRequest = self.requests.first(where: { $0.value == resourceLoaderRequest })?.key else {
            return
        }
        
        loadingRequest.dataRequest?.respond(with: data)
    }
    
    func dataRequestDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ error: Error?, _ downloadedData: Data) {
        guard let loadingRequest = self.requests.first(where: { $0.value == resourceLoaderRequest })?.key else {
            return
        }
        
        loadingRequest.finishLoading(with: error)
        requests.removeValue(forKey: loadingRequest)
    }
}

extension ResourceLoader {
    static func resourceLoaderRequestType(_ loadingRequest: AVAssetResourceLoadingRequest) -> ResourceLoaderRequest.RequestType {
        if let _ = loadingRequest.contentInformationRequest {
            return .contentInformation
        } else {
            return .dataRequest
        }
    }
    
    static func resourceLoaderRequestRange(_ type: ResourceLoaderRequest.RequestType, _ loadingRequest: AVAssetResourceLoadingRequest) -> ResourceLoaderRequest.RequestRange {
        if type == .contentInformation {
            return ResourceLoaderRequest.RequestRange(start: 0, end: .requestTo(1))
        } else {
            if loadingRequest.dataRequest?.requestsAllDataToEndOfResource == true {
                let lowerBound = loadingRequest.dataRequest?.currentOffset ?? 0
                return ResourceLoaderRequest.RequestRange(start: lowerBound, end: .requestToEnd)
            } else {
                let lowerBound = loadingRequest.dataRequest?.currentOffset ?? 0
                let length = Int64(loadingRequest.dataRequest?.requestedLength ?? 1)
                let upperBound = lowerBound + length
                return ResourceLoaderRequest.RequestRange(start: lowerBound, end: .requestTo(upperBound))
            }
        }
    }
}
```

If `loadingRequest.contentInformationRequest` is not nil, it indicates that this is the first request, and the player is asking for file information.

When requesting file information, we need to provide these three pieces of information:
- `loadingRequest.contentInformationRequest?.isByteRangeAccessSupported`: Indicates whether Range access for Data is supported.
- `loadingRequest.contentInformationRequest?.contentType`: The Uniform Resource Identifier (URI).
- `loadingRequest.contentInformationRequest?.contentLength`: The total length of the file as Int64.

You can obtain the starting offset of the requested range using `loadingRequest.dataRequest?.requestedOffset`.

You can obtain the length of the requested range using `loadingRequest.dataRequest?.requestedLength`.

If `loadingRequest.dataRequest?.requestsAllDataToEndOfResource` is true, it means that regardless of the requested range length, the entire resource will be fetched.

`loadingRequest.dataRequest?.respond(with: Data)` returns the loaded Data to the player.

You can get the current data offset using `loadingRequest.dataRequest?.currentOffset`, and after calling `dataRequest?.respond(with: Data)`, the `currentOffset` will be updated accordingly.

`loadingRequest.finishLoading()` indicates that all data has been loaded and informs the player.

```swift
func resourceLoader(_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest: AVAssetResourceLoadingRequest) -> Bool
```

When the player requests data, we first check if there is any data in the local cache. If there is, we return it; if only partial data is available, we return that portion. For example, if we have data from 0–100 in the local cache and the player requests 0–200, we will return 0–100 first.

If there is no local cache or the returned data is insufficient, a ResourceLoaderRequest will be initiated to fetch data from the network.

```swift
func resourceLoader(_ resourceLoader: AVAssetResourceLoader, didCancel loadingRequest: AVAssetResourceLoadingRequest)
```

When the player cancels a request, we cancel the ResourceLoaderRequest.

> _You may have noticed that the offset in `resourceLoaderRequestRange` is based on `currentOffset`, because we will first respond with the already downloaded Data from the local cache using `dataRequest?.respond(with: Data)`; thus, we can directly look at the updated offset._

```swift
func private var requests: [AVAssetResourceLoadingRequest: ResourceLoaderRequest] = [:]
```

> _⚠️ In some examples, requests are stored using only `currentRequest: ResourceLoaderRequest`, which can lead to issues. This is because if the current request is still being processed and the user seeks, it may cancel the old request and initiate a new one. However, since these actions may not occur in order, it is safer to use a Dictionary for storage!_

> _⚠️ Ensure that all operations are performed on the same DispatchQueue to prevent data inconsistencies._

**Cancel all ongoing requests during deinitialization.** The Resource Loader's deinitialization indicates that the AVURLAsset is being deinitialized, meaning the player no longer needs this resource. Therefore, we can cancel any ongoing data requests, while already loaded data will still be written to the cache.

### Supplement and Acknowledgments

Thanks to [Lex Tang](https://medium.com/u/2d01a2439753){:target="_blank"} for the guidance.

Thanks to [my granddaughter](https://medium.com/u/aab116fd9d4d){:target="_blank"} for providing development insights and support.

#### This article only addresses small music files.

Large video files may encounter Out Of Memory issues in downloadedData, AssetData/PINCacheAssetDataManager.

As mentioned earlier, to resolve this issue, please use fileHandler seek read/write to operate local cache reading and writing (instead of AssetData/PINCacheAssetDataManager); or check if there are any GitHub projects available for large data write/read to file.

#### AVQueuePlayer cancels ongoing downloads when switching playback items.

As mentioned in the previous knowledge, when changing playback targets, a Cancel will not be initiated. If it were AVPlayer, it would trigger AVURLAsset deinitialization, thus interrupting the download. However, AVQueuePlayer does not do this, as the items are still in the queue; it merely changes the playback target to the next song.

The only approach here is to listen for notifications of playback target changes and then cancel the previous AVURLAsset loading upon receiving the notification.

```swift
asset.cancelLoading()
```

#### Audio Data Encryption and Decryption

Audio encryption and decryption can be performed within ResourceLoaderRequest when obtaining Data, and when storing, it can be done in AssetData's encode/decode methods for the locally stored Data.

**CryptoKit SHA usage example:**
```swift
class AssetData: NSObject, NSCoding {
    static let encryptionKeyString = "encryptionKeyExzhgchgli"
    ...
    func encode(with coder: NSCoder) {
        coder.encode(self.contentInformation, forKey: #keyPath(AssetData.contentInformation))
        
        if #available(iOS 13.0, *),
           let encryptionData = try? ChaChaPoly.seal(self.mediaData, using: AssetData.encryptionKey).combined {
            coder.encode(encryptionData, forKey: #keyPath(AssetData.mediaData))
        } else {
          //
        }
    }
    
    required init?(coder: NSCoder) {
        super.init()
        ...
        if let mediaData = coder.decodeObject(forKey: #keyPath(AssetData.mediaData)) as? Data {
            if #available(iOS 13.0, *),
               let sealedBox = try? ChaChaPoly.SealedBox(combined: mediaData),
               let decryptedData = try? ChaChaPoly.open(sealedBox, using: AssetData.encryptionKey) {
                self.mediaData = decryptedData
            } else {
              //
            }
        } else {
            //
        }
    }
}
```

#### PINCache Related Operations

PINCache includes PINMemoryCache and PINDiskCache, which handle reading from files to memory or writing from memory to files. We only need to operate on PINCache.

To find the cache file location in the simulator:

![](/assets/6ce488898003/1*dUWZRwGTRhOAuxnqWJBvog.png)

Use `NSHomeDirectory()` to obtain the simulator file path.

![](/assets/6ce488898003/1*qXzny7KAwK20E6ma8zJUnw.png)

In Finder, go to -> paste the path.

![](/assets/6ce488898003/1*IcyAHKsTgaG-xqu1QzQq6Q.png)

In Library -> Caches -> com\.pinterest\.PINDiskCache\.ResourceLoader is the directory we created for the Resource Loader Cache.

`PINCache(name: “ResourceLoader”)` where the name is the directory name.

You can also specify rootPath, allowing the directory to be placed under Documents (to avoid being cleared by the system).

**Setting the maximum limit for PINCache:**
```swift
 PINCacheAssetDataManager.Cache.diskCache.byteCount = 300 * 1024 * 1024 // max: 300mb
 PINCacheAssetDataManager.Cache.diskCache.byteLimit = 90 * 60 * 60 * 24 // 90 days
```

![System default limit](/assets/6ce488898003/1*kjZWSBU__E-2jTYyyjWZEA.png)

The system default limit.

Setting it to 0 means files will not be deleted proactively.

### Postscript

Initially, I underestimated the difficulty of this feature, thinking it could be handled in a few steps; however, I faced many challenges and spent an additional two weeks addressing data storage issues. Nonetheless, I now have a thorough understanding of the entire Resource Loader operation mechanism, GCD, and Data.

### References

Finally, here are some reference materials for researching how to implement this:
1. [Design and Implementation of iOS AVPlayer Video Caching](http://chuquan.me/2019/12/03/ios-avplayer-support-cache/){:target="_blank"} - Discusses the principles only.
2. [Implementing Audio and Video Playback and Caching Based on AVPlayer, Supporting Synchronized Video Output](https://caisanze.com/post/swift-avplayer/){:target="_blank"} \[ [SZAVPlayer](https://github.com/eroscai/SZAVPlayer){:target="_blank"} \] - Includes code (very complete but complex).
3. [CachingPlayerItem](https://github.com/neekeetab/CachingPlayerItem/blob/7d998b8561693cf51077f0891ed240e92bec415e/CachingPlayerItem.swift){:target="_blank"} - A simple implementation that is easier to understand but not complete.
4. [Possibly the Best AVPlayer Audio and Video Caching Solution AVAssetResourceLoaderDelegate](https://www.jianshu.com/p/28157247d6a7){:target="_blank"}.
5. [Swift Version of Douyin](https://sshiqiao.github.io/document/douyin-swift.html#1){:target="_blank"} \[ [Github](https://github.com/sshiqiao/douyin-ios-swift){:target="_blank"} \] - An interesting project that replicates the Douyin app; it also uses Resource Loader.
6. [Exploring iOS HLS Cache Implementation Methods](../d796bf8e661e/)

### Extensions
- [DLCachePlayer](https://github.com/dminoror/DLCachePlayer){:target="_blank"} \(Objective-C version\)

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/avplayer-%E5%AF%A6%E8%B8%90%E6%9C%AC%E5%9C%B0-cache-%E5%8A%9F%E8%83%BD%E5%A4%A7%E5%85%A8-6ce488898003){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```