---
title: "Identifying Your Own Calls (Swift)"
author: "ZhgChgLi"
date: 2019-04-27T16:07:27.133+0000
last_modified_at: 2024-04-13T07:40:07.162+0000
categories: ["ZRealm Dev."]
tags: ["ios","whoscall","swift","ios-app-development","ios-apps"]
description: "iOS self-developed Whoscall call identification and phone number tagging feature"
image:
  path: /assets/ac557047d206/1*MYWY8n6v6YoGs0u5um0RdQ.jpeg
render_with_liquid: false
---

### Identifying Your Own Calls (Swift)

iOS self-developed Whoscall call identification and phone number tagging feature

#### Origin

I have always been a loyal user of Whoscall, having used it since my days with an Android phone. It can display information about unknown calls in real-time, allowing me to decide whether to answer immediately. Later, when I switched to the Apple ecosystem, my first Apple phone was the iPhone 6 (iOS 9). At that time, using Whoscall was quite awkward; it couldn't identify calls in real-time, and I had to copy the phone number to check it in the app. Eventually, Whoscall provided a service to install the unknown call database locally on the phone, which solved the real-time identification issue but could easily mess up your phone's contact list!

It wasn't until iOS 10+ that Apple opened up the Call Directory Extension permission to developers, allowing Whoscall to at least match the Android version in terms of experience, and even surpass it (the Android version has a lot of ads, but from a developer's perspective, it's understandable).

#### What Can It Do?

[Call Directory Extension](https://developer.apple.com/documentation/callkit/cxcalldirectoryextension){:target="_blank"} can achieve the following:
1. Identification tags for **outgoing** calls
2. Identification tags for **incoming** calls
3. Identification tags for **call history**
4. Blacklist settings for **rejected** calls

#### Limitations?
1. Users must manually go to "Settings," "Phone," and "Call Blocking & Identification" to enable your app for it to work.
2. It can only identify calls using an offline database (it cannot obtain real-time incoming call information and then call an API for queries; it can only pre-write the number <-> name correspondence in the phone database).
_*This is why Whoscall periodically pushes notifications asking users to open the app to update the call identification database._
3. Is there a limit on the number? Currently, I haven't found any information; it should depend on the user's phone capacity without a specific limit. However, if there are many entries, the identification list and blacklist need to be processed in batches!
4. Software limitation: iOS version must be ≥ 10

![Settings -> Phone -> Call Blocking & Identification](/assets/ac557047d206/1*MYWY8n6v6YoGs0u5um0RdQ.jpeg)

Settings -> Phone -> Call Blocking & Identification

#### Application Scenarios?
1. Communication software, office communication software; in the app, you may have the contact of the other party, but you haven't actually added their phone number to your phone's contact list. This feature can prevent calls from colleagues or even bosses from being treated as unknown calls, resulting in missed calls.
2. Our site ([Marry](https://www.marry.com.tw){:target="_blank"}) or our private site ([591 Housing Transaction](https://www.591.com.tw/){:target="_blank"}), the phone numbers dialed by users when contacting stores or landlords are all our forwarding numbers, which are routed through a forwarding center to the target phone. The general process is as follows:

![](/assets/ac557047d206/1*BXrzNfimPVPCQ0_XsY5HRg.png)

The phone numbers dialed by users are representative numbers from the forwarding center (#extension), and they will not know the real phone number. On one hand, this protects personal privacy; on the other hand, it allows us to know how many people contact the business (to evaluate effectiveness) and even know where they saw the number before dialing (e.g., the webpage shows #1234, the app shows #5678), and we can also offer free services, absorbing the phone communication costs.

However, this approach brings an unavoidable problem: the phone numbers become chaotic; it is impossible to identify who the call is for or who is calling back from the store. By using the call identification feature, this problem can be greatly resolved, enhancing the user experience!

#### Here’s a finished product image:

![[Marry App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E6%9C%80%E5%A4%A7%E5%A9%9A%E7%A6%AE%E7%B1%8C%E5%82%99app/id1356057329?mt=8){:target="_blank"}](/assets/ac557047d206/1*WEUjz38cymEtywWDvm86vg.jpeg)


[Marriage App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E6%9C%80%E5%A4%A7%E5%A9%9A%E7%A6%AE%E7%B1%8C%E5%82%99app/id1356057329?mt=8){:target="_blank"}

You can see that when entering a phone number or receiving a call, the identification results can be displayed directly, and the call history list will not be cluttered, showing the identification results below.
### Call Directory Extension Functionality Workflow:


![](/assets/ac557047d206/1*f0vCDqocPfZkoPJW7w3vBg.png)

### Let's Get Started:

Let's start working on it!
#### 1\. Add Call Directory Extension to the iOS Project


![Xcode \-&gt; File \-&gt; New \-&gt; Target](/assets/ac557047d206/1*k7RnXKeXW2uZPawkYQfIDg.png)

Xcode \-&gt; File \-&gt; New \-&gt; Target


![Select Call Directory Extension](/assets/ac557047d206/1*w5sK8DfqYOTUTPDJVYFyLg.png)

Select Call Directory Extension


![Enter Extension Name](/assets/ac557047d206/1*EqazaGGWvgLSQa0gQMYF7Q.png)

Enter Extension Name


![Optionally Add Scheme for Debugging](/assets/ac557047d206/1*WklbrBGAppM2leAsCuuKLg.png)

Optionally Add Scheme for Debugging


![The Call Directory Extension folder and program will appear under the directory](/assets/ac557047d206/1*8SfvjnXa2be6C8mdLk3Wwg.png)

The Call Directory Extension folder and program will appear under the directory.
#### 2\. Start Writing Call Directory Extension Related Code

First, return to the main iOS project.

**The first question is how to determine whether the user's device supports Call Directory Extension or if the "Call Blocking & Identification" setting is enabled:**
```swift
import CallKit
//
//......
//
if #available(iOS 10.0, *) {
    CXCallDirectoryManager.sharedInstance.getEnabledStatusForExtension(withIdentifier: "Enter the bundle identifier of the call directory extension here", completionHandler: { (status, error) in
        if status == .enabled {
          //Enabled
        } else if status == .disabled {
          //Disabled
        } else {
          //Unknown, not supported
        }
    })
}
```

**As mentioned earlier, the operation of call identification requires maintaining a local identification database; the next key point is how to achieve this functionality?**

Unfortunately, you cannot directly write data to the Call Directory Extension, so you need to maintain an additional corresponding structure, and then the Call Directory Extension will read your structure and write to the identification database. The process is as follows:


![This means we need to maintain our own database file, and then let the Extension read and write to the phone](/assets/ac557047d206/1*Fn8KAsdfolQ7ADigii9aHA.png)

This means we need to maintain our own database file, and then let the Extension read and write to the phone.

**What should the so-called identification data or file look like?**


> It is essentially a Dictionary structure, such as: \[“Phone”:”Mr. Wang”\] 





> The local file can use some Local DB (but it must also be installable and usable on the Extension); here we directly store a .json file on the phone; **it is not recommended to store directly in UserDefaults. If it is for testing or if the data is very small, it is acceptable, but for actual applications, it is strongly discouraged!** 





**Alright, let's get started:**
```swift
if #available(iOS 10.0, *) {
    if let dir = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "Your cross Extension, Group Identifier name") {
        let fileURL = dir.appendingPathComponent("phoneIdentity.json")
        var datas:[String:String] = ["8869190001234":"Mr. Li","886912002456":"The Great General"]
        if let content = try? String(contentsOf: fileURL, encoding: .utf8),let text = content.data(using: .utf8),let json2 = try? JSONSerialization.jsonObject(with: text, options: .mutableContainers) as? Dictionary<String,String>,let json = json2 {
            datas = json
        }
        if let data = jsonToData(jsonDic: datas) {
            DispatchQueue(label: "phoneIdentity").async {
                if let _ = try? data.write(to: fileURL) {
                    //Completed writing json file
                }
            }
        }
    }
}
```


It is just general local file maintenance, and the directory needs to be in a location that can be read by the Extension.
#### Supplement — Phone Number Format:
1. For landlines and mobile phones in Taiwan, remove the 0 and replace it with 886: e.g., 0255667788 -> 886255667788
2. The phone format should be a string of pure numeric combinations, without mixing in symbols like “-”, “,”, “#”, etc.
3. If a landline phone includes an **extension**, it should be directly attached without any symbols: e.g., 0255667788,0718 -> 8862556677880718
4. To convert a standard iOS phone format into a format acceptable by the recognition database, refer to the following two replacement methods:

```swift
var newNumber = "0255667788,0718"
if let regex = try? NSRegularExpression(pattern: "^0{1}") {
    newNumber = regex.stringByReplacingMatches(in: newNumber, options: [], range: NSRange(location: 0, length: newNumber.count), withTemplate: "886")
}
if let regex = try? NSRegularExpression(pattern: ",") {
    newNumber = regex.stringByReplacingMatches(in: newNumber, options: [], range: NSRange(location: 0, length: newNumber.count), withTemplate: "")
}
```

Next, as per the process, once the recognition data has been maintained, it is necessary to notify the Call Directory Extension to refresh the data on the phone:
```swift
if #available(iOS 10.0, *) {
    CXCallDirectoryManager.sharedInstance.reloadExtension(withIdentifier: "tw.com.marry.MarryiOS.CallDirectory") { errorOrNil in
        if let error = errorOrNil as? CXErrorCodeCallDirectoryManagerError {
            print("reload failed")
            
            switch error.code {
            case .unknown:
                print("error is unknown")
            case .noExtensionFound:
                print("error is noExtensionFound")
            case .loadingInterrupted:
                print("error is loadingInterrupted")
            case .entriesOutOfOrder:
                print("error is entriesOutOfOrder")
            case .duplicateEntries:
                print("error is duplicateEntries")
            case .maximumEntriesExceeded:
                print("maximumEntriesExceeded")
            case .extensionDisabled:
                print("extensionDisabled")
            case .currentlyLoading:
                print("currentlyLoading")
            case .unexpectedIncrementalRemoval:
                print("unexpectedIncrementalRemoval")
            }
        } else if let error = errorOrNil {
            print("reload error: \(error)")
        } else {
            print("reload succeeded")
        }
    }
}
```

```markdown
Use the above method to notify the Extension to refresh and obtain the execution result. (At this point, it will call the beginRequest in the Call Directory Extension, please continue reading)

The main iOS project's code ends here!
#### 3. Start modifying the Call Directory Extension code

Open the Call Directory Extension directory and find the already created file CallDirectoryHandler.swift

The only method that can be implemented is **beginRequest**, which handles the action of processing mobile phone data. The default example has already set this up for us, so there is not much need to modify it:
1. **addAllBlockingPhoneNumbers**: Handles adding numbers to the blacklist (full addition)
2. **addOrRemoveIncrementalBlockingPhoneNumbers**: Handles adding numbers to the blacklist (incremental method)
3. **addAllIdentificationPhoneNumbers**: Handles adding caller identification numbers (full addition)
4. **addOrRemoveIncrementalIdentificationPhoneNumbers**: Handles adding caller identification numbers (incremental method)

We only need to complete the implementation of the above functions. The principles of the blacklist function and caller identification method are the same, so I won't elaborate further here.
```swift
private func fetchAll(context: CXCallDirectoryExtensionContext) {
    if let dir = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "Your cross-Extension, Group Identifier name") {
        let fileURL = dir.appendingPathComponent("phoneIdentity.json")
        if let content = try? String(contentsOf: fileURL, encoding: .utf8), let text = content.data(using: .utf8), let numbers = try? JSONSerialization.jsonObject(with: text, options: .mutableContainers) as? Dictionary<String,String> {
            numbers?.sorted(by: { (Int($0.key) ?? 0) < Int($1.key) ?? 0 }).forEach({ (obj) in
                if let number = CXCallDirectoryPhoneNumber(obj.key) {
                    autoreleasepool {
                        if context.isIncremental {
                            context.removeIdentificationEntry(withPhoneNumber: number)
                        }
                        context.addIdentificationEntry(withNextSequentialPhoneNumber: number, label: obj.value)
                    }
                }
            })
        }
    }
}

private func addAllIdentificationPhoneNumbers(to context: CXCallDirectoryExtensionContext) {
    // Retrieve phone numbers to identify and their identification labels from data store. For optimal performance and memory usage when there are many phone numbers,
    // consider only loading a subset of numbers at a given time and using autorelease pool(s) to release objects allocated during each batch of numbers which are loaded.
    //
    // Numbers must be provided in numerically ascending order.
    //        let allPhoneNumbers: [CXCallDirectoryPhoneNumber] = [ 1_877_555_5555, 1_888_555_5555 ]
    //        let labels = [ "Telemarketer", "Local business" ]
    //
    //        for (phoneNumber, label) in zip(allPhoneNumbers, labels) {
    //            context.addIdentificationEntry(withNextSequentialPhoneNumber: phoneNumber, label: label)
    //        }
    fetchAll(context: context)
}

private func addOrRemoveIncrementalIdentificationPhoneNumbers(to context: CXCallDirectoryExtensionContext) {
    // Retrieve any changes to the set of phone numbers to identify (and their identification labels) from data store. For optimal performance and memory usage when there are many phone numbers,
    // consider only loading a subset of numbers at a given time and using autorelease pool(s) to release objects allocated during each batch of numbers which are loaded.
    //        let phoneNumbersToAdd: [CXCallDirectoryPhoneNumber] = [ 1_408_555_5678 ]
    //        let labelsToAdd = [ "New local business" ]
    //
    //        for (phoneNumber, label) in zip(phoneNumbersToAdd, labelsToAdd) {
    //            context.addIdentificationEntry(withNextSequentialPhoneNumber: phoneNumber, label: label)
    //        }
    //
    //        let phoneNumbersToRemove: [CXCallDirectoryPhoneNumber] = [ 1_888_555_5555 ]
    //
    //        for phoneNumber in phoneNumbersToRemove {
    //            context.removeIdentificationEntry(withPhoneNumber: phoneNumber)
    //        }
    
    //context.removeIdentificationEntry(withPhoneNumber: CXCallDirectoryPhoneNumber("886277283610")!)
    //context.addIdentificationEntry(withNextSequentialPhoneNumber: CXCallDirectoryPhoneNumber("886277283610")!, label: "TEST")
    
    fetchAll(context: context)
    // Record the most-recently loaded set of identification entries in data store for the next incremental load...
}
```


Due to the limited amount of data on our site and the simplicity of my local data structure, it cannot be incremental; therefore, we **uniformly use a full addition method. If an incremental method is used, the old data must be deleted first (this step is very important, otherwise the reload extension will fail!)**
#### Completed!

That's it! The implementation is very simple!
### Tips:
1. If the app keeps loading when opening under "Settings," "Phone," "Call Blocking & Identification," or cannot recognize numbers after opening, please first check if the number is correct, if the locally maintained .json data is correct, and if the reload extension was successful; or try restarting the device. If you still can't find the issue, you can select the call directory extension's Scheme Build to check for error messages.
2. The **most challenging aspect of this feature is not the programming but guiding the user to manually enable it**. For specific methods and guidance, you can refer to Whoscall:



![[Whoscall](https://whoscall.com/zh-TW/){:target="_blank"}](/assets/ac557047d206/1*L0EKptoSnE88lB8uEN7H3A.jpeg)

[Whoscall](https://whoscall.com/zh-TW/){:target="_blank"}


If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.



_[Post](https://medium.com/zrealm-ios-dev/%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9B%BB%E8%A9%B1%E8%87%AA%E5%B7%B1%E8%BE%A8%E8%AD%98-swift-ac557047d206){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
