---
title: "POC App End-to-End Testing Local Snapshot API Mock Server"
author: "ZhgChgLi"
date: 2023-08-28T14:53:27.813+0000
last_modified_at: 2023-09-04T14:32:47.020+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","end-to-end-testing","ui-testing","automation-testing","ios"]
description: "Verification of the feasibility of implementing E2E Testing for existing apps and current API architecture"
image:
  path: /assets/5a5c4b25a83d/1*L-FE2o3LRQQZSLZQx96urw.jpeg
render_with_liquid: false
---

### \[POC\] App End\-to\-End Testing Local Snapshot API Mock Server

Verification of the feasibility of implementing E2E Testing for existing apps and current API architecture



![Photo by [freestocks](https://unsplash.com/@freestocks?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/5a5c4b25a83d/1*L-FE2o3LRQQZSLZQx96urw.jpeg)

Photo by [freestocks](https://unsplash.com/@freestocks?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Introduction

As a project that has been operating online for many years, continuously improving stability is a significant challenge.
#### Unit Testing


![](/assets/5a5c4b25a83d/1*QAuldnLTydk33IgAdkXR-w.png)


Due to the development languages Swift/Kotlin being static + compiled + strongly typed, or the dynamic-to-static transition from Objective-C to Swift, the interfaces were not designed with testability in mind during development. This makes it nearly impossible to add Unit Testing later; however, the refactoring process can also introduce instability, leading to a chicken-and-egg problem.
#### UI Testing

For UI interactions and button testing; slight decoupling of data dependencies for new or existing screens can achieve this.
#### Snapshot Testing

Validating whether the UI display content and styles are consistent before and after adjustments; similar to UI Testing, slight decoupling of data dependencies for new or existing screens can achieve this.

This is particularly useful when converting Storyboard/XIB to Code Layout or UIView from OC to Swift; you can quickly implement it by importing [pointfreeco](https://github.com/pointfreeco){:target="_blank"} / [swift\-snapshot\-testing](https://github.com/pointfreeco/swift-snapshot-testing){:target="_blank"}.


[![](https://opengraph.githubassets.com/b3cc52a5b949767e4cb0af82145ed6474334d3235bd785ee1f7891c6b65fd69a/pointfreeco/swift-snapshot-testing)](https://github.com/pointfreeco/swift-snapshot-testing){:target="_blank"}


Although we can later add UI Testing and Snapshot Testing, the coverage of tests is quite limited; most errors are not UI style-related but rather process or logic issues, which can interrupt user operations. **If this occurs during the checkout process, it involves revenue, making the issue quite serious.**
### End\-to\-End Testing

As mentioned earlier, it is not easy to add unit tests to the current project, nor can we consolidate units for integration testing. For protecting logic and processes, we are left with the method of conducting End\-to\-End black-box testing from an external perspective, checking important processes (registration/checkout, etc.) to see if they function correctly.


> For significant feature refactoring, we can first establish process tests before refactoring, then re-validate afterward to ensure the functionality works as expected. 





> During refactoring, we can also add Unit Testing and Integration Testing to increase stability, breaking the chicken-and-egg problem. 



#### QA Team

The most straightforward and brute-force method for End\-to\-End Testing is to have a QA Team manually test according to a Test Plan, then continuously optimize or introduce automation; after calculating the costs, it would require at least 2 engineers + 1 leader spending at least half a year to a year to see results.

Considering time and costs, is there anything we can do in the current situation or prepare for the future QA Team so that when a QA Team is available, they can directly jump to optimization and automation, or even introduce AI(?).
#### Automation

Currently, the goal is to introduce automated End\-to\-End Testing, placing it in the CI/CD process for automatic checks. The test content does not need to be too comprehensive; as long as it can prevent major process issues, it is already very valuable. We can gradually iterate the Test Plan to fill in the coverage.
### End\-to\-End Testing — Technical Challenges
#### UI Operation Issues

The principle of the app is more like using another testing app to operate our tested app, then searching for target objects from the View Hierarchy; during testing, we cannot obtain the logs or outputs of the tested app because, essentially, they are two different apps.

iOS requires a complete View Accessibility Identifier to increase efficiency and accuracy, and we also need to handle Alerts (e.g., push requests).

In previous implementations on Android, there were issues finding target objects when mixing Compose and Fragment, but according to a teammate, the new version of Compose has resolved this.

In addition to the traditional common issues, a larger problem is the difficulty of integrating across platforms (writing one test to run on two platforms); currently, we are trying to use new testing tools [mobile\-dev\-inc](https://github.com/mobile-dev-inc){:target="_blank"} / [maestro](https://github.com/mobile-dev-inc/maestro){:target="_blank"}:


[![](https://opengraph.githubassets.com/d9e6bc8b1cb6b3db5f52dd9bfa04fe2661ed172d7be82155b8f3e4b6c874f821/mobile-dev-inc/maestro)](https://github.com/mobile-dev-inc/maestro){:target="_blank"}


You can write a Test Plan in YAML and execute tests across both platforms. Details on usage and trial experiences are pending another teammate's article share cc’ed [Alejandra Ts\.](https://medium.com/u/1139df7a27f3){:target="_blank"} 😝.
#### API Data Issues

The biggest variable in App E2E Testing is the API data. If we cannot provide guaranteed and certain data, it will increase the instability of the tests, leading to false reports, and ultimately, everyone will lose confidence in the Test Plan.

For example, in testing the checkout process, if products can potentially be removed or disappear, and these status changes are not controllable by the app, the above situation is very likely to occur.

There are many ways to solve data issues, such as establishing a clean Staging or Testing environment, or creating an Auto-Gen Mock API Server based on Open API; however, these all rely on the backend and external factors of the API. Additionally, the backend API, like the app, has been operating online for many years, and some specifications are still undergoing refactoring and migration, making it temporarily impossible to have a Mock Server.

Given these factors, if we get stuck here, the problem will remain unchanged, and the chicken-and-egg problem cannot be broken through. We may have to "take the risk" and directly make changes, addressing issues as they arise.
#### Snapshot API Local Mock Server


> "As long as the mindset doesn't decline, there are always more methods than difficulties." 




We can change our perspective: if the UI can use Snapshot to capture images for replay and verification testing, can we do the same for APIs? Can we save API Requests & Responses and then replay them for verification testing?

**This introduces the main point of this article: establishing a "Snapshot API Local Mock Server" to Record API Requests & Replay Responses, decoupling from API data dependencies.**


> This article only serves as a POC conceptual verification and has not yet fully implemented high-coverage End To End Testing, so the methods provided are for reference only. **I hope this inspires everyone in the current environment.** 




### Snapshot API Local Mock Server
#### Core Concept — Record & Replay API Data

**\[Record\]** — After completing the End\-to\-End Testing Test Case development, open the recording parameters, execute a test once, and all API Requests & Responses during the process will be saved in each Test Case directory.

**\[Replay\]** — Later, when running Test Cases, find the corresponding recorded Response Data from the Test Case directory based on the request to complete the testing process.
#### Diagram

Assuming we want to test the purchase process, the user opens the app, clicks on a product card on the homepage to enter the product detail page, presses the purchase button at the bottom, a login box pops up to complete the login, completes the purchase, and a purchase success prompt appears:


![](/assets/5a5c4b25a83d/1*VtCOkH7iply6RQPs9zxJrw.png)


How UI Testing controls button clicks, input box entries, etc., is not the main focus of this article; you can refer to existing testing frameworks for direct use.
#### Regular Proxy or Reverse Proxy

To achieve Record & Replay API, a Proxy needs to be added between the App and API to act as a middleman. You can refer to my earlier article "[APP uses HTTPS transmission, but data is still stolen.](../46410aaada00/)"

In simple terms, a proxy acts as a messenger between the App and API, similar to passing notes; all requests and responses exchanged between both parties will go through it. It can open the content of the notes and can also forge the content to give to each party without them noticing.

**Forward Proxy:**

A forward proxy is when the client sends a request to the proxy server, which then forwards the request to the target server and returns the target server's response to the client. In forward proxy mode, the proxy server acts on behalf of the client to initiate requests. The client needs to specify the address and port of the proxy server and send requests to it.

**Reverse Proxy:**

A reverse proxy is the opposite of a forward proxy; it sits between the target server and the client. The client sends requests to the reverse proxy server, which forwards the requests to the backend target server based on certain rules and returns the target server's response to the client. For the client, the target server appears to be the reverse proxy server, and the client does not need to know the real address of the target server.

For our needs, either forward or reverse can achieve the goal; the only consideration is how to set up the proxy:

**Forward Proxy requires setting the Proxy in the network settings of the computer or mobile device/emulator:**
- Android can individually set the Proxy in the emulator.
- iOS Simulator shares the computer's network environment and cannot set the Proxy individually, meaning you have to change the computer's settings to set up the Proxy. All traffic from the computer will also go through this Proxy, and if other network tools like Proxyman or Charles are opened simultaneously, they may force change the Proxy settings to that software, causing it to fail.


**Reverse Proxy requires modifying the API Host in the Codebase and declaring all API Domains to be proxied:**
- The API Host in the Codebase needs to be replaced with the Proxy Server IP during testing.
- When enabling Reverse Proxy, you need to declare which Domains should use the Proxy.
- Only the declared Domains will go through the Proxy; undeclared ones will go straight out.



> In conjunction with the iOS App, the following example uses iOS & Reverse Proxy for the POC, and Android can use it as well. 




#### Letting the iOS App Know It Is Running End\-to\-End Testing

We need to let the App know that it is currently running End\-to\-End Testing so that we can add API Host replacement logic in the App code:
```swift
// UI Testing Target:
let app = XCUIApplication()
app.launchArguments = ["duringE2ETesting"]
app.launch()
```

We make judgments and substitutions in the Network layer.


> This is an unavoidable adjustment; we should try not to change the App's Code just for testing. 




### Using MITMProxy to Implement Reverse Proxy Server


> You can also develop a Swift Server to achieve this; this article is just a POC, so we directly use the MITMProxy tool. 




#### \[2023–09–04 Update\] Mitmproxy\-rodo is now open source

The implementation details have been open-sourced to [mitmproxy\-rodo](https://github.com/ZhgChgLi/mitmproxy-rodo/tree/main){:target="_blank"}, feel free to check it out for reference.


[![](https://repository-images.githubusercontent.com/686628812/44cf2ec7-4de1-4a10-b213-bf7dd30748a4)](https://github.com/ZhgChgLi/mitmproxy-rodo/tree/main){:target="_blank"}


Some structures have been adjusted from this article's content during the open-sourcing:
- The storage directory structure has been changed to `host / requestPath / method / hash`
- Fixed Header information storage; it should be Bytes Data rather than pure JSON String
- Corrected some errors
- Added automatic extension of Set\-Cookie validity feature



> **⚠️ The following scripts are for demo reference only; subsequent script adjustments will be maintained in the open-source project.** 
 

> **⚠️ The following scripts are for demo reference only; subsequent script adjustments will be maintained in the open-source project.** 
 

> **⚠️ The following scripts are for demo reference only; subsequent script adjustments will be maintained in the open-source project.** 
 

> **⚠️ The following scripts are for demo reference only; subsequent script adjustments will be maintained in the open-source project.** 
 

> **⚠️ The following scripts are for demo reference only; subsequent script adjustments will be maintained in the open-source project.** 




#### [MITMProxy](https://mitmproxy.org){:target="_blank"}

Follow the instructions on the [MITMProxy official website](https://mitmproxy.org){:target="_blank"} to complete the installation:
```bash
brew install mitmproxy
```

For detailed usage of MITMProxy, you can refer to my earlier article "[APP uses HTTPS transmission, but data is still stolen.](../46410aaada00/)":
- `mitmproxy` provides an interactive command-line interface.
- `mitmweb` offers a browser-based graphical user interface.
- `mitmdump` provides non-interactive terminal output.

#### Implementing Record & Replay

Since MITMProxy Reverse Proxy does not natively have the functionality to Record (or dump) requests & Mapping Request Replay, we need to write our own script to implement this functionality.

`mock.py` :
```python
"""
Example:
    Record: mitmdump -m reverse:https://yourapihost.com -s mock.py --set record=true --set dumper_folder=loginFlow --set config_file=config.json
    Replay: mitmdump -m reverse:https://yourapihost.com -s mock.py --set dumper_folder=loginFlow --set config_file=config.json
"""

import re
import logging
import mimetypes
import os
import json
import hashlib

from pathlib import Path
from mitmproxy import ctx
from mitmproxy import http

class MockServerHandler:

    def load(self, loader):
        self.readHistory = {}
        self.configuration = {}

        loader.add_option(
            name="dumper_folder",
            typespec=str,
            default="dump",
            help="Response Dump directory, can be established by Test Case Name.",
        )

        loader.add_option(
            name="network_restricted",
            typespec=bool,
            default=True,
            help="If there is no Mapping data locally... setting true will return 404, false will make real requests to get data.",
        )

        loader.add_option(
            name="record",
            typespec=bool,
            default=False,
            help="Set true to record Request's Response.",
        )
```

```python
loader.add_option(
    name="config_file",
    typespec=str,
    default="",
    help="Path to the configuration file, example file is below",
)

def configure(self, updated):
    self.loadConfig()

def loadConfig(self):
    configFile = Path(ctx.options.config_file)
    if ctx.options.config_file == "" or not configFile.exists():
        return

    self.configuration = json.loads(open(configFile, "r").read())

def hash(self, request):
    query = request.query
    requestPath = "-".join(request.path_components)

    ignoredQueryParameterByPaths = self.configuration.get("ignored", {}).get("paths", {}).get(request.host, {}).get(requestPath, {}).get(request.method, {}).get("queryParamters", [])
    ignoredQueryParameterGlobal = self.configuration.get("ignored", {}).get("global", {}).get("queryParamters", [])

    filteredQuery = []
    if query:
        filteredQuery = [(key, value) for key, value in query.items() if key not in ignoredQueryParameterByPaths + ignoredQueryParameterGlobal]
    
    formData = []
    if request.get_content() is not None and request.get_content() != b'':
        formData = json.loads(request.get_content())
    
    # or just formData = request.urlencoded_form
    # or just formData = request.multipart_form
    # depends on your api design

    ignoredFormDataParametersByPaths = self.configuration.get("ignored", {}).get("paths", {}).get(request.host, {}).get(requestPath, {}).get(request.method, {}).get("formDataParameters", [])
    ignoredFormDataParametersGlobal = self.configuration.get("ignored", {}).get("global", {}).get("formDataParameters", [])

    filteredFormData = []
    if formData:
        filteredFormData = [(key, value) for key, value in formData.items() if key not in ignoredFormDataParametersByPaths + ignoredFormDataParametersGlobal]
    
    # Serialize the dictionary to a JSON string
    hashData = {"query":sorted(filteredQuery), "form": sorted(filteredFormData)}
    json_str = json.dumps(hashData, sort_keys=True)

    # Apply SHA-256 hash function
    hash_object = hashlib.sha256(json_str.encode())
    hash_string = hash_object.hexdigest()
    
    return hash_string

def readFromFile(self, request):
    host = request.host
    method = request.method
    hash = self.hash(request)
    requestPath = "-".join(request.path_components)

    folder = Path(ctx.options.dumper_folder) / host / method / requestPath / hash

    if not folder.exists():
        return None

    content_type = request.headers.get("content-type", "").split(";")[0]
    ext = mimetypes.guess_extension(content_type) or ".json"

    count = self.readHistory.get(host, {}).get(method, {}).get(requestPath, {}) or 0

    filepath = folder / f"Content-{str(count)}{ext}"

    while not filepath.exists() and count > 0:
        count = count - 1
        filepath = folder / f"Content-{str(count)}{ext}"

    if self.readHistory.get(host) is None:
        self.readHistory[host] = {}
    if self.readHistory.get(host).get(method) is None:
        self.readHistory[host][method] = {}
    if self.readHistory.get(host).get(method).get(requestPath) is None:
        self.readHistory[host][method][requestPath] = {}

    if filepath.exists():
        headerFilePath = folder / f"Header-{str(count)}.json"
        if not headerFilePath.exists():
            headerFilePath = None
        
        count += 1
        self.readHistory[host][method][requestPath] = count

        return {"content": filepath, "header": headerFilePath}
    else:
        return None

def saveToFile(self, request, response):
    host = request.host
    method = request.method
    hash = self.hash(request)
    requestPath = "-".join(request.path_components)

    iterable = self.configuration.get("ignored", {}).get("paths", {}).get(request.host, {}).get(requestPath, {}).get(request.method, {}).get("iterable", False)
    
    folder = Path(ctx.options.dumper_folder) / host / method / requestPath / hash

    # create dir if not exists
    if not folder.exists():
        os.makedirs(folder)

    content_type = response.headers.get("content-type", "").split(";")[0]
    ext = mimetypes.guess_extension(content_type) or ".json"

    repeatNumber = 0
    filepath = folder / f"Content-{str(repeatNumber)}{ext}"
    while filepath.exists() and iterable == False:
        repeatNumber += 1
        filepath = folder / f"Content-{str(repeatNumber)}{ext}"
    
    # dump to file
    with open(filepath, "wb") as f:
        f.write(response.content or b'')
        
    headerFilepath = folder / f"Header-{str(repeatNumber)}.json"
    with open(headerFilepath, "wb") as f:
        responseDict = dict(response.headers.items())
        responseDict['_status_code'] = response.status_code
        f.write(json.dumps(responseDict).encode('utf-8'))

    return {"content": filepath, "header": headerFilepath}

def request(self, flow):
    if ctx.options.record != True:
        host = flow.request.host
        path = flow.request.path

        result = self.readFromFile(flow.request)
        if result is not None:
            content = b''
            headers = {}
            statusCode = 200

            if result.get('content') is not None:
                content = open(result['content'], "r").read()

            if result.get('header') is not None:
                headers = json.loads(open(result['header'], "r").read())
                statusCode = headers['_status_code']
                del headers['_status_code']

            headers['_responseFromMitmproxy'] = '1'
            flow.response = http.Response.make(statusCode, content, headers)
            logging.info("Fulfill response from local with "+str(result['content']))
            return

        if ctx.options.network_restricted == True:
            flow.response = http.Response.make(404, b'', {'_responseFromMitmproxy': '1'})
    
def response(self, flow):
    if ctx.options.record == True and flow.response.headers.get('_responseFromMitmproxy') != '1':
        result = self.saveToFile(flow.request, flow.response)
        logging.info("Save response to local with "+str(result['content']))

addons = [MockServerHandler()]
```

You can refer to the [official documentation](https://docs.mitmproxy.org/stable/api/events.html){:target="_blank"} to adjust the script content as needed.

**The logic of this script is designed as follows:**
- File path logic: `dumper_folder(a.k.a Test Case Name)` / `Reverse's api host` / `HTTP Method` / `Path joined with -` \(e\.g\. `app/launch` \-&gt; `app-launch` \) / `Hash(Get Query & Post Content)` /
- File logic: Response content: `Content-0.xxx`, `Content-1.xxx` \(for the second request of the same request\)… and so on; Response header information: `Header-0.json` \(same logic as `Content-x`\)

![](/assets/5a5c4b25a83d/1*Lud_shSJYv4LSUfpfALGFA.png)

- When saving, it will store sequentially according to the path and file logic; during Replay, it will also retrieve in the same order.
- If the counts do not match, for example, if the same path is called 3 times during Replay, but the recorded data only saved up to the 2nd time; it will still respond with the 2nd time, which is the last result.
- When `record` is set to `True`, it will call the target server to obtain a response and save it according to the above logic; when `False`, it will only read data from the local (equivalent to Replay Mode).
- When `network_restricted` is set to `False`, if there is no mapping data locally, it will directly respond with `404`; when set to `True`, it will call the target server to get data.
- `_responseFromMitmproxy` is used to indicate that the current response comes from Local, which can be ignored, and `_status_code` is borrowed to store the HTTP Response status code in the Header.json field.

`config_file.json` **file logic design is as follows:**
```json
{
  "ignored": {
    "paths": {
      "yourapihost.com": {
        "add-to-cart": {
          "POST": {
            "queryParamters": [
              "created_timestamp"
            ],
            "formDataParameters": []
          }
        },
        "api-status-checker": {
          "GET": {
            "iterable": true
          }
        }
      }
    },
    "global": {
      "queryParamters": [
        "timestamp"
      ],
      "formDataParameters": []
    }
  }
}
```

`queryParamters` **& `formDataParameters`:**

Since some API parameters may change with each call, for example, some endpoints may include a timestamp parameter, the value of `Hash(Query Parameter & Body Content)` will differ during Replay Requests, resulting in no mapping to the Local Response. Therefore, a `config.json` was created to handle this situation, allowing you to set certain parameters to be excluded from the Hash by Endpoint Path or Globally, achieving the same mapping results.

`iterable` **:**

Since some polling check APIs may be called repeatedly at regular intervals, the server's design will produce many `Content-x.xxx` & `Header-x.json` files; however, if we do not care, we can set it to `True`, and the response will continuously save and overwrite to `Content-0.xxx` & `Header-0.json`, the first file.

**To enable Reverse Proxy Record Mode:**
```bash
mitmdump -m reverse:https://yourapihost.com -s mock.py --set record=true --set dumper_folder=loginFlow --set config_file=config.json
```

**To enable Reverse Proxy Replay Mode:**
```bash
mitmdump -m reverse:https://yourapihost.com -s mock.py --set dumper_folder=loginFlow --set config_file=config.json
```
### Assembly & Proof Of Concept
#### 0\. Complete the replacement of Host in the Codebase

And confirm that during testing, the API has been changed to `http://127.0.0.1:8080`
#### 1\. Start Snapshot API Local Mock Server (a.k.a Reverse Proxy Server) Record Mode
```bash
mitmdump -m reverse:https://yourapihost.com -s mock.py --set record=true --set dumper_folder=addCart --set config_file=config.json
```
#### 2\. Execute E2E Testing UI Operations

Using the [Pinkoi iOS App](https://apps.apple.com/tw/app/pinkoi-%E4%BA%9E%E6%B4%B2%E9%A0%98%E5%85%88%E8%B7%A8%E5%A2%83%E8%A8%AD%E8%A8%88%E8%B3%BC%E7%89%A9%E7%B6%B2%E7%AB%99/id557252416){:target="_blank"} as an example, test the following flow:

> Launch App \-&gt; Home \-&gt; Scroll Down \-&gt; Similar to Wish List Items Section \-&gt; First Product \-&gt; Click First Product \-&gt; Enter Product Page \-&gt; Click Add to Cart \-&gt; UI Response Added to Cart \-&gt; Test Successful ✅ 

![](/assets/5a5c4b25a83d/1*aLaMSaG-DFWzYy9RcwCfag.png)

The UI automation operation method was mentioned earlier; here we manually test the same flow to verify the results.
#### 3\. Obtain Record Results

After completing the operation, you can press `^ + C` to terminate the Snapshot API Mock Server and check the recording results in the file directory:

![](/assets/5a5c4b25a83d/1*YO957r5CGMOlsPrm26GbcA.png)

#### 4\. Replay to verify the same flow, start the Server & Use Replay Mode
```bash
mitmdump -m reverse:https://yourapihost.com -s mock.py --set dumper_folder=addCart --set config_file=config.json
```
#### 5\. Execute the previous UI operation again to verify the results

![](/assets/5a5c4b25a83d/1*70qzxOiM9uJVcvyhKdosVg.png)

- Left: Test Successful ✅
- Right: Testing by clicking on a product not recorded will result in an Error (since there is no local data + `network_restricted` is set to `False`, it directly returns 404 without fetching data from the network)

#### 6\. Proof Of Concept ✅

The proof of concept is successful; we can indeed implement a Reverse Proxy Server to store API Requests & Responses and serve as a Mock API Server to respond with data to the App during testing 🎉🎉🎉.
### \[2023–09–04\] mitmproxy-rodo has been open-sourced

[![](https://repository-images.githubusercontent.com/686628812/44cf2ec7-4de1-4a10-b213-bf7dd30748a4)](https://github.com/ZhgChgLi/mitmproxy-rodo/tree/main){:target="_blank"}

### Follow-up and Notes

This article only explores the proof of concept; there are still many areas to fill in and more features to implement.
1. Integration with the [maestro](https://github.com/mobile-dev-inc/maestro){:target="_blank"} UI Testing tool
2. CI/CD process integration design (how to automatically start Reverse Proxy? Where to start?)
3. How to package MITMProxy within development tools?
4. Validate more complex testing scenarios
5. **Verify the sent Tracking Requests, needing to implement storing Request Body, then retrieve which Tracking Event Data was sent and whether it conforms to the expected process**

#### Cookie Issues
```python
#...
def response(self, flow):
    setCookies = flow.response.headers.get_all("set-cookie")
    # setCookies = ['ad=0; Domain=.xxx.com; expires=Wed, 23 Aug 2023 04:59:07 GMT; Max-Age=1800; Path=/', 'sessionid=xxxx; Secure; HttpOnly; Domain=.xxx.com; expires=Wed, 23 Aug 2023 04:59:07 GMT; Max-Age=1800; Path=/']
    
    # OR Replace Cookie Domain From .xxx.com To 127.0.0.1
    setCookies = [re.sub(r"\s*\.xxx\.com\s*", "127.0.0.1", s) for s in setCookies]

    # AND Remove security-related restrictions
    setCookies = [re.sub(r";\s*Secure\s*", "", s) for s in setCookies]
    setCookies = [re.sub(r";\s*HttpOnly;\s*", "", s) for s in setCookies]

    flow.response.headers.set_all("Set-Cookie", setCookies)

    #...
```

If you encounter issues with cookies, such as the API responding with cookies but the App not receiving them, you can refer to the adjustments above.
#### In the last article at Pinkoi

During my 900+ days at Pinkoi, I realized many of my career aspirations in iOS/App development and processes. I am grateful to all my teammates for walking through the pandemic and weathering the storms together; the courage to say goodbye is akin to the courage I had when pursuing my dream job.

> [**I am now seeking new life challenges (including but not limited to engineering); if you have suitable opportunities (iOS or engineering management or startup products), please feel free to contact me.**](http://resume.zhgchg.li/){:target="_blank"} 🙏🙏🙏 

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/poc-app-end-to-end-testing-local-snapshot-api-mock-server-5a5c4b25a83d){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```