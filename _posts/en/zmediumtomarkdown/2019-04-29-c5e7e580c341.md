---
title: "Perfect Practices for One-Time Offers or Trials in iOS (Swift)"
author: "ZhgChgLi"
date: 2019-04-29T15:30:01.510+0000
last_modified_at: 2024-04-13T07:43:24.841+0000
categories: ["ZRealm Dev."]
tags: ["ios","ios-app-development","ios-11","swift","mobile-app-development"]
description: "iOS DeviceCheck follows you to the ends of the earth"
image:
  path: /assets/c5e7e580c341/1*yXSqoDouuL4Jl2sM49iLHA.png
render_with_liquid: false
---

### Perfect Practices for One-Time Offers or Trials in iOS \(Swift\)

iOS DeviceCheck follows you to the ends of the earth


While writing the previous [Call Directory Extension](../ac557047d206/), I accidentally discovered this obscure API. Although it is no longer a novelty (announced at WWDC 2017 / iOS ≥11 support), and the implementation is quite simple, I still did a little research and testing and organized this article as a record.
### What Can DeviceCheck Do?


> **Allows developers to identify and tag users' devices** 

Since iOS ≥ 6, developers have been unable to obtain a unique identifier (UUID) for users' devices. A compromise is to use IDFV combined with KeyChain (for details, refer to the previous [article](../a4bc3bce7513/)), but in situations like changing iCloud accounts or resetting phones, the UUID will still reset; it cannot guarantee the uniqueness of the device. If this is used for storing and judging some business logic, such as: first-time free trials, users may frequently change accounts or reset phones, leading to a loophole where they can continuously try for free.

Although DeviceCheck cannot provide us with a guaranteed unchanging UUID, it can achieve the function of " **storage**." Apple provides 2 bits of cloud storage space for each device. By sending a temporary identifier token generated by the device to Apple, we can write/read that 2 bits of information.
#### 2 bits? What Can Be Stored?


![](/assets/c5e7e580c341/1*29HWP-4vlMaMng3O2hJSQw.png)


Only four states can be combined, so the functionalities are limited.
#### Comparison with Original Storage Method:


![✓ Indicates data is still present](/assets/c5e7e580c341/1*fhw8C_wb2ehP_xgwMtPmoQ.png)

✓ Indicates data is still present

_p\.s\. I sacrificed my own phone to conduct actual tests, and the results matched; even after logging out and changing iCloud, clearing all data, restoring all settings, and returning to factory default, I was still able to retrieve the values after reinstalling the APP._
#### The Main Operation Process is as Follows:


![](/assets/c5e7e580c341/1*pB25wJ1uEzzznUfT05gfBw.png)


The iOS APP generates a temporary token for identifying the device through the DeviceCheck API, sends it to the backend, which then combines the developer's private key information and developer information into JWT format before passing it to Apple's server; after the backend receives the response from Apple and processes the format, it sends it back to the iOS APP.
### Applications of DeviceCheck

Here is a screenshot of DeviceCheck from [WWDC2017](https://developer.apple.com/videos/play/wwdc2017/702/){:target="_blank"}:


![](/assets/c5e7e580c341/1*yXSqoDouuL4Jl2sM49iLHA.png)


Due to the fact that **each device can only store 2 bits of information**, the items that can be implemented are roughly as mentioned by the official applications, including whether the device has previously tried, whether it has paid, whether it is a blocked user, etc.; and only one can be realized.

**Support:** iOS ≥ 11
### Let's Get Started!

After understanding the basic information, let's get started!
#### iOS APP Side:
```swift
import DeviceCheck
//....
//
DCDevice.current.generateToken { dataOrNil, errorOrNil in
  guard let data = dataOrNil else { return }
  let deviceToken = data.base64EncodedString()
            
   //...
   //POST deviceToken to the backend, asking the backend to query with Apple's server, and then return the result to the APP for processing
}
```

As described in the process, all the APP needs to do is obtain the temporary identifier token ( **deviceToken** )!


Next, send the deviceToken to our backend API for processing.  
#### Backend:

The focus is on the backend processing part.  
#### 1\. First, log in to the [Developer Console](https://developer.apple.com/account/#/membership/){:target="_blank"} and **note down the Team ID**.


![](/assets/c5e7e580c341/1*4_DB0CfHmEqt0HO6mDt8mA.png)

#### 2\. Then click on the sidebar [Certificates, IDs & Profiles](https://developer.apple.com/account/ios/certificate/){:target="_blank"} to go to the certificate management platform.


![Select "Keys" -> "All" -> Click the "+" in the upper right corner to add](/assets/c5e7e580c341/1*zoRcWhT9HcwLXWlmui5wNw.png)

Select "Keys" -> "All" -> Click the "+" in the upper right corner to add.


![Step 1. Create a new Key, check "DeviceCheck"](/assets/c5e7e580c341/1*QgSEmllj-9AjM74tGucUag.png)

Step 1. Create a new Key, check "DeviceCheck."


![Step 2. "Confirm" confirmation](/assets/c5e7e580c341/1*hC4rOksfkDJzo3TWJMFrXg.png)

Step 2. "Confirm" confirmation.


![Finished.](/assets/c5e7e580c341/1*I9TWEmsmEqZA-01OGq52kA.png)

Finished.

After the last step is completed, **note down the Key ID** and click "Download" to download the privateKey.p8 private key file.

At this point, you have prepared all the necessary information for push notifications:  
1. Team ID  
2. Key ID  
3. privateKey.p8  

#### 3\. Combine according to Apple’s specifications [JWT (JSON Web Token)](https://yami.io/jwt/){:target="_blank"} format.

**Algorithm:** ES256  
```json
//HEADER:
{
  "alg": "ES256",
  "kid": Key ID
}
//PAYLOAD:
{
  "iss": Team ID,
  "iat": Request timestamp (Unix Timestamp, EX: 1556549164),
  "exp": Expiration timestamp (Unix Timestamp, EX: 1557000000)
}
//The timestamps must be in integer format!
```

Obtain the combined JWT string: xxxxxx.xxxxxx.xxxxxx  
#### 4\. Send the data to Apple’s server & obtain the response.

**Just like APNS push notifications, there are separate environments for development and production:**  
1. Development environment: api.development.devicecheck.apple.com _（I don't know why my development environment always returns failure）_  
2. Production environment: api.devicecheck.apple.com  

**DeviceCheck API provides two operations:**  
**1\. Query stored data:** https://api.devicecheck.apple.com/v1/query_two_bits  
```plaintext
//Headers:
Authorization: Bearer xxxxxx.xxxxxx.xxxxxx (combined JWT string)

//Content:
device_token: deviceToken (the device token to query)  
transaction_id: UUID().uuidString (query identifier, here we directly use UUID to represent)  
timestamp: Request timestamp (milliseconds), note! This is in milliseconds (EX: 1556549164000)  
```

**Response status:**  


![[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}](/assets/c5e7e580c341/1*MAa5Z8bK9ppAN6WJxEButg.png)

[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}

**Response Content:**
```json
{
  "bit0": Int: 2 bits data of the first bit: 0 or 1,
  "bit1": Int: 2 bits data of the second bit: 0 or 1,
  "last_update_time": String: "Last modified time YYYY-MM"
}
```

_p\.s\. You are not mistaken, the last modified time can only display up to year-month._

**2\. Write Storage Data:** https://api\.devicecheck\.apple\.com/v1/update\_two\_bits
```plaintext
//Headers:
Authorization: Bearer xxxxxx.xxxxxx.xxxxxx (Combined JWT string)

//Content:
device_token:deviceToken (The device token to query)
transaction_id:UUID().uuidString (Query identifier, here directly using UUID to represent)
timestamp: Request timestamp (milliseconds), note! This is in milliseconds (EX: 1556549164000)
bit0: 2 bits data of the first bit: 0 or 1
bit1: 2 bits data of the second bit: 0 or 1
```
#### 5\. Get Apple Server Response

**Response Status:**


![[Official Document](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}](/assets/c5e7e580c341/1*MAa5Z8bK9ppAN6WJxEButg.png)

[Official Document](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}

**Response Content: None, response status 200 indicates successful write!**
#### 6\. Backend API Response to APP

The APP completes the response based on the corresponding status!
### Backend Supplement:

I haven't worked with PHP for a long time, if interested, please refer to the requestToken\.php section of the article [About DeviceCheck Added in iOS11](https://qiita.com/owen/items/85dff1e45083d2805140){:target="_blank"}.
#### Swift Version Demonstration Demo:

Since I cannot provide the backend implementation and not everyone knows PHP, here is an example using pure iOS (Swift) to handle what the backend should do (assemble JWT, send data to Apple), for everyone's reference!

You can simulate executing all content without writing backend code.


> ⚠ Please note _this is only for testing demonstration purposes and is not recommended for production environments_ ⚠ 




I would like to thank [Ethan Huang](https://medium.com/u/e13f6afcf9b9){:target="_blank"} for providing support for generating JWT format content within the iOS APP through [CupertinoJWT](https://github.com/ethanhuang13/CupertinoJWT){:target="_blank"}!

**Demo Main Code and Interface:**
```swift
import UIKit
import DeviceCheck
import CupertinoJWT

extension String {
    var queryEncode: String {
        return self.addingPercentEncoding(withAllowedCharacters: .whitespacesAndNewlines)?.replacingOccurrences(of: "+", with: "%2B") ?? ""
    }
}
class ViewController: UIViewController {

    
    @IBOutlet weak var getBtn: UIButton!
    @IBOutlet weak var statusBtn: UIButton!
    @IBAction func getBtnClick(_ sender: Any) {
        DCDevice.current.generateToken { dataOrNil, errorOrNil in
            guard let data = dataOrNil else { return }
            
            let deviceToken = data.base64EncodedString()
            
            // In a formal situation:
            // POST deviceToken to the backend, asking the backend to query with Apple server, then return the result to the APP for processing
            
            
            //!!!!!! The following is only for testing and demonstration purposes, not recommended for production environments!!!!!!
            //!!!!!!      Please do not expose your PRIVATE KEY    !!!!!!
                let p8 = """
                    -----BEGIN PRIVATE KEY-----
                    -----END PRIVATE KEY-----
                    """
                let keyID = "" // Your KEY ID
                let teamID = "" // Your Developer Team ID :https://developer.apple.com/account/#/membership
            
                let jwt = JWT(keyID: keyID, teamID: teamID, issueDate: Date(), expireDuration: 60 * 60)
            
                do {
                    let token = try jwt.sign(with: p8)
                    var request = URLRequest(url: URL(string: "https://api.devicecheck.apple.com/v1/update_two_bits")!)
                    request.httpMethod = "POST"
                    request.addValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
                    request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
                    let json: [String: Any] = ["device_token": deviceToken, "transaction_id": UUID().uuidString, "timestamp": Int(Date().timeIntervalSince1970.rounded()) * 1000, "bit0": true, "bit1": false]
                    request.httpBody = try? JSONSerialization.data(withJSONObject: json)
                    
                    let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
                        guard let data = data else {
                            return
                        }
                        print(String(data: data, encoding: String.Encoding.utf8))
                        DispatchQueue.main.async {
                            self.getBtn.isHidden = true
                            self.statusBtn.isSelected = true
                        }
                    }
                    task.resume()
                } catch {
                    // Handle error
                }
            //!!!!!! The above is only for testing and demonstration purposes, not recommended for production environments!!!!!!
            //
            
        }

    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        DCDevice.current.generateToken { dataOrNil, errorOrNil in
            guard let data = dataOrNil else { return }
            
            let deviceToken = data.base64EncodedString()
            
            // In a formal situation:
                // POST deviceToken to the backend, asking the backend to query with Apple server, then return the result to the APP for processing
            
            
            //!!!!!! The following is only for testing and demonstration purposes, not recommended for production environments!!!!!!
            //!!!!!!      Please do not expose your PRIVATE KEY    !!!!!!
                let p8 = """
                -----BEGIN PRIVATE KEY-----
                
                -----END PRIVATE KEY-----
                """
                let keyID = "" // Your KEY ID
                let teamID = "" // Your Developer Team ID :https://developer.apple.com/account/#/membership
            
                let jwt = JWT(keyID: keyID, teamID: teamID, issueDate: Date(), expireDuration: 60 * 60)
            
                do {
                    let token = try jwt.sign(with: p8)
                    var request = URLRequest(url: URL(string: "https://api.devicecheck.apple.com/v1/query_two_bits")!)
                    request.httpMethod = "POST"
                    request.addValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
                    request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
                    let json: [String: Any] = ["device_token": deviceToken, "transaction_id": UUID().uuidString, "timestamp": Int(Date().timeIntervalSince1970.rounded()) * 1000]
                    request.httpBody = try? JSONSerialization.data(withJSONObject: json)
                    
                    let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
                        guard let data = data, let json = try? JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String: Any], let status = json["bit0"] as? Int else {
                            return
                        }
                        print(json)
                        
                        if status == 1 {
                            DispatchQueue.main.async {
                                self.getBtn.isHidden = true
                                self.statusBtn.isSelected = true
                            }
                        }
                    }
                    task.resume()
                } catch {
                    // Handle error
                }
            //!!!!!! The above is only for testing and demonstration purposes, not recommended for production environments!!!!!!
            //
            
        }
        // Do any additional setup after loading the view.
    }


}
```

![Screenshot](/assets/c5e7e580c341/1*SwCOuRX_5KD4GsBNfaTQDQ.png)

Screenshot

What we have here is a one-time offer redemption, and each device can only redeem it once!
#### Complete Project Download:


[![](https://opengraph.githubassets.com/5b9e31058f9022c9102e9f1235cb0d3535b7db18c15a0dc2affda91d0f97507e/zhgchgli0718/iOSDeviceCheckExample)](https://github.com/zhgchgli0718/iOSDeviceCheckExample){:target="_blank"}



If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.



_[Post](https://medium.com/zrealm-ios-dev/ios-%E5%AE%8C%E7%BE%8E%E5%AF%A6%E8%B8%90%E4%B8%80%E6%AC%A1%E6%80%A7%E5%84%AA%E6%83%A0%E6%88%96%E8%A9%A6%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95-swift-c5e7e580c341){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
