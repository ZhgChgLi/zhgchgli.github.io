---
author: ZhgChgLi
categories:
- ZRealm Dev.
date: 2019-04-29T15:30:01.510+0000
description: iOS developers struggling with secure one-time offers or trials can leverage
  DeviceCheck to track user eligibility across devices, preventing abuse and ensuring
  fair usage. Learn how to implement this with Swift for reliable, scalable results.
image:
  path: /assets/c5e7e580c341/1*yXSqoDouuL4Jl2sM49iLHA.png
last_modified_at: 2024-04-13T07:43:24.841+0000
render_with_liquid: false
tags:
- english
- iOS
- iOS App Development
- iOS 11
- Swift
- Mobile App Development
title: iOS DeviceCheck｜Implement One-Time Offers and Trials Seamlessly with Swift
---

### Perfect iOS Implementation of One-Time Discounts or Trials (Swift)

iOS DeviceCheck Goes With You to the Ends of the Earth

While writing the previous article on [Call Directory Extension](../ac557047d206/), I accidentally discovered this lesser-known API. Although it’s not new (announced at WWDC 2017 / supported on iOS ≥11) and very easy to implement, I still did a bit of research and testing and compiled an article as a record.

### What can DeviceCheck do?

> **Allow developers to create identification tags for users' devices**

Since iOS ≥ 6, developers cannot access the device's unique identifier (UUID). The workaround is to use IDFV combined with KeyChain (for details, refer to the previous [article](../a4bc3bce7513/)). However, the UUID will reset when changing iCloud accounts or resetting the phone, etc. This cannot guarantee device uniqueness. If used for business logic storage and decisions, such as first-time free trials, users might exploit this by frequently changing accounts or resetting phones to repeatedly access unlimited free trials.

Although DeviceCheck does not guarantee an unchanging UUID, it provides a "**storage**" function. Apple offers 2 bits of cloud storage per device. By sending a temporary token generated by the device to Apple, you can write/read those 2 bits of information.

#### 2 bits? What can it store?

![](/assets/c5e7e580c341/1*29HWP-4vlMaMng3O2hJSQw.png)

Only four states can be combined, limiting the available functions.

#### Comparison with the Original Storage Method:

![✓ means the data is still available](/assets/c5e7e580c341/1*fhw8C_wb2ehP_xgwMtPmoQ.png)

✓ indicates the data is still available

*p.s. I personally tested this on my own phone, and the results matched; even after logging out and switching iCloud accounts, deleting all data, resetting all settings, restoring to factory defaults, and reinstalling the app, it still retrieved the values.*

#### The main operation process is as follows:

![](/assets/c5e7e580c341/1*pB25wJ1uEzzznUfT05gfBw.png)

The iOS app uses the DeviceCheck API to generate a temporary token for device identification, which is sent to the backend. The backend then combines the developer's private key and developer information to create a JWT, which is sent to Apple's server. After receiving the response from Apple, the backend processes the format and sends it back to the iOS app.

### Applications of DeviceCheck

Attached is a screenshot of DeviceCheck from [WWDC2017](https://developer.apple.com/videos/play/wwdc2017/702/){:target="_blank"}:

![](/assets/c5e7e580c341/1*yXSqoDouuL4Jl2sM49iLHA.png)

Because **each device can only store 2 bits of information**, the possible items are roughly as the official documentation mentions, including whether the device has been trialed, whether it has paid, whether it is a banned user, etc.; and only one item can be implemented.

**Support:** iOS ≥ 11

### Start!

After understanding the basic information, let's get started!

#### iOS APP side:

```swift
import DeviceCheck
//....
//
DCDevice.current.generateToken { dataOrNil, errorOrNil in
  guard let data = dataOrNil else { return }
  let deviceToken = data.base64EncodedString()
            
   //...
   //POST deviceToken to backend, let backend query Apple server, then return result to APP for processing
}
```

As described in the process, the APP only needs to obtain a temporary identification Token (**deviceToken**)!

Next, send the deviceToken to our backend API for processing.

#### Backend:

The focus is on the backend processing part.

#### 1. First, log in to the [Developer Console](https://developer.apple.com/account/#/membership/){:target="_blank"} **and note down the Team ID**

![](/assets/c5e7e580c341/1*4_DB0CfHmEqt0HO6mDt8mA.png)

#### 2. Click the sidebar's [Certificates, IDs & Profiles](https://developer.apple.com/account/ios/certificate/){:target="_blank"} to go to the certificate management platform

![Select "Keys" -> "All" -> "+" in the top right to add](/assets/c5e7e580c341/1*zoRcWhT9HcwLXWlmui5wNw.png)

Select "Keys" -> "All" -> "+" at the top right to add a new one

![Step 1. Create a new Key and check "DeviceCheck"](/assets/c5e7e580c341/1*QgSEmllj-9AjM74tGucUag.png)

Step 1. Create a new Key and check "DeviceCheck"

![Step 2. "Confirm"](/assets/c5e7e580c341/1*hC4rOksfkDJzo3TWJMFrXg.png)

Step 2. "Confirm" Confirmation

![Finished.](/assets/c5e7e580c341/1*I9TWEmsmEqZA-01OGq52kA.png)

Understood. Please provide the Markdown paragraphs you want me to translate into English.

After completing the final step, **note down the Key ID** and click "Download" to save the privateKey.p8 private key file.

At this point, you have prepared all the necessary data for push notifications:

1. Team ID

2. Key ID

3. privateKey.p8

#### 3. Combine [JWT (JSON Web Token)](https://yami.io/jwt/){:target="_blank"} format according to Apple specifications

**Algorithm:** ES256

```json
//HEADER:
{
  "alg": "ES256",
  "kid": Key ID
}
//PAYLOAD:
{
  "iss": Team ID,
  "iat": Request timestamp (Unix Timestamp, EX: 1556549164),
  "exp": Expiration timestamp (Unix Timestamp, EX: 1557000000)
}
//Timestamps must be in integer format!
```

Get the JWT string of the token: xxxxxx.xxxxxx.xxxxxx

#### 4. Send Data to Apple Server & Receive Response

**APNS push notifications have separate development and production environments:**
1. Development environment: api.development.devicecheck.apple.com *(For some reason, my development environment always returns failure when sending)*
2. Production environment: api.devicecheck.apple.com

**DeviceCheck API offers two operations:**  
**1. Query stored data:** https://api.devicecheck.apple.com/v1/query_two_bits

```plaintext
//Headers:
Authorization: Bearer xxxxxx.xxxxxx.xxxxxx (Combined JWT string)

//Content:
device_token:deviceToken (Device token to query)
transaction_id:UUID().uuidString (Query identifier, here represented by UUID)
timestamp: Request timestamp (milliseconds), note! This is in milliseconds (e.g., 1556549164000)
```

**Return Status:**

![[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}](/assets/c5e7e580c341/1*MAa5Z8bK9ppAN6WJxEButg.png)

[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}

**Returned Content:**

```json
{
  "bit0": Int: 2 bits data, first bit value: 0 or 1,
  "bit1": Int: 2 bits data, second bit value: 0 or 1,
  "last_update_time": String: "Last modified time YYYY-MM"
}
```

*p.s. You read that right, the last modified time can only be displayed up to year-month*

**2. Write Stored Data:** https://api.devicecheck.apple.com/v1/update_two_bits

```plaintext
//Headers:
Authorization: Bearer xxxxxx.xxxxxx.xxxxxx (Combined JWT string)

//Content:
device_token:deviceToken (Device token to query)
transaction_id:UUID().uuidString (Query identifier, here represented by UUID)
timestamp: Request timestamp (milliseconds), note! This is in milliseconds (e.g., 1556549164000)
bit0: 2 bits, first bit of the data: 0 or 1
bit1: 2 bits, second bit of the data: 0 or 1
```

#### 5. Get the Result Returned from Apple Server

**Return Status:**

![[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}](/assets/c5e7e580c341/1*MAa5Z8bK9ppAN6WJxEButg.png)

[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}

**Response content: None, a 200 status code indicates a successful write!**

#### 6. Backend API Returns Results to the APP

The app is complete once it responds to the corresponding states!

### Backend Supplement:

I haven't worked with PHP for a long time. If interested, please refer to the requestToken.php section in the article [DeviceCheck added in iOS11](https://qiita.com/owen/items/85dff1e45083d2805140){:target="_blank"}.

#### Swift Demo Example:

Since I cannot provide backend implementation and not everyone knows PHP, here is an example using pure iOS (Swift) that handles backend tasks (JWT creation, sending data to Apple) directly within the app for your reference!

Simulate and execute all content without writing backend code.

> ⚠ Please note *This is for testing demonstration only and is not recommended for production use* ⚠

Thanks to [Ethan Huang](https://medium.com/u/e13f6afcf9b9){:target="_blank"} for the great [CupertinoJWT](https://github.com/ethanhuang13/CupertinoJWT){:target="_blank"} library that supports generating JWT format content within iOS apps!

**Main Demo Program and Interface:**

```swift
import UIKit
import DeviceCheck
import CupertinoJWT

extension String {
    var queryEncode:String {
        return self.addingPercentEncoding(withAllowedCharacters: .whitespacesAndNewlines)?.replacingOccurrences(of: "+", with: "%2B") ?? ""
    }
}
class ViewController: UIViewController {

    
    @IBOutlet weak var getBtn: UIButton!
    @IBOutlet weak var statusBtn: UIButton!
    @IBAction func getBtnClick(_ sender: Any) {
        DCDevice.current.generateToken { dataOrNil, errorOrNil in
            guard let data = dataOrNil else { return }
            
            let deviceToken = data.base64EncodedString()
            
            // In production:
            // POST deviceToken to backend, let backend query Apple server, then return result to app
            
            
            //!!!!!! The following is only for testing/demo purposes, not recommended for production!!!!!!
            //!!!!!!      Do not expose your PRIVATE KEY carelessly    !!!!!!
                let p8 = """
                    -----BEGIN PRIVATE KEY-----
                    -----END PRIVATE KEY-----
                    """
                let keyID = "" // Your KEY ID
                let teamID = "" // Your Developer Team ID :https://developer.apple.com/account/#/membership
            
                let jwt = JWT(keyID: keyID, teamID: teamID, issueDate: Date(), expireDuration: 60 * 60)
            
                do {
                    let token = try jwt.sign(with: p8)
                    var request = URLRequest(url: URL(string: "https://api.devicecheck.apple.com/v1/update_two_bits")!)
                    request.httpMethod = "POST"
                    request.addValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
                    request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
                    let json:[String : Any] = ["device_token":deviceToken,"transaction_id":UUID().uuidString,"timestamp":Int(Date().timeIntervalSince1970.rounded()) * 1000,"bit0":true,"bit1":false]
                    request.httpBody = try? JSONSerialization.data(withJSONObject: json)
                    
                    let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
                        guard let data = data else {
                            return
                        }
                        print(String(data:data, encoding: String.Encoding.utf8))
                        DispatchQueue.main.async {
                            self.getBtn.isHidden = true
                            self.statusBtn.isSelected = true
                        }
                    }
                    task.resume()
                } catch {
                    // Handle error
                }
            //!!!!!! The above is only for testing/demo purposes, not recommended for production!!!!!!
            //
            
        }

    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        DCDevice.current.generateToken { dataOrNil, errorOrNil in
            guard let data = dataOrNil else { return }
            
            let deviceToken = data.base64EncodedString()
            
            // In production:
                // POST deviceToken to backend, let backend query Apple server, then return result to app
            
            
            //!!!!!! The following is only for testing/demo purposes, not recommended for production!!!!!!
            //!!!!!!      Do not expose your PRIVATE KEY carelessly    !!!!!!
                let p8 = """
                -----BEGIN PRIVATE KEY-----
                
                -----END PRIVATE KEY-----
                """
                let keyID = "" // Your KEY ID
                let teamID = "" // Your Developer Team ID :https://developer.apple.com/account/#/membership
            
                let jwt = JWT(keyID: keyID, teamID: teamID, issueDate: Date(), expireDuration: 60 * 60)
            
                do {
                    let token = try jwt.sign(with: p8)
                    var request = URLRequest(url: URL(string: "https://api.devicecheck.apple.com/v1/query_two_bits")!)
                    request.httpMethod = "POST"
                    request.addValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
                    request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
                    let json:[String : Any] = ["device_token":deviceToken,"transaction_id":UUID().uuidString,"timestamp":Int(Date().timeIntervalSince1970.rounded()) * 1000]
                    request.httpBody = try? JSONSerialization.data(withJSONObject: json)
                    
                    let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
                        guard let data = data,let json = try? JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String:Any],let stauts = json["bit0"] as? Int else {
                            return
                        }
                        print(json)
                        
                        if stauts == 1 {
                            DispatchQueue.main.async {
                                self.getBtn.isHidden = true
                                self.statusBtn.isSelected = true
                            }
                        }
                    }
                    task.resume()
                } catch {
                    // Handle error
                }
            //!!!!!! The above is only for testing/demo purposes, not recommended for production!!!!!!
            //
            
        }
        // Do any additional setup after loading the view.
    }


}
```

![Screenshot](/assets/c5e7e580c341/1*SwCOuRX_5KD4GsBNfaTQDQ.png)

Screenshot

This is a one-time offer redemption; each device can only claim it once!

#### Full Project Download:

[![](https://opengraph.githubassets.com/5b9e31058f9022c9102e9f1235cb0d3535b7db18c15a0dc2affda91d0f97507e/zhgchgli0718/iOSDeviceCheckExample)](https://github.com/zhgchgli0718/iOSDeviceCheckExample){:target="_blank"}

If you have any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

*[Post](https://medium.com/zrealm-ios-dev/ios-%E5%AE%8C%E7%BE%8E%E5%AF%A6%E8%B8%90%E4%B8%80%E6%AC%A1%E6%80%A7%E5%84%AA%E6%83%A0%E6%88%96%E8%A9%A6%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95-swift-c5e7e580c341){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*