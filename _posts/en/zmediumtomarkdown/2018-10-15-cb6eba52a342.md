---
title: "iOS ≥ 10 Notification Service Extension Application (Swift)"
author: "ZhgChgLi"
date: 2018-10-15T15:44:01.193+0000
last_modified_at: 2024-04-13T07:13:08.836+0000
categories: ["ZRealm Dev."]
tags: ["swift","push-notification","notificationservice","ios","ios-app-development"]
description: "Image push notifications, push notification display statistics, pre-processing of push notification display"
image:
  path: /assets/cb6eba52a342/1*8juoKO7BZiT3PQjqufWcrA.jpeg
render_with_liquid: false
---

### iOS ≥ 10 Notification Service Extension Application \(Swift\)

Image push notifications, push notification display statistics, pre-processing of push notification display

Regarding the basics of push notification setup and principles; there is a lot of information available online, so I won't elaborate further. This article mainly focuses on how to enable the app to support image push notifications and utilize new features to achieve more accurate push notification display statistics.

![](/assets/cb6eba52a342/1*8juoKO7BZiT3PQjqufWcrA.jpeg)

As shown in the image above, the Notification Service Extension allows you to preprocess the push notification after the app receives it, before displaying the notification content.

According to the official documentation, when processing the incoming push notification content, the processing time limit is about 30 seconds. If the callback is not called within 30 seconds, the push notification will continue to execute and appear on the user's device.

#### Supported Versions

iOS ≥ 10\.0

#### What can you do in 30 seconds?
- \(Goal 1\) Download the image from the image URL field in the push notification content and attach it to the notification content🏆

![](/assets/cb6eba52a342/1*dd2kRizi6v-AIXcMWourow.png)

- \(Goal 2\) Track whether the push notification was displayed🏆
- Modify and reorganize the notification content
- Encrypt/Decrypt the notification content for display
- _Decide whether to display the notification?_ =&gt;&gt; **Answer: No**

#### First, the Payload part of the backend push notification program

The structure of the backend push notification must include an additional line `“mutable-content":1` for the system to execute the Notification Service Extension upon receiving the push notification.
```json
{
    "aps": {
        "alert": {
            "title": "New article recommended for you",
            "body": "Check it out now"
        },
        "mutable-content":1,
        "sound": "default",
        "badge": 0
    }
}
```
#### And… Step One, create a new Target for the project

![**Step 1\.** Xcode \-&gt; File \-&gt; New \-&gt; Target](/assets/cb6eba52a342/1*ZjPVTxLR6ywAdk70Y7_J7A.png)

**Step 1\.** Xcode \-&gt; File \-&gt; New \-&gt; Target

![**Step 2\.** iOS \-&gt; Notification Service Extension \-&gt; Next](/assets/cb6eba52a342/1*2KRusR8MJUim7UH1CmS7pw.png)

**Step 2\.** iOS \-&gt; Notification Service Extension \-&gt; Next

![**Step 3\.** Enter Product Name \-&gt; Finish](/assets/cb6eba52a342/1*sAuzxJPpohTGp-KV13yupg.png)

**Step 3\.** Enter Product Name \-&gt; Finish

![**Step 4\.** Click Activate](/assets/cb6eba52a342/1*3DF_fMQLSrGxTbmLY6CJAg.png)

**Step 4\.** Click Activate

**Step Two, write the push notification content handler**

![Locate Product Name/NotificationService\.swift file](/assets/cb6eba52a342/1*UsCd2btDPK6GWKrYEA9LbQ.png)

Locate the Product Name/NotificationService\.swift file
```swift
import UserNotifications

class NotificationService: UNNotificationServiceExtension {

    var contentHandler: ((UNNotificationContent) -> Void)?
    var bestAttemptContent: UNMutableNotificationContent?

    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {
        self.contentHandler = contentHandler
        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
        
        if let bestAttemptContent = bestAttemptContent {
            // Modify the notification content here...
            // Process the notification content, load the image
            bestAttemptContent.title = "\(bestAttemptContent.title) [modified]"
            
            contentHandler(bestAttemptContent)
        }
    }
    
    override func serviceExtensionTimeWillExpire() {
        // Called just before the extension will be terminated by the system.
        // Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.
        // If time is running out, just modify the title content
        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {
            contentHandler(bestAttemptContent)
        }
    }

}
```

In the code above, the NotificationService has two interfaces; the first is `didReceive`, which is triggered when a push notification comes in. After processing, you need to call `contentHandler(bestAttemptContent)` to inform the system.

If too much time passes without calling the callback method, the second function `serviceExtensionTimeWillExpire()` will be triggered, indicating that time has expired, and you can only perform some cleanup actions (e.g., simply modifying the title or content without loading network data).

#### Practical Example

Here we assume our Payload is as follows:
```json
{
    "aps": {
        "alert": {
            "push_id":"2018001",
            "title": "New article recommended for you",
            "body": "Check it out now",
            "image": "https://d2uju15hmm6f78.cloudfront.net/image/2016/12/04/3113/2018/09/28/trim_153813426461775700_450x300.jpg"
        },
        "mutable-content":1,
        "sound": "default",
        "badge": 0
    }
}
```

The `push_id` and `image` are custom fields I created. The `push_id` is used to identify the push notification for easy reporting back to the server for statistics; the `image` is the URL of the image to be attached to the push notification content.
```swift
override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {
    self.contentHandler = contentHandler
    bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
    
    if let bestAttemptContent = bestAttemptContent {
        
        guard let info = request.content.userInfo["aps"] as? NSDictionary, let alert = info["alert"] as? Dictionary<String,String> else {
            contentHandler(bestAttemptContent)
            return
            // The format of the push notification content is not as expected, do not process
        }
        
        // Goal 2:
        // Notify the server that the push notification was displayed
        if let push_id = alert["push_id"], let url = URL(string: "Display statistics API URL") {
            var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 30)
            request.httpMethod = "POST"
            request.addValue(UserAgent, forHTTPHeaderField: "User-Agent")
            
            var httpBody = "push_id=\(push_id)"
            request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
            request.httpBody = httpBody.data(using: .utf8)
            
            let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
                
            }
            DispatchQueue.global().async {
                task.resume()
                // Asynchronous processing, regardless of the result
            }
        }
        
        // Goal 1:
        guard let imageURLString = alert["image"], let imageURL = URL(string: imageURLString) else {
            contentHandler(bestAttemptContent)
            return
            // If there is no attached image, no special processing is needed
        }
        
        
        let dataTask = URLSession.shared.dataTask(with: imageURL) { (data, response, error) in
            guard let fileURL = NSURL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(imageURL.lastPathComponent) else {
                contentHandler(bestAttemptContent)
                return
            }
            guard (try? data?.write(to: fileURL)) != nil else {
                contentHandler(bestAttemptContent)
                return
            }
            
            guard let attachment = try? UNNotificationAttachment(identifier: "image", url: fileURL, options: nil) else {
                contentHandler(bestAttemptContent)
                return
            }
            // The above code reads the image link, downloads it to the device, and creates a UNNotificationAttachment
            
            bestAttemptContent.categoryIdentifier = "image"
            bestAttemptContent.attachments = [attachment]
            // Attach the image to the push notification
            
            bestAttemptContent.body = (bestAttemptContent.body == "") ? ("Check it out now") : (bestAttemptContent.body)
            // If the body is empty, use the default content "Check it out now"
            
            contentHandler(bestAttemptContent)
        }
        dataTask.resume()
    }
}
```

I didn't specifically handle the `serviceExtensionTimeWillExpire` part, so I won't include it here; the key is still the `didReceive` code above.

As you can see, when a push notification is received, we first call the API to inform the backend that we have received and will display the push notification, which helps us with push notification statistics in the backend. Then, if there is an attached image, we process it.

#### When the App is in the In-App State:

The Notification Service Extension `didReceive` will also be triggered, which in turn triggers the AppDelegate's **func** application\( **\_** application: UIApplication, didReceiveRemoteNotification userInfo: \[AnyHashable : **Any** \], fetchCompletionHandler completionHandler: **@escaping** \(UIBackgroundFetchResult\) \-&gt; Void\) method.

#### Note: Regarding image push notifications, you can also…

Use the Notification Content Extension to customize the UIView that displays when the push notification is pressed (you can design it yourself), as well as the actions taken upon pressing.

You can refer to this article: [Advanced iOS 10 Push Notifications (Notification Extension)](https://www.jianshu.com/p/78ef7bc04655#UNNotificationContentExtension-%E9%80%9A%E7%9F%A5%E5%86%85%E5%AE%B9%E6%89%A9%E5%B1%95){:target="_blank"}

iOS 12 and later supports more action handling: [iOS 12 New Notification Features: Adding Interactivity to Implement Complex Functions in Notifications](https://www.appcoda.com.tw/user-notifications-ios12/){:target="_blank"}

For the Notification Content Extension, I only created a UIView that can display image push notifications without much additional work:

![[Marriage App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}](/assets/cb6eba52a342/1*SepeUiS7CN7xmGFxariPjA.png)

[Marriage App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-10-notification-service-extension-%E6%87%89%E7%94%A8-swift-cb6eba52a342){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._