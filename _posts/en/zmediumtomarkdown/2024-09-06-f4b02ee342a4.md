---
title: "Practical Application Record of Design Patterns—In WKWebView with Builder, Strategy & Chain of Responsibility Pattern"
author: "ZhgChgLi"
date: 2024-09-06T05:47:47.299+0000
last_modified_at: 2024-09-07T08:45:32.884+0000
categories: ["KKday Tech Blog"]
tags: ["ios-app-development","design-patterns","chain-of-responsibility","builder-pattern","strategy-pattern"]
description: "Design Patterns scenarios used when encapsulating iOS WKWebView (Strategy, Chain of Responsibility, Builder patterns)."
image:
  path: /assets/f4b02ee342a4/1*pwh6uN0WQNWPa8zmSSyMXA.jpeg
render_with_liquid: false
---

### Practical Application Record of Design Patterns—In WKWebView with Builder, Strategy & Chain of Responsibility Pattern

Design Patterns scenarios used when encapsulating iOS WKWebView (Strategy, Chain of Responsibility, Builder patterns).


![Photo by [Dean Pugh](https://unsplash.com/@wezlar11?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}](/assets/f4b02ee342a4/1*pwh6uN0WQNWPa8zmSSyMXA.jpeg)

Photo by [Dean Pugh](https://unsplash.com/@wezlar11?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}
### About Design Patterns

Every time before discussing Design Patterns, it is important to mention that the classic 23 design patterns from GoF have been published for over 30 years (released in 1994). The changes in tools, languages, and software development models are no longer comparable. Many new design patterns have emerged in various fields since then; Design Patterns are not a panacea or the only solution. Their existence is more like a "linguistic shorthand" that applies suitable design patterns in appropriate scenarios, which can reduce barriers to development collaboration. For example, if the strategy pattern is applied here, subsequent maintainers can iterate directly based on the structure of the strategy pattern. Moreover, design patterns are generally well decoupled, significantly aiding extensibility and testability.
#### **Principles for Using Design Patterns**
- Not a unique solution
- Not a universal solution
- Cannot be rigidly applied; choose the corresponding design pattern based on the type of problem to be solved (creation? behavior? structure?), and the purpose
- Avoid "magic modifications"; such modifications can easily lead to misunderstandings for future maintainers. Just like language, if everyone uses Apple, calling it Banana would become a development cost that requires special knowledge
- Avoid using keywords as much as possible; for example, if the Factory Pattern is commonly named `XXXFactory`, then if it is not a factory pattern, this naming keyword should not be used
- **Be cautious when creating your own patterns**; although there are only 23 classic ones, many new patterns have evolved over the years across various fields. It is advisable to refer to online resources to find suitable patterns (after all, three cobblers are better than Zhuge Liang). If there really isn't one, propose a new design pattern and try to publish it for review and adjustment by people from different fields and contexts
- Code is ultimately written for people to maintain; as long as it is easy to maintain and extend, it does not necessarily have to use design patterns
- The team must have a consensus on Design Patterns to use them appropriately
- Design Patterns can be combined with other Design Patterns
- Mastering Design Patterns requires practical experience and continuous refinement to develop sensitivity to which scenarios are suitable or unsuitable for application

#### Auxiliary Tool ChatGPT


![](/assets/f4b02ee342a4/1*gs1hW3YcAkpTgvzzz0lMkQ.png)


Since the advent of ChatGPT, learning the practical applications of Design Patterns has become easier. Just describe your questions specifically to it, asking which design patterns are suitable for a given scenario, and it can provide several potentially suitable patterns along with explanations. Although not every answer is perfectly suitable, it at least offers several feasible directions. We just need to delve deeper into these patterns in conjunction with our practical scenario issues, and in the end, we can select a good solution!
### Practical Application Scenarios of Design Patterns in WKWebView


This practical application of Design Patterns focuses on consolidating the functionality features of the WKWebView objects in the current codebase and sharing insights on applying Design Patterns at several appropriate logical abstraction points while developing a unified WKWebView component.


> _The complete demo project code will be attached at the end of the document._ 




### Original Non-Abstracted Implementation
```swift
class WKWebViewController: UIViewController {

    // MARK - Define some variables and switches for external initialization...

    // Simulated business logic: switch to open native pages for special paths
    let noNeedNativePresent: Bool
    // Simulated business logic: switch for DeeplinkManager checks
    let deeplinkCheck: Bool
    // Simulated business logic: is it the homepage?
    let isHomePage: Bool
    // Simulated business logic: scripts to inject into WKWebView as WKUserScript
    let userScripts: [WKUserScript]
    // Simulated business logic: scripts to inject into WKWebView as WKScriptMessageHandler
    let scriptMessageHandlers: [String: WKScriptMessageHandler]
    // Whether to allow overriding the ViewController title from the WebView title
    let overrideTitleFromWebView: Bool
    
    let url: URL
    
    // ... 
}
// ...
extension OldWKWebViewController: WKNavigationDelegate {
    // MARK - iOS WKWebView's navigationAction Delegate, used to determine how to handle the upcoming link
    // Always call decisionHandler(.allow) or decisionHandler(.cancel) at the end
    // decisionHandler(.cancel) will interrupt the loading of the upcoming page

    // Here, different variables and switches simulate different logical processes:

    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        guard let url = navigationAction.request.url else {
            decisionHandler(.allow)
            return
        }
        
        // Simulated business logic: WebViewController deeplinkCheck == true (indicating a need to pass DeepLinkManager checks and open the page)
        if deeplinkCheck {
            print("DeepLinkManager.open(\(url.absoluteString)")
            // Simulated DeepLinkManager logic, if the URL can be successfully opened, open it and end the process.
            // if DeepLinkManager.open(url) == true {
                decisionHandler(.cancel)
                return
            // }
        }
        
        // Simulated business logic: WebViewController isHomePage == true (indicating it is the homepage) & WebView is browsing the homepage, then switch TabBar Index
        if isHomePage {
            if url.absoluteString == "https://zhgchg.li" {
                print("Switch UITabBarController to Index 0")
                decisionHandler(.cancel)
            }
        }
        
        // Simulated business logic: WebViewController noNeedNativePresent == false (indicating a need to match special paths to open native pages)
        if !noNeedNativePresent {
            if url.pathComponents.count >= 3 {
                if url.pathComponents[1] == "product" {
                    // match http://zhgchg.li/product/1234
                    let id = url.pathComponents[2]
                    print("Present ProductViewController(\(id)")
                    decisionHandler(.cancel)
                } else if url.pathComponents[1] == "shop" {
                    // match http://zhgchg.li/shop/1234
                    let id = url.pathComponents[2]
                    print("Present ShopViewController(\(id)")
                    decisionHandler(.cancel)
                }
                // more...
            }
        }
        
        decisionHandler(.allow)
    }
}
// ...
```
#### Issues
1. The variables and switches are scattered throughout the class, making it unclear which are for configuration use.
2. The WKUserScript variable settings are directly exposed to the outside, and we want to control the injected JS, allowing only specific behaviors.
3. There is no control over the registration rules for WKScriptMessageHandler.
4. If a similar WebView needs to be initialized, the rules for injecting parameters need to be rewritten, and the parameter rules cannot be reused.
5. The `navigationAction Delegate` relies on variables to control the flow; if the flow or order needs to be modified, the entire code must be altered, which may disrupt processes that were originally functioning correctly.

### Builder Pattern

![](/assets/f4b02ee342a4/1*NvnrtRMn05Wo45QeQ221LA.png)

> _The Builder Pattern is a **creational** design pattern that separates the steps and logic of object creation, allowing the operator to set parameters step by step and reuse settings, ultimately creating the target object. Additionally, the same creation steps can be used to create different object implementations._

The above diagram uses the example of making a Pizza, breaking down the steps of Pizza creation into several methods, and declaring them in the `PizzaBuilder` Protocol (Interface). `ConcretePizzaBuilder` is the actual object that makes the Pizza, which could be `Vegetarian PizzaBuilder` & `Meat PizzaBuilder`; different Builders may use different ingredients, but they will all ultimately `build()` a `Pizza` object.

#### WKWebView Scenario

Returning to the WKWebView scenario, our final output object is `MyWKWebViewConfiguration`. We consolidate all the variables that `WKWebView` will need to configure into this object and use the Builder Pattern `MyWKWebViewConfigurator` to gradually complete the configuration construction.

```swift
public struct MyWKWebViewConfiguration {
    let headNavigationHandler: NavigationActionHandler?
    let scriptMessageStrategies: [ScriptMessageStrategy]
    let userScripts: [WKUserScript]
    let overrideTitleFromWebView: Bool
    let url: URL
}
// All parameters are only exposed internally within the Module (Internal)
```

#### MyWKWebViewConfigurator (Builder Pattern)

![](/assets/f4b02ee342a4/1*ZKpTThUiS8ZkV3jbpmWylw.png)

> _Here, since I only have the need to build for MyWKWebView, I did not further break down `MyWKWebViewConfigurator` into Protocols (Interfaces)._

```swift
public final class MyWKWebViewConfigurator {
    
    private var headNavigationHandler: NavigationActionHandler? = nil
    private var overrideTitleFromWebView: Bool = true
    private var disableZoom: Bool = false
    private var scriptMessageStrategies: [ScriptMessageStrategy] = []
    
    public init() {
        
    }
    
    // Parameter encapsulation, internal control
    public func set(disableZoom: Bool) -> Self {
        self.disableZoom = disableZoom
        return self
    }
    
    public func set(overrideTitleFromWebView: Bool) -> Self {
        self.overrideTitleFromWebView = overrideTitleFromWebView
        return self
    }
    
    public func set(headNavigationHandler: NavigationActionHandler) -> Self {
        self.headNavigationHandler = headNavigationHandler
        return self
    }
    
    // New logic rules can be encapsulated inside
    public func add(scriptMessageStrategy: ScriptMessageStrategy) -> Self {
        scriptMessageStrategies.removeAll(where: { type(of: $0).identifier == type(of: scriptMessageStrategy).identifier })
        scriptMessageStrategies.append(scriptMessageStrategy)
        return self
    }
    
    public func build(url: URL) -> MyWKWebViewConfiguration {
        var userScripts:[WKUserScript] = []
        // Attach only when generating
        if disableZoom {
            let script = "var meta = document.createElement('meta'); meta.name='viewport'; meta.content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'; document.getElementsByTagName('head')[0].appendChild(meta);"
            let disableZoomScript = WKUserScript(source: script, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
            userScripts.append(disableZoomScript)
        }
        
        return MyWKWebViewConfiguration(headNavigationHandler: headNavigationHandler, scriptMessageStrategies: scriptMessageStrategies, userScripts: userScripts, overrideTitleFromWebView: overrideTitleFromWebView, url: url)
    }
}
```

![](/assets/f4b02ee342a4/1*nD3Dc6Gxksr6vS6t2TXH-A.png)

By adding an additional layer, we can better utilize Access Control to isolate the usage permissions of parameters. In this scenario, we want to be able to directly inject `WKUserScript` into `MyWKWebView`, but we do not want to open it up so much that users can inject freely. Therefore, by combining the Builder Pattern with Swift Access Control, once `MyWKWebView` has been placed in a Module, `MyWKWebViewConfigurator` encapsulates the operation method `func set(disableZoom: Bool)` for external use, while internally it attaches `WKUserScript` when generating `MyWKWebViewConfiguration`. All parameters of `MyWKWebViewConfiguration` are unchangeable from the outside and can only be generated through `MyWKWebViewConfigurator`.

#### MyWKWebViewConfigurator + Simple Factory

With the `MyWKWebViewConfigurator` Builder in place, we can create a simple factory to encapsulate and reuse the creation steps.

```csharp
struct MyWKWebViewConfiguratorFactory {
    enum ForType {
        case `default`
        case productPage
        case payment
    }
    
    static func make(for type: ForType) -> MyWKWebViewConfigurator {
        switch type {
        case .default:
            return MyWKWebViewConfigurator()
                .add(scriptMessageStrategy: PageScriptMessageStrategy())
                .set(overrideTitleFromWebView: false)
                .set(disableZoom: false)
        case .productPage:
            return Self.make(for: .default).set(disableZoom: true).set(overrideTitleFromWebView: true)
        case .payment:
            return MyWKWebViewConfigurator().set(headNavigationHandler: paymentNavigationActionHandler)
        }
    }
}
```

### Chain of Responsibility Pattern

![](/assets/f4b02ee342a4/1*C0nmAQ9UzwMQ0vnAr8p2Ag.png)

> _The Chain of Responsibility Pattern is a **behavioral** design pattern that encapsulates the operations of object handling and links them together in a chain structure. Request operations are passed along the chain until they are handled; the linked operations can be freely and flexibly combined and reordered._

> **_The Chain of Responsibility focuses on whether you want to handle something that comes in; if not, just Skip_** _; therefore, it cannot handle partially or modify the input object before passing it to the next one. If that is the requirement, it is another [**Interceptor Pattern**](https://stackoverflow.com/questions/7951306/chain-of-responsibility-vs-interceptor){:target="_blank"}._

The above diagram uses Tech Support (or OnCall...) as an example. When a problem object comes in, it first goes through `CustomerService`. If it cannot be handled, it is passed to the next level, `Supervisor`. If it still cannot be handled, it continues down to `TechSupport`. Additionally, different responsibility chains can be formed for different issues; for example, if it is a problem from a major client, it will be handled starting from `Supervisor`. The [Responder Chain in Swift UIKit](https://www.appcoda.com.tw/responder-chain/){:target="_blank"} also uses the Chain of Responsibility pattern.


In our WKWebView scenario, it mainly applies to the `func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void)` delegate method.


> _When the system receives a URL request, it goes through this method to let us decide whether to allow the navigation, and after processing, it calls `decisionHandler(.allow)` or `decisionHandler(.cancel)` to inform the result._ 





**In the implementation of WKWebView, there will be many judgments or some pages that need to be handled differently:**
```swift
// Original implementation...
func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        guard let url = navigationAction.request.url else {
            decisionHandler(.allow)
            return
        }
        
        // Simulating business logic: WebViewController deeplinkCheck == true (indicating a check through DeepLinkManager is needed to open the page)
        if deeplinkCheck {
            print("DeepLinkManager.open(\(url.absoluteString)")
            // Simulating DeepLinkManager logic, if the URL can be successfully opened, then open it and end the process.
            // if DeepLinkManager.open(url) == true {
                decisionHandler(.cancel)
                return
            // }
        }
        
        // Simulating business logic: WebViewController isHomePage == true (indicating it is the homepage) & WebView is browsing the homepage, then switch TabBar Index
        if isHomePage {
            if url.absoluteString == "https://zhgchg.li" {
                print("Switch UITabBarController to Index 0")
                decisionHandler(.cancel)
            }
        }
        
        // Simulating business logic: WebViewController noNeedNativePresent == false (indicating a special path needs to match to open a native page)
        if !noNeedNativePresent {
            if url.pathComponents.count >= 3 {
                if url.pathComponents[1] == "product" {
                    // match http://zhgchg.li/product/1234
                    let id = url.pathComponents[2]
                    print("Present ProductViewController(\(id)")
                    decisionHandler(.cancel)
                } else if url.pathComponents[1] == "shop" {
                    // match http://zhgchg.li/shop/1234
                    let id = url.pathComponents[2]
                    print("Present ShopViewController(\(id)")
                    decisionHandler(.cancel)
                }
                // more...
            }
        }
        
        // more...
        decisionHandler(.allow)
}
```


As time goes by, the functions become increasingly complex, and the logic here will also multiply. If the processing order changes, it can turn into a disaster.
#### NavigationActionHandler \(Chain of Responsibility Pattern\)


![](/assets/f4b02ee342a4/1*29n1VSQhXFc4qUZ50IULIw.png)


**First, define the Handler Protocol:**
```less
public protocol NavigationActionHandler: AnyObject {
    var nextHandler: NavigationActionHandler? { get set }

    /// Handles navigation actions for the web view. Returns true if the action was handled, otherwise false.
    func handle(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) -> Bool
    /// Executes the navigation action policy decision. If the current handler does not handle it, the next handler in the chain will be executed.
    func exeute(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void)
}

public extension NavigationActionHandler {
    func exeute(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        if !handle(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler) {
            self.nextHandler?.exeute(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler) ?? decisionHandler(.allow)
        }
    }
}
```
- The operation will be implemented in `func handle()`. If there is further processing, return `true`; otherwise, return `false`.
- `func exeute()` is the default chain access implementation, which traverses the entire operation chain. The default behavior is that when `func handle()` returns `false` (indicating that this node cannot handle it), it automatically calls the next `nextHandler`'s `execute()` to continue processing until completion.


**Implementation:**
```swift
// Default implementation, usually placed at the end
public final class DefaultNavigationActionHandler: NavigationActionHandler {
    public var nextHandler: NavigationActionHandler?
    
    public init() {
        
    }
    
    public func handle(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) -> Bool {
        decisionHandler(.allow)
        return true
    }
}

//
final class PaymentNavigationActionHandler: NavigationActionHandler {
    var nextHandler: NavigationActionHandler?
    
    func handle(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) -> Bool {
        guard let url = navigationAction.request.url else {
            return false
        }
        
        // Simulate business logic: Payment related, two-factor authentication WebView...etc
        print("Present Payment Verify View Controller")
        decisionHandler(.cancel)
        return true
    }
}

//
final class DeeplinkManagerNavigationActionHandler: NavigationActionHandler {
    var nextHandler: NavigationActionHandler?
    
    func handle(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) -> Bool {
        guard let url = navigationAction.request.url else {
            return false
        }
        
        
        // Simulate DeepLinkManager logic; if the URL can be successfully opened, open it and end the process.
        // if DeepLinkManager.open(url) == true {
            decisionHandler(.cancel)
            return true
        // } else {
            return false
        //
    }
}

// More...
```

```swift
extension MyWKWebViewController: WKNavigationDelegate {
    public func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
       let headNavigationActionHandler = DeeplinkManagerNavigationActionHandler()
       let defaultNavigationActionHandler = DefaultNavigationActionHandler()
       let paymentNavigationActionHandler = PaymentNavigationActionHandler()
       
       headNavigationActionHandler.nextHandler = paymentNavigationActionHandler
       paymentNavigationActionHandler.nextHandler = defaultNavigationActionHandler
       
       headNavigationActionHandler.exeute(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler)
    }
}
```

This way, when a request is received, it will be processed in the order defined by our handling chain.

**Combining with the previous Builder Pattern** `MyWKWebViewConfigurator` **by exposing `headNavigationActionHandler` as a parameter, we can determine the handling requirements and order of this WKWebView from the outside:**
```swift
extension MyWKWebViewController: WKNavigationDelegate {
    public func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        configuration.headNavigationHandler?.exeute(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler) ?? decisionHandler(.allow)
    }
}

//...
struct MyWKWebViewConfiguratorFactory {
    enum ForType {
        case `default`
        case productPage
        case payment
    }
    
    static func make(for type: ForType) -> MyWKWebViewConfigurator {
        switch type {
        case .default:
            // Simulating default conditions with these handlers
            let deplinkManagerNavigationActionHandler = DeeplinkManagerNavigationActionHandler()
            let homePageTabSwitchNavigationActionHandler = HomePageTabSwitchNavigationActionHandler()
            let nativeViewControllerNavigationActionHandlera = NativeViewControllerNavigationActionHandler()
            let defaultNavigationActionHandler = DefaultNavigationActionHandler()
            
            deplinkManagerNavigationActionHandler.nextHandler = homePageTabSwitchNavigationActionHandler
            homePageTabSwitchNavigationActionHandler.nextHandler = nativeViewControllerNavigationActionHandlera
            nativeViewControllerNavigationActionHandlera.nextHandler = defaultNavigationActionHandler
            
            return MyWKWebViewConfigurator()
                .add(scriptMessageStrategy: PageScriptMessageStrategy())
                .add(scriptMessageStrategy: UserScriptMessageStrategy())
                .set(headNavigationHandler: deplinkManagerNavigationActionHandler)
                .set(overrideTitleFromWebView: false)
                .set(disableZoom: false)
        case .productPage:
            return Self.make(for: .default).set(disableZoom: true).set(overrideTitleFromWebView: true)
        case .payment:
            // Simulating that the payment page only needs these handlers, with paymentNavigationActionHandler having the highest priority
            let paymentNavigationActionHandler = PaymentNavigationActionHandler()
            let deplinkManagerNavigationActionHandler = DeeplinkManagerNavigationActionHandler()
            let defaultNavigationActionHandler = DefaultNavigationActionHandler()
            
            paymentNavigationActionHandler.nextHandler = deplinkManagerNavigationActionHandler
            deplinkManagerNavigationActionHandler.nextHandler = defaultNavigationActionHandler
            
            return MyWKWebViewConfigurator().set(headNavigationHandler: paymentNavigationActionHandler)
        }
    }
}
```
### Strategy Pattern

```markdown
![](/assets/f4b02ee342a4/1*RiMbrBGdFG6INBRCcE_WZw.png)



> _The Strategy Pattern is a **behavioral** design pattern that abstracts actual operations, allowing us to implement various different operations that can be flexibly replaced based on different scenarios._ 





The above image uses different payment methods as an example. We abstract payment as the `Payment` Protocol (Interface), and then various payment methods implement their own implementations. In `PaymentContext` (simulating external usage), based on the payment method chosen by the user, a corresponding Payment instance is created, and `pay()` is called uniformly for payment.
#### WKWebView Scenario


> _Used in the interaction between WebView and the front-end page._ 
 

> _When the front-end JavaScript calls:_ 
 

> _`window.webkit.messageHandlers.Name.postMessage(Parameters);`_ 
 

> _it will enter WKWebView to find the corresponding `Name`'s `WKScriptMessageHandler` Class to execute the operation._ 





The system already has a defined Protocol and the corresponding `func add(_ scriptMessageHandler: any WKScriptMessageHandler, name: String)` method. We only need to define our own `WKScriptMessageHandler` implementation and add it to WKWebView. The system will dispatch to the corresponding concrete strategy based on the received `name` according to the Strategy Pattern.

Here, we simply extend the Protocol `WKScriptMessageHandler` with an additional `identifier:String` for `add(.. name:)` usage:


![](/assets/f4b02ee342a4/1*RLA13rSVDIG9cV3CsWtS3g.png)

```swift
public protocol ScriptMessageStrategy: NSObject, WKScriptMessageHandler {
    static var identifier: String { get }
}
```

**Implementation:**
```swift
final class PageScriptMessageStrategy: NSObject, ScriptMessageStrategy {
    static var identifier: String = "page"
    
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        // Simulating called from js: window.webkit.messageHandlers.page.postMessage("Close");
        print("\(Self.identifier): \(message.body)")
    }
}

//

final class UserScriptMessageStrategy: NSObject, ScriptMessageStrategy {
    static var identifier: String = "user"
    
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        // Simulating called from js: window.webkit.messageHandlers.user.postMessage("Hello");
        print("\(Self.identifier): \(message.body)")
    }
}
```

**WKWebView Registration Usage:**
```css
var scriptMessageStrategies: [ScriptMessageStrategy] = []
scriptMessageStrategies.forEach { scriptMessageStrategy in
  webView.configuration.userContentController.add(scriptMessageStrategy, name: type(of: scriptMessageStrategy).identifier)
}
```


**Combining the previous Builder Pattern** `MyWKWebViewConfigurator` manages the registration of `ScriptMessageStrategy` from the outside:
```swift
public final class MyWKWebViewConfigurator {
    //...
    
    // New logic rules can be encapsulated here
    public func add(scriptMessageStrategy: ScriptMessageStrategy) -> Self {
        // Here, the logic only implements the removal of the old one when there is a duplicate identifier
        scriptMessageStrategies.removeAll(where: { type(of: $0).identifier == type(of: scriptMessageStrategy).identifier })
        scriptMessageStrategies.append(scriptMessageStrategy)
        return self
    }
    //...
}

//...

public class MyWKWebViewController: UIViewController {
    //...
    public override func viewDidLoad() {
        super.viewDidLoad()
       
        //...
        configuration.scriptMessageStrategies.forEach { scriptMessageStrategy in
            webView.configuration.userContentController.add(scriptMessageStrategy, name: type(of: scriptMessageStrategy).identifier)
        }
        //...
    }
}
```
#### Question: Can this scenario also be replaced with the Chain of Responsibility Pattern?

At this point, some friends might wonder if the Strategy Pattern here can be replaced with the Chain of Responsibility Pattern.

> _These two design patterns are both behavioral and can be interchangeable; however, it really depends on the specific requirements of the scenario. Here, it is a typical Strategy Pattern, where WKWebView decides which different Strategy to enter based on the Name. If our requirement is that different Strategies may have a chain dependency or recovery relationship, for example, if AStrategy does not handle it, it should be passed to BStrategy, then we would consider using the Chain of Responsibility Pattern._ 

![Strategy v\.s\. Chain of Responsibility](/assets/f4b02ee342a4/1*UWT-2lfzUyS7CARahfEN-A.png)

Strategy v\.s\. Chain of Responsibility
- Strategy Pattern: There is a clear dispatch of execution strategies, and there is no relationship between strategies.
- Chain of Responsibility Pattern: The execution strategy is determined in individual implementations; if it cannot be handled, it is passed down to the next implementation.

Complex scenarios can use the Strategy Pattern combined with the Chain of Responsibility Pattern to achieve the desired outcome.
### Final Combination


![](/assets/f4b02ee342a4/1*VgMVoIWfkuCPLn584Qv-xg.png)

- **Simple Factory Pattern** `MyWKWebViewConfiguratorFactory` \-&gt; encapsulates the generation steps of `MyWKWebViewConfigurator`
- **Builder Pattern** `MyWKWebViewConfigurator` \-&gt; encapsulates the parameters and construction steps of `MyWKWebViewConfiguration`
- `MyWKWebViewConfiguration` injection \-&gt; for use in `MyWKWebViewController`
- **Chain of Responsibility Pattern** `MyWKWebViewController`'s `func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void)` \-&gt; calls `headNavigationHandler?.execute(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler)` for chain execution handling
- **Strategy Pattern** `MyWKWebViewController`'s `webView.configuration.userContentController.addUserScript(XXX)` dispatches the corresponding JS Caller to the appropriate handling strategy

#### Complete Demo Repo

[![](https://opengraph.githubassets.com/dc74860bc0c53748213df85fb768a4317fe357347a630b6a75bdaf5b2e36acb1/zhgchgli0718/DesignPatternsInWKWebViewDemo)](https://github.com/zhgchgli0718/DesignPatternsInWKWebViewDemo){:target="_blank"}

### Further Reading
- [Practical Applications of Design Patterns](../78507a8de6a5/)
- [Visitor Pattern in Swift (Share Object to XXX Example)](../ba5773a7bfea/)
- [Visitor Pattern in TableView](../60473cb47550/)

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/kkdaytech/design-patterns-%E7%9A%84%E5%AF%A6%E6%88%B0%E6%87%89%E7%94%A8%E7%B4%80%E9%8C%84-in-wkwebview-with-builder-strategy-chain-of-responsibility-pattern-f4b02ee342a4){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
