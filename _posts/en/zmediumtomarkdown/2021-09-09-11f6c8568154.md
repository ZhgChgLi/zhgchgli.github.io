---
title: "2021 Pinkoi Tech Career Talk — Secrets of an Efficient Engineering Team"
author: "ZhgChgLi"
date: 2021-09-09T12:13:53.982+0000
last_modified_at: 2024-09-06T06:01:21.053+0000
categories: ["Pinkoi Engineering"]
tags: ["pinkoi","automation","ios-app-development","engineering-management","workflow"]
description: "Tech Talk sharing on the secrets of Pinkoi's efficient engineering team"
image:
  path: /assets/11f6c8568154/1*WmP6qgq40go7IMDw1ZcCPg.png
render_with_liquid: false
---

### 2021 Pinkoi Tech Career Talk — Secrets of an Efficient Engineering Team

Tech Talk sharing on the secrets of Pinkoi's efficient engineering team


![](/assets/11f6c8568154/1*WmP6qgq40go7IMDw1ZcCPg.png)

### Secrets of an Efficient Engineering Team

2021/09/08 19:00 @ [Pinkoi x Yourator](https://www.accupass.com/event/2108230716001792899747){:target="_blank"}


![](/assets/11f6c8568154/1*0plljgmrQhyW0N5F9wtlrg.png)



![](/assets/11f6c8568154/1*7M1AgCebRbRMEgmdJh6rIA.jpeg)


**My Medium:** [ZhgChgLi](https://medium.com/u/8854784154b8){:target="_blank"}
### About the Team

**Pinkoi's work structure consists of multiple Squads:**
- Buyer-Squad: Focuses on buyer-side features
- Seller-Squad: Focuses on designer-side features
- Exploring-Squad: Focuses on browsing and exploration
- Ad-Squad: Focuses on platform advertising
- Out-Of-Squad: Primarily handles support, infrastructure, or process optimization


Each Squad is composed of team members from various functions, including PM, Product Designer, Data, Frontend, Backend, iOS, Android, etc.; long-term and ongoing work objectives are accomplished by the Squad.

In addition to Squads, there are also cross-team projects that usually have mid- to short-term work objectives. These can be initiated by any team member, regardless of their role, who acts as the Project Owner, and the project is closed upon completion.


> _At the end of the article, there is a section on **how Pinkoi's culture supports teammates in problem-solving**. If **you're not interested in the specifics of what was done, feel free to skip to the bottom of the page to view this section**._




### The Relationship Between Team Size and Efficiency


![](/assets/11f6c8568154/1*V7jEnBoR5XpRsPM-WF8GdA.png)


The growth in team size and its relationship with work efficiency is significant; having experienced teams ranging from 10 to 100 people (though I haven't yet faced a team of 1,000), the difference between 10 and 100 is quite noticeable in many aspects.

With fewer people, communication and task handling are quick; discussions can happen on the spot, and solutions can be provided immediately. The "connections between people" are strong, allowing for synchronized collaboration.

However, with a larger team, direct communication becomes challenging. As more people collaborate, time spent discussing can easily consume an entire morning; with many people involved, tasks must be prioritized, and non-urgent matters cannot be addressed immediately, leading to asynchronous waiting while other tasks are completed.


![](/assets/11f6c8568154/1*nkSy-H-33Jdtf10fISwqrw.png)


Adding more roles allows for more specialized work distribution, providing greater output or better quality and faster results.

But as mentioned earlier, this also means more collaboration, which in turn requires more communication time.

Small issues can be magnified; for example, if one person spends 10 minutes daily updating reports, that's manageable. But if this scales to 20 people, it could lead to an additional 3 hours spent daily on report updates. This is where optimizing and automating report updates becomes valuable—saving 3 hours daily over 250 working days a year results in a waste of 750 hours.


![](/assets/11f6c8568154/1*S-OXkos4LdViqlTtgP-DXg.png)


As the team size grows, for the App Team, there are several roles that require close collaboration.

Backend — API, Product Designer — UI, which is self-explanatory. Since Pinkoi is an international product, localization is necessary for feature text, and with our Data Team conducting data collection and analysis, discussions with the Data Team about event tracking points are also essential.

Customer Service frequently interacts with us as well; users sometimes directly leave feedback about order issues through the marketplace, and more often, they leave a one-star rating when encountering problems. In such cases, we need to ask the customer service team to conduct in-depth inquiries: What issue did you encounter? How can we assist you?


![](/assets/11f6c8568154/1*smgTFSo4jQFcbiOfiH42hQ.png)


With so many collaborative relationships, there are numerous communication opportunities.


> **_But remember, we are not trying to avoid or minimize communication; excellent engineers also need strong communication skills._** 





What we need to focus on is important communication, such as brainstorming, discussing requirements, and timelines; we should avoid wasting time on repetitive confirmations of issues or vague communications where everyone is asking questions without clarity.

Especially in the era of the pandemic, communication time is precious and should be dedicated to more valuable discussions.


![](/assets/11f6c8568154/1*ksnbNTYxBX4ou90D2WmmdA.png)


"I thought you thought I thought" — this phrase perfectly illustrates the consequences of vague communication.

Not only in work but also in daily life, we often encounter misunderstandings due to differing perceptions. In daily life, we rely on mutual understanding; however, in work, if there are differing perceptions without in-depth discussions, it is easy to discover discrepancies during the output phase.
### Interface Communication


![](/assets/11f6c8568154/1*AUPvV8j9-AWyHor-Ig_jiA.png)


The idea introduced here is to communicate through a consensus interface, similar to the Dependency Inversion Principle in object-oriented programming's SOLID principles (no need to understand it fully); the same concept can be applied to communication.

The first step is to identify areas that are vague, require repeated confirmations, or need focused and effective communication, even identifying deliverables that do not require additional communication.

Once the issues are identified, we can define the "interface," which serves as a medium—this could be a document, process, checklist, or tool, etc.

Using this "interface" as a bridge for communication, multiple interfaces can exist; use the appropriate interface for each scenario. When encountering similar situations, prioritize using this interface for initial communication; if further discussion is needed, it can be based on this interface for focused problem-solving.
#### App Team and External Collaboration Relationships

Here are four examples of interface communication in collaboration with the App Team:


![](/assets/11f6c8568154/1*QeKDmnbkrkQvMU2yn8FBZg.png)


The first example is the collaboration with Backend, which may lead to the situation depicted above without any consensus interface.

Regarding how to use the API, simply providing the API Response String to the App Team can lead to ambiguity; for instance, how do we know if `date` refers to the Register Date or Birthday? There are many fields that need clarification.

This communication is also repetitive; every time a new Endpoint is introduced, it needs to be confirmed again.

This is a classic case of ineffective communication.


![](/assets/11f6c8568154/1*FQy-Xr_V6sz9cuppumVaFw.png)


What the App and Backend lack is a communication interface. There are many solutions, and it doesn't necessarily have to be a tool; it could simply be a manually maintained document.


![[This was shared during the 2020 Pinkoi Developer Night — by Toki](https://www.yourator.co/articles/171#Toki){:target="_blank"}](/assets/11f6c8568154/1*q_MQ6y3RPKeO7q-zxSGqDg.png)

[This was shared during the 2020 Pinkoi Developer Night — by Toki](https://www.yourator.co/articles/171#Toki){:target="_blank"}

Pinkoi uses Python (FastAPI) to automatically generate documentation from API Code, while PHP can utilize Swagger (previously used by the company); the advantage is that the document's framework and data formats can be automatically generated from the code, reducing maintenance costs, only requiring proper field descriptions.

p.s. Currently, new Python 3 projects use FastAPI, while older projects will be gradually updated, temporarily using PostMan as the communication interface.


![](/assets/11f6c8568154/1*luRT1gAUkFuxSixkd-OsrA.png)


The second example is collaboration with Product Designers, which is similar to Backend but focuses on confirming UI Specs and Flow.

If color codes and fonts are scattered, our App will also suffer; aside from the inherent requirements, we want to avoid situations where the same Title has the same color but different codes or inconsistent UI in the same position.


![](/assets/11f6c8568154/1*smel97dJH6y2LzXdWTKYYw.jpeg)


The most basic solution is to have the designers organize the UI component library and establish a Design System (Guideline), marking the UI clearly when it's produced.

In our Code Base, we establish corresponding Fonts and Colors based on the Design System (Guideline) and create Buttons and Views according to the component library.

When templating, we uniformly use these established components, allowing us to quickly align with the UI design drafts.


> **_However, this can easily become chaotic and needs to be dynamically adjusted; it cannot cover too many exceptions, nor can it be rigid and inflexible._** 





p.s. Collaboration between Pinkoi and Product Designers is mutual; Developers can also propose better practices for discussion with Product Designers.


![](/assets/11f6c8568154/1*jWzR6iVOeXD9naa3KQllLw.png)


The third example is the interface with Customer Service. Marketplace reviews are crucial for products, but they involve a lot of manual and repetitive communication.

We need to periodically check new reviews manually, and if there are customer service issues, we forward them to the customer service team for assistance, which is quite repetitive and labor-intensive.


![](/assets/11f6c8568154/1*2e_pEWb1khuMTgJPkpCY9w.png)


The best solution is to enable marketplace reviews to automatically sync to our work platform, either by purchasing existing services or using my developed [ZhgChgLi](https://github.com/ZhgChgLi){:target="_blank"} / [ZReviewTender](https://github.com/ZhgChgLi/ZReviewTender){:target="_blank"} (new in 2022).


> _For deployment methods, tutorials, and technical details, refer to: [**ZReviewTender — Free Open Source App Reviews Monitoring Bot**](../e36e48bb9265/)_

This bot serves as our communication interface, automatically forwarding reviews to a Slack Channel, allowing everyone to quickly receive the latest review information and track discussions.


![](/assets/11f6c8568154/1*9SG2JlwEfNSJq9WxscfV5w.png)


The final example is our dependency on the Localization Team; whether for new features or modifying old translations, we need to wait for the Localization Team to complete their work before we can proceed.

![](/assets/11f6c8568154/1*vJcYjkcLpZcKRvgFzP5C1g.png)


The cost of developing our own tools is too high, so we directly use third-party services to help us eliminate dependency.

All translations and keys are managed by third-party tools; we just need to define the keys in advance to act independently, with both parties only needing to complete their work before the deadline; once the Localization Team finishes the translations, the tool automatically triggers a git pull to update the latest text files in the project.

p.s. Pinkoi has had this process in place for a long time, initially using Onesky, but in recent years, more excellent tools have become available for consideration.
#### Internal Collaboration Relationships within the App Team

Having discussed external collaboration, let's now focus on internal collaboration.


![](/assets/11f6c8568154/1*Jg0DrQsNe1QA6UOT3Z_elg.png)


When there are fewer people or when a single developer maintains a project, you can do whatever you want; your grasp and understanding of the project are high, so there are usually no issues. Of course, if you have good instincts, even a one-person project can achieve everything mentioned here.

However, as more teammates collaborate on the same project, if everyone continues to work independently, it can lead to disaster.

For example, if APIs are implemented inconsistently, with some doing it one way and others another, it often results in wasted time reinventing the wheel or carelessly pushing things live, which can significantly increase future maintenance and scalability costs.


![](/assets/11f6c8568154/1*5wBfMU9AiCVfmEcvmPZSiQ.png)


Within the team, rather than referring to interfaces, I think it’s more about consensus and resonance, fostering a stronger team spirit.

The most basic and often-discussed aspect is Coding Style, including naming conventions, placement, how to use Delegates, etc.; we can use commonly adopted tools like [realm](https://github.com/realm){:target="_blank"} / [SwiftLint](https://github.com/realm/SwiftLint){:target="_blank"} for constraints, and multi-language statements can be organized using [freshOS](https://github.com/freshOS){:target="_blank"} / [Localize](https://github.com/freshOS/Localize){:target="_blank"} (of course, if you are already using the aforementioned third-party tools for unified management, this may not be necessary).

The second aspect is the App architecture; whether it's MVC/MVVM/VIPER/Clean Architecture, the core focus should be on cleanliness and uniformity; there’s no need to chase trends, just ensure consistency.


> _The Pinkoi App Team uses [Clean Architecture](https://www.yourator.co/articles/171#Matt){:target="_blank"}._ 

> _Previously at StreetVoice, we used pure MVC, but it was clean and consistent, making collaboration smooth._ 





Additionally, Unit Testing is crucial; with more people, it’s hard to avoid the risk of breaking the logic you’re currently working on; writing more tests provides an extra layer of assurance.

Lastly, documentation is essential for outlining team processes, specifications, or operation manuals, making it easier for teammates to quickly reference when they forget or for newcomers to get up to speed.


![](/assets/11f6c8568154/1*8Ywxhvk1dzmDLGLunuHNww.png)


Beyond code-level interfaces, there are other interfaces that assist us in improving efficiency in collaboration.

The first is having a Request for Comments phase before implementing requirements, where the responsible developer briefly explains how the requirement will be addressed, allowing others to provide feedback and ideas.

```markdown
---
title: Enhancing Work Efficiency through Automation and Communication
---

Aside from preventing the reinvention of the wheel, we can also brainstorm collectively. For instance, we can consider how others might want to expand on what has been done, or what future needs might arise... etc. Those involved may be confused, but the observers can see clearly.

The second point is to conduct thorough Code Reviews to ensure that our interface consensus is being implemented correctly. This includes aspects like naming conventions, UI layout methods, delegate usage, protocol/class declarations, etc. We also need to check if the architecture is being misused or if code is being rushed, especially if we aim for a full transition to Swift and there’s still Objective-C code being sent... etc.

The main focus should be on reviewing these aspects, and only then on whether the functionality is working properly... and so on.

p.s. The purpose of an RFC is to enhance work efficiency, so it should not be overly lengthy, as that could severely hinder progress; think of it as a simple discussion phase before starting work.

![](/assets/11f6c8568154/1*nn--T1ToO7FxRUHAv_3vig.png)

To summarize the functionality of our team's interface consensus, I want to mention a **Crash Theory** mindset, which I believe serves as a good behavioral benchmark.

![Excerpt from [MBA Knowledge Base](https://wiki.mbalib.com/zh-tw/%E5%9D%A0%E6%9C%BA%E7%90%86%E8%AE%BA){:target="_blank"}](/assets/11f6c8568154/1*QJ8P_HjSvPdYrUmrqsQZXA.png)

Excerpt from [MBA Knowledge Base](https://wiki.mbalib.com/zh-tw/%E5%9D%A0%E6%9C%BA%E7%90%86%E8%AE%BA){:target="_blank"}

Applying this to the team, we should ask ourselves: if everyone suddenly disappeared, would the existing code, processes, and systems allow new people to quickly get up to speed?

![](/assets/11f6c8568154/1*Q44KLIwDjvAPuNDDf6KB3g.png)

Recapping the meaning of interfaces, the interfaces within the team are meant to enhance mutual understanding, while collaboration outside the team aims to reduce ineffective communication. Using interfaces as a communication tool should focus on discussing needs without interruptions.

![](/assets/11f6c8568154/1*WXYAk1_4fA0kll-HyMXL5w.png)

To reiterate, "interface communication" is not some special proprietary term or tool; it’s just a concept applicable to any collaborative work scenario. It can simply be a document or a process, and it’s essential to have this in place before moving on to communication.

![](/assets/11f6c8568154/1*oN-qJ4lNMtijsCoSIqrr_g.png)

Here, let’s assume that each time we spend an extra 10 minutes communicating, with a team of 60 people, and this happens 10 times a month, we waste 1,200 hours a year on unnecessary communication.
### Improving Efficiency — Automating Repetitive Tasks

![](/assets/11f6c8568154/1*vMq1UmYeW611XYf0yHv8AQ.png)

In this chapter, I want to share some insights on how automating repetitive tasks can enhance work efficiency, using iOS as an example, though the same principles apply to Android.

I won’t delve into technical implementation details, but rather discuss the feasibility of the principles.

![](/assets/11f6c8568154/1*i_0yUCYq6jl-7uf5mynxLA.png)

Let’s summarize the services we use, including but not limited to:
- Slack: Communication software
- Fastlane: iOS automation script tool
- Github: Git provider
- Github Action: CI/CD service from Github, which will be introduced later
- Firebase: Crashlytics, Event, App Distribution (to be introduced later), Remote Config...
- Google Apps Script: Plugin script for Google Apps, to be introduced later
- Bitrise: CI/CD server
- Onesky: A third-party tool for localization mentioned earlier
- Testflight: iOS app internal testing platform
- Google Calendar: Google Calendar, which will be introduced later
- Asana: Project management tool

#### Issues with Releasing Test Versions

![](/assets/11f6c8568154/1*kaNm3auxnqlJ4ObE84sitA.png)

The first repetitive issue arises when we want to allow other teammates to test the app during the development phase. Traditionally, this involves directly borrowing a phone to build the app; this is manageable with just 1-2 people, but with a team of 20-30, the day spent helping to install the test version becomes a workday lost. Moreover, if there are updates, everything has to be redone.

![](/assets/11f6c8568154/1*r_jYD3jukkUPKOdtnK8zyA.png)

Another method is to use TestFlight as a medium for releasing test versions, which I think is also good; however, there are two issues. First, TestFlight is equivalent to a production environment, not a debug one. Second, when many teammates are testing different requirements simultaneously, TestFlight can become chaotic, and the builds can change rapidly, though it’s still feasible.

![](/assets/11f6c8568154/1*XLB0THtHAM65_e4FdtEXKg.png)

At Pinkoi, the solution is to separate the task of "installing the test version by the App Team" using Slack Workflow as the input UI. Once the input is complete, it triggers Bitrise to run the Fastlane script to package and upload the test version IPA to Firebase App Distribution.

> _For reference on using Slack Workflow, see this article: [Creating a Fully Automated WFH Employee Health Reporting System with Slack](../d61062833c1a/)_

![](/assets/11f6c8568154/1*2mNIlReKlROzcgviY9_JTg.jpeg)

![Firebase App Distribution](/assets/11f6c8568154/1*dwwOvnVwuF1sCUnyppBCDQ.jpeg)

Teammates who need to test can simply follow the steps in Firebase App Distribution to install the certificates and register their devices, allowing them to choose which test version to install or directly click the link in the email to install.

> _However, note that iOS Firebase App Distribution uses Development Devices, with a limit of only 100 devices that can be registered, based on devices rather than individuals._

> _Thus, a trade-off may need to be made with TestFlight (which allows 1,000 external testers per person)._

At least the initial Slack Workflow UI input can be considered for adoption.

> _For advanced options, a Slack Bot can be developed for a more complete and customized process and forms._

![](/assets/11f6c8568154/1*-2oet_gRdews7-wccdrmiA.png)

Recapping the automation of releasing test versions, the most significant benefit is moving the entire process to the cloud, allowing the App Team to be hands-off and fully self-service.
#### Issues with Packaging Official Versions

The second common task for the App Team is packaging and submitting the official version of the app.

![](/assets/11f6c8568154/1*Fd245lp2QSQV7d3AIdf94w.png)

When the team is small, with only single-threaded development, updating app versions is not a big issue, allowing for both freedom and regularity.

However, with a larger team, where multiple threads of requirements are being developed and iterated, situations like the one depicted above can arise. If we do not properly implement the "interface communication" mentioned earlier, everyone will work independently, leading to the App Team being overwhelmed. The cost of app updates is higher than that of web updates, and the process is more cumbersome. Additionally, frequent and chaotic updates can disrupt users.

Finally, there’s a management issue. Without a fixed process and schedule, it becomes challenging to optimize what needs to be done at each step.

![](/assets/11f6c8568154/1*eRm97daYTwlEBFGtWoZgdQ.png)

The issues are as shown above.

![](/assets/11f6c8568154/1*3b_wX91dtYF0ogHjKsaR6g.png)

The solution is to introduce a Release Train into the development process. The core concept is to separate version updates from project development.

We will fix the schedule and define what needs to be done at each stage:
- Fixed updates on Monday mornings
- Fixed code freeze on Wednesdays (no more merging feature PRs)
- Fixed QA starts on Thursdays
- Fixed packaging of the official version on Fridays

The actual schedule (how long QA takes) and release cycle (weekly, bi-weekly, monthly) can be adjusted according to each company's situation. **The core is to determine what fixed tasks need to be done at what time.**

This is a survey of version update cycles shared by international peers, most of which are bi-weekly.

![](/assets/11f6c8568154/1*uOXXmdDoocyFImsq-z7tVQ.png)

Taking our weekly updates and multi-team approach as an example, it would look like the image above.

As the name suggests, the Release Train operates like a train station, where each version is a train.

**If you miss it, you have to wait for the next one.** Each squad team and project can choose when to board.

This serves as a great communication interface; as long as everyone has a consensus and adheres to the rules, updates can proceed in an orderly manner.

**For more technical details on Release Train, refer to:**
- [Mobile release trains — Travelperk](https://speakerdeck.com/lgvalle/mobile-release-trains){:target="_blank"}
- [Agile Release Train](https://www.scaledagileframework.com/agile-release-train/){:target="_blank"}
- [Release Quality and Mobile Trains](https://developers.soundcloud.com/blog/quality-mobile-trains){:target="_blank"}

![](/assets/11f6c8568154/1*DZwSmwnVCGkO--1PEzgqgw.png)

Once the processes and schedules are established, we can optimize what needs to be done at each stage.

For instance, packaging the official version traditionally takes a lot of time and effort. The entire process from packaging, uploading, to submission takes about an hour, during which one has to constantly switch work states, making it difficult to focus on other tasks. Each packaging session repeats this process, wasting work efficiency.

![](/assets/11f6c8568154/1*RPSgRUXh3ITDJykQ6N-DTw.png)

Since we have already fixed the schedule, we can directly integrate Google Calendar, adding the tasks to be done on the planned dates. When the time comes, Google Apps Script will call Bitrise to execute the Fastlane script for packaging the official version and submitting it, completing all tasks.

Using Google Calendar integration also has the advantage that if unexpected situations arise requiring delays or advancements, one can simply change the date.

> _Currently, to automatically execute Google Apps Script at the time of a Google Calendar event, one must run a service themselves. For a quick solution, IFTTT can be used as a bridge between Google Calendar and Bitrise/Google Apps Script. For details, refer to this article: [Link](https://gist.github.com/tanaikech/fbbfaa8f2a8a770424974aa16b9b6f3b){:target="_blank"}._

p.s.
1. Currently, the Pinkoi iOS Team uses the Gitflow workflow.
2. In principle, this consensus should be adhered to by all teams, so we do not want any requirements that break this rule (e.g., needing to go live on a special Wednesday). However, for projects involving external collaboration, flexibility must be maintained if absolutely necessary, as this consensus is internal to the team.
3. Hotfixes for serious issues can be updated at any time, regardless of the Release Train regulations.

![](/assets/11f6c8568154/1*tBGh-uxgoCTXfQ-u4GZq8g.png)

I’ve also mentioned the application of Google Apps Scripts; for details, refer to: [Using Google Apps Script to Forward Gmail Messages to Slack](../d414bdbdb8c9/).

![](/assets/11f6c8568154/1*gdwkOBumSPH469IMCd8TVw.png)

The last point is using Github Action to enhance collaboration efficiency (PR Review).

Github Action is Github's CI/CD service that can be directly linked to Github events, with triggers available for actions such as opening issues, opening PRs, and merging PRs, among others.

Github Action can be used for any Git project hosted on Github. Public repositories have no restrictions, while private ones have a free quota of 2,000 minutes per month.

**Here are two functionalities:**
- (Left) After a PR review is completed, it automatically labels the reviewer’s name, allowing us to quickly summarize the PR review status.
- (Right) Every day at a fixed time, it organizes and sends messages to a Slack channel, reminding teammates of PRs awaiting review ([mimicking the functionality of Pull Reminders](https://pullreminders.com/){:target="_blank"}).

Github Action has many automation possibilities; everyone can unleash their imagination.

For instance, issue bots commonly seen in open-source projects:

![[fastlane](https://github.com/fastlane){:target="_blank"} / [fastlane](https://github.com/fastlane/fastlane){:target="_blank"}](/assets/11f6c8568154/1*64GaqzcldMHwU-HE4yt3_A.png)

[fastlane](https://github.com/fastlane){:target="_blank"} / [fastlane](https://github.com/fastlane/fastlane){:target="_blank"}

Or automatically closing PRs that haven’t been merged for too long can also be accomplished using Github Action.

![](/assets/11f6c8568154/1*olR70CQ2zbvTWwzh72-gRQ.png)

Recapping the effectiveness of automating the packaging of official versions, we again directly use existing tools for integration; in addition to **automation, we also incorporate fixed processes to double enhance work efficiency.**

Originally, aside from the time spent on manual packaging, there was also the additional cost of communicating about the release time, which is now reduced to zero; as long as we ensure we **board** on schedule, we can focus all our time on "discussion" and "development."

![](/assets/11f6c8568154/1*8CZSygOrZbXPVIDzx2AFRQ.png)

Calculating the total impact of these two automations, we can save 216 work hours in a year.

![](/assets/11f6c8568154/1*d3I-cJoeUiT_h2uvZ8PgFw.png)

With automation combined with the previously mentioned communication interfaces, let’s see how much efficiency we can enhance overall.

![](/assets/11f6c8568154/1*xMFfrYqGJD6CPY8YTIVMIg.png)

In addition to the items just discussed, we also need to evaluate the **cost of switching flow states**. When we are continuously engaged in work for a period, we enter a "flow" state, where our thoughts and productivity peak, allowing us to produce the most effective output. However, if we are interrupted by unnecessary matters (e.g., excessive communication, repetitive tasks), returning to the flow state will require additional time, which we can estimate at 30 minutes.

![](/assets/11f6c8568154/1*_1Pe12uYqddPyd5muKuTMw.png)

The cost of switching flow states due to unnecessary interruptions should also be factored in; here, we estimate 30 minutes each time, occurring 10 times a month, resulting in an additional 3,600 hours wasted in a year for a team of 60.

![](/assets/11f6c8568154/1*TllAhkbBRr7H1PSFB-iyfg.png)

The cost of switching flow states (3,600) + the extra communication due to poor communication interfaces (1,200) + the repetitive work solved by automation (216) = a total loss of 5,016 hours in a year.

The time wasted can be redirected towards more valuable tasks, so the actual productivity gain should be multiplied by 200%.

> **_Especially as the team size continues to grow, the impact on work efficiency also amplifies._**

> **_Optimize early to enjoy the benefits; delaying optimization comes with no discounts!!_**

![](/assets/11f6c8568154/1*kRiuACBFiI-xjyxt_oKRMw.png)

Recapping the inner workings of a high-efficiency work team, we mainly focused on what we did.
```

```markdown
> **_No Code/Low Code First_** _Prioritize using existing tools for integration (like in this example). If there are no available tools, then evaluate the cost of automation against the actual savings in revenue._

### Support for Culture

![At Pinkoi, everyone can be a problem-solving leader](/assets/11f6c8568154/1*HtF6bI9jcL95Dn3AHRXmcw.png)

At Pinkoi, everyone can be a problem-solving leader.

For solving problems and making changes, it often requires a lot of teamwork to achieve better outcomes. This is where company culture plays a crucial role in providing support and encouragement; otherwise, pushing things forward alone can be very challenging.

> _At Pinkoi, everyone can be a problem-solving leader. You don't have to be a Lead or PM to solve problems. Many of the communication interfaces, tools, or automation projects mentioned earlier are identified by teammates who discover issues and propose solutions, working together to complete them._

![](/assets/11f6c8568154/1*nbSdYTY3AQEVdCOYkWh04A.png)

Regarding how team culture supports driving change, the four stages of problem-solving can be linked to Pinkoi's Core Values.

**Step One: Grow Beyond Yesterday**
- Always strive for better. If you notice a problem, regardless of its size, remember that as the team grows, even small issues can have a magnified effect.
- Investigate and summarize the issues, avoiding premature optimization (some problems may just be temporary transitions).

**Next is Build Partnerships**
- Actively communicate and gather suggestions from all angles.
- Maintain empathy (as some problems may be the best solution for others, so weigh your options carefully).

**Step Three: Impact Beyond Your Role**
- Leverage your influence.
- Propose problem-solving plans.
- If it relates to repetitive tasks, prioritize using automation solutions.
- Remember to maintain flexibility and scalability to avoid over-engineering.

**Finally, Dare to Fail!**
- Be brave in practice.
- Continuously track and dynamically adjust solutions.
- **After achieving success, remember to share the results with the team to facilitate cross-departmental resource integration** (as the same problem may exist in multiple departments).

**This concludes the sharing from Pinkoi's highly efficient engineering team. Thank you, everyone.**

Join Pinkoi now >>> [https://www\.pinkoi\.com/about/careers](https://www.pinkoi.com/about/careers){:target="_blank"}

If you have any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/pinkoi-engineering/2021-pinkoi-tech-career-talk-%E9%AB%98%E6%95%88%E7%8E%87%E5%B7%A5%E7%A8%8B%E5%9C%98%E9%9A%8A%E5%A4%A7%E8%A7%A3%E5%AF%86-11f6c8568154){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```