---
title: "iOS UITextView Image Wrapping Editor (Swift)"
author: "ZhgChgLi"
date: 2018-10-13T18:07:49.431+0000
last_modified_at: 2024-04-13T07:11:24.880+0000
categories: ["ZRealm Dev."]
tags: ["swift","ios","mobile-app-development","uitextview","ios-app-development"]
description: "Text"
image:
  path: /assets/e37d66ea1146/1*Sh0XaryqYnqVGV0wJ_dDHA.gif
render_with_liquid: false
---

### iOS UITextView Image Wrapping Editor \(Swift\)

Practical Route

#### Target Features:

The app includes a discussion forum feature that allows users to publish articles. The article publishing interface needs to support text input, insertion of multiple images, and image wrapping.
#### Functional Requirements:
- Ability to input multiple lines of text
- Ability to insert images within the text
- Ability to upload multiple images
- Ability to freely remove inserted images
- Image upload effects/error handling
- Ability to translate input content into transmittable text, e.g., BBCODE

#### Here’s a preview of the finished product:


![[Marriage App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}](/assets/e37d66ea1146/1*Sh0XaryqYnqVGV0wJ_dDHA.gif)

[Marriage App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}
### Getting Started:
#### Chapter One

What? You say Chapter One? Isn’t it just using UITextView to achieve the editor functionality? Why does it need to be divided into "chapters"? Yes, that was my initial reaction too, until I started working on it and realized things were not that simple. I struggled for two weeks, sifting through various resources both domestically and internationally before finally finding a solution. Let me share my journey of implementation...

If you want to know the final solution directly, please skip to the last chapter \(scroll down, down, down, down, down\).
#### At the Beginning

The text editor naturally uses the UITextView component. After looking at the documentation, I found that UITextView's attributedText comes with the NSTextAttachment object, which can attach images to achieve the image wrapping effect. The code is quite simple:
```swift
let imageAttachment = NSTextAttachment()
imageAttachment.image = UIImage(named: "example")
self.contentTextView.attributedText = NSAttributedString(attachment: imageAttachment)
```

At that time, I naively thought it was quite simple and convenient; however, the real challenges were just beginning:
- Images need to be selectable and uploadable from local storage: This is easy to solve. I used the [TLPhotoPicker](https://github.com/tilltue/TLPhotoPicker){:target="_blank"} library (supports multiple image selection/custom settings/camera switching/Live Photos). The specific approach is to convert the PHAsset to UIImage after selecting images with TLPhotoPicker and assign it to imageAttachment.image, while also uploading the images to the server in the background.
- Image uploads need to have effects and allow interactive operations (click to view the original image/click X to delete): I couldn't achieve this; I couldn't find a way to make NSTextAttachment fulfill this requirement. However, it’s okay that this feature is missing since you can still delete images (by pressing the "Back" key on the keyboard after the image). Let's continue...
- Original image files are too large, causing slow uploads and insertions, and consuming performance: Resize the images before insertion and upload using [Kingfisher](https://github.com/onevcat/Kingfisher){:target="_blank"}'s resizeTo.
- Images should be inserted at the cursor's current position: Here, I had to modify the original code as follows:

```swift
let range = self.contentTextView.selectedRange.location ?? NSRange(location: 0, length: 0)
let combination = NSMutableAttributedString(attributedString: self.contentTextView.attributedText) // Get current content
combination.insert(NSAttributedString(attachment: imageAttachment), at: range)
self.contentTextView.attributedText = combination // Write back
```
- Handling image upload failures: Here, I need to mention that I actually wrote a separate class to extend the original NSTextAttachment, with the purpose of adding an extra property to store an identifier value.

```swift
class UploadImageNSTextAttachment:NSTextAttachment {
   var uuid:String?
}
```

When uploading an image, change it to:
```swift
let id = UUID().uuidString
let attachment = UploadImageNSTextAttachment()
attachment.uuid = id
```

Once we can identify the corresponding NSTextAttachment, we can search for the NSTextAttachment in attributedText for images that failed to upload, find them, and replace them with an error prompt image or remove them directly.
```swift
if let content = self.contentTextView.attributedText {
    content.enumerateAttributes(in: NSMakeRange(0, content.length),  options: NSAttributedString.EnumerationOptions(rawValue: 0)) { (object, range, stop) in
        if object.keys.contains(NSAttributedStringKey.attachment) {
            if let attachment = object[NSAttributedStringKey.attachment] as? UploadImageNSTextAttachment,attachment.uuid == "targetID" {
                attachment.bounds = CGRect(x: 0, y: 0, width: 30, height: 30)
                attachment.image =  UIImage(named: "IconError")
                let combination = NSMutableAttributedString(attributedString: content)
                combination.replaceCharacters(in: range, with: NSAttributedString(attachment: attachment))
                //To remove directly, use deleteCharacters(in: range)
                self.contentTextView.attributedText = combination
            }
        }
    }
}
```

After overcoming the above issues, the code will look something like this:
```swift
class UploadImageNSTextAttachment:NSTextAttachment {
    var uuid:String?
}
func dismissPhotoPicker(withTLPHAssets: [TLPHAsset]) {
    //TLPhotoPicker image picker callback
    
    let range = self.contentTextView.selectedRange.location ?? NSRange(location: 0, length: 0)
    //Get the cursor position, or start from the beginning if none
    
    guard withTLPHAssets.count > 0 else {
        return
    }
    
    DispatchQueue.global().async { in
        //Handle in the background
        let orderWithTLPHAssets = withTLPHAssets.sorted(by: { $0.selectedOrder > $1.selectedOrder })
        orderWithTLPHAssets.forEach { (obj) in
            if var image = obj.fullResolutionImage {
                
                let id = UUID().uuidString
                
                var maxWidth:CGFloat = 1500
                var size = image.size
                if size.width > maxWidth {
                    size.width = maxWidth
                    size.height = (maxWidth/image.size.width) * size.height
                }
                image = image.resizeTo(scaledToSize: size)
                //Thumbnail
                
                let attachment = UploadImageNSTextAttachment()
                attachment.bounds = CGRect(x: 0, y: 0, width: size.width, height: size.height)
                attachment.uuid = id
                
                DispatchQueue.main.async {
                    //Switch back to the main thread to update UI and insert image
                    let combination = NSMutableAttributedString(attributedString: self.contentTextView.attributedText)
                    attachments.forEach({ (attachment) in
                        combination.insert(NSAttributedString(string: "\n"), at: range)
                        combination.insert(NSAttributedString(attachment: attachment), at: range)
                        combination.insert(NSAttributedString(string: "\n"), at: range)
                    })
                    self.contentTextView.attributedText = combination
                    
                }
                
                //Upload image to Server
                //Alamofire post or....
                //POST image
                //if failed {
                    if let content = self.contentTextView.attributedText {
                        content.enumerateAttributes(in: NSMakeRange(0, content.length),  options: NSAttributedString.EnumerationOptions(rawValue: 0)) { (object, range, stop) in
                            
                            if object.keys.contains(NSAttributedStringKey.attachment) {
                                if let attachment = object[NSAttributedStringKey.attachment] as? UploadImageNSTextAttachment,attachment.uuid == obj.key {
                                    
                                    //REPLACE:
                                    attachment.bounds = CGRect(x: 0, y: 0, width: 30, height: 30)
                                    attachment.image = //ERROR Image
                                    let combination = NSMutableAttributedString(attributedString: content)
                                    combination.replaceCharacters(in: range, with: NSAttributedString(attachment: attachment))
                                    //OR DELETE:
                                    //combination.deleteCharacters(in: range)
                                    
                                    self.contentTextView.attributedText = combination
                                }
                            }
                        }
                    }
                //}
                //
                
            }
        }
    }
}
```


Almost all the problems have been resolved, but what has troubled me for two weeks?

Answer: "Memory" issue


![iPhone 6 can't handle it!](/assets/e37d66ea1146/1*IcnoXq6e6OUnU_mg83XDxg.gif)

iPhone 6 can't handle it!

The above method inserts more than 5 images, and UITextView starts to lag; to a certain extent, the app will crash directly due to memory overload.

p.s. I have tried various compression/other storage methods, but the results remain the same.

The reason is speculated to be that UITextView does not reuse the NSTextAttachment for images; all the images you insert are loaded into memory and will not be released. Therefore, unless they are small images used for inserting emojis 😅, they cannot be used for wrapping text at all.
#### Chapter Two

After discovering this "hard injury" of memory, I continued to search for solutions online and found the following other methods:
- Use WebView to embed HTML files ( &lt;div contentEditable=”true”&gt;&lt;/div&gt;) and interact with WebView using JS.
- Combine UITableView with UITextView for reuse.
- Extend UITextView based on TextKit🏆


The first method of using WebView to embed HTML files; considering performance and user experience, I will not consider it. Interested friends can search for related solutions on GitHub (EX: [RichTextDemo](https://github.com/xiaosheng0601/RichTextDemo){:target="_blank"}).

The second method combines UITableView with UITextView.

I implemented about 70% of it, specifically, each line is a Cell, with two types of Cells: one is UITextView and the other is UIImageView, with one line of text and one line of image; the content must be stored in an array to avoid disappearing during the reuse process.

It can excellently reuse to solve the memory issue, but I still gave up in the end. The two parts of **controlling the end of the line to press Return to create a new line and jump to that line** and **controlling the beginning of the line to press the Back key to jump to the previous line (if the current line is empty, it should be able to delete that line)** were very difficult to control.

Interested friends can refer to: [MMRichTextEdit](https://gitee.com/dhar/MMRichTextEdit){:target="_blank"}.
#### Final Chapter

Having come this far has consumed a lot of time, and the development schedule has been severely delayed; the final solution is to use TextKit.

Here are two articles I found for friends interested in research:
- [Exploring TextKit](https://www.jianshu.com/p/3f445d7f44d6){:target="_blank"}
- [Optimizing Text Rendering from UITextView](http://djs66256.github.io/2016/06/23/2016-06-23-cong-uitextviewkan-wen-zi-hui-zhi-you-hua/){:target="_blank"}


However, there is a certain learning curve, which is too difficult for me as a beginner. Moreover, time is running out, so I can only aimlessly search for other solutions on GitHub.

Eventually, I found the project [XLYTextKitExtension](https://github.com/kaizeiyimi/XLYTextKitExtension){:target="_blank"}, which can be directly imported for use.

✔ Allows NSTextAttachment to support custom UIView, and any interaction operations can be added.

✔ NSTextAttachment can be reused without overwhelming memory.

The specific implementation method is similar to **Chapter One**, just that it originally used NSTextAttachment and now uses XLYTextAttachment.

For the UITextView you want to use:
```swift
contentTextView.setUseXLYLayoutManager()
```

Tip 1: Change the place where you insert NSTextAttachment to:
```swift
let combine = NSMutableAttributedString(attributedString: NSAttributedString(string: ""))
let imageView = UIView() // your custom view
let imageAttachment = XLYTextAttachment { () -> UIView in
    return imageView
}
imageAttachment.id = id
imageAttachment.bounds = CGRect(x: 0, y: 0, width: size.width, height: size.height)
combine.append(NSAttributedString(attachment: imageAttachment))
self.contentTextView.textStorage.insert(combine, at: range)
```

Tip 2: Change NSTextAttachment search to
```php
self.contentTextView.textStorage.enumerateAttribute(NSAttributedStringKey.attachment, in: NSRange(location: 0, length: self.contentTextView.textStorage.length), options: []) { (value, range, stop) in
    if let attachment = value as? XLYTextAttachment {
        //attachment.id
    }
}
```

Tip 3: Change to delete NSTextAttachment items
```swift
self.contentTextView.textStorage.deleteCharacters(in: range)
```

Tip 4: Get the current content length
```swift
self.contentTextView.textStorage.length
```

Tip 5: Refresh the size of the Attachment's Bounds

The main reason is for user experience; when inserting an image, I first place a loading image, and the inserted image will be replaced after being compressed in the background. The Bounds of the TextAttachment need to be updated to the resized size.
```swift
self.contentTextView.textStorage.addAttributes([:], range: range)
```

\(Add empty attributes to trigger refresh\)

Tip 6: Translate the input content into transferable text

Use Tip 2 to search all input content and extract the IDs of the found Attachments to combine them into a format similar to \[ \[ID\] \] for transmission.

Tip 7: Content replacement
```swift
self.contentTextView.textStorage.replaceCharacters(in: range, with: NSAttributedString(attachment: newImageAttachment))
```

Tip 8: Regular expression to match the content's Range
```swift
let pattern = "(\\[\\[image_id=){1}([0-9]+){1}(\\]\\]){1}"
let textStorage = self.contentTextView.textStorage

if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {
    while true {
        let range = NSRange(location: 0, length: textStorage.length)
        if let match = regex.matches(in: textStorage.string, options: .withTransparentBounds, range: range).first {
            let matchString = textStorage.attributedSubstring(from: match.range)
            //FINDED!
        } else {
            break
        }
    }
}
```

Note: If you want to search & replace items, you need to use a while loop; otherwise, when there are multiple search results, finding the first one and replacing it will cause the range of subsequent search results to be incorrect, leading to a crash.
#### Conclusion

Currently, this method has been used to complete the product and go online, and I haven't encountered any problems; I will take some time to explore the principles behind it!

This article is more of a personal problem-solving experience rather than a tutorial; if you are also implementing similar functions, I hope it helps you. If you have any questions or suggestions, feel free to contact me.

> Medium's official first article

### Further Reading
- [ZMarkupParser HTML String to NSAttributedString Tool](../a5643de271e4/)
- [The Things About Manually Creating an HTML Parser](../2724f02f6e7/)

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-uitextview-%E6%96%87%E7%B9%9E%E5%9C%96%E7%B7%A8%E8%BC%AF%E5%99%A8-swift-e37d66ea1146){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._

It seems there is no Markdown content provided for translation. Please provide the text you would like me to translate.
