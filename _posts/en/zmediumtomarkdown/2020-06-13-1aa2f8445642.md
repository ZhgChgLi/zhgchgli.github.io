---
title: "A Compilation of Decode Issues Encountered in Real-World Use of Codable"
author: "ZhgChgLi"
date: 2020-06-13T16:33:58.105+0000
last_modified_at: 2024-04-13T08:24:35.445+0000
categories: ["ZRealm Dev."]
tags: ["ios","ios-app-development","codable","json","decode"]
description: "From basics to advanced, a deep dive into using Decodable to address all possible problem scenarios."
image:
  path: /assets/1aa2f8445642/1*9VYP3_Mhj9xsLKbgCwt6XQ.jpeg
render_with_liquid: false
---

### A Compilation of Decode Issues Encountered in Real-World Use of Codable (Part 1)

From basics to advanced, a deep dive into using Decodable to address all possible problem scenarios.



![Photo by [Gustas Brazaitis](https://unsplash.com/@gustasbrazaitis){:target="_blank"}](/assets/1aa2f8445642/1*9VYP3_Mhj9xsLKbgCwt6XQ.jpeg)

Photo by [Gustas Brazaitis](https://unsplash.com/@gustasbrazaitis){:target="_blank"}
### Introduction

In response to the backend API upgrade, adjustments to the API processing architecture were necessary. Recently, we took this opportunity to update the network processing architecture originally written in Objective-C to Swift. Due to the difference in languages, it was no longer suitable to use the original [Restkit](https://github.com/RestKit/RestKit){:target="_blank"} to handle our network layer applications. However, it must be said that Restkit's functionality is incredibly powerful, and it was used effectively in the project with minimal issues. On the downside, it is quite heavy, almost no longer maintained, and purely Objective-C; thus, it will inevitably need to be replaced in the future.

Restkit handled almost all the functionalities required for network requests, from basic network processing, API calls, network handling, to response processing of JSON String to Object, and even storing Objects in Core Data. It was a comprehensive framework that could do the work of ten.

With the evolution of the times, current frameworks no longer focus on a one-size-fits-all approach; instead, they emphasize flexibility, lightness, and modularity, allowing for greater adaptability and creativity. Therefore, while replacing it with Swift, we chose to use Moya as the networking component, while other required functionalities would be combined using different methods.
### Main Topic

Regarding the JSON String to Object Mapping part, we used Swift's built-in Codable (Decodable) protocol & JSONDecoder for processing. We also split the Entity/Model to enhance responsibility separation, operation, and readability, while considering the mixed Code Base of Objective-C and Swift.

> _＊ The Encodable part is omitted; the examples only demonstrate the implementation of Decodable, which is quite similar, as being able to Decode also means being able to Encode._ 

### Getting Started

Assuming our initial API Response JSON String is as follows:
```json
{
  "id": 123456,
  "comment": "It's告五人, not五告人!",
  "target_object": {
    "type": "song",
    "id": 99,
    "name": "披星戴月的想你"
  },
  "commenter": {
    "type": "user",
    "id": 1,
    "name": "zhgchgli",
    "email": "zhgchgli@gmail.com"
  }
}
```

From the above example, we can break it down into three Entities & Models: User/Song/Comment, allowing us to create reusable components. For convenience in demonstration, we will write the Entity/Model in the same file.

User:
```swift
// Entity:
struct UserEntity: Decodable {
    var id: Int
    var name: String
    var email: String
}

//Model:
class UserModel: NSObject {
    init(_ entity: UserEntity) {
      self.id = entity.id
      self.name = entity.name
      self.email = entity.email
    }
    var id: Int
    var name: String
    var email: String
}
```


Song:
```swift
// Entity:
struct SongEntity: Decodable {
    var id: Int
    var name: String
}

//Model:
class SongModel: NSObject {
    init(_ entity: SongEntity) {
      self.id = entity.id
      self.name = entity.name
    }
    var id: Int
    var name: String
}
```

Comment:
```swift
// Entity:
struct CommentEntity: Decodable {
    enum CodingKeys: String, CodingKey {
      case id
      case comment
      case targetObject = "target_object"
      case commenter
    }
    
    var id: Int
    var comment: String
    var targetObject: SongEntity
    var commenter: UserEntity
}

//Model:
class CommentModel: NSObject {
    init(_ entity: CommentEntity) {
      self.id = entity.id
      self.comment = entity.comment
      self.targetObject = SongModel(entity.targetObject)
      self.commenter = UserModel(entity.commenter)
    }
    var id: Int
    var comment: String
    var targetObject: SongModel
    var commenter: UserModel
}
```

JSONDecoder:
```swift
let jsonString = "{ \"id\": 123456, \"comment\": \"It's告五人, not 五告人!\", \"target_object\": { \"type\": \"song\", \"id\": 99, \"name\": \"披星戴月的想你\" }, \"commenter\": { \"type\": \"user\", \"id\": 1, \"name\": \"zhgchgli\", \"email\": \"zhgchgli@gmail.com\" } }"
let jsonDecoder = JSONDecoder()
do {
    let result = try jsonDecoder.decode(CommentEntity.self, from: jsonString.data(using: .utf8)!)
} catch {
    print(error)
}
```
#### CodingKeys Enum?

When the JSON String Key Name does not match the Entity Object Property Name, we can add a CodingKeys enumeration internally for mapping, as we cannot control the Naming Convention of the backend data source.
```swift
case PropertyKeyName = "backend_field_name"
case PropertyKeyName // If not specified, defaults to using PropertyKeyName as the backend field name
```

Once the CodingKeys enumeration is added, all non-Optional fields must be enumerated; you cannot only list the keys you want to customize.

Another way is to set the JSONDecoder's keyDecodingStrategy. If the Response data fields and Property Names differ only by `snake_case` &lt;\-&gt; `camelCase`, you can directly set `.keyDecodingStrategy` = `.convertFromSnakeCase` to automatically match the mapping.
```swift
let jsonDecoder = JSONDecoder()
jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
try jsonDecoder.decode(CommentEntity.self, from: jsonString.data(using: .utf8)!)
```
#### When the returned data is an array:
```swift
struct SongListEntity: Decodable {
    var songs:[SongEntity]
}
```
#### Adding constraints to String:
```swift
struct SongEntity: Decodable {
  var id: Int
  var name: String
  var type: SongType
  
  enum SongType {
    case rock
    case pop
    case country
  }
}
```

```markdown
Applicable to string types with a limited scope, written as an Enum for easier transmission and usage; if an enumerated value appears, decoding will fail!
#### Make good use of generics to wrap fixed structures:

Assuming the fixed format of the JSON String returned is:
```json
{
  "count": 10,
  "offset": 0,
  "limit": 0,
  "results": [
    {
      "type": "song",
      "id": 1,
      "name": "1"
    }
  ]
}
```

You can wrap it using generics:
```swift
struct PageEntity<E: Decodable>: Decodable {
    var count: Int
    var offset: Int
    var limit: Int
    var results: [E]
}
```

Usage: `PageEntity<Song>.self`
#### Date/Timestamp Automatic Decoding:

Set the `dateDecodingStrategy` of `JSONDecoder`
- `.secondsSince1970/.millisecondsSince1970`: unix timestamp
- `.deferredToDate`: Apple's timestamp, rarely used, different from unix timestamp, this starts from 2001/01/01
- `.iso8601`: ISO 8601 date format
- `.formatted(DateFormatter)`: Decode Date according to the passed DateFormatter
- `.custom`: Custom Date decoding logic


**\.custom Example: Assume the API returns both YYYY/MM/DD and ISO 8601 formats, both need to be decoded:**
```swift
var dateFormatter = DateFormatter()
var iso8601DateFormatter = ISO8601DateFormatter()

let decoder: JSONDecoder = JSONDecoder()
decoder.dateDecodingStrategy = .custom({ (decoder) -> Date in
    let container = try decoder.singleValueContainer()
    let dateString = try container.decode(String.self)
    
    //ISO8601:
    if let date = iso8601DateFormatter.date(from: dateString) {
        return date
    }
    
    //YYYY-MM-DD:
    dateFormatter.dateFormat = "yyyy-MM-dd"
    if let date = dateFormatter.date(from: dateString) {
        return date
    }
    
    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Cannot decode date string \(dateString)")
})

let result = try jsonDecoder.decode(CommentEntity.self, from: jsonString.data(using: .utf8)!)
```


> _＊DateFormatter is very performance-intensive during initialization, so reuse it as much as possible._ 




#### Basic Decoding Knowledge:
1. The field types (struct/class/enum) within the Decodable Protocol must implement the Decodable Protocol; or assign values during the init decoder.
2. Decoding will fail if the field types do not match.
3. If a field in a Decodable Object is set as Optional, it is optional; if provided, it will decode.
4. Optional fields can accept: JSON String with no field, provided but given nil.
5. Blank and 0 do not equal nil; nil is nil; be cautious with weakly typed backend APIs!
6. By default, if a Decodable Object has an enumerated field that is non-Optional and the JSON String does not provide it, decoding will fail (subsequent sections will explain how to handle this).
7. By default, encountering a decoding failure will directly interrupt and exit; it cannot simply skip erroneous data (subsequent sections will explain how to handle this).
```

```markdown
![[Left: "" / Right: nil](https://josjong.com/2017/10/16/null-vs-empty-strings-why-oracle-was-right-and-apple-is-not/){:target="_blank"}](/assets/1aa2f8445642/1*B-j47uMMshXozF32msbRtg.jpeg)

[Left: "" / Right: nil](https://josjong.com/2017/10/16/null-vs-empty-strings-why-oracle-was-right-and-apple-is-not/){:target="_blank"}
### Advanced Usage

Up to this point, the basic usage has been completed, but the real world is not that simple; below are several advanced scenarios that may be encountered along with applicable Codable solutions. From here on, we can no longer rely on the original Decode to assist us with Mapping; we need to implement `init(from decoder: Decoder)` for custom Decode operations.

> _*Here, only the Entity part is temporarily displayed; the Model is not yet needed._ 

#### init\(from decoder: Decoder\)

In the init decoder, all non-Optional fields must be assigned initial values (that's the init!).

When customizing Decode operations, we need to obtain the `container` from the `decoder` to operate on the values. There are three types of content retrieval for the `container`.

![](/assets/1aa2f8445642/1*U2Rt9KZq3Vw_lkZkJl7t_Q.png)

**First type container\(keyedBy: CodingKeys\.self\)** **Operate according to CodingKeys:**
```swift
struct SongEntity: Decodable {
    var id: Int
    var name: String
    
    enum CodingKeys: String, CodingKey {
      case id
      case name
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try container.decode(Int.self, forKey: .id)
        // Parameter 1 accepts support: classes that implement Decodable
        // Parameter 2 CodingKeys
        
        self.name = try container.decode(String.self, forKey: .name)
    }
}
```

**Second type singleValueContainer** **Extract the entire package (single value):**
```swift
enum HandsomeLevel: Decodable {
    case handsome(String)
    case normal(String)
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let name = try container.decode(String.self)
        if name == "zhgchgli" {
            self = .handsome(name)
        } else {
            self = .normal(name)
        }
    }
}

struct UserEntity: Decodable {
    var id: Int
    var name: HandsomeLevel
    var email: String
    
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case email
    }
}
```

Applicable for Associated Value Enum field types, such as name which also carries a level of handsomeness!

**Third type unkeyedContainer** **Treat the entire package as an array:**
```swift
struct ListEntity: Decodable {
    var items:[Decodable]
    init(from decoder: Decoder) throws {
        var unkeyedContainer = try decoder.unkeyedContainer()
        self.items = []
        while !unkeyedContainer.isAtEnd {
            // The internal pointer of unkeyedContainer will automatically point to the next object after the decode operation
            // Until it points to the end, it indicates that the traversal is complete
            if let id = try? unkeyedContainer.decode(Int.self) {
                items.append(id)
            } else if let name = try? unkeyedContainer.decode(String.self) {
                items.append(name)
            }
        }
    }
}

let jsonString = "[\"test\",1234,5566]"
let jsonDecoder = JSONDecoder()
let result = try jsonDecoder.decode(ListEntity.self, from: jsonString.data(using: .utf8)!)
print(result)
```

```markdown
Applicable to array fields of non-fixed types.
#### Under Container, we can also use nestedContainer / nestedUnkeyedContainer to operate on specific fields:


> **_＊Flatten data fields (similar to flatMap)_** 






![](/assets/1aa2f8445642/1*IE_dCAdXGDMaW-nSNT2ITg.png)

```swift
struct ListEntity: Decodable {
    
    enum CodingKeys: String, CodingKey {
        case items
        case date
        case name
        case target
    }
    
    enum PredictKey: String, CodingKey {
        case type
    }
    
    var date: Date
    var name: String
    var items: [Decodable]
    var target: Decodable
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        self.date = try container.decode(Date.self, forKey: .date)
        self.name = try container.decode(String.self, forKey: .name)
        
        let nestedContainer = try container.nestedContainer(keyedBy: PredictKey.self, forKey: .target)
        
        let type = try nestedContainer.decode(String.self, forKey: .type)
        if type == "song" {
            self.target = try container.decode(SongEntity.self, forKey: .target)
        } else {
            self.target = try container.decode(UserEntity.self, forKey: .target)
        }
        
        var unkeyedContainer = try container.nestedUnkeyedContainer(forKey: .items)
        self.items = []
        while !unkeyedContainer.isAtEnd {
            if let song = try? unkeyedContainer.decode(SongEntity.self) {
                items.append(song)
            } else if let user = try? unkeyedContainer.decode(UserEntity.self) {
                items.append(user)
            }
        }
    }
}
```

Accessing and decoding objects at different levels, the example demonstrates how to use nestedContainer to flatten the type and then decode accordingly based on the type.
#### Decode & DecodeIfPresent
- **DecodeIfPresent:** Decoding will only occur if the response provides the data field (when the Codable property is set to Optional).
- **Decode:** Performs the decode operation, and if the response does not provide the data field, it will throw an error.



> **_＊The above is just a brief introduction to the methods and functionalities of init decoder and container. It's okay if you don't understand; let's directly enter a real-world scenario and experience the combined operations in the example._** 




### Real-World Scenario

Returning to the original example JSON String.
#### Scenario 1. Suppose today a comment could be directed at either a song or a person. How should we handle the `targetObject` field, which could be either `User` or `Song`?
```json
{
  "results": [
    {
      "id": 123456,
      "comment": "It's the Five People, not the Five People!",
      "target_object": {
        "type": "song",
        "id": 99,
        "name": "Missing You Under the Stars"
      },
      "commenter": {
        "type": "user",
        "id": 1,
        "name": "zhgchgli",
        "email": "zhgchgli@gmail.com"
      }
    },
    {
      "id": 55,
      "comment": "66666!",
      "target_object": {
        "type": "user",
        "id": 1,
        "name": "zhgchgli"
      },
      "commenter": {
        "type": "user",
        "id": 2,
        "name": "aaaa",
        "email": "aaaa@gmail.com"
      }
    }
  ]
}
```
#### Method a.
```

Using Enum as a Container for Decode.
```swift
struct CommentEntity: Decodable {
    
    enum CodingKeys: String, CodingKey {
      case id
      case comment
      case targetObject = "target_object"
      case commenter
    }
    
    var id: Int
    var comment: String
    var targetObject: TargetObject
    var commenter: UserEntity
    
    enum TargetObject: Decodable {
        case song(SongEntity)
        case user(UserEntity)
        
        enum PredictKey: String, CodingKey {
            case type
        }
        
        enum TargetObjectType: String, Decodable {
            case song
            case user
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: PredictKey.self)
            let singleValueContainer = try decoder.singleValueContainer()
            let targetObjectType = try container.decode(TargetObjectType.self, forKey: .type)
            
            switch targetObjectType {
            case .song:
                let song = try singleValueContainer.decode(SongEntity.self)
                self = .song(song)
            case .user:
                let user = try singleValueContainer.decode(UserEntity.self)
                self = .user(user)
            }
        }
    }
}
```

We change the `targetObject` property to an Associated Value Enum, deciding what content to place in the Enum during Decode.

The core practice is to establish a Decodable Enum as a container, first extracting the key field to determine (the `type` field in the example JSON String), and if it is `Song`, use the singleValueContainer to decode it into `SongEntity`, and similarly for `User`.

**To use it, extract from the Enum:**
```swift
//if case let
if case let CommentEntity.TargetObject.user(user) = result.targetObject {
    print(user)
} else if case let CommentEntity.TargetObject.song(song) = result.targetObject {
    print(song)
}

//switch case let
switch result.targetObject {
case .song(let song):
    print(song)
case .user(let user):
    print(user)
}
```
#### Method b.

Change the property declaration to Base Class.
```swift
struct CommentEntity: Decodable {
    enum CodingKeys: String, CodingKey {
      case id
      case comment
      case targetObject = "target_object"
      case commenter
    }
    enum PredictKey: String, CodingKey {
        case type
    }
    
    var id: Int
    var comment: String
    var targetObject: Decodable
    var commenter: UserEntity
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try container.decode(Int.self, forKey: .id)
        self.comment = try container.decode(String.self, forKey: .comment)
        self.commenter = try container.decode(UserEntity.self, forKey: .commenter)
        
        //
        let targetObjectContainer = try container.nestedContainer(keyedBy: PredictKey.self, forKey: .targetObject)
        let targetObjectType = try targetObjectContainer.decode(String.self, forKey: .type)
        if targetObjectType == "user" {
            self.targetObject = try container.decode(UserEntity.self, forKey: .targetObject)
        } else {
            self.targetObject = try container.decode(SongEntity.self, forKey: .targetObject)
        }
    }
}
```

The principle is similar, but here we first use `nestedContainer` to access `targetObject` and retrieve `type` for judgment, then decide what type `targetObject` should be parsed into.

**Cast when using:**
```swift
if let song = result.targetObject as? Song {
  print(song)
} else if let user = result.targetObject as? User {
  print(user)
}
```
#### Scenario 2. How to Decode when the data array contains multiple types of data?
```
{
  "results": [
    {
      "type": "song",
      "id": 99,
      "name": "Missing You Under the Stars"
    },
    {
      "type": "user",
      "id": 1,
      "name": "zhgchgli",
      "email": "zhgchgli@gmail.com"
    }
  ]
}
```

Combine the solution mentioned above with `nestedUnkeyedContainer` + Scenario 1; you can also use **Scenario 1**'s **a. solution** to access values using an Associated Value Enum.
#### Scenario 3. Decode only when the JSON String field has a value
```
[
  {
    "type": "song",
    "id": 99,
    "name": "Missing You Under the Stars"
  },
    {
    "type": "song",
    "id": 11
  }
]
```

Use decodeIfPresent to perform decoding.
#### Scenario 4. Skip decoding failed data in the array
```json
{
  "results": [
    {
      "type": "song",
      "id": 99,
      "name": "Missing You Under the Stars"
    },
    {
      "error": "error"
    },
    {
      "type": "song",
      "id": 19,
      "name": "Take Me to Nightlife"
    }
  ]
}
```

As mentioned earlier, Decodable defaults to requiring all data parsing to be correct for mapping output; sometimes, the data provided by the backend is unstable, giving a long array but with some entries missing fields or having mismatched field types, leading to decoding failures; this causes the entire package to fail and return nil.
```swift
struct ResultsEntity: Decodable {
    enum CodingKeys: String, CodingKey {
        case results
    }
    var results: [SongEntity]
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        var nestedUnkeyedContainer = try container.nestedUnkeyedContainer(forKey: .results)
        
        self.results = []
        while !nestedUnkeyedContainer.isAtEnd {
            if let song = try? nestedUnkeyedContainer.decode(SongEntity.self) {
                self.results.append(song)
            } else {
                let _ = try nestedUnkeyedContainer.decode(EmptyEntity.self)
            }
        }
    }
}

struct EmptyEntity: Decodable { }

struct SongEntity: Decodable {
    var type: String
    var id: Int
    var name: String
}

let jsonString = "{ \"results\": [ { \"type\": \"song\", \"id\": 99, \"name\": \"Missing You Under the Stars\" }, { \"error\": \"error\" }, { \"type\": \"song\", \"id\": 19, \"name\": \"Take Me to Nightlife\" } ] }"
let jsonDecoder = JSONDecoder()
let result = try jsonDecoder.decode(ResultsEntity.self, from: jsonString.data(using: .utf8)!)
print(result)
```


The solution is similar to **the solution in Scenario 2**; `nestedUnkeyedContainer` iterates through each item and attempts to `try? Decode`. If the Decode fails, it uses Empty Decode to allow the internal pointer of `nestedUnkeyedContainer` to continue executing.


> _*This method is somewhat of a workaround, as we cannot skip commands for `nestedUnkeyedContainer`, and `nestedUnkeyedContainer` must successfully decode to continue execution; hence this approach. I saw in the Swift community that someone proposed adding [moveNext()](https://forums.swift.org/t/pitch-unkeyeddecodingcontainer-movenext-to-skip-items-in-deserialization/22151/16){:target="_blank"}, but it has not been implemented in the current version.*_ 




#### Scenario 5. Some fields are for internal use in my program and are not meant to be decoded.
#### Method a. Entity/Model

Here, I want to mention what I said at the beginning about splitting the functionality of Entity/Model; the Entity is solely responsible for JSON String to Entity (Decodable) Mapping; the Model is initialized with the Entity, and the actual program passes, operates, and handles business logic using the Model.
```swift
struct SongEntity: Decodable {
    var type: String
    var id: Int
    var name: String
}

class SongModel: NSObject {
    init(_ entity: SongEntity) {
        self.type = entity.type
        self.id = entity.id
        self.name = entity.name
    }
    
    var type: String
    var id: Int
    var name: String
    
    var isSave:Bool = false //business logic
}
```

**Benefits of splitting Entity/Model:**
1. Clear responsibilities: Entity: JSON String to Decodable, Model: business logic
2. Easy to see which fields are mapped just by looking at the Entity
3. Avoids clutter when there are many fields
4. **Objective-C can also use it** (since Model is just NSObject, struct/Decodable is not visible in Objective-C)
5. Business logic and fields for internal use can be placed in the Model

#### Method b. Handling init

List the CodingKeys and exclude fields for internal use, providing default values during init or setting fields to have default values or be optional, but these are not good methods; they just allow the code to run.
#### [2020/06/26 Update] — Next article Scenario 6. How to decode API Response using 0/1 to represent Bool?
- [Summary of Decode issues encountered in practical use of Codable (Part 2)](../cb00b1977537/)

#### [2020/06/26 Update] — Next article Scenario 7. Not wanting to rewrite init decoder every time
- [Summary of Decode issues encountered in practical use of Codable (Part 2)](../cb00b1977537/)

#### [2020/06/26 Update] — Next article Scenario 8. Reasonable handling of Response Null field data
- [Summary of Decode issues encountered in practical use of Codable (Part 2)](../cb00b1977537/)

### Comprehensive Scenario Example

A complete example integrating both basic and advanced usage:
```
{
  "count": 5,
  "offset": 0,
  "limit": 10,
  "results": [
    {
      "id": 123456,
      "comment": "It's the Five People, not the Five People!",
      "target_object": {
        "type": "song",
        "id": 99,
        "name": "Missing You Under the Stars",
        "create_date": "2020-06-13T15:21:42+0800"
      },
      "commenter": {
        "type": "user",
        "id": 1,
        "name": "zhgchgli",
        "email": "zhgchgli@gmail.com",
        "birthday": "1994/07/18"
      }
    },
    {
      "error": "not found"
    },
    {
      "error": "not found"
    },
    {
      "id": 2,
      "comment": "Haha, me too!",
      "target_object": {
        "type": "user",
        "id": 1,
        "name": "zhgchgli",
        "email": "zhgchgli@gmail.com",
        "birthday": "1994/07/18"
      },
      "commenter": {
        "type": "user",
        "id": 1,
        "name": "Passerby A",
        "email": "man@gmail.com",
        "birthday": "2000/01/12"
      }
    }
  ]
}
```

**Output:**
```
zhgchgli: It's Accusefive, not Five Accuse!

Complete example demonstration as above!
### (Next) Article & Other Scenarios Updated:
- [Summary of Decode Issues Encountered with Codable in Real Use (Next)](../cb00b1977537/)

### Summary

The benefits of choosing to use Codable are, first and foremost, because it is native, so there’s no fear of future maintenance issues, and it looks nice to write; however, the limitations are relatively strict, making it less flexible in parsing JSON Strings. Otherwise, it requires doing more as discussed in this article, and its performance is actually not superior to using other mapping libraries (Decodable still uses NSJSONSerialization from the Objective-C era for parsing). However, I believe that in future updates, Apple may optimize this, and we won’t need to change our code.

The scenarios and examples in the article may be quite extreme, but sometimes you just have to deal with them; of course, I hope that under normal circumstances, simple Codable can meet our needs; but with the above tricks, there should be no insurmountable problems!

> _Thanks to [＠saiday](https://twitter.com/saiday){:target="_blank"} for the technical support._

[![Accusefive【Take Me to Night Life】Official Music Video](/assets/1aa2f8445642/43b3_hqdefault.jpg "Accusefive【Take Me to Night Life】Official Music Video")](https://www.youtube.com/watch?v=W9Fq1HC_5hg){:target="_blank"}

### Further Reading
1. [In-depth Decodable — Writing a JSON Parser Beyond Native](https://kemchenj.github.io/2018-06-03/){:target="_blank"} 
   A wealth of content to understand Decoder/JSONDecoder in depth.
2. [Looking at Problems from Different Angles — From Codable to Swift Metaprogramming](https://onevcat.com/2018/03/swift-meta/){:target="_blank"}
3. [Why Model Objects Shouldn’t Implement Swift’s Decodable or Encodable Protocols](https://medium.com/better-programming/why-model-objects-shouldnt-implement-swift-s-decodable-or-encodable-protocols-1249cb44d4b3){:target="_blank"}

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/%E7%8F%BE%E5%AF%A6%E4%BD%BF%E7%94%A8-codable-%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84-decode-%E5%95%8F%E9%A1%8C%E5%A0%B4%E6%99%AF%E7%B8%BD%E5%8C%AF-1aa2f8445642){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```
