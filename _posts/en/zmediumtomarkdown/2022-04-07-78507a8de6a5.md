---
title: "Practical Applications of Design Patterns"
author: "ZhgChgLi"
date: 2022-04-07T14:49:17.715+0000
last_modified_at: 2024-09-06T06:00:33.888+0000
categories: ["Pinkoi Engineering"]
tags: ["ios-app-development","design-patterns","socketio","websocket","finite-state-machine"]
description: "The problem scenarios encountered and the design patterns applied when encapsulating the Socket.IO Client Library."
image:
  path: /assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg
pin: true
render_with_liquid: false
---

### Practical Applications of Design Patterns

The problem scenarios encountered and the design patterns applied when encapsulating the Socket.IO Client Library.


![Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg)

Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Introduction

This article documents real development needs and the scenarios where design patterns were used to solve problems. The content will cover the background of the requirements, the actual problems encountered (What?), why patterns were applied to solve these problems (Why?), and how they were implemented (How?). It is recommended to read from the beginning for better coherence.


> _This article will introduce four scenarios encountered during the development of this requirement and seven design patterns applied to solve these scenarios._ 




### Background
#### Organizational Structure

Our company has split into multiple Feature Teams and a Platform Team this year; the former is primarily responsible for user-side requirements, while the Platform Team deals with internal members of the company. One of their tasks is to introduce technology, infrastructure, and ensure systematic integration, paving the way for Feature Teams when developing requirements.
#### Current Requirements

Feature Teams want to change the original messaging function (fetching message data by hitting an API when entering the page, with the only way to update the latest messages being a refresh) to real-time messaging (being able to receive the latest messages instantly and send messages).
#### Platform Team's Work

The Platform Team focuses not only on the immediate real-time messaging needs but also on long-term construction and reusability. After evaluation, the webSocket bidirectional communication mechanism is deemed essential in modern apps. Besides this requirement, there will be many future opportunities to use it. Given the available human resources, they decided to assist in designing and developing the interface.

**Goals:**
- Encapsulate communication and authentication logic between Pinkoi Server Side and Socket.IO
- Simplify the cumbersome operations of Socket.IO, providing an extensible and user-friendly interface based on Pinkoi's business needs
- Standardize the interface across both platforms **(the functionalities and interfaces supported by Socket.IO's Android and iOS Client Side Libraries are different)**
- Feature teams do not need to understand the Socket.IO mechanism
- Feature teams do not need to manage complex connection states
- Future webSocket bidirectional communication needs can be directly utilized


**Time and Resources:**
- One person dedicated to iOS & Android each
- Development timeline: 3 weeks

#### Technical Details

The feature will be supported across Web, iOS, and Android platforms; the webSocket bidirectional communication protocol will be introduced to achieve this, with the backend expected to directly use [Socket.io](http://socket.io/){:target="_blank"} services.


> **_First, it should be noted that Socket \!= WebSocket_** 





For more information about Socket and WebSocket and technical details, please refer to the following two articles:
- [Differences between Socket, WebSocket, and Socket.io](https://leesonhsu.blogspot.com/2018/07/socketwebsocketsocketio.html){:target="_blank"}
- [Why not use socket directly and define a new websocket?](https://github.com/onlyliuxin/coding2017/issues/497){:target="_blank"}



In short:
```
Socket is an abstract encapsulation interface of the TCP/UDP transport layer, while WebSocket is a transport protocol at the application layer. The relationship between Socket and WebSocket is like that between a dog and a hot dog; they are unrelated.
```


![](/assets/78507a8de6a5/1*MC_nQC382khMeWggLejWOA.jpeg)


Socket.IO is an abstract operational encapsulation layer over Engine.IO, which is a wrapper for using WebSocket. Each layer is responsible for communication between the layers above and below, and direct operations are not allowed (e.g., Socket.IO directly manipulating WebSocket connections).

In addition to basic WebSocket connections, Socket.IO/Engine.IO implements many convenient and useful features (e.g., offline event sending mechanism, similar to HTTP request mechanism, Room/Group mechanism, etc.).

The main responsibility of the Platform Team is to bridge the logic between Socket.IO and the Pinkoi Server Side for the upper Feature Teams to use when developing functionalities.
#### [Socket.IO Swift Client](https://github.com/socketio/socket.io-client-swift){:target="_blank"} has pitfalls
- It has not been updated for a long time (the latest version is still from 2019), and it is uncertain whether it is still maintained.
- The Client & Server Side Socket IO versions must align; the Server Side can add `{allowEIO3: true}` / or the Client Side must specify the same version `.version`, otherwise, it won't connect no matter what.
- The naming conventions, interfaces, and examples on the official website often do not match.
- The examples on the Socket.io official website are presented using the web, but in reality, the Swift Client **does not necessarily support all the features described on the official website**. During this implementation, it was found that the iOS library did not implement the offline event sending mechanism (we implemented it ourselves, please continue reading).

> **_It is recommended to experiment with the mechanisms you want to use with Socket.IO beforehand to see if they are supported._** 

> _The Socket.IO Swift Client is a wrapper based on the **[Starscream](https://github.com/daltoniam/Starscream){:target="_blank"}** WebSocket Library, and can be downgraded to use Starscream if necessary._ 




```
Background information ends here, and we will now get to the main topic.
```
### Design Patterns

Design patterns are simply common solutions to recurring problems in software design. It is not necessary to use design patterns to develop, and design patterns may not be applicable in all scenarios. No one says you cannot derive new design patterns on your own.

![[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}](/assets/78507a8de6a5/1*MAm5WPynbv7M9tdmW2lNGQ.jpeg)

[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}

However, the existing design patterns (The 23 Gang of Four Design Patterns) have become common knowledge in software design. Whenever a specific pattern is mentioned, everyone will have a corresponding architectural blueprint in mind, requiring no further explanation. This also makes subsequent maintenance easier to understand, and these methods have been validated by the industry, so there is no need to spend time scrutinizing object dependency issues. Choosing the appropriate pattern for the right scenario can reduce communication and maintenance costs and improve development efficiency.

> **_Design patterns can be used in combination, but it is not recommended to modify existing design patterns excessively, or to apply them forcefully without justification, or to apply patterns that do not fit the classification (e.g., using the responsibility chain pattern to create objects), as this will lose the meaning of their use and may cause misunderstandings for those who take over later._** 




#### Design Patterns mentioned in this article:
- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"}
- [Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"}
- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"}
- [Command Pattern](https://refactoring.guru/design-patterns/command){:target="_blank"}
- [Finite-State Machine](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"} + [State Pattern](https://refactoring.guru/design-patterns/state){:target="_blank"}
- [Chain Of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility){:target="_blank"}
- [Builder Pattern](https://refactoring.guru/design-patterns/builder){:target="_blank"}



Each scenario will be explained one by one later on.

> _This article focuses on the application of Design Patterns rather than the operation of Socket.IO. Some examples may be simplified for convenience, **and may not be applicable to a real Socket.IO encapsulation**._ 

> _Due to space limitations, this article will not provide a detailed introduction to the structure of each design pattern. Please click on the links for each pattern to understand its structure before continuing to read._ 

> _Demo Code will be written in Swift._ 

### Requirement Scenario 1.
#### What?
- Use the same Path to request a Connection on different pages or Objects, allowing for the reuse of the same object.
- The Connection must be an abstract interface, not directly dependent on the Socket.IO Object.

#### Why?
- Reduce memory overhead and the time and traffic costs of repeated connections.
- Reserve space for future replacement with other frameworks.

#### How?
- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"}: A creational pattern that ensures a class has only one instance and provides a global point of access to it.
- [Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"}: A structural pattern that allows sharing of objects to support a large number of fine-grained objects efficiently.
- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"}: A creational pattern that defines an interface for creating an object but lets subclasses alter the type of objects that will be created.

**Practical Case Usage:**

![](/assets/78507a8de6a5/1*flQa_EfErGBwbmEwpI7ZgQ.png)

- **Singleton Pattern:** The `ConnectionManager` exists as a single object throughout the App Lifecycle, managing the operations for obtaining `Connection`.
- **Flyweight Pattern:** The `ConnectionPool` is a shared pool of Connections, where methods uniformly retrieve Connections from this pool. The logic includes directly providing an existing Connection from the pool when the same URL Path is detected. The `ConnectionHandler` serves as the external operator and state manager for the `Connection`.
- **Factory Pattern:** The `ConnectionFactory`, in conjunction with the Flyweight Pattern, generates a new Connection using this factory interface when no reusable `Connection` is available in the pool.

```swift
import Combine
import Foundation

protocol Connection {
    var url: URL {get}
    var id: UUID {get}
    
    init(url: URL)
    
    func connect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

protocol ConnectionFactory {
    func create(url: URL) -> Connection
}

class ConnectionPool {
    
    private let connectionFactory: ConnectionFactory
    private var connections: [Connection] = []
    
    init(connectionFactory: ConnectionFactory) {
        self.connectionFactory = connectionFactory
    }
    
    func getOrCreateConnection(url: URL) -> Connection {
        if let connection = connections.first(where: { $0.url == url }) {
            return connection
        } else {
            let connection = connectionFactory.create(url: url)
            connections.append(connection)
            return connection
        }
    }
    
}

class ConnectionHandler {
    private let connection: Connection
    init(connection: Connection) {
        self.connection = connection
    }
    
    func getConnectionUUID() -> UUID {
        return connection.id
    }
}

class ConnectionManager {
    static let shared = ConnectionManager(connectionPool: ConnectionPool(connectionFactory: SIOConnectionFactory()))
    private let connectionPool: ConnectionPool
    private init(connectionPool: ConnectionPool) {
        self.connectionPool = connectionPool
    }
    
    //
    func requestConnectionHandler(url: URL) -> ConnectionHandler {
        let connection = connectionPool.getOrCreateConnection(url: url)
        return ConnectionHandler(connection: connection)
    }
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

class SIOConnectionFactory: ConnectionFactory {
    func create(url: URL) -> Connection {
        //
        return SIOConnection(url: url)
    }
}
//

print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/1")!).getConnectionUUID().uuidString)
print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/1")!).getConnectionUUID().uuidString)

print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/2")!).getConnectionUUID().uuidString)

// output:
// D99F5429-1C6D-4EB5-A56E-9373D6F37307
// D99F5429-1C6D-4EB5-A56E-9373D6F37307
// 599CF16F-3D7C-49CF-817B-5A57C119FE31
```
### Requirement Scenario 2.
#### What?


As described in the background technical details, the Socket.IO Swift Client's `Send Event` does not support offline sending (unlike the Web/Android versions of the library), so the iOS side needs to implement this functionality on its own.
```
Interestingly, the Socket.IO Swift Client - onEvent supports offline subscriptions.
```
#### Why?
- Unified cross-platform functionality
- Code is easier to understand

#### How?
- [Command Pattern](https://refactoring.guru/design-patterns/command){:target="_blank"}: A behavioral pattern that encapsulates operations as objects, providing a collection of operations such as queuing, delaying, and canceling.

![](/assets/78507a8de6a5/1*O9zc28nMx64HDiDy4aiexA.png)

- **Command Pattern:** `SIOManager` is the lowest-level encapsulation for communicating with Socket.IO. The `send` and `request` methods are operations for Socket.IO Send Event. When it detects that the current Socket.IO is in a disconnected state, it places the request parameters into `bufferedCommands`, which are processed one by one when reconnected (First In First Out).

```swift
protocol BufferedCommand {
    var sioManager: SIOManagerSpec? { get set }
    var event: String { get }
    
    func execute()
}

struct SendBufferedCommand: BufferedCommand {
    let event: String
    weak var sioManager: SIOManagerSpec?
    
    func execute() {
        sioManager?.send(event)
    }
}

struct RequestBufferedCommand: BufferedCommand {
    let event: String
    let callback: (Data?) -> Void
    weak var sioManager: SIOManagerSpec?
    
    func execute() {
        sioManager?.request(event, callback: callback)
    }
}

protocol SIOManagerSpec: AnyObject {
    func connect()
    func disconnect()
    func onEvent(event: String, callback: @escaping (Data?) -> Void)
    func send(_ event: String)
    func request(_ event: String, callback: @escaping (Data?) -> Void)
}

enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

class SIOManager: SIOManagerSpec {
        
    var state: ConnectionState = .disconnected {
        didSet {
            if state == .connected {
                executeBufferedCommands()
            }
        }
    }
    
    private var bufferedCommands: [BufferedCommand] = []
    
    func connect() {
        state = .connected
    }
    
    func disconnect() {
        state = .disconnected
    }
    
    func send(_ event: String) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self))
            return
        }
        
        print("Send:\(event)")
    }
    
    func request(_ event: String, callback: @escaping (Data?) -> Void) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self))
            return
        }
        
        print("request:\(event)")
    }
    
    func onEvent(event: String, callback: @escaping (Data?) -> Void) {
        //
    }
    
    func appendBufferedCommands(connectionCommand: BufferedCommand) {
        bufferedCommands.append(connectionCommand)
    }
    
    func executeBufferedCommands() {
        // First in, first out
        bufferedCommands.forEach { connectionCommand in
            connectionCommand.execute()
        }
        bufferedCommands.removeAll()
    }
    
    func removeAllBufferedCommands() {
        bufferedCommands.removeAll()
    }
}

let manager = SIOManager()
manager.send("send_event_1")
manager.send("send_event_2")
manager.request("request_event_1") { _ in
    //
}
manager.state = .connected
```


Similarly, it can be implemented for `onEvent`.

Extension: The [Proxy Pattern](https://refactoring.guru/design-patterns/proxy){:target="_blank"} can also be applied, treating the Buffer functionality as a type of Proxy.
### Requirement Scenario 3.
#### What?

The Connection has multiple states, with ordered transitions between states, and different operations allowed for each state.


![](/assets/78507a8de6a5/1*DBl6K1cPQc_cHOYXZ1VQ8A.jpeg)



![](/assets/78507a8de6a5/1*-Xk_TT6SMW5Jxd-c8iSCcw.jpeg)

- Created: The object has been created, allowing transitions to `Connected` or directly to `Disconnected`
- Connected: Connected to Socket.IO, allowing transition to `Disconnected`
- Disconnected: Disconnected from Socket.IO, allowing transitions to `Reconnecting`, `Released`
- Reconnecting: Attempting to reconnect to Socket.IO, allowing transitions to `Connected`, `Disconnected`
- Released: The object has been marked for garbage collection, disallowing any operations or state transitions

#### Why?
- The logic and representation of state transitions are not easy to manage.
- Each state needs to restrict operation methods (e.g., when State = Released, calling Send Event is not allowed), directly using if...else makes the code difficult to maintain and read.

#### How?
- [Finite State Machine](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"}: Manages transitions between states.
- [State Pattern](https://refactoring.guru/design-patterns/state){:target="_blank"}: A behavioral pattern that provides different handling when the state of an object changes.



![](/assets/78507a8de6a5/1*NgehABZTiXL_fFEYQh63Hg.png)

- **Finite State Machine**: `SIOConnectionStateMachine` is the implementation of the state machine, `currentSIOConnectionState` is the current state, and `created, connected, disconnected, reconnecting, released` lists the possible transition states of this state machine.
`enterXXXState() throws` implements the allowed and disallowed transitions (throw error) when entering a certain state from the Current State.
- **State Pattern**: `SIOConnectionState` is the abstract interface for operation methods used by all states.

```swift
protocol SIOManagerSpec: AnyObject {
    func connect()
    func disconnect()
    func onEvent(event: String, callback: @escaping (Data?) -> Void)
    func send(_ event: String)
    func request(_ event: String, callback: @escaping (Data?) -> Void)
}

enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

class SIOManager: SIOManagerSpec {
        
    var state: ConnectionState = .disconnected {
        didSet {
            if state == .connected {
                executeBufferedCommands()
            }
        }
    }
    
    private var bufferedCommands: [BufferedCommand] = []
    
    func connect() {
        state = .connected
    }
    
    func disconnect() {
        state = .disconnected
    }
    
    func send(_ event: String) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self))
            return
        }
        
        print("Send:\(event)")
    }
    
    func request(_ event: String, callback: @escaping (Data?) -> Void) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self))
            return
        }
        
        print("request:\(event)")
    }
    
    func onEvent(event: String, callback: @escaping (Data?) -> Void) {
        //
    }
    
    func appendBufferedCommands(connectionCommand: BufferedCommand) {
        bufferedCommands.append(connectionCommand)
    }
    
    func executeBufferedCommands() {
        // First in, first out
        bufferedCommands.forEach { connectionCommand in
            connectionCommand.execute()
        }
        bufferedCommands.removeAll()
    }
    
    func removeAllBufferedCommands() {
        bufferedCommands.removeAll()
    }
}

let manager = SIOManager()
manager.send("send_event_1")
manager.send("send_event_2")
manager.request("request_event_1") { _ in
    //
}
manager.state = .connected

//

class SIOConnectionStateMachine {
    
    private(set) var currentSIOConnectionState: SIOConnectionState!

    private var created: SIOConnectionState!
    private var connected: SIOConnectionState!
    private var disconnected: SIOConnectionState!
    private var reconnecting: SIOConnectionState!
    private var released: SIOConnectionState!
    
    init() {
        self.created = SIOConnectionCreatedState(stateMachine: self)
        self.connected = SIOConnectionConnectedState(stateMachine: self)
        self.disconnected = SIOConnectionDisconnectedState(stateMachine: self)
        self.reconnecting = SIOConnectionReconnectingState(stateMachine: self)
        self.released = SIOConnectionReleasedState(stateMachine: self)
        
        self.currentSIOConnectionState = created
    }
    
    func enterConnected() throws {
        if [created.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(connected)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Connected")
        }
    }
    
    func enterDisconnected() throws {
        if [created.connectionState, connected.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(disconnected)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Disconnected")
        }
    }

    func enterReconnecting() throws {
        if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(reconnecting)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Reconnecting")
        }
    }

    func enterReleased() throws {
        if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(released)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Released")
        }
    }
    
    private func enter(_ state: SIOConnectionState) {
        currentSIOConnectionState = state
    }
}


protocol SIOConnectionState {
    var connectionState: ConnectionState { get }
    var stateMachine: SIOConnectionStateMachine { get }
    init(stateMachine: SIOConnectionStateMachine)

    func onConnected() throws
    func onDisconnected() throws
    
    
    func connect(socketManager: SIOManagerSpec) throws
    func disconnect(socketManager: SIOManagerSpec) throws
    func release(socketManager: SIOManagerSpec) throws
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws
    func send(socketManager: SIOManagerSpec, event: String) throws
}

struct SIOConnectionStateMachineError: Error {
    let message: String

    init(_ message: String) {
        self.message = message
    }

    var localizedDescription: String {
        return message
    }
}

class SIOConnectionCreatedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .created
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("CreatedState can't disconnect!")
    }
}

class SIOConnectionConnectedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .connected
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }
    
    func onConnected() throws {
        //
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionDisconnectedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .disconnected
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        //
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        try stateMachine.enterReleased()
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        try stateMachine.enterReconnecting()
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionReconnectingState: SIOConnectionState {
    
    let connectionState: ConnectionState = .reconnecting
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReconnectState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReconnectState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionReleasedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .released
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        throw SIOConnectionStateMachineError("ReleasedState can't onConnected!")
    }
    
    func onDisconnected() throws {
        throw SIOConnectionStateMachineError("ReleasedState can't onDisconnected!")
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't release!")
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't request!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't receiveOn!")
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't send!")
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't disconnect!")
    }
}

do {
    let stateMachine = SIOConnectionStateMachine()
    // mock on socket.io connect:
    // socketIO.on(connect){
    try stateMachine.currentSIOConnectionState.onConnected()
    try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: "test")
    try stateMachine.currentSIOConnectionState.release(socketManager: manager)
    try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: "test")
    // }
} catch {
    print("error: \(error)")
}

// output:
// error: SIOConnectionStateMachineError(message: "ConnectedState can\'t release!")
```
### Requirement Scenario 3.
#### What?


Combining scenarios 1 and 2, with the `ConnectionPool` as a flyweight pool and the State Pattern for state management; we continue to extend further. As stated in the background objectives, the Feature side does not need to concern itself with the underlying connection mechanism of the Connection. Therefore, we have established a poller (named `ConnectionKeeper`) that will periodically scan the `Connection` objects strongly held in the `ConnectionPool` and perform operations when the following conditions occur:
- If a `Connection` is in use and its state is not `Connected`: change the state to `Reconnecting` and attempt to reconnect.
- If a `Connection` is not in use and its state is `Connected`: change the state to `Disconnected`.
- If a `Connection` is not in use and its state is `Disconnected`: change the state to `Released` and remove it from the `ConnectionPool`.

#### Why?
- The three operations have a hierarchical relationship and are mutually exclusive (disconnected -> released or reconnecting).
- Flexible to swap or add operational conditions.
- If not encapsulated, the three judgments and operations can only be directly written in the method (making it difficult to test the logic).
- e.g:

```swift
if !connection.isOccupie() && connection.state == .connected then
... connection.disconnected()
else if !connection.isOccupie() && state == .released then
... connection.release()
else if connection.isOccupie() && state == .disconnected then
... connection.reconnecting()
end
```
#### How?
- [Chain Of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility){:target="_blank"}: A behavioral pattern, as the name suggests, is a chain where each node has a corresponding operation. After inputting data, the node can decide whether to operate or pass it to the next node for processing. Another real-world application is the [iOS Responder Chain](https://swiftrocks.com/understanding-the-ios-responder-chain){:target="_blank"}.

> _According to the definition, the Chain of Responsibility Pattern does not allow a node that has already taken over the processing of data to pass it to the next node for further processing after completing its task. **If you start, finish it; otherwise, do not start.**_

> _If the above scenario is more suitable, it should be the [Interceptor Pattern](https://stackoverflow.com/questions/7951306/chain-of-responsibility-vs-interceptor){:target="_blank"}._

![](/assets/78507a8de6a5/1*e8jHpykN1m3Y66Ukf-5OJA.png)

- **Chain of Responsibility:** `ConnectionKeeperHandler` is the abstract node of the chain, specifically extracting the `canExcute` method to avoid the situation where this node processes but then wants to call the next node to continue execution. `handle` is the connection of the chain nodes, and `excute` is the logic of how to handle the processing. `ConnectionKeeperHandlerContext` is used to store the data needed, and `isOccupie` indicates whether the Connection is in use.

```swift
enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

protocol Connection {
    var connectionState: ConnectionState {get}
    var url: URL {get}
    var id: UUID {get}
    
    init(url: URL)
    
    func connect()
    func reconnect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let connectionState: ConnectionState = .created
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func reconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

//

struct ConnectionKeeperHandlerContext {
    let connection: Connection
    let isOccupie: Bool
}

protocol ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler? { get set }
    
    func handle(context: ConnectionKeeperHandlerContext)
    func execute(context: ConnectionKeeperHandlerContext)
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool
}

extension ConnectionKeeperHandler {
    func handle(context: ConnectionKeeperHandlerContext) {
        if canExcute(context: context) {
            execute(context: context)
        } else {
            nextHandler?.handle(context: context)
        }
    }
}

class DisconnectedConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.disconnect()
    }
    
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .connected && !context.isOccupie {
            return true
        }
        return false
    }
}

class ReconnectConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.reconnect()
    }
    
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .disconnected && context.isOccupie {
            return true
        }
        return false
    }
}

class ReleasedConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.disconnect()
    }
    
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .disconnected && !context.isOccupie {
            return true
        }
        return false
    }
}
let connection = SIOConnection(url: URL(string: "wss://pinkoi.com")!)
let disconnectedHandler = DisconnectedConnectionKeeperHandler()
let reconnectHandler = ReconnectConnectionKeeperHandler()
let releasedHandler = ReleasedConnectionKeeperHandler()
disconnectedHandler.nextHandler = reconnectHandler
reconnectHandler.nextHandler = releasedHandler

disconnectedHandler.handle(context: ConnectionKeeperHandlerContext(connection: connection, isOccupie: false))
```
### Requirement Scenario 4.
#### What?

```markdown
The `Connection` we encapsulate needs to be set up before it can be used, such as providing a URL path, configuring settings, etc.
#### Why?
- It allows for flexible addition and removal of construction openings.
- It enables the reuse of construction logic.
- If not encapsulated, external entities can operate the class unexpectedly.
- e.g.:

```
❌
let connection = Connection()
connection.send(event) // unexpected method call, should call .connect() first
✅
let connection = Connection()
connection.connect()
connection.send(event)
// but...who knows???
```
#### How?
- [Builder Pattern](https://refactoring.guru/design-patterns/builder){:target="_blank"}: A creation pattern that allows for step-by-step construction of objects and the reuse of construction methods.

![](/assets/78507a8de6a5/1*J5eKaks1-fT6u8FojeUkUQ.png)

- **Builder Pattern:** `SIOConnectionBuilder` is the builder for `Connection`, responsible for setting and storing the data needed to construct a `Connection`; the `ConnectionConfiguration` abstract interface ensures that `.connect()` must be called before obtaining a `Connection` instance.

```swift
enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

protocol Connection {
    var connectionState: ConnectionState {get}
    var url: URL {get}
    var id: UUID {get}
    
    init(url: URL)
    
    func connect()
    func reconnect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let connectionState: ConnectionState = .created
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func reconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

//
class SIOConnectionClient: ConnectionConfiguration {
    private let url: URL
    private let config: [String: Any]
    
    init(url: URL, config: [String: Any]) {
        self.url = url
        self.config = config
    }
    
    func connect() -> Connection {
        // set config
        return SIOConnection(url: url)
    }
}

protocol ConnectionConfiguration {
    func connect() -> Connection
}

class SIOConnectionBuilder {
    private(set) var config: [String: Any] = [:]
    
    func setConfig(_ config: [String: Any]) -> SIOConnectionBuilder {
        self.config = config
        return self
    }
    
    // url is required parameter
    func build(url: URL) -> ConnectionConfiguration {
        return SIOConnectionClient(url: url, config: self.config)
    }
}

let builder = SIOConnectionBuilder().setConfig(["test":123])


let connection1 = builder.build(url: URL(string: "wss://pinkoi.com/1")!).connect()
let connection2 = builder.build(url: URL(string: "wss://pinkoi.com/1")!).connect()
```


Extension: Here, the [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"} can also be applied to produce `SIOConnection` using a factory.
### Conclusion!

The above covers the four scenarios encountered in encapsulating Socket.IO and the seven design patterns used to solve the problems.
#### Finally, here is the complete design blueprint for this Socket.IO encapsulation.


![](/assets/78507a8de6a5/1*DMfFpmF7aVCIIM1dskn97w.jpeg)


This diagram represents the actual design architecture, which slightly differs from the naming and examples in the text; we hope to invite the original designer to share their design philosophy and open-source it in the future.
### Who?

Who designed and is responsible for the Socket.IO encapsulation project?
#### [Sean Zheng](https://www.linkedin.com/in/%E5%AE%87%E7%BF%94-%E9%84%AD-9b3409175/){:target="_blank"}, Android Engineer @ Pinkoi


![](/assets/78507a8de6a5/1*Q_35023LtcZbOtnfvSxv-A.jpeg)


Main architect designer, evaluated and applied design patterns, implemented the design using Kotlin on the Android side.
#### [ZhgChgLi](https://www.linkedin.com/in/zhgchgli/){:target="_blank"}, Engineer Lead/iOS Engineer @ Pinkoi


![](/assets/78507a8de6a5/1*1NCE3Q7fO5Mh15NT2xoYlA.png)


Project lead for the Platform Team, pair programming, implemented the design using Swift on the iOS side, discussed and raised questions (a.k.a. just talking) and finally wrote this article to share with everyone.
### Further Reading
- Practical applications of Design Patterns — In WKWebView with Builder, Strategy & Chain of Responsibility Pattern
- [Visitor Pattern in Swift (Share Object to XXX Example)](../ba5773a7bfea/)
- [Visitor Pattern in TableView](../60473cb47550/)



If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.



_[Post](https://medium.com/pinkoi-engineering/%E5%AF%A6%E6%88%B0%E7%B4%80%E9%8C%84-4-%E5%80%8B%E5%A0%B4%E6%99%AF-7-%E5%80%8B-design-patterns-78507a8de6a5){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
