---
title: "Practical Applications of Design Patterns"
author: "ZhgChgLi"
date: 2022-04-07T14:49:17.715+0000
last_modified_at: 2024-09-06T06:00:33.888+0000
categories: ["Pinkoi Engineering"]
tags: ["ios-app-development","design-patterns","socketio","websocket","finite-state-machine"]
description: "Challenges encountered while encapsulating the Socket.IO Client Library and the design patterns applied to solve them."
image:
  path: /assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg
pin: true
render_with_liquid: false
---

### Practical Applications of Design Patterns

This article documents real-world development scenarios encountered while encapsulating the Socket.IO Client Library, along with the design patterns applied to solve these issues.

![Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg)

Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}

### Introduction

This article records the practical application of design patterns in addressing real development needs. It covers the background of the requirements, the specific problems encountered (What?), the rationale for applying design patterns (Why?), and how to implement them (How?). It is recommended to read from the beginning for better coherence.

> _This article will introduce four scenarios encountered during the development of this requirement and seven design patterns applied to address these scenarios._

### Background

#### Organizational Structure

Our company has recently split into multiple Feature Teams and a Platform Team. The Feature Teams primarily handle user-facing requirements, while the Platform Team focuses on internal technical integration, infrastructure, and paving the way for the Feature Teams during development.

#### Current Requirement

The Feature Teams need to transform the existing messaging functionality (where users had to refresh the page to get the latest messages) into real-time communication (where users can receive messages instantly and send messages).

#### Platform Team's Role

The Platform Team's focus is not just on the immediate real-time communication requirement but also on long-term infrastructure and reusability. After evaluation, we determined that the WebSocket bidirectional communication mechanism is essential in modern apps. This requirement will likely be needed in many future projects, so we decided to assist in designing and developing the interface.

**Goals:**
- Encapsulate communication and authentication logic between the Pinkoi Server Side and Socket.IO.
- Simplify the complex operations of Socket.IO, providing an extensible and user-friendly interface based on Pinkoi's business needs.
- Standardize the interface across both platforms (the functionalities and interfaces supported by Socket.IO's Android and iOS Client Side Libraries differ).
- Ensure that the Feature Teams do not need to understand the Socket.IO mechanism.
- Allow the Feature Teams to avoid managing complex connection states.
- Enable future use of WebSocket bidirectional communication directly.

**Time and Resources:**
- One developer for iOS and one for Android.
- Development timeline: 3 weeks.

#### Technical Details

The feature will be supported across Web, iOS, and Android platforms. We plan to implement the WebSocket bidirectional communication protocol using the [Socket.IO](http://socket.io/){:target="_blank"} service on the backend.

> **_First, it's important to clarify that Socket is not the same as WebSocket._**

For more information on the differences between Socket and WebSocket, refer to the following articles:
- [Differences between Socket, WebSocket, and Socket.IO](https://leesonhsu.blogspot.com/2018/07/socketwebsocketsocketio.html){:target="_blank"}
- [Why not use Socket directly and define a new WebSocket?](https://github.com/onlyliuxin/coding2017/issues/497){:target="_blank"}

In short:
```
Socket is an abstract interface for TCP/UDP transport layers, while WebSocket is an application layer transport protocol.
The relationship between Socket and WebSocket is like that of a dog and a hot dog; they are unrelated.
```

![](/assets/78507a8de6a5/1*MC_nQC382khMeWggLejWOA.jpeg)

Socket.IO is an abstraction layer over Engine.IO, which itself encapsulates the use of WebSocket. Each layer is responsible for communication between the layers above and below it, and direct operations (e.g., Socket.IO directly manipulating WebSocket connections) are not allowed.

In addition to basic WebSocket connections, Socket.IO/Engine.IO implements many convenient features (e.g., offline event sending mechanism, HTTP request-like mechanism, Room/Group mechanism, etc.).

The primary responsibility of the Platform Team is to bridge the logic between Socket.IO and the Pinkoi Server Side for the Feature Teams to use when developing functionalities.

#### Challenges with [Socket.IO Swift Client](https://github.com/socketio/socket.io-client-swift){:target="_blank"}
- The library has not been updated for a long time (the latest version is from 2019), and it's unclear if it is still maintained.
- The Client and Server Side Socket.IO versions must align; the Server Side can include `{allowEIO3: true}` or the Client Side can specify the same version with `.version`, otherwise, connections will fail.
- Naming conventions and interfaces often do not match the official examples.
- The Socket.IO official examples are primarily based on web implementations, and the Swift Client **does not necessarily support all the features described on the official site**. During this implementation, we found that the iOS library does not implement the offline event sending mechanism (which we implemented ourselves; please read on).

> **_It is recommended to test the desired mechanisms before adopting Socket.IO._**

> _The Socket.IO Swift Client is a wrapper around the **[Starscream](https://github.com/daltoniam/Starscream){:target="_blank"}** WebSocket Library, which can be used directly if necessary._

```
This concludes the background information; let's move on to the main topic.
```

### Design Patterns

Design patterns are essentially common solutions to recurring problems in software design. It is not necessary to use design patterns to develop software, and not all design patterns are suitable for every scenario. There is no rule against creating new design patterns.

![[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}](/assets/78507a8de6a5/1*MAm5WPynbv7M9tdmW2lNGQ.jpeg)

[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}

However, the existing design patterns (the 23 Gang of Four Design Patterns) are common knowledge in software design. When a specific pattern is mentioned, a corresponding architectural blueprint comes to mind, requiring little explanation. This also aids in future maintenance, as the methods have been validated by the industry, reducing the time spent on reviewing object dependencies. Choosing the appropriate pattern for the right scenario can lower communication and maintenance costs and enhance development efficiency.

> **_Design patterns can be used in combination, but it is not advisable to modify existing patterns excessively or to apply them forcefully inappropriately (e.g., using the Chain of Responsibility pattern to create objects), as this can defeat their purpose and lead to misunderstandings for future maintainers._**

#### The Design Patterns Discussed in This Article:
- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"}
- [Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"}
- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"}
- [Command Pattern](https://refactoring.guru/design-patterns/command){:target="_blank"}
- [Finite-State Machine](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"} + [State Pattern](https://refactoring.guru/design-patterns/state){:target="_blank"}
- [Chain of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility){:target="_blank"}
- [Builder Pattern](https://refactoring.guru/design-patterns/builder){:target="_blank"}

Each pattern will be explained in the context of its application, along with the reasons for its use.

> _This article focuses on the application of design patterns rather than the operations of Socket.IO. Some examples may be simplified for clarity and **are not applicable to the actual Socket.IO encapsulation**._

> _Due to space limitations, this article will not provide detailed explanations of each design pattern's structure. Please click on the links for each pattern to understand their structures before continuing to read._

> _Demo code will be written in Swift._

### Requirement Scenario 1
#### What?
- Reuse the same connection object across different pages and objects using the same path.
- The connection must be an abstract interface, not directly dependent on the Socket.IO object.

#### Why?
- Reduce memory overhead and the time and bandwidth costs of repeated connections.
- Allow for future replacement with other frameworks.

#### How?
- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"}: A creational pattern that ensures a class has only one instance and provides a global point of access to it.
- [Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"}: A structural pattern that allows sharing of objects to support a large number of fine-grained objects efficiently.
- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"}: A creational pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created.

**Practical Example:**

![](/assets/78507a8de6a5/1*flQa_EfErGBwbmEwpI7ZgQ.png)

- **Singleton Pattern:** The `ConnectionManager` exists as a single object throughout the app lifecycle, managing the operations for obtaining connections.
- **Flyweight Pattern:** The `ConnectionPool` serves as a shared pool for connections, providing a method to retrieve connections from this pool. The logic includes returning an existing connection from the pool if the URL path matches.
The `ConnectionHandler` acts as an external operator and state manager for the `Connection`.
- **Factory Pattern:** The `ConnectionFactory` works with the Flyweight Pattern to create a new connection when none is available in the pool.

```swift
import Combine
import Foundation

protocol Connection {
    var url: URL { get }
    var id: UUID { get }
    
    init(url: URL)
    
    func connect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

protocol ConnectionFactory {
    func create(url: URL) -> Connection
}

class ConnectionPool {
    
    private let connectionFactory: ConnectionFactory
    private var connections: [Connection] = []
    
    init(connectionFactory: ConnectionFactory) {
        self.connectionFactory = connectionFactory
    }
    
    func getOrCreateConnection(url: URL) -> Connection {
        if let connection = connections.first(where: { $0.url == url }) {
            return connection
        } else {
            let connection = connectionFactory.create(url: url)
            connections.append(connection)
            return connection
        }
    }
    
}

class ConnectionHandler {
    private let connection: Connection
    init(connection: Connection) {
        self.connection = connection
    }
    
    func getConnectionUUID() -> UUID {
        return connection.id
    }
}

class ConnectionManager {
    static let shared = ConnectionManager(connectionPool: ConnectionPool(connectionFactory: SIOConnectionFactory()))
    private let connectionPool: ConnectionPool
    private init(connectionPool: ConnectionPool) {
        self.connectionPool = connectionPool
    }
    
    func requestConnectionHandler(url: URL) -> ConnectionHandler {
        let connection = connectionPool.getOrCreateConnection(url: url)
        return ConnectionHandler(connection: connection)
    }
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

class SIOConnectionFactory: ConnectionFactory {
    func create(url: URL) -> Connection {
        //
        return SIOConnection(url: url)
    }
}

//

print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/1")!).getConnectionUUID().uuidString)
print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/1")!).getConnectionUUID().uuidString)

print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/2")!).getConnectionUUID().uuidString)

// output:
// D99F5429-1C6D-4EB5-A56E-9373D6F37307
// D99F5429-1C6D-4EB5-A56E-9373D6F37307
// 599CF16F-3D7C-49CF-817B-5A57C119FE31
```

### Requirement Scenario 2
#### What?

As mentioned in the technical details, the Socket.IO Swift Client's `Send Event` does not support offline sending (unlike the Web/Android versions). Therefore, the iOS side needs to implement this functionality.
```
Interestingly, the Socket.IO Swift Client's onEvent does support offline subscriptions.
```

#### Why?
- To unify functionality across platforms.
- To make the code easier to understand.

#### How?
- [Command Pattern](https://refactoring.guru/design-patterns/command){:target="_blank"}: A behavioral pattern that encapsulates a request as an object, thereby allowing for parameterization of clients with queues, requests, and operations.

![](/assets/78507a8de6a5/1*O9zc28nMx64HDiDy4aiexA.png)

- **Command Pattern:** The `SIOManager` serves as the lowest-level encapsulation for communicating with Socket.IO. Its `send` and `request` methods operate on the Socket.IO Send Event. When the current Socket.IO is disconnected, the request parameters are placed into `bufferedCommands`, which are processed sequentially (First In First Out) once the connection is reestablished.

```swift
protocol BufferedCommand {
    var sioManager: SIOManagerSpec? { get set }
    var event: String { get }
    
    func execute()
}

struct SendBufferedCommand: BufferedCommand {
    let event: String
    weak var sioManager: SIOManagerSpec?
    
    func execute() {
        sioManager?.send(event)
    }
}

struct RequestBufferedCommand: BufferedCommand {
    let event: String
    let callback: (Data?) -> Void
    weak var sioManager: SIOManagerSpec?
    
    func execute() {
        sioManager?.request(event, callback: callback)
    }
}

protocol SIOManagerSpec: AnyObject {
    func connect()
    func disconnect()
    func onEvent(event: String, callback: @escaping (Data?) -> Void)
    func send(_ event: String)
    func request(_ event: String, callback: @escaping (Data?) -> Void)
}

enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

class SIOManager: SIOManagerSpec {
        
    var state: ConnectionState = .disconnected {
        didSet {
            if state == .connected {
                executeBufferedCommands()
            }
        }
    }
    
    private var bufferedCommands: [BufferedCommand] = []
    
    func connect() {
        state = .connected
    }
    
    func disconnect() {
        state = .disconnected
    }
    
    func send(_ event: String) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self))
            return
        }
        
        print("Send:\(event)")
    }
    
    func request(_ event: String, callback: @escaping (Data?) -> Void) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self))
            return
        }
        
        print("request:\(event)")
    }
    
    func onEvent(event: String, callback: @escaping (Data?) -> Void) {
        //
    }
    
    func appendBufferedCommands(connectionCommand: BufferedCommand) {
        bufferedCommands.append(connectionCommand)
    }
    
    func executeBufferedCommands() {
        // First in, first out
        bufferedCommands.forEach { connectionCommand in
            connectionCommand.execute()
        }
        bufferedCommands.removeAll()
    }
    
    func removeAllBufferedCommands() {
        bufferedCommands.removeAll()
    }
}

let manager = SIOManager()
manager.send("send_event_1")
manager.send("send_event_2")
manager.request("request_event_1") { _ in
    //
}
manager.state = .connected
```

Similarly, this can also be implemented for `onEvent`.

As an extension, the [Proxy Pattern](https://refactoring.guru/design-patterns/proxy){:target="_blank"} can be applied, viewing the buffer functionality as a type of proxy.

### Requirement Scenario 3
#### What?

The connection has multiple states, with ordered transitions between states, and different operations allowed in each state.

![](/assets/78507a8de6a5/1*DBl6K1cPQc_cHOYXZ1VQ8A.jpeg)

![](/assets/78507a8de6a5/1*-Xk_TT6SMW5Jxd-c8iSCcw.jpeg)

Here's the translated text in naturalistic English while preserving the original markdown image source:

- **Created**: The object has been created, allowing transitions to `Connected` or directly to `Disconnected`.
- **Connected**: The connection to Socket.IO is established, allowing a transition to `Disconnected`.
- **Disconnected**: The connection to Socket.IO has been lost, allowing transitions to `Reconnecting` or `Released`.
- **Reconnecting**: Attempting to reconnect to Socket.IO, allowing transitions to `Connected` or `Disconnected`.
- **Released**: The object has been marked for garbage collection, and no operations or state transitions are allowed.

#### Why?
- The logic and expressions for state transitions are not easy to understand.
- Each state needs to restrict operational methods (e.g., when `State = Released`, calling `Send Event` is not allowed). Using simple if-else statements makes the code hard to maintain and read.

#### How?
- [Finite State Machine](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"}: Manages transitions between states.
- [State Pattern](https://refactoring.guru/design-patterns/state){:target="_blank"}: A behavioral pattern that provides different handling when an object's state changes.

![](/assets/78507a8de6a5/1*NgehABZTiXL_fFEYQh63Hg.png)

- **Finite State Machine**: `SIOConnectionStateMachine` is the implementation of the state machine, with `currentSIOConnectionState` representing the current state. The states `created`, `connected`, `disconnected`, `reconnecting`, and `released` are listed as possible transitions for this state machine. The method `enterXXXState() throws` implements the allowed and disallowed transitions (throwing an error) when entering a certain state from the current state.
- **State Pattern**: `SIOConnectionState` is the abstract interface for all operations that will be used by the states.

```swift
protocol SIOManagerSpec: AnyObject {
    func connect()
    func disconnect()
    func onEvent(event: String, callback: @escaping (Data?) -> Void)
    func send(_ event: String)
    func request(_ event: String, callback: @escaping (Data?) -> Void)
}

enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

class SIOManager: SIOManagerSpec {
        
    var state: ConnectionState = .disconnected {
        didSet {
            if state == .connected {
                executeBufferedCommands()
            }
        }
    }
    
    private var bufferedCommands: [BufferedCommand] = []
    
    func connect() {
        state = .connected
    }
    
    func disconnect() {
        state = .disconnected
    }
    
    func send(_ event: String) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self))
            return
        }
        
        print("Send: \(event)")
    }
    
    func request(_ event: String, callback: @escaping (Data?) -> Void) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self))
            return
        }
        
        print("Request: \(event)")
    }
    
    func onEvent(event: String, callback: @escaping (Data?) -> Void) {
        //
    }
    
    func appendBufferedCommands(connectionCommand: BufferedCommand) {
        bufferedCommands.append(connectionCommand)
    }
    
    func executeBufferedCommands() {
        // First in, first out
        bufferedCommands.forEach { connectionCommand in
            connectionCommand.execute()
        }
        bufferedCommands.removeAll()
    }
    
    func removeAllBufferedCommands() {
        bufferedCommands.removeAll()
    }
}

let manager = SIOManager()
manager.send("send_event_1")
manager.send("send_event_2")
manager.request("request_event_1") { _ in
    //
}
manager.state = .connected

//

class SIOConnectionStateMachine {
    
    private(set) var currentSIOConnectionState: SIOConnectionState!

    private var created: SIOConnectionState!
    private var connected: SIOConnectionState!
    private var disconnected: SIOConnectionState!
    private var reconnecting: SIOConnectionState!
    private var released: SIOConnectionState!
    
    init() {
        self.created = SIOConnectionCreatedState(stateMachine: self)
        self.connected = SIOConnectionConnectedState(stateMachine: self)
        self.disconnected = SIOConnectionDisconnectedState(stateMachine: self)
        self.reconnecting = SIOConnectionReconnectingState(stateMachine: self)
        self.released = SIOConnectionReleasedState(stateMachine: self)
        
        self.currentSIOConnectionState = created
    }
    
    func enterConnected() throws {
        if [created.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(connected)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Connected")
        }
    }
    
    func enterDisconnected() throws {
        if [created.connectionState, connected.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(disconnected)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Disconnected")
        }
    }

    func enterReconnecting() throws {
        if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(reconnecting)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Reconnecting")
        }
    }

    func enterReleased() throws {
        if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(released)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Released")
        }
    }
    
    private func enter(_ state: SIOConnectionState) {
        currentSIOConnectionState = state
    }
}


protocol SIOConnectionState {
    var connectionState: ConnectionState { get }
    var stateMachine: SIOConnectionStateMachine { get }
    init(stateMachine: SIOConnectionStateMachine)

    func onConnected() throws
    func onDisconnected() throws
    
    func connect(socketManager: SIOManagerSpec) throws
    func disconnect(socketManager: SIOManagerSpec) throws
    func release(socketManager: SIOManagerSpec) throws
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws
    func send(socketManager: SIOManagerSpec, event: String) throws
}

struct SIOConnectionStateMachineError: Error {
    let message: String

    init(_ message: String) {
        self.message = message
    }

    var localizedDescription: String {
        return message
    }
}

class SIOConnectionCreatedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .created
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("CreatedState can't disconnect!")
    }
}

class SIOConnectionConnectedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .connected
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }
    
    func onConnected() throws {
        //
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionDisconnectedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .disconnected
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        //
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        try stateMachine.enterReleased()
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        try stateMachine.enterReconnecting()
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionReconnectingState: SIOConnectionState {
    
    let connectionState: ConnectionState = .reconnecting
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReconnectState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReconnectState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionReleasedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .released
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        throw SIOConnectionStateMachineError("ReleasedState can't onConnected!")
    }
    
    func onDisconnected() throws {
        throw SIOConnectionStateMachineError("ReleasedState can't onDisconnected!")
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't release!")
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't request!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't receiveOn!")
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't send!")
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't disconnect!")
    }
}

do {
    let stateMachine = SIOConnectionStateMachine()
    // mock on socket.io connect:
    // socketIO.on(connect){
    try stateMachine.currentSIOConnectionState.onConnected()
    try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: "test")
    try stateMachine.currentSIOConnectionState.release(socketManager: manager)
    try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: "test")
    // }
} catch {
    print("error: \(error)")
}

// output:
// error: SIOConnectionStateMachineError(message: "ConnectedState can't release!")
```

### Scenario 3
#### What?

Combining scenarios 1 and 2, with the `ConnectionPool` as a flyweight pool and the State Pattern for state management, we further extend the functionality. As described in the background objectives, the feature side should not concern itself with the underlying connection mechanism. Therefore, we create a poller (named `ConnectionKeeper`) that periodically scans the `ConnectionPool` for strongly held `Connections` and performs operations under the following conditions:
- If a `Connection` is in use and its state is not `Connected`: change its state to `Reconnecting` and attempt to reconnect.
- If a `Connection` is not in use and its state is `Connected`: change its state to `Disconnected`.
- If a `Connection` is not in use and its state is `Disconnected`: change its state to `Released` and remove it from the `ConnectionPool`.

#### Why?
- The three operations have a hierarchical relationship and are mutually exclusive (i.e., `disconnected` can lead to either `released` or `reconnecting`).
- This allows for flexible substitution and addition of operational conditions.
- Without encapsulation, the three checks and operations would have to be written directly in the method (making it difficult to test the logic).
- For example:

```swift
if !connection.isOccupie() && connection.state == .connected {
    ... connection.disconnected()
} else if !connection.isOccupie() && state == .released {
    ... connection.release()
} else if connection.isOccupie() && state == .disconnected {
    ... connection.reconnecting()
}
```

#### How?
- [Chain Of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility){:target="_blank"}: A behavioral pattern that, as the name suggests, forms a chain where each node has a corresponding operation. After inputting data, the node can decide whether to process it or pass it to the next node. Another real-world application is the [iOS Responder Chain](https://swiftrocks.com/understanding-the-ios-responder-chain){:target="_blank"}.

> _According to the definition, the Chain of Responsibility Pattern does not allow a node that has already taken responsibility for processing data to pass it on to the next node for further processing. **If you do it, do it completely; otherwise, don't do it at all.**_

> _For the above scenario, a more suitable pattern would be the [Interceptor Pattern](https://stackoverflow.com/questions/7951306/chain-of-responsibility-vs-interceptor){:target="_blank"}._

![](/assets/78507a8de6a5/1*e8jHpykN1m3Y66Ukf-5OJA.png)

- **Chain of Responsibility**: `ConnectionKeeperHandler` is the abstract node of the chain, specifically extracting the `canExecute` method to avoid the situation where a node processes the data but then wants to call the next node to continue execution. The `handle` method connects the nodes in the chain, and the `execute` method defines the logic for how to handle the operation. `ConnectionKeeperHandlerContext` is used to store relevant data, with `isOccupie` indicating whether the Connection is in use.

```swift
enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

protocol Connection {
    var connectionState: ConnectionState { get }
    var url: URL { get }
    var id: UUID { get }
    
    init(url: URL)
    
    func connect()
    func reconnect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let connectionState: ConnectionState = .created
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func reconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

//

struct ConnectionKeeperHandlerContext {
    let connection: Connection
    let isOccupie: Bool
}

protocol ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler? { get set }
    
    func handle(context: ConnectionKeeperHandlerContext)
    func execute(context: ConnectionKeeperHandlerContext)
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool
}

extension ConnectionKeeperHandler {
    func handle(context: ConnectionKeeperHandlerContext) {
        if canExcute(context: context) {
            execute(context: context)
        } else {
            nextHandler?.handle(context: context)
        }
    }
}
```

```swift
class DisconnectedConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.disconnect()
    }
    
    func canExecute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .connected && !context.isOccupied {
            return true
        }
        return false
    }
}

class ReconnectConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.reconnect()
    }
    
    func canExecute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .disconnected && context.isOccupied {
            return true
        }
        return false
    }
}

class ReleasedConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.disconnect()
    }
    
    func canExecute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .disconnected && !context.isOccupied {
            return true
        }
        return false
    }
}

let connection = SIOConnection(url: URL(string: "wss://pinkoi.com")!)
let disconnectedHandler = DisconnectedConnectionKeeperHandler()
let reconnectHandler = ReconnectConnectionKeeperHandler()
let releasedHandler = ReleasedConnectionKeeperHandler()
disconnectedHandler.nextHandler = reconnectHandler
reconnectHandler.nextHandler = releasedHandler

disconnectedHandler.handle(context: ConnectionKeeperHandlerContext(connection: connection, isOccupied: false))
```

### Scenario 4
#### What?

The `Connection` we encapsulated needs to be set up before use, such as providing a URL path, configuring settings, etc.
#### Why?
- Allows for flexible addition or removal of construction openings.
- Enables reuse of construction logic.
- If not encapsulated, external entities can operate the class in unexpected ways.
- e.g.:

```
❌
let connection = Connection()
connection.send(event) // unexpected method call, should call .connect() first
✅
let connection = Connection()
connection.connect()
connection.send(event)
// but...who knows???
```
#### How?
- [Builder Pattern](https://refactoring.guru/design-patterns/builder){:target="_blank"}: A creational pattern that allows for step-by-step construction of objects and reuse of construction methods.

![](/assets/78507a8de6a5/1*J5eKaks1-fT6u8FojeUkUQ.png)

- **Builder Pattern:** `SIOConnectionBuilder` serves as the builder for `Connection`, responsible for setting and storing data needed to construct a `Connection`; the `ConnectionConfiguration` abstract interface ensures that `.connect()` must be called before obtaining a `Connection` instance.

```swift
enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

protocol Connection {
    var connectionState: ConnectionState { get }
    var url: URL { get }
    var id: UUID { get }
    
    init(url: URL)
    
    func connect()
    func reconnect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let connectionState: ConnectionState = .created
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func reconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

//
class SIOConnectionClient: ConnectionConfiguration {
    private let url: URL
    private let config: [String: Any]
    
    init(url: URL, config: [String: Any]) {
        self.url = url
        self.config = config
    }
    
    func connect() -> Connection {
        // set config
        return SIOConnection(url: url)
    }
}

protocol ConnectionConfiguration {
    func connect() -> Connection
}

class SIOConnectionBuilder {
    private(set) var config: [String: Any] = [:]
    
    func setConfig(_ config: [String: Any]) -> SIOConnectionBuilder {
        self.config = config
        return self
    }
    
    // url is a required parameter
    func build(url: URL) -> ConnectionConfiguration {
        return SIOConnectionClient(url: url, config: self.config)
    }
}

let builder = SIOConnectionBuilder().setConfig(["test": 123])

let connection1 = builder.build(url: URL(string: "wss://pinkoi.com/1")!).connect()
let connection2 = builder.build(url: URL(string: "wss://pinkoi.com/1")!).connect()
```

Additionally, the [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"} can also be applied here to produce `SIOConnection` through a factory.

### Conclusion

This concludes the four scenarios encountered during the encapsulation of Socket.IO and the seven design patterns used to solve these problems.
#### Finally, here is the complete design blueprint for the Socket.IO encapsulation.

![](/assets/78507a8de6a5/1*DMfFpmF7aVCIIM1dskn97w.jpeg)

This diagram represents the actual design architecture, which may differ slightly from the naming and examples in the text. We hope to have the original designer share their design philosophy and open-source it in the future.

### Who?

Who designed and is responsible for the Socket.IO encapsulation project?
#### [Sean Zheng](https://www.linkedin.com/in/%E5%AE%87%E7%BF%94-%E9%84%AD-9b3409175/){:target="_blank"}, Android Engineer @ Pinkoi

![](/assets/78507a8de6a5/1*Q_35023LtcZbOtnfvSxv-A.jpeg)

Main architect designer, evaluated and applied design patterns, implemented the design using Kotlin on the Android side.

#### [ZhgChgLi](https://www.linkedin.com/in/zhgchgli/){:target="_blank"}, Engineer Lead/iOS Engineer @ Pinkoi

![](/assets/78507a8de6a5/1*1NCE3Q7fO5Mh15NT2xoYlA.png)

Project lead for the Platform Team, engaged in pair programming, implemented the design using Swift on the iOS side, discussed and raised questions (a.k.a. contributed ideas), and finally wrote this article to share with everyone.

### Further Reading
- Practical applications of Design Patterns — In WKWebView with Builder, Strategy & Chain of Responsibility Pattern
- [Visitor Pattern in Swift (Share Object to XXX Example)](../ba5773a7bfea/)
- [Visitor Pattern in TableView](../60473cb47550/)

If you have any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/pinkoi-engineering/%E5%AF%A6%E6%88%B0%E7%B4%80%E9%8C%84-4-%E5%80%8B%E5%A0%B4%E6%99%AF-7-%E5%80%8B-design-patterns-78507a8de6a5){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```