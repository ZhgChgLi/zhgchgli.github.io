---
author: ZhgChgLi
categories:
- Pinkoi Engineering
date: 2022-04-07T14:49:17.715+0000
description: Discover how to resolve common challenges in encapsulating Socket.IO
  Client Library using proven Design Patterns, enhancing code maintainability and
  scalability for developers facing similar integration issues.
image:
  path: /assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg
last_modified_at: 2025-12-14T08:02:26.826+0000
pin: true
render_with_liquid: false
tags:
- ios-app-development
- design-patterns
- socketio
- websocket
- finite-state-machine
- english
- ai-translation
title: Design Patterns｜Practical Solutions for Socket.IO Client Library Challenges
---

### Practical Application Records of Design Patterns

Problem Scenarios Encountered When Encapsulating the Socket.IO Client Library and Design Patterns Applied to Solutions

![Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg)

Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}

### Preface

This article records real development scenarios where Design Patterns were used to solve problems. It covers the background of the requirements, the actual problem scenarios (What?), why applying Patterns is necessary (Why?), and how to implement them (How?). It is recommended to read from the beginning for better coherence.

> *This article introduces four development scenarios encountered for this requirement and the application of seven Design Patterns to solve these scenarios.*

### Background

#### Organization Structure

Our company split into multiple Feature Teams and a Platform Team this year; the former mainly handles user-side requirements, while the Platform Team works internally within the company. One of its tasks is technology adoption, infrastructure, and systematic integration to pave the way for Feature Teams when developing their requirements.

#### Current Requirements

Feature Teams want to change the original messaging feature (fetching message data by calling APIs on page load, requiring refresh to update messages) to real-time communication (able to receive the latest messages instantly and send messages in real time).

#### Platform Team Work

The Platform Team focuses not only on the current real-time communication needs but also on long-term development and reusability. After evaluation, the WebSocket bidirectional communication mechanism is indispensable in modern apps. Beyond this requirement, there will be many opportunities to use it in the future. With sufficient human resources, the team is committed to assisting in designing and developing the interface.

**Goal:**

- Encapsulating Pinkoi Server Side and Socket.IO Communication, Authentication Logic

- Encapsulate the tedious operations of Socket.IO, providing an extensible and user-friendly interface based on Pinkoi's business requirements

- Unified Cross-Platform Interface **(The Socket.IO Android and iOS Client Side Libraries support different features and interfaces)**

- Feature side does not need to understand the Socket.IO mechanism

- Feature side does not need to manage complex connection states

- Future WebSocket bidirectional communication needs can be directly supported

**Time and Manpower:**

- One person dedicated to iOS and one to Android respectively

- Development Schedule: Duration 3 weeks

#### Technical Details

This feature will be supported on Web, iOS, and Android platforms; it requires introducing the WebSocket bidirectional communication protocol. The backend plans to use the [Socket.io](http://socket.io/){:target="_blank"} service directly.

> ***First of all, Socket != WebSocket***

For details about Socket and WebSocket technologies, please refer to the following two articles:

- [Differences between Socket, Websocket, and Socket.io](https://leesonhsu.blogspot.com/2018/07/socketwebsocketsocketio.html){:target="_blank"}

- [Why not use socket directly and instead define a new websocket?](https://github.com/onlyliuxin/coding2017/issues/497){:target="_blank"}

In short:

```
Socket is an abstract interface for the TCP/UDP transport layer, while WebSocket is a transport protocol at the application layer.
The relationship between Socket and WebSocket is like that between a dog and a hot dog—no relation.
```

![](/assets/78507a8de6a5/1*MC_nQC382khMeWggLejWOA.jpeg)

Socket.IO is an abstraction layer built on top of Engine.IO, which itself wraps WebSocket usage. Each layer only handles communication between the layer above and below it, disallowing direct operations across layers (e.g., Socket.IO does not directly operate the WebSocket connection).

Socket.IO/Engine.IO implements many convenient features beyond basic WebSocket connections (e.g., offline event sending mechanism, HTTP-like request mechanism, Room/Group mechanism, etc.).

The main responsibility of the Platform Team layer is to bridge the logic between Socket.IO and the Pinkoi Server Side, providing support for upper Feature Teams during feature development.

#### [Socket.IO Swift Client](https://github.com/socketio/socket.io-client-swift){:target="_blank"} has pitfalls

- It has not been updated for a long time (the latest version is still from 2019), so it is unclear if it is still maintained.

- Client & Server Side Socket IO versions must match. On the Server Side, you can add `{allowEIO3: true}`, or specify the same version on the Client Side using `.version`.  
  Otherwise, the connection will fail no matter what.

- Naming conventions, interfaces, and official website examples often do not match.

- Socket.io official examples are all based on Web, but the Swift Client **does not necessarily support all features shown on the official site**.  
  In this implementation, we found that the iOS Library does not provide an offline event sending mechanism  
  (which we implemented ourselves, please continue reading).

> ***It is recommended to experiment first to see if the desired mechanism is supported before adopting Socket.IO.***

> *Socket.IO Swift Client is a wrapper based on the **[Starscream](https://github.com/daltoniam/Starscream){:target="_blank"}** WebSocket Library and can fallback to Starscream when necessary.*

```
Background information ends here. Now, let's get to the main topic.
```

### Design Patterns

Design patterns are essentially solutions to common problems in software design. You don't have to use design patterns to develop, design patterns may not fit all scenarios, and no one says you can't create your own new design patterns.

![[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}](/assets/78507a8de6a5/1*MAm5WPynbv7M9tdmW2lNGQ.jpeg)

[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}

However, the existing design patterns (The 23 Gang of Four Design Patterns) are common knowledge in software design. When mentioning a XXX Pattern, everyone immediately envisions the corresponding architectural blueprint, requiring little explanation. This also makes subsequent maintenance easier to understand and is a proven industry method that rarely requires time to review object dependency issues. Choosing the right pattern for the right scenario can reduce communication and maintenance costs and improve development efficiency.

> ***Design patterns can be combined, but it is not recommended to drastically modify existing patterns, forcefully apply them without reason, or use patterns outside their intended category (e.g., using the Chain of Responsibility pattern to create objects). Doing so defeats their purpose and may cause confusion for future maintainers.***

#### Design Patterns Mentioned in This Article:

- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"}

- [Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"}

- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"}

- [Command Pattern](https://refactoring.guru/design-patterns/command){:target="_blank"}

- [Finite-State Machine](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"} + [State Pattern](https://refactoring.guru/design-patterns/state){:target="_blank"}

- [Chain Of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility){:target="_blank"}

- [Builder Pattern](https://refactoring.guru/design-patterns/builder){:target="_blank"}

Each will be explained later one by one: the scenario used and why it was chosen.

> *This article focuses on the application of Design Patterns rather than Socket.IO operations. Some examples are simplified for clarity and **are not suitable for real Socket.IO encapsulation**.*

> *Due to space limitations, this article will not detail the architecture of each design pattern. Please click on the links for each pattern to understand their structures before continuing.*

> *The demo code will be written in Swift.*

### Requirement Scenario 1.

#### What?

- Reuse the same object when requesting a Connection with the same Path on different pages or Objects.

- Connection should be an abstract interface, not directly dependent on the Socket.IO Object

#### Why?

- Reduce memory overhead and the time and traffic costs of repeated connections.

- Reserve space for future replacement with other frameworks

#### How?

- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"}: A creational pattern that ensures a class has only one instance.

- [Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"}: A structural pattern that shares common states among multiple objects for reuse.

- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"}: A creational pattern that abstracts the object creation method, allowing it to be replaced externally.

**Real Case Usage:**

![](/assets/78507a8de6a5/1*flQa_EfErGBwbmEwpI7ZgQ.png)

- **Singleton Pattern:** The `ConnectionManager` exists as a single instance throughout the App Lifecycle, managing access to `Connection` objects.

- **Flyweight Pattern:** The `ConnectionPool` is a shared pool of Connections. It provides a unified way to get a Connection from the pool, including logic to return an existing Connection if the URL Path matches.  
  `ConnectionHandler` acts as an external operator and state manager for the `Connection`.

- **Factory Pattern:** The `ConnectionFactory` works with the Flyweight Pattern above to create a new `Connection` via this factory interface when no reusable connection is found in the pool.

```swift
import Combine
import Foundation

protocol Connection {
    var url: URL {get}
    var id: UUID {get}
    
    init(url: URL)
    
    func connect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

protocol ConnectionFactory {
    func create(url: URL) -> Connection
}

class ConnectionPool {
    
    private let connectionFactory: ConnectionFactory
    private var connections: [Connection] = []
    
    init(connectionFactory: ConnectionFactory) {
        self.connectionFactory = connectionFactory
    }
    
    func getOrCreateConnection(url: URL) -> Connection {
        if let connection = connections.first(where: { $0.url == url }) {
            return connection
        } else {
            let connection = connectionFactory.create(url: url)
            connections.append(connection)
            return connection
        }
    }
    
}

class ConnectionHandler {
    private let connection: Connection
    init(connection: Connection) {
        self.connection = connection
    }
    
    func getConnectionUUID() -> UUID {
        return connection.id
    }
}

class ConnectionManager {
    static let shared = ConnectionManager(connectionPool: ConnectionPool(connectionFactory: SIOConnectionFactory()))
    private let connectionPool: ConnectionPool
    private init(connectionPool: ConnectionPool) {
        self.connectionPool = connectionPool
    }
    
    //
    func requestConnectionHandler(url: URL) -> ConnectionHandler {
        let connection = connectionPool.getOrCreateConnection(url: url)
        return ConnectionHandler(connection: connection)
    }
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

class SIOConnectionFactory: ConnectionFactory {
    func create(url: URL) -> Connection {
        //
        return SIOConnection(url: url)
    }
}
//

print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/1")!).getConnectionUUID().uuidString)
print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/1")!).getConnectionUUID().uuidString)

print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/2")!).getConnectionUUID().uuidString)

// output:
// D99F5429-1C6D-4EB5-A56E-9373D6F37307
// D99F5429-1C6D-4EB5-A56E-9373D6F37307
// 599CF16F-3D7C-49CF-817B-5A57C119FE31
```

### Requirement Scenario 2.

#### What?

As described in the background technical details, the Socket.IO Swift Client's `Send Event` does not support offline sending (while the Web/Android versions of the library do), so the iOS side needs to implement this feature independently.

```
The amazing thing is that the Socket.IO Swift Client - onEvent supports offline subscription.
```

#### Why?

- Cross-Platform Feature Unification

- The code is easy to understand

#### How?

- [Command Pattern](https://refactoring.guru/design-patterns/command){:target="_blank"}: A behavioral pattern that encapsulates operations into objects, allowing queuing, delaying, canceling, and other batch actions.

![](/assets/78507a8de6a5/1*O9zc28nMx64HDiDy4aiexA.png)

- **Command Pattern:** `SIOManager` is the lowest-level wrapper for communicating with Socket.IO. Its `send` and `request` methods operate on Socket.IO Send Events. When the current Socket.IO is disconnected, the request parameters are placed into `bufferedCommands`. Once reconnected, these commands are processed one by one (First In First Out).

```swift
protocol BufferedCommand {
    var sioManager: SIOManagerSpec? { get set }
    var event: String { get }
    
    func execute()
}

struct SendBufferedCommand: BufferedCommand {
    let event: String
    weak var sioManager: SIOManagerSpec?
    
    func execute() {
        sioManager?.send(event)
    }
}

struct RequestBufferedCommand: BufferedCommand {
    let event: String
    let callback: (Data?) -> Void
    weak var sioManager: SIOManagerSpec?
    
    func execute() {
        sioManager?.request(event, callback: callback)
    }
}

protocol SIOManagerSpec: AnyObject {
    func connect()
    func disconnect()
    func onEvent(event: String, callback: @escaping (Data?) -> Void)
    func send(_ event: String)
    func request(_ event: String, callback: @escaping (Data?) -> Void)
}

enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

class SIOManager: SIOManagerSpec {
        
    var state: ConnectionState = .disconnected {
        didSet {
            if state == .connected {
                executeBufferedCommands()
            }
        }
    }
    
    private var bufferedCommands: [BufferedCommand] = []
    
    func connect() {
        state = .connected
    }
    
    func disconnect() {
        state = .disconnected
    }
    
    func send(_ event: String) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self))
            return
        }
        
        print("Send:\(event)")
    }
    
    func request(_ event: String, callback: @escaping (Data?) -> Void) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self))
            return
        }
        
        print("request:\(event)")
    }
    
    func onEvent(event: String, callback: @escaping (Data?) -> Void) {
        //
    }
    
    func appendBufferedCommands(connectionCommand: BufferedCommand) {
        bufferedCommands.append(connectionCommand)
    }
    
    func executeBufferedCommands() {
        // First in, first out
        bufferedCommands.forEach { connectionCommand in
            connectionCommand.execute()
        }
        bufferedCommands.removeAll()
    }
    
    func removeAllBufferedCommands() {
        bufferedCommands.removeAll()
    }
}

let manager = SIOManager()
manager.send("send_event_1")
manager.send("send_event_2")
manager.request("request_event_1") { _ in
    //
}
manager.state = .connected
```

Similarly, it can also be implemented on `onEvent`.

Extension: You can also apply the [Proxy Pattern](https://refactoring.guru/design-patterns/proxy){:target="_blank"}, treating the Buffer functionality as a type of Proxy.

### Requirement Scenario 3.

#### What?

Connection has multiple states, with ordered transitions between states, and each state allows different operations.

![](/assets/78507a8de6a5/1*DBl6K1cPQc_cHOYXZ1VQ8A.jpeg)

![](/assets/78507a8de6a5/1*-Xk_TT6SMW5Jxd-c8iSCcw.jpeg)

- Created: The object is created, allowing transition to -> `Connected` or directly to `Disconnected`

- Connected: Connected to Socket.IO, allows -> `Disconnected`

- Disconnected: Disconnected from Socket.IO, allows -> `Reconnectiong`, `Released`

- Reconnectiong: Attempting to reconnect to Socket.IO, allowed states -> `Connected`, `Disconnected`

- Released: The object has been marked for memory deallocation and does not allow any operations or state transitions.

#### Why?

- The logic and representation of states and state transitions are complex.

- Each state must restrict certain operations (e.g., when State = Released, calling Send Event is not allowed). Using if...else directly makes the code difficult to maintain and read.

#### How?

- [Finite State Machine](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"}: Manage transitions between states

- [State Pattern](https://refactoring.guru/design-patterns/state){:target="_blank"}: A behavioral pattern that handles different responses based on the object's state changes

![](/assets/78507a8de6a5/1*NgehABZTiXL_fFEYQh63Hg.png)

- **Finite State Machine**: `SIOConnectionStateMachine` is the state machine implementation, `currentSIOConnectionState` represents the current state, and `created`, `connected`, `disconnected`, `reconnecting`, `released` list the possible states this machine can switch to.  
  `enterXXXState() throws` handles the allowed and disallowed (throw error) transitions when entering a certain state from the current state.

- **State Pattern**: `SIOConnectionState` is the abstract interface for all operations used by the states.

```swift
protocol SIOManagerSpec: AnyObject {
    func connect()
    func disconnect()
    func onEvent(event: String, callback: @escaping (Data?) -> Void)
    func send(_ event: String)
    func request(_ event: String, callback: @escaping (Data?) -> Void)
}

enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

class SIOManager: SIOManagerSpec {
        
    var state: ConnectionState = .disconnected {
        didSet {
            if state == .connected {
                executeBufferedCommands()
            }
        }
    }
    
    private var bufferedCommands: [BufferedCommand] = []
    
    func connect() {
        state = .connected
    }
    
    func disconnect() {
        state = .disconnected
    }
    
    func send(_ event: String) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self))
            return
        }
        
        print("Send:\(event)")
    }
    
    func request(_ event: String, callback: @escaping (Data?) -> Void) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self))
            return
        }
        
        print("request:\(event)")
    }
    
    func onEvent(event: String, callback: @escaping (Data?) -> Void) {
        //
    }
    
    func appendBufferedCommands(connectionCommand: BufferedCommand) {
        bufferedCommands.append(connectionCommand)
    }
    
    func executeBufferedCommands() {
        // First in, first out
        bufferedCommands.forEach { connectionCommand in
            connectionCommand.execute()
        }
        bufferedCommands.removeAll()
    }
    
    func removeAllBufferedCommands() {
        bufferedCommands.removeAll()
    }
}

let manager = SIOManager()
manager.send("send_event_1")
manager.send("send_event_2")
manager.request("request_event_1") { _ in
    //
}
manager.state = .connected

//

class SIOConnectionStateMachine {
    
    private(set) var currentSIOConnectionState: SIOConnectionState!

    private var created: SIOConnectionState!
    private var connected: SIOConnectionState!
    private var disconnected: SIOConnectionState!
    private var reconnecting: SIOConnectionState!
    private var released: SIOConnectionState!
    
    init() {
        self.created = SIOConnectionCreatedState(stateMachine: self)
        self.connected = SIOConnectionConnectedState(stateMachine: self)
        self.disconnected = SIOConnectionDisconnectedState(stateMachine: self)
        self.reconnecting = SIOConnectionReconnectingState(stateMachine: self)
        self.released = SIOConnectionReleasedState(stateMachine: self)
        
        self.currentSIOConnectionState = created
    }
    
    func enterConnected() throws {
        if [created.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(connected)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Connected")
        }
    }
    
    func enterDisconnected() throws {
        if [created.connectionState, connected.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(disconnected)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Disconnected")
        }
    }

    func enterReconnecting() throws {
        if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(reconnecting)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Reconnecting")
        }
    }

    func enterReleased() throws {
        if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(released)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Released")
        }
    }
    
    private func enter(_ state: SIOConnectionState) {
        currentSIOConnectionState = state
    }
}


protocol SIOConnectionState {
    var connectionState: ConnectionState { get }
    var stateMachine: SIOConnectionStateMachine { get }
    init(stateMachine: SIOConnectionStateMachine)

    func onConnected() throws
    func onDisconnected() throws
    
    
    func connect(socketManager: SIOManagerSpec) throws
    func disconnect(socketManager: SIOManagerSpec) throws
    func release(socketManager: SIOManagerSpec) throws
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws
    func send(socketManager: SIOManagerSpec, event: String) throws
}

struct SIOConnectionStateMachineError: Error {
    let message: String

    init(_ message: String) {
        self.message = message
    }

    var localizedDescription: String {
        return message
    }
}

class SIOConnectionCreatedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .created
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("CreatedState can't disconnect!")
    }
}

class SIOConnectionConnectedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .connected
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }
    
    func onConnected() throws {
        //
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionDisconnectedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .disconnected
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        //
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        try stateMachine.enterReleased()
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        try stateMachine.enterReconnecting()
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionReconnectingState: SIOConnectionState {
    
    let connectionState: ConnectionState = .reconnecting
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReconnectState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReconnectState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionReleasedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .released
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        throw SIOConnectionStateMachineError("ReleasedState can't onConnected!")
    }
    
    func onDisconnected() throws {
        throw SIOConnectionStateMachineError("ReleasedState can't onDisconnected!")
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't release!")
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't request!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't receiveOn!")
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't send!")
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't disconnect!")
    }
}

do {
    let stateMachine = SIOConnectionStateMachine()
    // mock on socket.io connect:
    // socketIO.on(connect){
    try stateMachine.currentSIOConnectionState.onConnected()
    try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: "test")
    try stateMachine.currentSIOConnectionState.release(socketManager: manager)
    try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: "test")
    // }
} catch {
    print("error: \(error)")
}

// output:
// error: SIOConnectionStateMachineError(message: "ConnectedState can\'t release!")
```

### Requirement Scenario 3.

#### What?

Combining scenarios 1 and 2, with the `ConnectionPool` flyweight pool and State Pattern for state management; we continue to extend. As stated in the background goal, the Feature side does not need to manage the underlying Connection mechanism. Therefore, we created a poller (named `ConnectionKeeper`) that periodically scans the strongly held `Connection` objects in the `ConnectionPool` and performs actions when the following situations occur:

- `Connection` is in use and the status is not `Connected`: change the status to `Reconnecting` and attempt to reconnect

- `Connection` is no longer in use and its status is `Connected`: change the status to `Disconnected`

- `Connection` is no longer in use and its state is `Disconnected`: change the state to `Released` and remove it from the `ConnectionPool`

#### Why?

- Three operations have a hierarchical relationship and are mutually exclusive (disconnected -> released or reconnecting)

- Flexible swapping and adding condition handling

- Without encapsulation, the three checks and operations can only be written directly within the method (making it difficult to test the logic).

- e.g:

```swift
if !connection.isOccupie() && connection.state == .connected then
... connection.disconnected()
else if !connection.isOccupie() && state == .released then
... connection.release()
else if connection.isOccupie() && state == .disconnected then
... connection.reconnecting()
end
```

#### How?

- [Chain Of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility){:target="_blank"}: A behavioral pattern that, as the name suggests, is a chain where each node has a corresponding operation. After receiving input data, a node decides whether to handle it or pass it to the next node. Another real-world example is the [iOS Responder Chain](https://swiftrocks.com/understanding-the-ios-responder-chain){:target="_blank"}.

> *By definition, the Chain of Responsibility Pattern does not allow a node to process the data and then pass it to the next node for further processing. **Either complete the processing or do not process at all**.*

> *If the above scenario is more suitable, it should be the [Interceptor Pattern](https://stackoverflow.com/questions/7951306/chain-of-responsibility-vs-interceptor){:target="_blank"}.*

![](/assets/78507a8de6a5/1*e8jHpykN1m3Y66Ukf-5OJA.png)

- **Chain of responsibility:** `ConnectionKeeperHandler` is the abstract node of the chain. The `canExcute` method is specially extracted to avoid the situation where this node handles the task but then wants to call the next node to continue execution. The `handle` method links the nodes in the chain, and `excute` defines the logic of how to process the task if it is handled.  
  `ConnectionKeeperHandlerContext` is used to store the necessary data, where `isOccupie` indicates whether the Connection is currently in use.

```swift
enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

protocol Connection {
    var connectionState: ConnectionState {get}
    var url: URL {get}
    var id: UUID {get}
    
    init(url: URL)
    
    func connect()
    func reconnect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let connectionState: ConnectionState = .created
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func reconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

//

struct ConnectionKeeperHandlerContext {
    let connection: Connection
    let isOccupie: Bool
}

protocol ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler? { get set }
    
    func handle(context: ConnectionKeeperHandlerContext)
    func execute(context: ConnectionKeeperHandlerContext)
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool
}

extension ConnectionKeeperHandler {
    func handle(context: ConnectionKeeperHandlerContext) {
        if canExcute(context: context) {
            execute(context: context)
        } else {
            nextHandler?.handle(context: context)
        }
    }
}

class DisconnectedConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.disconnect()
    }
    
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .connected && !context.isOccupie {
            return true
        }
        return false
    }
}

class ReconnectConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.reconnect()
    }
    
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .disconnected && context.isOccupie {
            return true
        }
        return false
    }
}

class ReleasedConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.disconnect()
    }
    
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .disconnected && !context.isOccupie {
            return true
        }
        return false
    }
}
let connection = SIOConnection(url: URL(string: "wss://pinkoi.com")!)
let disconnectedHandler = DisconnectedConnectionKeeperHandler()
let reconnectHandler = ReconnectConnectionKeeperHandler()
let releasedHandler = ReleasedConnectionKeeperHandler()
disconnectedHandler.nextHandler = reconnectHandler
reconnectHandler.nextHandler = releasedHandler

disconnectedHandler.handle(context: ConnectionKeeperHandlerContext(connection: connection, isOccupie: false))
```

### Requirement Scenario 4.

#### What?

The `Connection` we encapsulate needs to be set up before use, such as providing the URL Path, configuring settings, and so on.

#### Why?

- Flexible addition and removal of construction openings

- Reusable Construction Logic

- Without encapsulation, external code may operate the class in unintended ways.

- e.g.:

```
❌
let connection = Connection()
connection.send(event) // unexpected method call, should call .connect() first
✅
let connection = Connection()
connection.connect()
connection.send(event)
// but...who knows???
```

#### How?

- [Builder Pattern](https://refactoring.guru/design-patterns/builder){:target="_blank"}: A creational pattern that enables step-by-step object construction and reuse of building methods.

![](/assets/78507a8de6a5/1*J5eKaks1-fT6u8FojeUkUQ.png)

- **Builder Pattern:** `SIOConnectionBuilder` is the builder for `Connection`, responsible for setting and storing data used during the construction of a `Connection`; the `ConnectionConfiguration` abstract interface ensures that `.connect()` must be called before obtaining a `Connection` instance.

```swift
enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

protocol Connection {
    var connectionState: ConnectionState {get}
    var url: URL {get}
    var id: UUID {get}
    
    init(url: URL)
    
    func connect()
    func reconnect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let connectionState: ConnectionState = .created
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func reconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

//
class SIOConnectionClient: ConnectionConfiguration {
    private let url: URL
    private let config: [String: Any]
    
    init(url: URL, config: [String: Any]) {
        self.url = url
        self.config = config
    }
    
    func connect() -> Connection {
        // set config
        return SIOConnection(url: url)
    }
}

protocol ConnectionConfiguration {
    func connect() -> Connection
}

class SIOConnectionBuilder {
    private(set) var config: [String: Any] = [:]
    
    func setConfig(_ config: [String: Any]) -> SIOConnectionBuilder {
        self.config = config
        return self
    }
    
    // url is required parameter
    func build(url: URL) -> ConnectionConfiguration {
        return SIOConnectionClient(url: url, config: self.config)
    }
}

let builder = SIOConnectionBuilder().setConfig(["test":123])


let connection1 = builder.build(url: URL(string: "wss://pinkoi.com/1")!).connect()
let connection2 = builder.build(url: URL(string: "wss://pinkoi.com/1")!).connect()
```

Extension: Here, you can also apply the [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"} to generate `SIOConnection` using a factory.

### Done!

These are the four scenarios encountered during the Socket.IO encapsulation and the seven Design Patterns used to solve the problems.

#### Finally, the complete design blueprint for this Socket.IO encapsulation is attached

![](/assets/78507a8de6a5/1*DMfFpmF7aVCIIM1dskn97w.jpeg)

The naming and examples differ slightly from the text; this diagram shows the actual design architecture. We hope the original designer can share the design concept and open source it in the future.

### Who?

Who designed these and was responsible for the Socket.IO packaging project?

#### [Sean Zheng](https://www.linkedin.com/in/%E5%AE%87%E7%BF%94-%E9%84%AD-9b3409175/){:target="_blank"} , Android Engineer @ Pinkoi

![](/assets/78507a8de6a5/1*Q_35023LtcZbOtnfvSxv-A.jpeg)

Main architect, design pattern evaluation and application, implemented design on Android using Kotlin.

#### [ZhgChgLi](https://www.linkedin.com/in/zhgchgli/){:target="_blank"} , Engineer Lead/iOS Engineer @ Pinkoi

![](/assets/78507a8de6a5/1*1NCE3Q7fO5Mh15NT2xoYlA.png)

Platform Team project leader, pair programming, implementing designs in Swift on iOS, discussing and raising questions (a.k.a. just talking), and finally writing this article to share with everyone.

### Further Reading

- [Practical Application of Design Patterns (Encapsulating WKWebView)](../f4b02ee342a4/)

- [Visitor Pattern in Swift (Share Object to XXX Example)](../ba5773a7bfea/)

- [Visitor Pattern in TableView](../60473cb47550/)

For any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"} .

*[Post](https://medium.com/pinkoi-engineering/%E5%AF%A6%E6%88%B0%E7%B4%80%E9%8C%84-4-%E5%80%8B%E5%A0%B4%E6%99%AF-7-%E5%80%8B-design-patterns-78507a8de6a5){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*