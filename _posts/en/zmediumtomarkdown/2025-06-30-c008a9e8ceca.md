---
title: "CI/CD Practical Guide (Part 1): What is CI/CD? How to Build a Stable and Efficient Development Team through CI/CD? Tool Selection?"
author: "ZhgChgLi"
date: 2025-06-30T07:10:16.177+0000
last_modified_at: 2025-07-10T12:39:55.079+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","cicd","github-actions","jenkins","agile"]
description: "Using the App (iOS) Team as an example, this guide introduces CI/CD from scratch and the tangible value it can bring after implementation."
image:
  path: /assets/c008a9e8ceca/1*vokpvb4dyWHOnVnF3WGbfw.jpeg
pin: true
render_with_liquid: false
---

### CI/CD Practical Guide (Part 1): What is CI/CD? How to Build a Stable and Efficient Development Team through CI/CD? Tool Selection?

Using the App \(iOS\) Team as an example, this guide will help you understand CI/CD from scratch and the tangible value it can bring after implementation.

![Photo by [Leif Christoph Gottwald](https://unsplash.com/@project2204?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}](/assets/c008a9e8ceca/1*vokpvb4dyWHOnVnF3WGbfw.jpeg)

Photo by [Leif Christoph Gottwald](https://unsplash.com/@project2204?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}
#### Introduction

After going through the experience of setting up App CI/CD in two different development teams, I finally found time to organize my thoughts on the journey from "why do it" to "how to do it." I can't guarantee that this is the most standard CI/CD workflow, but it is definitely a worthwhile starting point to help your team begin implementation, enhance product stability, and improve overall development efficiency.
#### Chapters

This series of articles will start with "What is CI/CD and what value does it bring?" Then, we will walk through the hands-on implementation of "How to set up a CI/CD environment using GitHub Actions + self-hosted Runner" and "Using App development as an example, practically implementing CI and CD." Finally, we will introduce how to "Use Google Apps Script Web App in conjunction with GitHub Actions to create a convenient app packaging platform for cross-team use." I hope this series will be helpful to you.
- [**CI/CD Practical Guide (Part 1): What is CI/CD? How to Build a Stable and Efficient Development Team through CI/CD? Tool Selection?**](../c008a9e8ceca/)
- [**CI/CD Practical Guide (Part 2): Comprehensive Guide to Using and Setting Up GitHub Actions and Self-hosted Runner**](../404bd5c70040/)
- [**CI/CD Practical Guide (Part 3): Implementing CI and CD Workflows for App Projects Using GitHub Actions**](../4b001d2e8440/)
- [**CI/CD Practical Guide (Part 4): Building a Free and Easy-to-Use Packaging Tool Platform Using Google Apps Script Web App and GitHub Actions**](../4273e57e7148/)

#### Final Results

Without further ado, here are the final results.

![[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}](/assets/c008a9e8ceca/1*7-abScyjHQno1XzH4aGkaw.png)

[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}

![[Demo Web App](https://script.google.com/macros/s/AKfycbxk1nYhzfBzqny34rvBlxmcWMEQbWTL5a28mBmYId0NDaCZd0S-U3ytpBoTi2wZp0d6cg/exec){:target="_blank"}](/assets/c008a9e8ceca/1*yXMeaOELhqdvMCxIJ5ElBw.gif)

[Demo Web App](https://script.google.com/macros/s/AKfycbxk1nYhzfBzqny34rvBlxmcWMEQbWTL5a28mBmYId0NDaCZd0S-U3ytpBoTi2wZp0d6cg/exec){:target="_blank"}

CI/CD â€” All developed using GitHub Actions, easy to maintain and expand.

**CI:**
- Automatically trigger unit tests upon PR submission
- Execute corresponding tests based on the scope of changed files
- Only merge PRs after tests pass

**CD:**
- Google Apps Script Web App \(CD packaging interface\) allows engineers, QA, and PMs to package the app through this website on their computers or mobile devices
- GitHub Actions Self-hosted Runner uses your own machine for unlimited CI/CD usage
- Integrate with Firebase App Distribution API to directly obtain download links for packaged test versions

**Automation:**
- Automatically assign self upon PR submission
- Randomly assign reviewers upon PR submission
- Tag PR size labels

#### Demo Web App/Project

[**Sign in**](https://script.google.com/macros/s/AKfycbxk1nYhzfBzqny34rvBlxmcWMEQbWTL5a28mBmYId0NDaCZd0S-U3ytpBoTi2wZp0d6cg/exec){:target="_blank"} 
[_Edit description_ script\.google\.com](https://script.google.com/macros/s/AKfycbxk1nYhzfBzqny34rvBlxmcWMEQbWTL5a28mBmYId0NDaCZd0S-U3ytpBoTi2wZp0d6cg/exec){:target="_blank"}

[![](https://opengraph.githubassets.com/aae912e865445f1ec806c63abb65a8a4900e177a5c113b1b188caf01df5bb064/ZhgChgLi/github-actions-ci-cd-demo)](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/){:target="_blank"}

### What is CI/CD?
#### Story â€” Development Process Without CI/CD

Before discussing what CI/CD is, let's set aside the term "CI/CD" and recall how a startup development team without any established workflow would operate. The process can be summarized in the following diagram:

![](/assets/c008a9e8ceca/1*FHKyuk2C8THOD697wkVekQ.png)

1. A product has a bug, Developer T creates a branch fix/bug\-c from the main branch to fix it, and after completing the fix, merges it back to the main branch.
2. Next, Developer Z creates a branch feature/a from the main branch for Requirement A. Halfway through, they notice something is off with the functionality and **upon checking, realize that the current feature has been broken and the tests are also failing**, so they notify Developer T to make corrections.
3. Once all development is complete, Developer Z **packages the version for QA testing on their computer, going back and forth to make corrections and package it again**. Finally, after confirming everything is fine, they merge the feature back to the main branch.
4. As the Sprint comes to an end, they need to package a release for users; Developer Z **puts aside their current work** to assist in packaging from the main branch for QA to conduct regression testing, similarly **going back and forth to fix issues and repackage**, and once completed, submits the package for App review.
5. After Apple/Google reviews, it is released to users.

#### Problems

From the above story, we can identify two major issues.

**Question 1: There is no unified check mechanism for changes to currently functioning features.**
- Code that does not comply with coding style can still be merged
- I can merge even if the build fails
- Changes can be merged even if basic unit tests and important checks have not passed
- My environment may work correctly, but others may not
- It affects others who are currently developing

**Question 2: A significant amount of manpower and time is wasted on packaging tasks.**
- Packaging requires engineer manpower, interrupting current development work
- The cost of switching between packaging and development is extremely high
- Waiting time for packaging prevents other development work from proceeding
- The time cost of engineers translates to money
- Manual operations may lead to errors
- QA needs to ask engineers to package \(back and forth communication\)

#### CI â€” Continuous Integration

In response to Question 1, "Continuous Integration" aims to ensure that all changes automatically execute builds and tests in a unified environment, ensuring that changes pass all test cases and comply with team standards before entering the production environment â€” "continuously and automatically ensuring correct code integration into the production environment."

Additionally, it can increase nightly builds and more automated testing phases to ensure stability.
#### CD â€” Continuous Delivery / Deployment

In response to Question 2, "Continuous Deployment" aims to ensure that once the code passes the CI phase without issues, the results of the changes are automatically packaged and deployed through tedious processes for internal testing \(QA, Debug, Staging, Beta...\) or external release \(Production, Release...\).
- **Continuous Deployment:** Fully automated direct deployment to the Production environment
- **Continuous Delivery:** Automatically deploys to Staging/Debug environments, requiring manual verification before deploying to the Production environment

In the context of App development, it leans more towards **Continuous Delivery**, as we want to ensure that the app is fully verified by humans before release, ensuring the accuracy of release timing and functionality.
#### Story â€” **Building a Stable and Efficient Development Team through CI/CD**

![](/assets/c008a9e8ceca/1*wUwtvrN5Gwg5_slKc_QwFQ.png)

**Looking back at our story, after implementing CI/CD:**
- CI
All adjustments must pass automated testing verification before entering the main branch, and nightly builds are added to enhance stability.
- CD
Everyone uses CD for packaging, allowing Developer T and Developer Z to fully focus on business development, reducing manual communication and operational errors.

> Team efficiency and product stability ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ 

### The Value of CI/CD

Combining the core concept of agile development, "small steps, fast iterations," CI/CD provides the foundation for stability and work efficiency during "frequent continuous feature iterations."

**Automated Unified Verification of Iteration Results**
- Ensures all adjustments meet the correct expected results, do not affect other functionalities, and do not impact other team members

**Automated Execution of Tedious Deployment Processes**
- Allows team members to focus on primary business development, reducing manual operational errors

#### The Effectiveness of CI/CD

Reflecting on the 2021 talk at Pinkoi, "[**2021 Pinkoi Tech Career Talk â€” Secrets of High-Efficiency Engineering Teams**](../11f6c8568154/)," the content revolves around "automation, reducing reliance on individuals, and focusing on primary business." Implementing CI/CD aligns perfectly with these three directions, allowing us to estimate effectiveness using the same methods.

**Another point to highlight is the [cost of switching tasks](https://zh.wikipedia.org/wiki/%E5%BF%83%E6%B5%81%E7%90%86%E8%AB%96){:target="_blank"}:**

![](/assets/c008a9e8ceca/1*xOzjG-lSiFmdT-C4GHf0JA.png)

When we continuously engage in work for a period, we enter a "flow" state, where our thoughts and productivity peak, enabling us to produce the most effective output. However, if interrupted, it takes time to return to that flow state; for example, about 30 minutes.

**In a scenario without CI/CD, it might be:** Spending a lot of time only to discover that something was broken and then going back to communicate adjustments \(CI\), and having QA/PM ask engineers to help package the test version of the app \(CD\).
#### Estimating CI/CD Effectiveness

![Team size of 6 people / Monthly calculation](/assets/c008a9e8ceca/1*PYrKCNw84Om96Cez5EES5A.png)

Team size of 6 people / Monthly calculation

Here, we take a monthly basis, assuming that without CI/CD processes, there would be 4 instances per month of accidentally breaking the main branch, leading to subsequent correction and communication costs, approximately taking 720 minutes; plus the time spent packaging test versions, official versions, and potential errors caused by manual operations, totaling about 1,010 minutes; calculating with an engineer's monthly salary of 80,000, this results in approximately 13,000 in wasted costs each month.
#### CI/CD **Implementation Costs**
- Labor Costs:
Based on the construction outlined in this series of articles, it is estimated that 1 person would need to invest 10 days = **4,800 minutes** to complete it. \(~= **NT$36,384** \)
- Equipment and Execution Costs:
Using GitHub Actions self-hosted Runner requires only 1â€“2 [Mac-Mini](https://www.apple.com/tw/shop/buy-mac/mac-mini/m4){:target="_blank"} for initial procurement or directly using existing replaced MacBook Pro as CI/CD Runner.
Taking the example of purchasing a brand new Mac Mini for a 6-person team: 32G RAM M4 Mini \(= **NT$40,900** \)

The total cost is approximately **NT$80,000**, allowing for completion of the setup, with benefits starting about six months later.

> **_Disclaimer:_** _This is just one way to calculate benefits and may not be the most accurate; it is merely to provide a concept for extending, **allowing management decision-makers to see the benefits of CI/CD** and subsequently authorize the promotion of the entire workflow._ 

### Tool Selection for CI/CD
#### Cloud Services Bitrise / XCode Cloud
- **Bitrise:** The earliest cloud service focused on providing App CI/CD. My first experience with CI/CD was also using Bitrise, which offers a user-friendly step editing tool that allows for quick setup of App CI/CD processes.
**Cons:** Initially priced at $99 for unlimited usage, when Apple M series processors were first released, it switched to usage-based billing \( **a trap** \), estimating that the team's usage would cost at least $500 per month, so we migrated to GitHub Actions.
However, I recently checked their website, and they now offer 1 App / 1 Concurrent / unlimited usage for $89 per month.
- **XCode Cloud:** 100 hours / 1 month / $50, with the advantage of being highly integrated with XCode and App development; however, it also has the drawback of not supporting Android and some steps requiring customization can be challenging. But if it's a small iOS-only app, I would reconsider using it directly.

> _I am genuinely concerned about **cloud services having hidden costs**, and I prefer to have control in my hands, so I am considering on-premises services._ 

#### On-Premises Services Jenkins / GitHub Actions / Gitlab CI/CD
- **Gitlab CI/CD:** 
Launched earlier than GitHub Actions and has more complete features, but since our project is hosted on GitHub, we won't consider using Gitlab CI/CD; however, both have similar functionalities, and this series of articles will use GitHub Actions as an example.
- **GitHub Actions** 
Launched by GitHub in 2018, this CI/CD service is directly tied to GitHub projects and has continuously updated and improved features over the years, with many pre-packaged steps available in the \( [Marketplace](https://github.com/marketplace?type=actions){:target="_blank"} \) for direct use; it supports self-hosted runners, allowing unlimited use of your own machines. \(essentially a hybrid cloud\)
- **Jenkins:** 
An open-source free tool specifically for handling CI/CD, it is old but powerful; from application layer task design, permission management to underlying service dispatch execution, Jenkins covers it all; it also has [Plugins](https://plugins.jenkins.io/){:target="_blank"} that can be used directly, making it an essential tool for early DevOps CI/CD.

### Jenkins vs. GitHub Actions
#### **TL;DR**

> _For an App Team without dedicated DevOps, the barrier for App developers to set up and maintain a Jenkins environment from 0 to 1 is too high, and there are not many who know how to do it, which could also lead to network security issues; choosing to use GitHub Actions directly allows App developers to focus solely on CI/CD process design, quickly setting up a free, stable, and secure CI/CD service by just reviewing the official documentation on how to write and start the Runner._ 

```markdown
![](/assets/c008a9e8ceca/1*qg8SkzoJqNVvWPxx2Lh6uA.png)

> _The following comparison is based solely on the setup of App CI/CD and does not apply to all technical scenarios._

#### **Ease of Setup and Maintenance** Jenkins >>> GitHub Actions

![](/assets/c008a9e8ceca/1*7Quxx3LronhoOs8nyMzziw.png)

Here, I will use a not-so-professional structural diagram to explain the differences between the two. As mentioned earlier, Jenkins encompasses all functionalities from top to bottom, making self-hosting much more complex. In contrast, GitHub Actions only requires you to write YAML workflows on GitHub; your local machine only needs to register a GitHub self-hosted Runner (which can be done in 5 commands), and GitHub will automatically dispatch tasks to your local machine for execution. Other aspects, such as GitHub Actions/Runner version upgrades or task dispatch issues, are maintained by GitHub, so we don't need to handle them.

Another complicating factor is that Jenkins operates independently of Git, requiring communication through APIs (e.g., GitHub API/WebHook), which adds to the complexity of the setup.

I previously conducted a survey among about 30 iOS developers I could reach, and only a handful (2) understood Jenkins, while over 10 were using GitHub Actions, as it simply involves writing YAML to complete CI/CD tasks.

#### Learning Difficulty Jenkins >>> GitHub Actions

Similarly, you only need to refer to the official documentation to learn how to use the YAML commands for GitHub Actions and how to set up your own Runner locally.

#### Stability GitHub Actions > Jenkins

In this regard, I believe GitHub Actions slightly outperforms Jenkins.

Jenkins can crash due to system upgrades or conflicts with installed plugins (though if it runs smoothly and you don't touch it, there shouldn't be any issues).

GitHub Actions is subject to [GitHub service status](https://www.githubstatus.com/){:target="_blank"} (if GitHub is down, it will also be down), but this happens infrequently, with an average uptime of 99.9%. If there is a problem, we don't need to handle it; we just wait for a fix.

#### Security GitHub Actions > Jenkins

Considering that the GitHub Actions/Runner service is maintained and automatically updated by GitHub, it may be more secure than Jenkins, which requires manual updates.

Additionally, Jenkins needs to open API/WebHook ports for communication with GitHub, which is relatively risky. In contrast, GitHub integrates seamlessly with GitHub Actions, and the communication between GitHub Actions and self-hosted Runners follows an observer pattern, where the self-hosted Runner requests tasks from GitHub, meaning it doesn't need to open external interfaces.

However, in a fully closed network environment, Jenkins would be more secure than GitHub Actions.

#### Permission Control Jenkins >>> GitHub Actions

This point needs to be highlighted for comparison. Jenkins allows for separate account login permissions for control, while GitHub Actions is directly tied to the GitHub Repo, meaning only those with Repo permissions can use it.

> _*This is why the following articles will use GAS Web App to build a cross-team operational platform._ 

#### Usage Scope Jenkins >>> GitHub Actions

In teams with a complete DevOps team, there is no doubt that Jenkins would still be the preferred choice, as it has been running the longest in other fields (such as Web, backend, Java, etc.), with the most plugins available and best usability. It can also unify the CI/CD service for all teams, making management easier, or handle complex CI/CD scenarios like automatically deploying the frontend after backend deployment.

> _*GitHub Actions later also supported cross-repo Actions/Runners._ 

#### Richness of Third-Party Plugins Jenkins > GitHub Actions

In terms of quantity, GitHub Actions has more than Jenkins, but Jenkins has deeper and more powerful CI/CD functionalities, while many GitHub Actions features are merely automation functions.

#### Depth of Functionality Jenkins >>> GitHub Actions

This is not comparable; Jenkins has been around for nearly 20 years, while GitHub Actions still has many features to catch up on, such as permission management, secret management (currently limited to plain text; key files must be converted to plain text), and cache/artifact support (currently only for the cloud), etc.

**In terms of expansion, GitHub Self-hosted Runner also supports [Docker or k8s](https://docs.github.com/en/actions/concepts/runners/about-actions-runner-controller#scaling-runners){:target="_blank"} .**

#### Customization Depth Jenkins >>> GitHub Actions

Jenkins allows for complete control over the system, offering greater customization capabilities that can impact the entire system. GitHub Actions can only customize different steps at the application layer.

For example, the built-in artifacts in GitHub Actions do not support self-hosted runners, so you can only change the step to use `sh copy` to another directory, without the ability to customize artifacts.

> _*App CI/CD scenarios do not require overly complex functionalities._ 

#### Usability GitHub Actions >>> Jenkins

In terms of interface, GitHub Actions is a newer tool and is easier to use than Jenkins; in terms of script settings, Jenkins uses Pipeline Script stored on Jenkins, while GitHub Actions uses YAML files managed with Git, making it easier to set up than Jenkins.

#### Cost Risk Jenkins > GitHub Actions

Jenkins is fully open-source and free, giving you complete control, while GitHub Actions is partially open-source, but task dispatch and execution are part of GitHub's closed SaaS service. Currently, the policy is that GitHub Actions is completely free, but using GitHub Runner incurs costs (for private repos), while using self-hosted runners is free.

### Purpose of Google Apps Script Web App and Why It Was Chosen

Another tool choice is Google Apps Script Web App. The reason for needing this is that the form functionality provided by GitHub Actions is too basic (the interface is too engineering-oriented and only static), and the execution permissions are tied to the GitHub Repo, which can be very cumbersome if we need to provide it for other functional partners to use.

**As follows:**

![](/assets/c008a9e8ceca/1*kULMefCX5D6I5z9xt71A5A.png)

The CD packaging process would require the operator to fill in some information, such as Release Notes.

Therefore, we need a "user interface" tool to provide for other partners or even for our engineers to use more conveniently.

**Required Scenario:**

> _Fill in the necessary information on this more user-friendly "interface," connect to project management tools (e.g., Jira, Asana) to obtain tasks or directly retrieve the PR list from GitHub, select from a dropdown menu, and submit. Then, use the GitHub API to trigger GitHub Actions for packaging._

#### Slack

When we first introduced CI/CD, we chose to integrate with the Slack API to achieve effects similar to the following:

![[https://slack\.com/intl/zh\-tw/blog/productivity/workflow\-builder\-tools\-automation\-examples](https://slack.com/intl/zh-tw/blog/productivity/workflow-builder-tools-automation-examples){:target="_blank"}](/assets/c008a9e8ceca/1*m85bTTlrwAmCxoVqVXo2fg.png)

[https://slack\.com/intl/zh\-tw/blog/productivity/workflow\-builder\-tools\-automation\-examples](https://slack.com/intl/zh-tw/blog/productivity/workflow-builder-tools-automation-examples){:target="_blank"}
- Partners can directly use forms in Slack to fill in information, trigger CD packaging, and receive Slack notifications.

The operation was smooth and unified within our daily office tools (SSOT), requiring no retraining. However, the underlying issue is that **the development and maintenance costs are extremely high**, one reason being that the Slack Outgoing Webhook API has very high response requirements (it needs to respond within 3 seconds), which essentially rules out the use of FAAS services for simple integration (e.g., Cloud Functions, GAS, Lambdaâ€¦).

**Previously, one partner who was very interested in automation and backend developed a complete backend service using Kotlin + ktor, and then set up a server on GCP for Slack integration.**

> **_The development and maintenance costs are very, very high and difficult to hand over._** 

#### Google Apps Script â€” Web App

I previously shared "[Using Google Apps Script Web App Forms to Integrate with GitHub Action CI/CD Work](../4cb4437818f2/)":

![](/assets/c008a9e8ceca/1*Gr4PnV2J2AB9cVFuXMLjcA.png)

![[Demo Web App Form URL](https://script.google.com/macros/s/AKfycbw8SuK7lLLMdY86y3jxMJyzXqa5tdxJryRnteOnNi-lK--j6CmKYXj7UuU58DiS0NSVvA/exec){:target="_blank"}](/assets/c008a9e8ceca/1*NJRcY2ULVylZlsKnBtM27A.png)

[Demo Web App Form URL](https://script.google.com/macros/s/AKfycbw8SuK7lLLMdY86y3jxMJyzXqa5tdxJryRnteOnNi-lK--j6CmKYXj7UuU58DiS0NSVvA/exec){:target="_blank"}

**The advantages of using Google Apps Script â€” Web App are:**
- Web-based
- Permission management with Google Workspace enterprise accounts, allowing access only to Google accounts within the organization
- **Completely free**
- **Function as a Service without the need to set up and maintain servers**
- Easier to maintain and hand over
- Usable on mobile devices
- **AI Can Help!** 
**Whether it's ChatGPT or other AI tools, they are very familiar with GAS and can directly assist us in creating packaging forms and integrating with the GitHub API.**
- Can also integrate with Jira, Asana, and Slack notification APIs.

For the second promotion, I switched to using GAS Web App for partners, which received very positive feedback. The only difference from Slack is that you need to bookmark one more URL and open it to operate the packaging from the web form when needed.

### Complete Tool Workflow for App CI/CD

Here, I will attach the complete workflow. The next article will gradually introduce how to use and integrate each tool.

![](/assets/c008a9e8ceca/1*pQ-2Jj6s2qlvwTrLghJSjg.png)

#### Tool Roles:
- **GitHub Actions**: CI/CD logic script code
- **GitHub Actions â€” Self-hosted Runner**: The actual execution location for CI/CD, using a self-hosted Runner to execute tasks, only incurring the cost of purchasing the machine, allowing unlimited task execution.
- **Google Apps Script Web App**: Since packaging may not always be the responsibility of engineers, a platform is needed for cross-functional partners to use; GAS Web App can quickly create a web tool and share the URL for others to operate.
- **Asana/Jira**: Project management tools that can be integrated with GAS Web App, allowing QA/PM to directly select tasks to be packaged.
- **Slack**: Responsible for receiving execution result notifications.

#### Scenarios:
- End-User (QA/PM/PD/Developer): Uses GAS Web App to submit the packaging form (fetching the corresponding branch for Jira or Asana tasks) -> GAS calls GitHub API -> triggers CD packaging in GitHub Actions <- GitHub self-hosted runner listens for tasks and pulls them back to execute -> upon completion, Slack notification, updates GAS Web App packaging status.
- End-User (Developer): Opens PR, pushes new commits to PR -> triggers CI testing process <- GitHub self-hosted runner listens for tasks and pulls them back to execute -> upon completion, comments on test results, updates checks.

### Conclusion

This article primarily aims to give everyone a preliminary understanding of what CI/CD is and the benefits it brings. The next article will delve into the technical aspects, guiding you step-by-step to understand and implement GitHub Actions CI/CD to achieve the final results discussed earlier.

### Series Articles:
- [**CI/CD Practical Guide (1): What is CI/CD? How to Build a Stable and Efficient Development Team through CI/CD? Tool Selection?**](../c008a9e8ceca/)
- [**CI/CD Practical Guide (2): Comprehensive Guide to Using and Building GitHub Actions and Self-hosted Runners**](../404bd5c70040/)
- [**CI/CD Practical Guide (3): Implementing CI and CD Workflows for App Projects Using GitHub Actions**](../4b001d2e8440/)
- [**CI/CD Practical Guide (4): Using Google Apps Script Web App to Integrate GitHub Actions to Build a Free and Easy-to-Use Packaging Tool Platform**](../4273e57e7148/)

If you have any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://dev.zhgchg.li/ci-cd-%E5%AF%A6%E6%88%B0%E6%8C%87%E5%8D%97-%E4%B8%80-ci-cd-%E6%98%AF%E4%BB%80%E9%BA%BC-%E5%A6%82%E4%BD%95%E9%80%8F%E9%81%8E-ci-cd-%E6%89%93%E9%80%A0%E7%A9%A9%E5%AE%9A%E9%AB%98%E6%95%88%E7%9A%84%E9%96%8B%E7%99%BC%E5%9C%98%E9%9A%8A-%E5%B7%A5%E5%85%B7%E9%81%B8%E6%93%87-c008a9e8ceca){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```