---
title: "CI/CD Practical Guide (1): What is CI/CD? How to Build a Stable and Efficient Development Team through CI/CD? Tool Selection?"
author: "ZhgChgLi"
date: 2025-06-30T07:10:16.177+0000
last_modified_at: 2025-07-07T15:04:22.501+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","cicd","github-actions","jenkins","agile"]
description: "Using the App (iOS) Team as an example, this guide will introduce you to CI/CD from scratch and the tangible value it can bring after implementation."
image:
  path: /assets/c008a9e8ceca/1*vokpvb4dyWHOnVnF3WGbfw.jpeg
pin: true
render_with_liquid: false
---

### CI/CD Practical Guide (1): What is CI/CD? How to Build a Stable and Efficient Development Team through CI/CD? Tool Selection?

Using the App \(iOS\) Team as an example, this guide will introduce you to CI/CD from scratch and the tangible value it can bring after implementation.

![Photo by [Leif Christoph Gottwald](https://unsplash.com/@project2204?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}](/assets/c008a9e8ceca/1*vokpvb4dyWHOnVnF3WGbfw.jpeg)

Photo by [Leif Christoph Gottwald](https://unsplash.com/@project2204?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}
#### Introduction

After going through two experiences of building App CI/CD in different development teams, I finally found time to organize my thoughts from "why do it" to "how to do it." I can't guarantee this is the most standard CI/CD workflow, but it is definitely a worthwhile starting point to help your team begin implementation, enhance product stability, and improve overall development efficiency.
#### Chapters

This series of articles will start with "What is CI/CD and what value does it bring?" Then, we will proceed with a hands-on implementation of "How to set up a CI/CD environment using GitHub Actions + self-hosted Runner" and "Using App development as an example, practically implementing CI and CD." Finally, we will introduce how to "Use AI Vibe Coding Google Apps Script Web App combined with GitHub Actions to create a convenient app packaging platform for cross-team use." I hope this series will be helpful to you.
- [**CI/CD Practical Guide (1): What is CI/CD? How to Build a Stable and Efficient Development Team through CI/CD? Tool Selection?**](../c008a9e8ceca/)
- [**CI/CD Practical Guide (2): Comprehensive Guide to Using and Building GitHub Actions and Self-hosted Runner**](../404bd5c70040/)
- [**CI/CD Practical Guide (3): Implementing CI and CD Workflows for App Projects Using GitHub Actions**](../4b001d2e8440/)
- **CI/CD Practical Guide (4): Using Google Apps Script Web App (AI Vibe Coding) Combined with GitHub Actions to Create a Free and Easy-to-Use Cross-Team Packaging Platform Tool**

#### Final Results

Without further ado, here are the final results.

![](/assets/c008a9e8ceca/1*1OrLo5Poiynn_r8ciLVNQQ.png)

![](/assets/c008a9e8ceca/1*KfOn8J8erPGgGcs7_DE3yA.png)

![](/assets/c008a9e8ceca/1*NTgTv_FVdAJPX31vEylDdw.png)

CI/CD — All developed using GitHub Actions, easy to maintain and expand.

**CI:**
- Automatically trigger unit tests upon PR submission
- Execute corresponding tests based on the scope of changed files
- Only merge PRs after tests pass

**CD:**
- Google Apps Script Web App (CD packaging interface) allows engineers, QA, and PMs to package the app on their computers or mobile devices
- GitHub Actions Self-hosted Runner uses your own machine for unlimited CI/CD usage
- Integrate with Firebase App Distribution API to directly obtain download links for packaged test versions

**Automation:**
- Automatically assign self upon PR submission
- Randomly assign reviewers upon PR submission
- Label PR size

### What is CI/CD?
#### Story — Development Process Without CI/CD

Before discussing what CI/CD really is, let's set aside the term "CI/CD" and recall how a startup development team without any established workflow operates. The process can be summarized in the following diagram:

![](/assets/c008a9e8ceca/1*FHKyuk2C8THOD697wkVekQ.png)

1. A product has a bug, Developer T creates a branch fix/bug\-c from the main branch to fix it, and after fixing, merges it back to the main branch.
2. Next, Developer Z creates a branch feature/a from the main branch for Requirement A, but halfway through realizes something is wrong with the functionality. **Upon checking, they discover that the current functionality has been broken and the tests are also failing**, and they notify Developer T to fix it.
3. Once development is complete, Developer Z **packages the version for QA testing on their computer, going back and forth to fix and package**. After confirming everything is fine, they merge the functionality back to the main branch.
4. As the sprint comes to an end, a release needs to be packaged for users; Developer Z **puts aside their current work** to assist in packaging from the main branch for QA to conduct regression testing, similarly **going back and forth to fix issues and repackage**. Once completed, they submit the package for app review.
5. After Apple/Google reviews, it is released to users.

#### Problems

From the above story, we can identify two major issues.

**Question 1: There is no unified check mechanism for current functional changes.**
- Code that does not conform to coding style can still be merged
- I can merge even if the build fails
- Changes can be merged even if basic unit tests and important checks have not passed
- My environment may work correctly, but others may not
- It affects others who are currently developing

**Question 2: A significant amount of human time is wasted on packaging work.**
- Packaging requires engineers to manually package, interrupting current development work
- The cost of switching between packaging and development is extremely high
- Waiting time for packaging prevents other development work from proceeding
- The time cost of engineers is money
- Manual operations can lead to errors
- QA needs to ask engineers to package \(back and forth communication\)

#### CI — Continuous Integration

In response to Question 1, "Continuous Integration" aims to ensure that all changes can automatically execute builds and tests in a unified environment, ensuring that changes pass all test cases and meet team standards before entering the production environment — "continuously and automatically ensuring the correct code is integrated into the production environment."

Additionally, it can increase nightly builds and more automated testing phases to ensure stability.
#### CD — Continuous Delivery / Deployment

In response to Question 2, "Continuous Deployment" aims to ensure that after the CI phase has no issues, the results of changes are automatically packaged and deployed to internal testing \(QA, Debug, Staging, Beta...\) or externally to production \(Production, Release...\).
- **Continuous Deployment:** Fully automated direct deployment to the production environment
- **Continuous Delivery:** Automatically deploys to staging/debug environments, requiring manual verification before deploying to production

In the context of app development, it leans more towards **Continuous Delivery**, as we want to ensure that the app is manually verified to be completely problem-free before release, ensuring the correctness of release timing and functionality.
#### Story — **Building a Stable and Efficient Development Team through CI/CD**

![](/assets/c008a9e8ceca/1*wUwtvrN5Gwg5_slKc_QwFQ.png)

**Looking back at our story, after implementing CI/CD:**
- CI
All adjustments must pass automated testing verification before entering the main branch, and nightly builds are added to enhance stability.
- CD
All packaging is unified, allowing Developer T and Developer Z to fully focus on business development, reducing manual communication and operational errors.

> Teamwork efficiency and product stability 🚀🚀🚀🚀🚀 

### The Value of CI/CD

Combining the core concept of agile development "small steps, fast iterations," CI/CD provides the foundation for stability and work efficiency during "frequent continuous iterations of features."

**Automated Unified Verification of Iteration Results**
- Ensures all adjustments meet the correct expected results, do not affect other functionalities, and do not impact other team members

**Automated Execution of Tedious Deployment Processes**
- Allows team members to focus on primary business development, reducing manual operational errors

#### The Effectiveness of CI/CD

Reflecting on the 2021 talk at Pinkoi "[**2021 Pinkoi Tech Career Talk — Unveiling High-Efficiency Engineering Teams**](../11f6c8568154/)," the message is quite similar, revolving around "automation, reducing dependency on individuals, and focusing on primary business." Implementing CI/CD aligns perfectly with these three directions, allowing us to estimate effectiveness using the same methods.

**Another point to highlight is the [cost of switching tasks](https://zh.wikipedia.org/wiki/%E5%BF%83%E6%B5%81%E7%90%86%E8%AB%96){:target="_blank"}:** 

![](/assets/c008a9e8ceca/1*xOzjG-lSiFmdT-C4GHf0JA.png)

When we continuously engage in work for a period, we enter a "flow" state, where our thoughts and productivity peak, allowing for the most effective output. However, if interrupted, it takes time to return to that flow state; here, we take 30 minutes as an example.

**In a scenario without CI/CD, it might be:** Spending a lot of time discovering that something was broken and then going back to communicate adjustments \(CI\), and having QA/PM ask engineers to help package the test version of the app \(CD\).
#### Estimating CI/CD Effectiveness

![Team size of 6 people / Calculated over one month](/assets/c008a9e8ceca/1*PYrKCNw84Om96Cez5EES5A.png)

Team size of 6 people / Calculated over one month

Here, we base it on a monthly cycle, assuming that without a CI/CD process, there would be 4 instances of accidentally breaking the main branch each month, resulting in subsequent correction and communication costs, approximately taking 720 minutes; plus the time spent packaging test versions, official versions, and potential errors due to manual operations, totaling about 1,010 minutes; with an engineer's monthly salary of 80,000, this results in approximately 13,000 in wasted costs each month.
#### CI/CD **Implementation Costs**
- Labor Costs:
Based on the construction outlined in this series of articles, it is estimated that 1 person would need to invest 10 days = **4,800 minutes** to complete it. \(~= **NT$36,384** \)
- Equipment and Execution Costs:
Using GitHub Actions self-hosted Runner only requires the procurement of 1–2 [Mac Mini](https://www.apple.com/tw/shop/buy-mac/mac-mini/m4){:target="_blank"} or directly using existing replaced MacBook Pros to serve as CI/CD Runners.
Taking the example of purchasing a brand new Mac Mini for a 6-person team: 32G RAM M4 Mini \(= **NT$40,900** \)

The total cost is approximately **NT$80,000**, allowing for completion of the setup, with benefits starting about six months later.

> **_Disclaimer:_** _This is just one way to calculate benefits and may not be the most accurate; it is merely to provide a concept for extending, **allowing management decision-makers to see the benefits of CI/CD** and thus authorize the promotion of the entire workflow._ 

### Tool Selection for CI/CD
#### Cloud Services Bitrise / XCode Cloud
- **Bitrise:** The earliest cloud service focused on providing App CI/CD. My first encounter with CI/CD was also through Bitrise, which offers a user-friendly step editing tool that allows for quick setup of App CI/CD processes.
**Cons:** Initially priced at $99 for unlimited usage, when Apple M series processors were first released, they switched to usage-based billing \( **"bait and switch"** \), estimating that the team's usage would cost at least $500 per month, so we migrated to GitHub Actions.
However, I recently checked their website, and they now offer 1 App / 1 Concurrent / unlimited usage for $89 per month.
- **XCode Cloud:** 100 hours / 1 month / $50, with the advantage of being highly integrated with XCode and app development; however, it also has the drawback of not supporting Android usage and some custom steps can be difficult; but if it's a small iOS-only app, I would reconsider using it directly.

> _I am really worried about **cloud services having hidden costs**, so I prefer to have control in my own hands and am considering on-premises services._ 

#### On-Premises Services Jenkins / GitHub Actions / Gitlab CI/CD
- **Gitlab CI/CD:** 
Launched earlier than GitHub Actions and has more complete features, but since our project is hosted on GitHub, we won't consider using Gitlab CI/CD; however, the functionalities are similar, and this series of articles will use GitHub Actions as an example.
- **GitHub Actions** 
Launched by GitHub in 2018, this CI/CD service is directly tied to GitHub projects and has continuously updated and improved features over the years, with many pre-packaged steps available in the \( [Marketplace](https://github.com/marketplace?type=actions){:target="_blank"} \) for direct use; it supports self-hosted runners, allowing for unlimited use of your own machines. \(essentially a hybrid cloud\)
- **Jenkins:** 
An open-source free tool specifically for handling CI/CD, it is old but powerful; from application layer task design, permission management to underlying service dispatch execution, Jenkins covers it all; it also has \( [Plugins](https://plugins.jenkins.io/){:target="_blank"} \) that can be used directly, making it an essential tool for early DevOps CI/CD.

### Jenkins vs. GitHub Actions
#### **TL;DR**

> _For an App Team without dedicated DevOps, having app developers set up and maintain a Jenkins environment from scratch is too high a barrier, and there are not many who can do it, which could also lead to network security issues; choosing to use GitHub Actions directly allows app developers to focus solely on CI/CD process design, and with a quick glance at the official documentation on how to write and start the Runner, they can quickly set up a free, stable, and secure CI/CD service._ 

![](/assets/c008a9e8ceca/1*qg8SkzoJqNVvWPxx2Lh6uA.png)

> _The following comparison is based solely on setting up App CI/CD and may not apply to all technical scenarios._ 

#### **Ease of Setup and Maintenance** Jenkins >>> GitHub Actions

![](/assets/c008a9e8ceca/1*7Quxx3LronhoOs8nyMzziw.png)

Here, I will use a not-so-professional structural diagram to explain the differences between the two. As mentioned, Jenkins covers everything from top to bottom, making self-hosting much more complex; whereas GitHub Actions only requires writing YAML workflows on GitHub, and the local machine only needs to register the GitHub self-hosted Runner \(5 commands to complete\), after which GitHub will automatically dispatch tasks to the local machine for execution. Other aspects, including GitHub Actions/Runner version upgrades or task dispatch issues, are maintained by GitHub, so we do not need to handle them.

---
還有另一個比較麻煩的點是 Jenkins 是獨立於 Git 的服務，之間要透過 API \(e\.g\. GitHub API/WebHook\) 進行溝通，設定又更複雜了。

之前也從身邊能接觸到的 iOS 開發者\(約 30 位\)做過調查，懂 Jenkins 的屈指可數\( 2 位\) 而有在使用 GitHub Actions 的則超過 \(10 位\) 畢竟就是寫一寫 YAML 就能完成 CI/CD 任務。
#### 學習難易度 Jenkins >>> GitHub Actions

同上只需參考官方文件學習 GitHub Actions 可用 YAML 指令跟如何在本地起自己的 Runner 即可。
#### 穩定性 GitHub Actions > Jenkins

這點我覺得 GitHub Actions 略勝 Jenkins。

Jenkins 有機會因為系統升級或裝到有衝突的 Plugin 導致服務崩潰 \(不過如果跑得好好的不去動它基本上沒有問題\)。

GitHub Actions 受限於 [GitHub 服務狀態](https://www.githubstatus.com/){:target="_blank"} \(如果 GitHub 掛也會跟著掛\)，但是發生頻率不高，平均在線率都能維持在 99\.9%；真出問題也不用處理，坐等修復。
#### 安全性 GitHub Actions > Jenkins

考量到 GitHub Actions/Runner 服務本身是 GitHub 在維護跟自動更新這點可能會比 Jenkins 需要手動更新來的更安全。

另外 Jenkins 跟 GitHub 溝通之間需要開 API/WebHook 口相對比較危險，GitHub 與 GitHub Actions 之間是無痛整合、GitHub Actions 與 self\-hosted Runner 之間是觀察者模式，self\-hosted Runner 會去跟 GitHub 要任務回來做，所以 Runner 本身不需開對外接口。

但如果是全封閉網路環境，Jenkins 會比 GitHub Actions 安全。
#### 權限控管 Jenkins >>> GitHub Actions

這點需要特別挑出來比較，Jenkins 可以另外設定帳號登入權限進行控管；GitHub Actions 則直接與 GitHub Repo 進行綁定，要有 Repo 權限的人才能使用。

> _\*因此後面的文章才會又用 GAS Web App 搭建跨團隊的操作平台。_

#### 使用廣度 Jenkins >>> GitHub Actions

在有完整 DevOps Team 的團隊無庸置疑的應該還是會選擇 Jenkins，畢竟在其他領域 \(例如 Web, 後端, Java…\) 還是 Jenkins 運行最久、Plugin 做多最好用，並且可以統一建置一套 CI/CD 服務所有團隊使用方便控管，或是後端部署完前端自動部署這種複雜的 CI/CD 場景。

> _\*GitHub Actions 後來也支援跨 Repo Actions/Runner 了。_

#### 第三方套件豐富度 Jenkins > GitHub Actions

就數量上 GitHub Actions 大於 Jenkins，但是 Jenkins 理的 CI/CD 功能比較有深度跟強大，GitHub Actions 很多只是自動化的功能。
#### 功能深度 Jenkins >>> GitHub Actions

這點沒法比，Jenkins 已做了快 20 年，GitHub Actions 還有很多功能需要再補上；例如：權限管理、Secret 管理\(目前只限純文字，密鑰檔案的話要先轉成純文字\)、Cache/Artifact 目前只支援 Cloud…等等

**擴展上，GitHub Self\-hosted Runner 也支援 [Docker or k8s](https://docs.github.com/en/actions/concepts/runners/about-actions-runner-controller#scaling-runners){:target="_blank"} 。**
#### 客製化深度 Jenkins >>> GitHub Actions

Jenkins 從頭到尾都掌控在自己手上，客製化的權限比較大，可以影響到整個系統，GitHub Actions 只能在應用層客製化不同步驟而已。

例如目前 GitHub Actions 內建的 Artifacts 不支援 self\-hosted，那也只能在步驟中改成 sh copy 到其他目錄，無法自行客製化實現 Artifacts。

> _\*App CI/CD 場景也用不到太深度的功能。_

#### 易用性 GitHub Actions >>> Jenkins

介面上 GitHub Actions 是新的工具在介面使用上比 Jenkins 更容易使用； 腳本設定上 Jenkins 是 Pipeline Script 儲存在 Jenkins 上、GitHub Actions 是 YAML 檔跟著專案 Git 管理，也比 Jenkins 容易設定。
#### 費用風險 Jenkins > GitHub Actions

Jenkins 全開源免費權掌握在手，GitHub Actions 部分開源但任務派發與執行是 GitHub 封閉的 SAAS 服務；目前政策是 GitHub Actions 完全免費，使用 GitHub Runner 才要錢\(Private Repo\)，使用 self\-hosted runner 則不用。
### Google Apps Script Web App 的用途與為何選擇

另一個工具選擇是 Google Apps Script Web App，會需要多一個這個的原因是 GitHub Actions 自帶的表單功能過於陽春\(介面太工程、只能靜態\)並且執行權限跟 GitHub Repo 綁定在一起，如果我們需要提供給其他職能夥伴使用會非常的麻煩。

**如下：**

![](/assets/c008a9e8ceca/1*kULMefCX5D6I5z9xt71A5A.png)

CD 打包會希望讓操作人填寫一些資訊，例如 Release Notes。

因此我們需要一個「介面」工具提供給其他夥伴使用或甚至是自己工程師更方便的使用。

**所需情境：**

> _在這個比較好用的「介面」上填寫需要的資訊，串接專案管理工具\(e\.g\. Jira, Asana\) 取得 Task 或是 GitHub 直接取得 PR 列表，直接下拉選單選擇後送出，再透過 GitHub API 觸發 GitHub Actions 進行打包。_

#### Slack

第一次導入 CI/CD 的時候我們選擇串接 Slack API 達成類似如下效果：

![[https://slack\.com/intl/zh\-tw/blog/productivity/workflow\-builder\-tools\-automation\-examples](https://slack.com/intl/zh-tw/blog/productivity/workflow-builder-tools-automation-examples){:target="_blank"}](/assets/c008a9e8ceca/1*m85bTTlrwAmCxoVqVXo2fg.png)

[https://slack\.com/intl/zh\-tw/blog/productivity/workflow\-builder\-tools\-automation\-examples](https://slack.com/intl/zh-tw/blog/productivity/workflow-builder-tools-automation-examples){:target="_blank"}
- 夥伴可以直接在 Slack 中使用表單填寫資訊、並觸發 CD 打包、收到 Slack 通知

使用操作起來很順暢並且統一在日常的辦公工具上\(SSOT\) 不需重新學習；但是他背後的問題是 **開發跟維護成本非常的高** ，其中有一個原因是 Slack Outgoing\-Webhook API 對響應要求非常高 \(需要在 3 秒內\)，因此基本上可以直接排除使用 FAAS 服務簡單串接了 \(e\.g\. Cloud Functions, GAS, Lambda…\)。

**之前的做法是有一位對自動化跟後端很有興趣的夥伴自己用 Kotlin\+ktor 開發了一整套後端服務，然後再 GCP 起伺服器供 Slack 串接使用。**

> **_開發與維護成本非常非常高而且很難交接。_**

#### Google Apps Script — Web App

之前有分享過「 [使用 Google Apps Script Web App 表單串接 Github Action CI/CD 工作](../4cb4437818f2/) 」:

![](/assets/c008a9e8ceca/1*Gr4PnV2J2AB9cVFuXMLjcA.png)

![[Demo Web App Form URL](https://script.google.com/macros/s/AKfycbw8SuK7lLLMdY86y3jxMJyzXqa5tdxJryRnteOnNi-lK--j6CmKYXj7UuU58DiS0NSVvA/exec){:target="_blank"}](/assets/c008a9e8ceca/1*NJRcY2ULVylZlsKnBtM27A.png)

[Demo Web App Form URL](https://script.google.com/macros/s/AKfycbw8SuK7lLLMdY86y3jxMJyzXqa5tdxJryRnteOnNi-lK--j6CmKYXj7UuU58DiS0NSVvA/exec){:target="_blank"}

**使用 Google Apps Script — Web App 的優勢是：**
- 網站 Web
- 同 Google Workspace 企業帳號權限管理，可設定只有組織內的 Google 帳號才能存取
- **完全免費**
- **Function as a Service 不需自行架設維護伺服器**
- 較容易維護與交接
- 手機上可以操作
- **AI Can Help\!** 
**不管是 ChatGPT 或其他 AI 工具對 GAS 都非常熟悉，可以直接動口請他幫我們製作打包表單與串接 GitHub API**
- 一樣能串接 Jira, Asana, Slack 通知 API

第二推廣我就改用 GAS Web App 給夥伴使用，同樣得到很好的反響，跟 Slack 差別就只在要多記一個網址到書籤，需要打包的時候打開網址從網頁表單操作打包。
### App CI/CD 完整工具流程

這邊先附上完整的工作流程，下篇開始會逐步介紹每個工具如何使用與串接。

![](/assets/c008a9e8ceca/1*1puKPXp2bZRB7pBgxuEy-Q.png)

#### 工具角色：
- **GitHub Actions** : CI/CD 邏輯腳本程式碼
- **GitHub Actions — Self\-hosted Runner** : CI/CD 實際執行的地方，使用自己架設的 Runner 執行，只需要負擔機器購買成本，就能無限制使用量的執行任務。
- **Google Apps Script Web App** : 因打包不一定是工程師負責，需要有一個平台給跨職能夥伴可以使用； GAS Web App 能快速打造一個 Web 工具分享網址給其他人操作使用。
- **Asana/Jira** : 專案管理工具，可與 GAS Web App 串接讓 QA/PM 可以直接選擇想把包的 Task 進行打包。
- **Slack** : 負責接收執行結果通知

#### 場景：
- End\-User \(QA/PM/PD/Developer\): 使用 GAS Web App 送出打包表單 \(撈取 Jira or Asana 任務單對應的 Branch\) \-&gt; GAS 打 GitHub API \-&gt; 觸發 CD 打包 Github Actions &lt;\- GitHub self\-hosted runner 監聽到任務拉回機器執行 \-&gt; 執行完畢 Slack 通知、更新 GAS Web App 打包狀態。
- End\-User \(Developer\): 開 PR、Push new commit 到 PR \-&gt; 觸發 CI 測試流程 &lt;\- GitHub self\-hosted runner 監聽到任務拉回機器執行 \-&gt; 執行完畢 Comment 測試結果、更新 Checks。

### 總結

本篇主要是帶大家初步了解 CI/CD 是什麼跟帶來的效益，下一篇開始會進入技術環節，手把手帶您了解、實作 GitHub Actions CI/CD 到最終完成前文的最終成果。
#### 下一篇： [**CI/CD 實戰指南（二）：GitHub Actions 與 self\-hosted Runner 使用與建置大全**](../404bd5c70040/)

有任何問題及指教歡迎 [與我聯絡](https://www.zhgchg.li/contact){:target="_blank"} 。

_[Post](https://dev.zhgchg.li/ci-cd-%E5%AF%A6%E6%88%B0%E6%8C%87%E5%8D%97-%E4%B8%80-ci-cd-%E6%98%AF%E4%BB%80%E9%BA%BC-%E5%A6%82%E4%BD%95%E9%80%8F%E9%81%8E-ci-cd-%E6%89%93%E9%80%A0%E7%A9%A9%E5%AE%9A%E9%AB%98%E6%95%88%E7%9A%84%E9%96%8B%E7%99%BC%E5%9C%98%E9%9A%8A-%E5%B7%A5%E5%85%B7%E9%81%B8%E6%93%87-c008a9e8ceca){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._