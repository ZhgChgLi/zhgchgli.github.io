---
author: ZhgChgLi
categories:
- ZRealm Development
date: 2019-02-05T16:23:30.749+0000
description: Discover how to build an Apple Watch app from scratch with this hands-on
  watchOS 5 tutorial, designed for developers seeking clear, practical steps to launch
  functional apps efficiently.
image:
  path: /assets/e85d77b05061/1*aNqsa7aR3Vi3NIIvaUFZLA.png
last_modified_at: 2024-04-13T07:37:01.476+0000
render_with_liquid: false
tags:
- iOS
- watchOS
- Apple Watch Apps
- WatchKit
- iOS App Development
title: Apple Watch App Development｜Step-by-Step watchOS 5 Guide for Beginners
---

### Let's Build an Apple Watch App! (Swift)

watchOS 5 Step-by-Step Development of Apple Watch App from Scratch

#### [[Latest] Apple Watch Series 6 Unboxing & Two-Year Experience >>> Click Here](../eab0e984043/)

### Introduction:

After the previous [Apple Watch Unboxing Article](../a2920e33e73e/), almost three months have passed, and I finally found the opportunity to start developing an Apple Watch App.

![[Wedding Planner — The Largest Wedding Planning App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329#?platform=appleWatch){:target="_blank"}](/assets/e85d77b05061/1*aNqsa7aR3Vi3NIIvaUFZLA.png)

[Wedding Planner — The Largest Wedding Planning App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329#?platform=appleWatch){:target="_blank"}

Here is the feedback after using it for three months:
1. e-SIM (LTE) still hasn’t found a use case, so I haven’t applied for or used it.
2. Frequently used features: unlocking Mac by proximity, raise to check notifications, Apple Pay.
3. Health reminders: after three months, I’ve started to slack off; I glance at notifications, but feel indifferent if I don’t close the activity rings.
4. Third-party app support is still very poor.
5. Watch faces can be changed freely according to mood, adding freshness.
6. More detailed workout tracking: for example, if I walk a bit farther to buy dinner, the watch automatically detects it and asks if I want to record the workout.

After using it for three months, overall, it is still like multiple little life assistants as described in the original unboxing article, helping you handle trivial matters.

### Third-Party App Support Is Still Poor

Before I actually developed an Apple Watch App, I wondered why apps on Apple Watch were so basic or just "barely usable," including LINE (messages not synced and never updated) and Messenger (just barely usable); it wasn't until I developed an Apple Watch App myself that I understood the developers' difficulties...

### First, Understand the Positioning of the Apple Watch App, Simplify Complexity

The positioning of Apple Watch is **"not to replace the iPhone, but to assist"**. This direction is reflected in official introductions, official apps, and watchOS APIs; that's why third-party apps often feel basic and limited in functionality (sorry, I was too greedy Orz).

Using [Our A](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E6%9C%80%E5%A4%A7%E5%A9%9A%E7%A6%AE%E7%B1%8C%E5%82%99app/id1356057329?mt=8){:target="_blank"} app as an example, it includes features like searching for businesses, viewing columns, discussion forums, and online inquiries. Online inquiries are valuable to bring to the Apple Watch because they require immediacy and faster replies, which increase the chance of securing orders. Features like searching for businesses, viewing columns, and discussion forums are more complex and less meaningful on the watch due to limited screen space and lack of urgency.

The core concept is still "assistive first," so not every feature needs to be on the Apple Watch. After all, users rarely wear only the watch without their phone, and in such cases, their needs are limited to essential functions (for example, reading column articles is not urgent enough to require immediate access on the watch).

### Let's get started!

> ***This is also my first time developing an Apple Watch App, so the article may not be very detailed. I welcome your feedback!!***

> ***This article is only suitable for readers with basic experience in iOS App/UIKit development***

> ***This article uses: iOS ≥ 9, watchOS ≥ 5***

#### Creating a watchOS Target for an iOS Project:

![File -> New -> Target -> watchOS -> WatchKit App](/assets/e85d77b05061/1*yxwki7mCbfJbEfsTDM683A.png)

File -> New -> Target -> watchOS -> WatchKit App

**Apple Watch App cannot be installed independently; it must be bundled with an iOS App**

After creating it, the directory will look like this:

![](/assets/e85d77b05061/1*WIjSrYl5Hch0mGIjlNbyFQ.png)

You will find two Target items, both essential:

1. WatchKit App: Responsible for storing resources and UI display  
   /Interface.storyboard: Same as iOS, contains system-created view controllers  
   /Assets.xcassets: Same as iOS, stores used resource items  
   /info.plist: Same as iOS, WatchKit App related settings

2. WatchKit Extension: Responsible for program calls and logic processing (*.swift)  
   /InterfaceController.swift: Default view controller program  
   /ExtensionDelegate.swift: Similar to Swift's AppDelegate, the entry point for the Apple Watch App  
   /NotificationController.swift: Handles push notification display on the Apple Watch App  
   /Assets.xcassets: Not used here; all assets are stored under WatchKit App's Assets.xcassets  
   /info.plist: Similar to iOS, WatchKit Extension related settings  
   /PushNotificationPayload.apns: Push notification data, used for testing push notifications on the simulator

Details will be introduced later; for now, just get a general understanding of the table of contents and the document's features.

#### View Controller:

**In Apple Watch, the view controller is called InterfaceController instead of ViewController.** You can find the Interface Controller Scene in WatchKit App/Interface.storyboard. The code controlling it is located in WatchKit Extension/InterfaceController.swift (similar to the iOS concept).

![Scene is set to be together with the Notification Controller Scene by default (I will move it up a bit to separate them)](/assets/e85d77b05061/1*2ibd9b4yaRGxwSpgKMdyUw.png)

The Scene is set to be grouped with the Notification Controller Scene by default (I will move it up a bit to separate them).

You can set the title text of the InterfaceController on the right side.

The title color is determined by the Interface Builder Document/Global tint setting, ensuring a consistent color scheme throughout the entire app.

![](/assets/e85d77b05061/1*ZcS9q4gNSBo6MZLp1eITeA.jpeg)

#### Component Library:

![No complex components, and all component functions are simple and clear](/assets/e85d77b05061/1*Armv40CxLqJ1wlbMI_o1oQ.png)

There are not many complex components, and the functions of the components are simple and clear.

#### UI Layout:

A towering building starts from the View. For layout, there is no Auto Layout, constraints, or layers like in UIKit (iOS). All layout settings are done using parameters, making it simpler and more powerful (somewhat like UIStackView in UIKit).

> **All layouts are composed of Groups, similar to UIStackView in UIKit but with more layout parameters available**

![Group Parameter Settings](/assets/e85d77b05061/1*aoHxAFjEGgH3ZLQx9GhH_Q.png)

Group Parameter Settings

1. Layout: Set the arrangement of enclosed subviews (horizontal, vertical, layer stacking)

2. Insets: Set the top, bottom, left, and right margins of the Group

3. Spacing: Set the spacing between the enclosed child Views

4. Radius: Set the corner radius of the Group. That's right! WatchKit comes with built-in corner radius parameters.

5. Alignment/Horizontal: Sets the horizontal alignment (left, center, right) and is linked to the settings of neighboring and outer wrapping Views.

6. Alignment/Vertical: Sets the vertical alignment (top, center, bottom) and interacts with neighboring and outer wrapper views.

7. Size/Width: Set the size of the Group with three modes available: "Fixed: specify width," "Size To Fit Content: width based on the size of child views," and "Relative to Container: width relative to the outer container view (can set % or +/- adjustments)."

8. Size/Height: Same as Size/Width, this sets the height.

#### Font/Font Size Settings:

![](/assets/e85d77b05061/1*8NfJeD4FsUw-SpAx_VFDCQ.png)

You can directly apply the system's Text Styles or use Custom (but I tested Custom and couldn't set the font size); so **I use System** to customize the font size of each display Label.

#### **Learning by Doing: Using Line Formatting as an Example**

![](/assets/e85d77b05061/1*oY9kLcnASy9j1WXxV4FGPA.png)

Layout is not as complex as on iOS, so I’ll demonstrate with an example to help you get started quickly; using Line’s main page layout as an example:

*Find the Interface Controller Scene in WatchKit App/Interface.storyboard:*

1. The entire page is equivalent to the UITableView used in iOS App development. In Apple Watch Apps, it simplifies the operation and is renamed "WKInterfaceTable."  
First, drag a Table into the Interface Controller Scene.

![](/assets/e85d77b05061/1*bui2UXp9QwBYSYC-mwyK6g.png)

Like UIKit's UITableView, there is the main Table and Cells (called Rows on Apple Watch); using it simplifies many tasks. **You can directly design and layout Cells on this interface!**

2. Analyze the layout structure and design the Row display style:

![](/assets/e85d77b05061/1*2bsyQ9Szfptugtg_KKxcgg.png)

To layout a full-height image with rounded corners on the left stacked with a label, and on the right evenly divide two sections with a label on top and another label below:

2–1: Layout of Left and Right Sections

![](/assets/e85d77b05061/1*ez1NpEq3fgAMEqNjwTvWdw.png)

Drag two Groups into a Group, and set the Size parameter for each:

Left green section:

![Layout setting overlap, with a subview displaying unread message label layer stacking](/assets/e85d77b05061/1*axrBV1EHrPtOHvTnLtB79w.png)

Layout setting Overlap, where the child View displays unread message Labels in layered stacking.

![Set a fixed width and height of 40 for the square](/assets/e85d77b05061/1*Ti346bLg8AM2FInO6PNwLw.png)

Set a square with fixed width and height of 40.

Right side red part:

![Layout set to Vertical, with two child views displayed top and bottom](/assets/e85d77b05061/1*5aq_TTFEp3kq6RusiTkYcw.png)

Layout set to Vertical, with child Views arranged in two vertical sections.

![Width set relative to outer layer, 100% ratio, minus 40 from the left green part](/assets/e85d77b05061/1*aXH2d1kDRLNl4XsizV9P_g.png)

Width set relative to the outer layer, 100% minus 40 for the left green part

Layout inside left and right containers:

![](/assets/e85d77b05061/1*NR2vAZ3mqPMjCLqBCJ6ZxQ.png)

Left side: Drag in an Image, then drag in a Group containing a Label aligned to the bottom right (set the Group background color, spacing, and corner radius).

Right side: Add two Labels, one aligned to the top left and the other aligned to the bottom left.

#### Naming a Row (Similar to setting an identifier for a Cell in UIKit UITableView):

![Select Row -> Identifier -> Enter Custom Name](/assets/e85d77b05061/1*VTCVIJRAG-sGdBLjC26TKg.png)

Select Row -> Identifier -> Enter a custom name

#### There is more than one way to display a Row.

Very simple, just add a Row inside the Table (the style of the Row to display is controlled by the program) and enter an Identifier to name it.

![Here I add another Row to display a message when there is no data](/assets/e85d77b05061/1*kQOKjxqmtI7M8BwYQ0yY0A.png)

Here, I add another Row to display a message when there is no data.

#### Layout Related Information

The hidden property in watchKit does not occupy space, which can be used for interactive applications (e.g., show a Table only when logged in; show a prompt Label when not logged in).

![](/assets/e85d77b05061/1*RiCY7mH4_MyocNPN1GDuvA.png)

The layout is complete for now and can be adjusted according to your personal design; it’s easy to get started—just try aligning a few more times and experimenting with the parameters to get familiar!

#### Program Control Section:

Continuing with Row, we need to create a Class to reference and operate on Row:

```swift
class ContactRow:NSObject {
}
```

![](/assets/e85d77b05061/1*-AnyG0_PLubAX7f-579BMw.png)

```swift
class ContactRow:NSObject {
    var id:String?
    @IBOutlet var unReadGroup: WKInterfaceGroup!
    @IBOutlet var unReadLabel: WKInterfaceLabel!
    @IBOutlet weak var imageView: WKInterfaceImage!
    @IBOutlet weak var nameLabel: WKInterfaceLabel!
    @IBOutlet weak var timeLabel: WKInterfaceLabel!
}
```

Pull outlet, store variable

For the Table section, similarly drag the Outlet to the Controller:

```swift
class InterfaceController: WKInterfaceController {

    @IBOutlet weak var Table: WKInterfaceTable!
    override func awake(withContext context: Any?) {
        super.awake(withContext: context)
        
        // Configure interface objects here.
    }
    
    override func willActivate() {
        // This method is called when watch view controller is about to be visible to user
        super.willActivate()
    }
    
    struct ContactStruct {
        var name:String
        var image:String
        var time:String
    }
    
    func loadData() {
        //Get API Call Back...
        //postData {
        let data:[ContactStruct] = [] //api returned data...
        
        self.Table.setNumberOfRows(data.count, withRowType: "ContactRow")
        //If you have multiple row types to display, use:
            //self.Table.setRowTypes(["ContactRow","ContactRow2","ContactRow3"])
        //
        for item in data.enumerated() {
            if let row = self.Table.rowController(at: item.offset) as? ContactRow {
                row.nameLabel.setText(item.element.name)
                //assign value to label/image......
            }
        }
        
        //}
    }
    
    override func didDeactivate() {
        // This method is called when watch view controller is no longer visible
        super.didDeactivate()
        loadData()
    }
    
    //Handle row selection:
    override func table(_ table: WKInterfaceTable, didSelectRowAt rowIndex: Int) {
        guard let row = table.rowController(at: rowIndex) as? ContactRow,let id = row.id else {
            return
        }
        self.pushController(withName: "showDetail", context: id)
    }
}
```

Table operations are much simpler without delegate/datasource. To set data, just call setNumberOfRows/setRowTypes to specify the number and type of rows, then use rowController(at:) to set the content for each row!

The Table row selection event can be handled simply by overriding the function  
`override func table(_ table: WKInterfaceTable, didSelectRowAt rowIndex: Int)`. (This is the only event for Table)

#### How to skip pages?

![Set the Identifier for the Interface Controller first](/assets/e85d77b05061/1*1KovG3qshPRsCgUXkbDYFw.png)

First, set the Identifier for the Interface Controller

watchKit has two page navigation modes:

1. Similar to iOS UIKit push  
self.pushController(withName: **Interface Controller Identifier**, context: **Any?**)

![Push method with back button at top left](/assets/e85d77b05061/1*snXj8xFP0MtF3_sVWK1xUw.png)

Push method allows returning from the top left corner

Go Back to Previous Page with iOS UIKit: self.pop()

Return to root page: self.popToRootController()

Open a new page: self.presentController( )

2. [Tab Display Style](https://developer.apple.com/library/archive/documentation/General/Conceptual/WatchKitProgrammingGuide/InterfaceStyles.html){:target="_blank"}
WKInterfaceController.reloadRootControllers(withNames: [ **Interface Controller Identifier** ], contexts: [ **Any?** ] )

Or in the Storyboard, press Control+Click on the first page's Interface Controller and drag to the second page, then select "next page".

![Tabs can be switched left and right to change pages](/assets/e85d77b05061/1*teUOM4Wql2hexR51g7v1lQ.png)

The tab display allows switching pages left and right

Do not mix the two page-skipping methods.

#### Pagination Parameters?

Unlike iOS, which requires custom delegates or segues to pass parameters, watchKit passes parameters by placing them in the **contexts** of the method above.

Receiving parameters in **InterfaceController**'s awake(withContext context: Any?)

For example, when I want to navigate from Page A to Page B and pass an id:Int:

Page A:

```swift
self.pushController(withName: "showDetail", context: 100)
```

Page B:

```swift
override func awake(withContext context: Any?) {
        super.awake(withContext: context)
        guard let id = context as? Int else {
           print("Parameter error!")
           self.popToRootController()
           return
        }
        // Configure interface objects here.
}
```

#### Program Control Components

Compared to iOS UIKit, it is much simpler. Those who have developed for iOS should pick it up quickly!  
For example, label becomes setText()  
p.s. Also, there is no getText method; you can only use an extension variable or store it in an external variable.

#### Syncing/Data Transfer with iPhone

If you have developed iOS-related Extensions, you would instinctively use App Groups to share UserDefaults. I enthusiastically did the same but got stuck for a long time because the data wouldn't transfer. Only after searching online did I find out that watchOS > 2 no longer supports this method...

To use the new WatchConnectivity method for communication between the phone and the watch (similar to the socket concept), both iOS phone and watchOS need to implement it. We write it as a singleton pattern as follows:

**Mobile:**

```swift
import WatchConnectivity

class WatchSessionManager: NSObject, WCSessionDelegate {
    @available(iOS 9.3, *)
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        // Session activation completed on the iPhone side
    }
    
    func session(_ session: WCSession, didReceiveUserInfo userInfo: [String : Any] = [:]) {
        // iPhone received UserInfo sent from the watch
    }
    
    func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {
        // iPhone received a Message sent from the watch
    }
    
    // There are also didReceiveMessageData and didReceiveFile methods to handle data received from the watch
    // Choose which one to use based on your data transfer and reception needs
    
    func sendUserInfo() {
        guard let validSession = self.validSession, validSession.isReachable else {
            return
        }
        
        if userDefaultsTransfer?.isTransferring == true {
            userDefaultsTransfer?.cancel()
        }
        
        var list:[String:Any] = [:]
        // Put UserDefaults data into list....
        
        self.userDefaultsTransfer = validSession.transferUserInfo(list)
    }
    
    func sessionReachabilityDidChange(_ session: WCSession) {
        // When connection status with the watch app changes (watch app opened/closed)
        sendUserInfo()
        // Sync UserDefaults once when the watch app opens on status change
    }
    
    func session(_ session: WCSession, didFinish userInfoTransfer: WCSessionUserInfoTransfer, error: Error?) {
        // Completed syncing UserDefaults (transferUserInfo)
    }
    
    func sessionDidBecomeInactive(_ session: WCSession) {
        
    }
    
    func sessionDidDeactivate(_ session: WCSession) {
        
    }
    
    static let sharedManager = WatchSessionManager()
    private override init() {
        super.init()
    }
    
    private let session: WCSession? = WCSession.isSupported() ? WCSession.default : nil
    private var validSession: WCSession? {
        if let session = session, session.isPaired && session.isWatchAppInstalled {
            return session
        }
        // Return a valid session that is connected and has the watch app installed and running
        return nil
    }
    
    func startSession() {
        session?.delegate = self
        session?.activate()
    }
}
```

WatchConnectivity Code on the iPhone Side

Add WatchSessionManager.sharedManager.startSession() in iOS/AppDelegate.swift's application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) to connect the session after launching the mobile app.

**Watch Side:**

```swift
import WatchConnectivity

class WatchSessionManager: NSObject, WCSessionDelegate {
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
    }
    
    func sessionReachabilityDidChange(_ session: WCSession) {
        guard session.isReachable else {
            return
        }
        
    }
    
    func session(_ session: WCSession, didFinish userInfoTransfer: WCSessionUserInfoTransfer, error: Error?) {
        
    }
    
    func session(_ session: WCSession, didReceiveUserInfo userInfo: [String : Any] = [:]) {
        DispatchQueue.main.async {
            // UserDefaults:
            // print(userInfo)
        }
    }
    
    static let sharedManager = WatchSessionManager()
    private override init() {
        super.init()
    }
    
    private let session: WCSession? = WCSession.isSupported() ? WCSession.default : nil
    
    func startSession() {
        session?.delegate = self
        session?.activate()
    }
}

```

WatchConnectivity Watch App Code

Add the following line in WatchOS Extension/ExtensionDelegate.swift inside applicationDidFinishLaunching():

WatchSessionManager.sharedManager.startSession()

to connect the session after launching the watch app.

#### WatchConnectivity Data Transfer Methods

To send data: sendMessage, sendMessageData, transferUserInfo, transferFile  
To receive data: didReceiveMessageData, didReceive, didReceiveMessage  
Both sides use the same methods for sending and receiving.

![](/assets/e85d77b05061/1*eVT-62WCBy1ZZC90abJPqA.png)

You can see that data transfer from the watch to the phone works fine, but data transfer from the phone to the watch only works when the watch app is open.

#### watchOS Push Notification Handling

The PushNotificationPayload.apns file under the project directory comes in handy here. It is used to test push notifications on the simulator. When you deploy the Watch App target on the simulator and launch the app after installation, you will receive a push notification with the content from this file, making it easier for developers to test push notification functionality.

![To modify/enable/disable PushNotificationPayload.apns, select the Target then Edit Scheme](/assets/e85d77b05061/1*1nlJOqwVqpMP6WtwdRcLPA.png)

To modify/enable/disable PushNotificationPayload.apns, please select the Target and then Edit Scheme.

**watchOS Push Notification Handling:**

Like in iOS, we implement UNUserNotificationCenterDelegate. In watchOS, we also implement the same method in watchOS Extension/ExtensionDelegate.swift.

```swift
import WatchKit
import UserNotifications
import WatchConnectivity

class ExtensionDelegate: NSObject, WKExtensionDelegate, UNUserNotificationCenterDelegate {

    func applicationDidFinishLaunching() {
        
        WatchSessionManager.sharedManager.startSession() // The previously mentioned WatchConnectivity connection
      
        UNUserNotificationCenter.current().delegate = self // Set UNUserNotificationCenter delegate
        // Perform any final initialization of your application.
    }
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler([.sound, .alert])
        // Same as iOS, this allows notifications to show when the app is in the foreground
    }
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        // When the notification is tapped
        guard let info = response.notification.request.content.userInfo["aps"] as? NSDictionary, let alert = info["alert"] as? Dictionary<String,String>, let data = info["data"] as? Dictionary<String,String> else {
            completionHandler()
            return
        }
        
        // response.actionIdentifier gives the tapped action identifier
        // Default tap action: UNNotificationDefaultActionIdentifier
        
        if alert["type"] == "new_ask" {
            WKExtension.shared().rootInterfaceController?.pushController(withName: "showDetail", context: 100)
            // Get the current root interface controller and push
        } else {
           // Other handling...
           // WKExtension.shared().rootInterfaceController?.presentController(withName: "", context: nil)
            
        }
        
        completionHandler()
    }
}
```

ExtensionDelegate.swift

**watchOS push notifications display in three types:**

1. static: Default push notification display mode

![Along with mobile push notifications, the iOS app implements UNUserNotificationCenter.setNotificationCategories to add buttons below the notification; this also appears by default on Apple Watch](/assets/e85d77b05061/1*uQN8Km08rio4tylAw48LyQ.jpeg)

Together with mobile push notifications, the iOS app implements UNUserNotificationCenter.setNotificationCategories to add buttons below the notification; Apple Watch will also display them by default.

1. dynamic: Dynamically handle push notification display styles (rearrange content, display images)

2. interactive: Supported on watchOS ≥ 5, adding button support on top of dynamic features

![You can set the notification handling method in the Static Notification Interface Controller Scene in Interface.storyboard](/assets/e85d77b05061/1*PlYKw5M3XBVDtjOa2tklgg.png)

You can set the notification handling method in the Static Notification Interface Controller Scene within Interface.storyboard.

There’s not much to say about static; it just uses the default display method. Here, we’ll introduce dynamic. After checking "Has Dynamic Interface," the "Dynamic Interface" option appears, where you can design your custom push notification layout (Buttons cannot be used here):

![My Custom Push Notification Design](/assets/e85d77b05061/1*RYSdWHxgmZX6Ht6m11Qpig.png)

My Custom Push Notification Design

```swift
import WatchKit
import Foundation
import UserNotifications

class NotificationController: WKUserNotificationInterfaceController {

    @IBOutlet var imageView: WKInterfaceImage!
    @IBOutlet var titleLabel: WKInterfaceLabel!
    @IBOutlet var contentLabel: WKInterfaceLabel!
    
    override init() {
        // Initialize variables here.
        super.init()
        self.setTitle("Marry Me") // Set the top-right title
        // Configure interface objects here.
    }

    override func willActivate() {
        // This method is called when watch view controller is about to be visible to user
        super.willActivate()
    }

    override func didDeactivate() {
        // This method is called when watch view controller is no longer visible
        super.didDeactivate()
    }
    
    override func didReceive(_ notification: UNNotification) {
        
        if #available(watchOSApplicationExtension 5.0, *) {
            self.notificationActions = []
            // Clear buttons added below the notification by iOS implementation of UNUserNotificationCenter.setNotificationCategories
        }
        
        guard let info = notification.request.content.userInfo["aps"] as? NSDictionary,let alert = info["alert"] as? Dictionary<String,String> else {
            return
        }
        // Notification info
        
        self.titleLabel.setText(alert["title"])
        self.contentLabel.setText(alert["body"])
        
        if #available(watchOSApplicationExtension 5.0, *) {
            if alert["type"] == "new_msg" {
              // If it's a new message notification, add a reply button below the notification
              self.notificationActions = [UNNotificationAction(identifier: "replyAction",title: "Reply", options: [.foreground])]
            } else {
              // Otherwise, add a view button
              self.notificationActions = [UNNotificationAction(identifier: "openAction",title: "View", options: [.foreground])]
            }
        }
        
        
        // This method is called when a notification needs to be presented.
        // Implement it if you use a dynamic notification interface.
        // Populate your dynamic notification interface as quickly as possible.
        
    }
}
```

For the code part, similarly connect the outlet to the controller and implement the functionality.

Next, regarding interactive, like dynamic, it can add Buttons and share the same Class for program control; I didn't use interactive because my buttons are added programmatically via self.notificationActions. The differences are as follows:

![Left uses interactive, right uses self.notificationActions](/assets/e85d77b05061/1*_1Crgx61kE6F509Jd2qxPQ.jpeg)

Left uses interactive, right uses self.notificationActions

Both methods require watchOS ≥ 5 support.

Using self.notificationActions to add buttons means the button events are handled by ExtensionDelegate's `userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void)`, and actions are identified by their identifier.

#### Menu Functions?

![Drag Menu into the component library, then drag Menu Item, and finally drag IBAction to program control](/assets/e85d77b05061/1*qHUly8lLEa5L7FSPJCrbcw.png)

Drag a Menu from the component library, then drag a Menu Item into it, and finally drag an IBAction to the code controller.

Pressing repeatedly on the page will display:

![](/assets/e85d77b05061/1*9aj7kUPsv9d8XUvgCpqfOg.png)

#### Content Input?

You can simply use the built-in presentTextInputController method!

```swift
@IBAction func replyBtnClick() {
    guard let target = target else {
        return
    }
    
    self.presentTextInputController(withSuggestions: ["Reply later","Thank you","Feel free to contact me","Okay","OK!"], allowedInputMode: WKTextInputMode.plain) { (results) in
        
        guard let results = results else {
            return
        }
        // When there is input
        
        let txts = results.filter({ (txt) -> Bool in
            if let txt = txt as? String, txt != "" {
                return true
            } else {
                return false
            }
        }).map({ (txt) -> String in
            return txt as? String ?? ""
        })
        // Preprocess input
        
        
        txts.forEach({ (txt) in
            print(txt)
        })
    }
}
```

![](/assets/e85d77b05061/1*CWr9RIb55Sn-FoMrTmc7sQ.png)

### Summary

> ***Thank you for reading this! Much appreciated!***

The article concludes here, briefly covering UI layout, programming, push notifications, and interface applications. For those who have developed iOS apps, the learning curve is very quick since it's quite similar, and many methods have been simplified for easier use. However, the available features are indeed fewer (for example, it's currently unclear how to implement "load more" for Tables). The current capabilities are quite limited, so I hope the official team will open up more APIs for developers in the future ❤️❤️❤️

#### MurMur:

![Deploying Apple Watch App Target to the watch is really slow — [Narcos](https://www.netflix.com/tw/title/80025172){:target="_blank"}](/assets/e85d77b05061/1*-J9qZ846ZysJEhMTSZeE3w.jpeg)

Apple Watch App Target deployment to the watch is really slow — [Narcos](https://www.netflix.com/tw/title/80025172){:target="_blank"}

If you have any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

*[Post](https://medium.com/zrealm-ios-dev/%E5%8B%95%E6%89%8B%E5%81%9A%E4%B8%80%E6%94%AF-apple-watch-app-%E5%90%A7-e85d77b05061){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*