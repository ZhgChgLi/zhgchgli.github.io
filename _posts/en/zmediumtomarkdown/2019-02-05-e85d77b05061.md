---
title: "Let's Create an Apple Watch App!"
author: "ZhgChgLi"
date: 2019-02-05T16:23:30.749+0000
last_modified_at: 2024-04-13T07:37:01.476+0000
categories: ["ZRealm Dev."]
tags: ["ios","watchos","apple-watch-apps","watchkit","ios-app-development"]
description: "A step-by-step guide to developing an Apple Watch App from scratch in watchOS 5"
image:
  path: /assets/e85d77b05061/1*aNqsa7aR3Vi3NIIvaUFZLA.png
render_with_liquid: false
---

### Let's Create an Apple Watch App! \(Swift\)

A step-by-step guide to developing an Apple Watch App from scratch in watchOS 5

#### [\[Latest\] Apple Watch Series 6 Unboxing & Two-Year Experience Review &gt;&gt;&gt; Click here](../eab0e984043/)
### Introduction:

It has been almost three months since my last article on [Apple Watch Unboxing](../a2920e33e73e/), and I finally found the opportunity to explore developing an Apple Watch App.

![[Wedding App — The Largest Wedding Planning App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329#?platform=appleWatch){:target="_blank"}](/assets/e85d77b05061/1*aNqsa7aR3Vi3NIIvaUFZLA.png)

[Wedding App — The Largest Wedding Planning App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329#?platform=appleWatch){:target="_blank"}

Here are my thoughts after using it for three months:
1. e-sim (LTE) still seems unnecessary, so I haven't applied for it or used it.
2. Commonly used features: unlocking my Mac with proximity, checking notifications by raising my wrist, Apple Pay.
3. Health reminders: after three months, I've started to slack off; I see the notifications but don't feel compelled to complete the circles.
4. Third-party app support is still quite poor.
5. The watch face can be changed according to my mood, adding freshness.
6. More detailed exercise tracking: for example, if I walk a bit further to buy dinner, the watch automatically detects and asks if I want to log the exercise.

Overall, after three months, it still feels like multiple little life assistants, helping you with trivial matters, just as I mentioned in the unboxing article.
### Third-Party App Support is Still Quite Poor

Before I actually developed an Apple Watch App, I was puzzled as to why the apps on the Apple Watch were so basic or merely "usable," including LINE (messages not syncing and never updated) and Messenger (just usable); it wasn't until I developed an Apple Watch App that I understood the developers' struggles… 
### First, Understand the Positioning of Apple Watch Apps, Simplifying Complexity

The positioning of the Apple Watch is **"not to replace the iPhone, but to assist it."** This is the direction reflected in official introductions, official apps, and watchOS APIs; hence, it feels like third-party apps are quite basic and have limited functionality (sorry, I was too greedy Orz).

Taking [our A](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E6%9C%80%E5%A4%A7%E5%A9%9A%E7%A6%AE%E7%B1%8C%E5%82%99app/id1356057329?mt=8){:target="_blank"} app as an example, it has features like searching for vendors, viewing columns, discussion forums, online inquiries, etc.; online inquiries are valuable to bring to the Apple Watch because they require immediacy, and quicker responses mean a higher chance of securing orders. Features like searching for vendors, viewing columns, and discussion forums are relatively complex, and even if they could be implemented on the watch, they wouldn't be very meaningful (the screen can display too little information, and they don't require immediacy).

The core concept remains "primarily supportive," so not every function needs to be brought to the Apple Watch; after all, users rarely find themselves wearing only the watch without the phone, and in such cases, their needs are limited to essential functions (like viewing column articles, which aren't urgent enough to need immediate access on the watch).
### Let's Get Started!

> **_This is also my first time developing an Apple Watch App, and the content of this article may not be very in-depth. I welcome everyone's guidance!!_** 

> **_This article is only suitable for readers who have experience in developing iOS Apps/UIKit._** 

> **_This article uses: iOS ≥ 9, watchOS ≥ 5_** 

#### Creating a watchOS Target for an iOS Project:

![File \-&gt; New \-&gt; Target \-&gt; watchOS \-&gt; WatchKit App](/assets/e85d77b05061/1*yxwki7mCbfJbEfsTDM683A.png)

File \-&gt; New \-&gt; Target \-&gt; watchOS \-&gt; WatchKit App

_\*The Apple Watch App cannot be installed independently; it must be attached to an iOS App._

After creating it, the directory will look like this:

![](/assets/e85d77b05061/1*WIjSrYl5Hch0mGIjlNbyFQ.png)

You will notice there are two Target items, both are essential:
1. WatchKit App: Responsible for storing resources and UI display
   - /Interface\.storyboard: Similar to iOS, it contains the system's default view controllers.
   - /Assets\.xcassets: Similar to iOS, it stores the resources used.
   - /info\.plist: Similar to iOS, it contains WatchKit App related settings.
2. WatchKit Extension: Responsible for program calls and logic processing (\*\.swift)
   - /InterfaceController\.swift: The default view controller program.
   - /ExtensionDelegate\.swift: Similar to Swift's AppDelegate, the entry point for the Apple Watch App.
   - /NotificationController\.swift: Used to handle push notifications displayed on the Apple Watch App.
   - /Assets\.xcassets: Not used here; I place everything in the WatchKit App's Assets\.xcassets.
   - /info\.plist: Similar to iOS, it contains WatchKit Extension related settings.
   - /PushNotificationPayload\.apns: Push notification data, which can be used to test push notification functionality on the simulator.

Details will be introduced later; for now, just have a general understanding of the directory and file content functions.

#### View Controller:

**In Apple Watch, the view controller is called InterfaceController instead of ViewController.** You can find the Interface Controller Scene in WatchKit App/Interface\.storyboard, and its controlling program is located in WatchKit Extension/InterfaceController\.swift (similar to the iOS concept).

![Scene defaults to being crowded with the Notification Controller Scene (I will pull it up a bit to separate them)](/assets/e85d77b05061/1*2ibd9b4yaRGxwSpgKMdyUw.png)

Scene defaults to being crowded with the Notification Controller Scene (I will pull it up a bit to separate them).

You can set the title display text for the InterfaceController on the right side.

The title color is determined by the Interface Builder Document/Global hint settings, ensuring a unified style color for the entire app.

![](/assets/e85d77b05061/1*ZcS9q4gNSBo6MZLp1eITeA.jpeg)

#### Component Library:

![There aren't many complex components, and their functions are simple and clear](/assets/e85d77b05061/1*Armv40CxLqJ1wlbMI_o1oQ.png)

There aren't many complex components, and their functions are simple and clear.

#### UI Layout:

A tall building starts from the View. The layout part does not have Auto Layout, constraints, or layers like UIKit (iOS); all layout settings are done using parameters, making it simpler and more powerful (it resembles UIStackView in UIKit).

> **All layouts are composed of Groups, similar to UIStackView in UIKit but with more layout parameters available.**

![Group parameter settings](/assets/e85d77b05061/1*aoHxAFjEGgH3ZLQx9GhH_Q.png)

Group parameter settings:
1. Layout: Sets the layout method for the child Views contained within (horizontal, vertical, stacked).
2. Insets: Sets the top, bottom, left, and right margins for the Group.
3. Spacing: Sets the spacing between the child Views contained within.
4. Radius: Sets the corner radius for the Group; yes! WatchKit has built-in corner radius settings.
5. Alignment/Horizontal: Sets the horizontal alignment (left, center, right) and interacts with neighboring and outer container Views.
6. Alignment/Vertical: Sets the vertical alignment (top, center, bottom) and interacts with neighboring and outer container Views.
7. Size/Width: Sets the size of the Group, with three modes to choose from: "Fixed: specified width," "Size To Fit Content: width determined by the size of the child Views," "Relative to Container: width based on the size of the outer container View (can set %/+ - adjustment values)."
8. Size/Height: Same as Size/Width; this sets the height.

#### Font/Font Size Settings:

![](/assets/e85d77b05061/1*8NfJeD4FsUw-SpAx_VFDCQ.png)

You can directly apply the system's Text Styles or use Custom (but I found that using Custom does not allow setting the font size); therefore, **I used System** to customize the font size for each display label.

#### **Learning by Doing: An Example with Line Layout**

![](/assets/e85d77b05061/1*oY9kLcnASy9j1WXxV4FGPA.png)

The layout part is not as complicated as iOS, so I will demonstrate it directly through examples for everyone to easily grasp; taking the main page layout of Line as an example:

_In the WatchKit App/Interface\.storyboard, find the Interface Controller Scene:_

1. The entire page corresponds to the UITableView used in iOS App development, which has been simplified in the Apple Watch App and renamed to "WKInterfaceTable." First, drag a Table into the Interface Controller Scene.

![](/assets/e85d77b05061/1*bui2UXp9QwBYSYC-mwyK6g.png)

Similar to UIKit's UITableView, there is the Table itself and Cells (called Rows in Apple Watch); it simplifies the usage significantly, **you can directly design the layout of the Cells in this interface!**

2. Analyze the layout structure and design the Row display style:

![](/assets/e85d77b05061/1*2bsyQ9Szfptugtg_KKxcgg.png)

To create a layout with a full-width image on the left with rounded corners and a label stacked on top, and on the right, evenly distribute two sections with a label on the top and another label on the bottom.

2–1: Create the structure for the left and right sections.

![](/assets/e85d77b05061/1*ez1NpEq3fgAMEqNjwTvWdw.png)

Drag two Groups into the Group and set the Size parameters respectively:

Left green section:

![Layout setting Overlap, where the subview needs to display the unread message label in a stacked manner](/assets/e85d77b05061/1*axrBV1EHrPtOHvTnLtB79w.png)

Layout setting Overlap, where the subview needs to display the unread message label in a stacked manner.

![Set a fixed square with a width and height of 40](/assets/e85d77b05061/1*Ti346bLg8AM2FInO6PNwLw.png)

Set a fixed square with a width and height of 40.

Right red section:

![Layout setting Vertical, where the subview needs to display two sections vertically](/assets/e85d77b05061/1*5aq_TTFEp3kq6RusiTkYcw.png)

Layout setting Vertical, where the subview needs to display two sections vertically.

![Width setting refers to the outer layer, proportion 100%, minus the left green section 40](/assets/e85d77b05061/1*aXH2d1kDRLNl4XsizV9P_g.png)

Width setting refers to the outer layer, proportion 100%, minus the left green section 40.

Layout within the left and right containers:

![](/assets/e85d77b05061/1*NR2vAZ3mqPMjCLqBCJ6ZxQ.png)

Left part: Drag in an Image, then drag in a Group that wraps a Label aligned to the bottom right (set the Group's background color, spacing, and corner radius).

Right part: Drag in two Labels, one aligned to the top left and the other aligned to the bottom left.

#### Naming the Row (similar to setting identifier for Cell in UIKit UITableView):

![Select Row -> Identifier -> Enter custom name](/assets/e85d77b05061/1*VTCVIJRAG-sGdBLjC26TKg.png)

Select Row -> Identifier -> Enter custom name.

#### Are there multiple presentation styles for the Row?

It's very simple; just drag another Row into the Table (the actual style of the ROW displayed is controlled by the program) and enter the Identifier name.

![Here I dragged another Row to display a prompt when there is no data](/assets/e85d77b05061/1*kQOKjxqmtI7M8BwYQ0yY0A.png)

Here I dragged another Row to display a prompt when there is no data.

#### Layout Related Information

The hidden property in WatchKit does not occupy space and can be used for interactive applications (show the Table only when logged in; show a prompt Label when not logged in).

![](/assets/e85d77b05061/1*RiCY7mH4_MyocNPN1GDuvA.png)

The layout ends here; you can modify it according to personal design; it's easy to get started, and after practicing a few times and playing with the alignment parameters, you'll become familiar with it!

#### Program Control Section:


Continuing with Row, we need to create a Class to reference Row operations:
```swift
class ContactRow:NSObject {
}
```


![](/assets/e85d77b05061/1*-AnyG0_PLubAX7f-579BMw.png)

```swift
class ContactRow:NSObject {
    var id:String?
    @IBOutlet var unReadGroup: WKInterfaceGroup!
    @IBOutlet var unReadLabel: WKInterfaceLabel!
    @IBOutlet weak var imageView: WKInterfaceImage!
    @IBOutlet weak var nameLabel: WKInterfaceLabel!
    @IBOutlet weak var timeLabel: WKInterfaceLabel!
}
```

Pull outlets and store variables.

For the Table part, similarly pull the Outlet into the Controller:
```swift
class InterfaceController: WKInterfaceController {

    @IBOutlet weak var Table: WKInterfaceTable!
    override func awake(withContext context: Any?) {
        super.awake(withContext: context)
        
        // Configure interface objects here.
    }
    
    override func willActivate() {
        // This method is called when watch view controller is about to be visible to user
        super.willActivate()
    }
    
    struct ContactStruct {
        var name:String
        var image:String
        var time:String
    }
    
    func loadData() {
        //Get API Call Back...
        //postData {
        let data:[ContactStruct] = [] //api returned data...
        
        self.Table.setNumberOfRows(data.count, withRowType: "ContactRow")
        //If you have multiple ROW types to present, use:
            //self.Table.setRowTypes(["ContactRow","ContactRow2","ContactRow3"])
        //
        for item in data.enumerated() {
            if let row = self.Table.rowController(at: item.offset) as? ContactRow {
                row.nameLabel.setText(item.element.name)
                //assign value to label/image......
            }
        }
        
        //}
    }
    
    override func didDeactivate() {
        // This method is called when watch view controller is no longer visible
        super.didDeactivate()
        loadData()
    }
    
    //Handle Row selection:
    override func table(_ table: WKInterfaceTable, didSelectRowAt rowIndex: Int) {
        guard let row = table.rowController(at: rowIndex) as? ContactRow, let id = row.id else {
            return
        }
        self.pushController(withName: "showDetail", context: id)
    }
}
```

```markdown
The operations of the Table have been greatly simplified without delegate/datasource. You only need to call setNumberOfRows/setRowTypes to specify the number and type of rows, and then use rowController(at:) to set the data content for each row!

The row selection event for the Table can be handled simply by overriding func table(_ table: WKInterfaceTable, didSelectRowAt rowIndex: Int). (This is the only event for the Table.)

#### How to navigate pages?

![First, set the Identifier for the Interface Controller](/assets/e85d77b05061/1*1KovG3qshPRsCgUXkbDYFw.png)

First, set the Identifier for the Interface Controller.

WatchKit has two page navigation modes:

1. Similar to iOS UIKit push
   self.pushController(withName: **Interface Controller Identifier**, context: **Any?**)

![Push method allows back to the top left](/assets/e85d77b05061/1*snXj8xFP0MtF3_sVWK1xUw.png)

The push method allows back to the top left.

To return to the previous page, use the same method as iOS UIKit: self.pop()

To return to the root page: self.popToRootController()

To open a new page: self.presentController()

2. [Tab display method](https://developer.apple.com/library/archive/documentation/General/Conceptual/WatchKitProgrammingGuide/InterfaceStyles.html){:target="_blank"}
   WKInterfaceController.reloadRootControllers(withNames: [**Interface Controller Identifier**], contexts: [**Any?**])

Alternatively, in the Storyboard, you can Control+Click drag from the first page's Interface Controller to the second page and select "next page."

![Tab display method allows horizontal page switching](/assets/e85d77b05061/1*teUOM4Wql2hexR51g7v1lQ.png)

The tab display method allows horizontal page switching.

The two navigation methods cannot be mixed.

#### Navigation parameters?

Unlike iOS, which requires custom delegates or segues to pass parameters, the WatchKit navigation with parameters simply involves placing the parameters in the **contexts** of the above methods.

To receive parameters in **InterfaceController**, use awake(withContext context: Any?).

For example, if I want to navigate from page A to page B and pass an id: Int:

Page A:
```swift
self.pushController(withName: "showDetail", context: 100)
```

Page B:
```swift
override func awake(withContext context: Any?) {
        super.awake(withContext: context)
        guard let id = context as? Int else {
           print("Parameter error!")
           self.popToRootController()
           return
        }
        // Configure interface objects here.
}
```

#### Program control components

Compared to iOS UIKit, it has also been greatly simplified, and those who have developed for iOS should find it easy to get started! For example, the label becomes setText().
p.s. Moreover, there is actually no getText() method; you can only use an extension variable or store it in an external variable.

#### Synchronization/Data transmission with iPhone

If you have developed iOS-related Extensions, you might instinctively use App Groups to share UserDefaults. I was also excited to do this initially, but after getting stuck for a long time, I found out that the data could not be transferred. After searching online, I discovered that this method is no longer supported after watchOS > 2...

To use the new WatchConnectivity method for communication between the phone and the watch (similar to socket concepts), both the iOS phone and the watchOS need to be implemented. We write it in singleton mode as follows:
```

**Mobile:**
```swift
import WatchConnectivity

class WatchSessionManager: NSObject, WCSessionDelegate {
    @available(iOS 9.3, *)
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        // Mobile session activation completed
    }
    
    func session(_ session: WCSession, didReceiveUserInfo userInfo: [String : Any] = [:]) {
        // Mobile received UserInfo from the watch
    }
    
    func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {
        // Mobile received Message from the watch
    }
    
    // Additionally, there are didReceiveMessageData and didReceiveFile, which also handle data received from the watch
    // Choose which one to use based on your data transfer needs
    
    func sendUserInfo() {
        guard let validSession = self.validSession, validSession.isReachable else {
            return
        }
        
        if userDefaultsTransfer?.isTransferring == true {
            userDefaultsTransfer?.cancel()
        }
        
        var list:[String:Any] = [:]
        // Place UserDefaults into list....
        
        self.userDefaultsTransfer = validSession.transferUserInfo(list)
    }
    
    func sessionReachabilityDidChange(_ session: WCSession) {
        // When the connection status with the watch app changes (when the watch opens/closes the app)
        sendUserInfo()
        // I synchronize UserDefaults once when the status changes, such as when the watch opens the app
    }
    
    func session(_ session: WCSession, didFinish userInfoTransfer: WCSessionUserInfoTransfer, error: Error?) {
        // Completed synchronizing UserDefaults (transferUserInfo)
    }
    
    func sessionDidBecomeInactive(_ session: WCSession) {
        
    }
    
    func sessionDidDeactivate(_ session: WCSession) {
        
    }
    
    static let sharedManager = WatchSessionManager()
    private override init() {
        super.init()
    }
    
    private let session: WCSession? = WCSession.isSupported() ? WCSession.default : nil
    private var validSession: WCSession? {
        if let session = session, session.isPaired && session.isWatchAppInstalled {
            return session
        }
        // Return a valid, connected session with the watch app open
        return nil
    }
    
    func startSession() {
        session?.delegate = self
        session?.activate()
    }
}
```

```markdown
WatchConnectivity Mobile Code

Add `WatchSessionManager.sharedManager.startSession()` in `iOS/AppDelegate.swift` within the `application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)` method to connect to the session after launching the mobile app.

**Watch Side:**
```swift
import WatchConnectivity

class WatchSessionManager: NSObject, WCSessionDelegate {
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
    }
    
    func sessionReachabilityDidChange(_ session: WCSession) {
        guard session.isReachable else {
            return
        }
        
    }
    
    func session(_ session: WCSession, didFinish userInfoTransfer: WCSessionUserInfoTransfer, error: Error?) {
        
    }
    
    func session(_ session: WCSession, didReceiveUserInfo userInfo: [String : Any] = [:]) {
        DispatchQueue.main.async {
            //UserDefaults:
            //print(userInfo)
        }
    }
    
    static let sharedManager = WatchSessionManager()
    private override init() {
        super.init()
    }
    
    private let session: WCSession? = WCSession.isSupported() ? WCSession.default : nil
    
    func startSession() {
        session?.delegate = self
        session?.activate()
    }
}

```

WatchConnectivity Watch Code

Add `WatchSessionManager.sharedManager.startSession()` in `WatchOS Extension/ExtensionDelegate.swift` within the `applicationDidFinishLaunching()` method to connect to the session after launching the watch app.

#### WatchConnectivity Data Transfer Methods

To send data: `sendMessage`, `sendMessageData`, `transferUserInfo`, `transferFile`  
To receive data: `didReceiveMessageData`, `didReceive`, `didReceiveMessage`  
The methods for sending and receiving data are the same on both ends.

![](/assets/e85d77b05061/1*eVT-62WCBy1ZZC90abJPqA.png)

As can be seen, data sent from the watch to the phone works fine, but data sent from the phone to the watch is only available when the watch app is open.

#### watchOS Push Notification Handling

The `PushNotificationPayload.apns` file in the project directory comes into play here. It is used for testing push notifications on the simulator. When the Watch App target is deployed on the simulator, after installing and launching the app, a push notification will be received with the content of this file, making it easier for developers to test the push notification functionality.

![To modify/enable/disable PushNotificationPayload.apns, select Target and then Edit Scheme](/assets/e85d77b05061/1*1nlJOqwVqpMP6WtwdRcLPA.png)

To modify/enable/disable `PushNotificationPayload.apns`, please select Target and then Edit Scheme.
```

**watchOS Push Notification Handling:**

Similar to iOS, we implement `UNUserNotificationCenterDelegate`. In watchOS, we also implement the same methods in `watchOS Extension/ExtensionDelegate.swift`
```swift
import WatchKit
import UserNotifications
import WatchConnectivity

class ExtensionDelegate: NSObject, WKExtensionDelegate, UNUserNotificationCenterDelegate {

    func applicationDidFinishLaunching() {
        
        WatchSessionManager.sharedManager.startSession() // The WatchConnectivity connection mentioned earlier
      
        UNUserNotificationCenter.current().delegate = self // Set UNUserNotificationCenter delegate
        // Perform any final initialization of your application.
    }
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler([.sound, .alert])
        // Similar to iOS, this approach allows notifications to be displayed while the app is in the foreground
    }
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        // When the notification is tapped
        guard let info = response.notification.request.content.userInfo["aps"] as? NSDictionary, let alert = info["alert"] as? Dictionary<String,String>, let data = info["data"] as? Dictionary<String,String> else {
            completionHandler()
            return
        }
        
        // response.actionIdentifier can get the identifier of the tap event
        // Default tap event: UNNotificationDefaultActionIdentifier
        
        if alert["type"] == "new_ask" {
            WKExtension.shared().rootInterfaceController?.pushController(withName: "showDetail", context: 100)
            // Get the current root interface controller and push
        } else {
           // Other handling....
           // WKExtension.shared().rootInterfaceController?.presentController(withName: "", context: nil)
            
        }
        
        completionHandler()
    }
}
```

ExtensionDelegate.swift

**watchOS Push Notification Display, divided into three types:**
1. static: Default push notification display method

![Similar to mobile push notifications, the iOS side has implemented `UNUserNotificationCenter.setNotificationCategories` to add buttons below the notification; Apple Watch will also display this by default](/assets/e85d77b05061/1*uQN8Km08rio4tylAw48LyQ.jpeg)


For mobile push notifications, the iOS side has implemented `UNUserNotificationCenter.setNotificationCategories` to add buttons below the notifications; the Apple Watch will also display this by default.
1. dynamic: Dynamically handle the display style of push notifications (reorganize content, display images)
2. interactive: Supported in watchOS ≥ 5, adding support for buttons on top of the dynamic interface

![You can set the push notification handling method in the Static Notification Interface Controller Scene in Interface.storyboard](/assets/e85d77b05061/1*PlYKw5M3XBVDtjOa2tklgg.png)

You can set the push notification handling method in the Static Notification Interface Controller Scene in Interface.storyboard

Static doesn't require much explanation; it simply uses the default display method. Here, I will introduce dynamic. After checking "Has Dynamic Interface," "Dynamic Interface" will appear, allowing you to design your custom push notification presentation (Buttons cannot be used):

![My custom push notification presentation design](/assets/e85d77b05061/1*RYSdWHxgmZX6Ht6m11Qpig.png)

My custom push notification presentation design
```swift
import WatchKit
import Foundation
import UserNotifications

class NotificationController: WKUserNotificationInterfaceController {

    @IBOutlet var imageView: WKInterfaceImage!
    @IBOutlet var titleLabel: WKInterfaceLabel!
    @IBOutlet var contentLabel: WKInterfaceLabel!
    
    override init() {
        // Initialize variables here.
        super.init()
        self.setTitle("Let's Get Married") // Set the title in the upper right corner
        // Configure interface objects here.
    }

    override func willActivate() {
        // This method is called when watch view controller is about to be visible to user
        super.willActivate()
    }

    override func didDeactivate() {
        // This method is called when watch view controller is no longer visible
        super.didDeactivate()
    }
    
    override func didReceive(_ notification: UNNotification) {
        
        if #available(watchOSApplicationExtension 5.0, *) {
            self.notificationActions = []
            // Clear the buttons added by iOS's implementation of UNUserNotificationCenter.setNotificationCategories below the notification
        }
        
        guard let info = notification.request.content.userInfo["aps"] as? NSDictionary, let alert = info["alert"] as? Dictionary<String,String> else {
            return
        }
        // Push notification information
        
        self.titleLabel.setText(alert["title"])
        self.contentLabel.setText(alert["body"])
        
        if #available(watchOSApplicationExtension 5.0, *) {
            if alert["type"] == "new_msg" {
              // If it's a new message push notification, add a reply button below the notification
              self.notificationActions = [UNNotificationAction(identifier: "replyAction", title: "Reply", options: [.foreground])]
            } else {
              // Otherwise, add a view button
              self.notificationActions = [UNNotificationAction(identifier: "openAction", title: "View", options: [.foreground])]
            }
        }
        
        
        // This method is called when a notification needs to be presented.
        // Implement it if you use a dynamic notification interface.
        // Populate your dynamic notification interface as quickly as possible.
        
    }
}
```

```markdown
For the programming part, similarly, connect the outlet to the controller and implement the functionality.

Next, let's talk about interactive, which is similar to dynamic, but allows for additional buttons that can be controlled by the same class as dynamic; I did not use interactive because my buttons are added programmatically using self.notificationActions. The differences are as follows:

![Left uses interactive, right uses self.notificationActions](/assets/e85d77b05061/1*_1Crgx61kE6F509Jd2qxPQ.jpeg)

Left uses interactive, right uses self.notificationActions.

Both methods require watchOS ≥ 5 support.

Using self.notificationActions to add buttons means that the button event handling is managed by `userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void)` in ExtensionDelegate, and actions are identified by their identifiers.
#### Menu Functionality?

![Drag Menu from the component library, then drag Menu Item, and connect IBAction to the program control](/assets/e85d77b05061/1*qHUly8lLEa5L7FSPJCrbcw.png)

Drag Menu from the component library, then drag Menu Item, and connect IBAction to the program control.

When you press the page hard, it will appear:

![](/assets/e85d77b05061/1*9aj7kUPsv9d8XUvgCpqfOg.png)

#### Content Input?

You can simply use the built-in presentTextInputController method!
```swift
@IBAction func replyBtnClick() {
    guard let target = target else {
        return
    }
    
    self.presentTextInputController(withSuggestions: ["I will reply to you later", "Thank you", "Feel free to contact me", "Okay", "OK!"], allowedInputMode: WKTextInputMode.plain) { (results) in
        
        guard let results = results else {
            return
        }
        // When there are input values
        
        let txts = results.filter({ (txt) -> Bool in
            if let txt = txt as? String, txt != "" {
                return true
            } else {
                return false
            }
        }).map({ (txt) -> String in
            return txt as? String ?? ""
        })
        // Preprocess input
        
        txts.forEach({ (txt) in
            print(txt)
        })
    }
}
```

![](/assets/e85d77b05061/1*CWr9RIb55Sn-FoMrTmc7sQ.png)

### Summary

> **_Thank you for reading this! You've worked hard!_**

This concludes the article, which briefly touched on UI layout, programming, push notifications, and interface applications. If you have developed for iOS before, you will find it very easy to get started; it's almost the same, and many methods have been simplified for a more concise use. However, the things you can do have indeed become fewer (like currently not knowing how to load more for Table); there are indeed very few things that can be done at the moment, and I hope the official team can open up more APIs for developers to use in the future ❤️❤️❤️
#### MurMur:

![Deploying Apple Watch App Target to the watch is really slow — [Narcos](https://www.netflix.com/tw/title/80025172){:target="_blank"}](/assets/e85d77b05061/1*-J9qZ846ZysJEhMTSZeE3w.jpeg)

Deploying Apple Watch App Target to the watch is really slow — [Narcos](https://www.netflix.com/tw/title/80025172){:target="_blank"}
```

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/%E5%8B%95%E6%89%8B%E5%81%9A%E4%B8%80%E6%94%AF-apple-watch-app-%E5%90%A7-e85d77b05061){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
