---
title: "CI/CD Practical Guide (Part 2): Comprehensive Guide to Using and Building GitHub Actions and Self-hosted Runners"
author: "ZhgChgLi"
date: 2025-07-02T12:22:32.788+0000
last_modified_at: 2025-07-10T14:31:01.574+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","cicd","github-actions","github","self-hosted"]
description: "A comprehensive introduction to how GitHub Actions and Self-hosted Runners work, along with a step-by-step tutorial."
image:
  path: /assets/404bd5c70040/1*_vGYh_XSI3ZDbdeT8xCihA.jpeg
render_with_liquid: false
---

### CI/CD Practical Guide (Part 2): Comprehensive Guide to Using and Building GitHub Actions and Self-hosted Runners

This guide will help you understand how GitHub Actions and Self-hosted Runners work from the ground up, along with a hands-on tutorial.

![Photo by [Dan Taylor](https://unsplash.com/@theoneandonlydantaylor?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}](/assets/404bd5c70040/1*_vGYh_XSI3ZDbdeT8xCihA.jpeg)

Photo by [Dan Taylor](https://unsplash.com/@theoneandonlydantaylor?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}
#### Introduction

In the previous article, "[**CI/CD Practical Guide (Part 1): What is CI/CD? How to Build a Stable and Efficient Development Team with CI/CD? Tool Selection?**](../c008a9e8ceca/)", we introduced what CI/CD is, the benefits it brings, and how to choose tools. **This article will focus on the architecture and usage of GitHub Actions and Self-hosted Runners**, and we will build several interesting automation workflows together to help you get started.

### GitHub Actions Architecture Flowchart

Before we begin, let's clarify the operational architecture and responsibilities of GitHub Actions.

![](/assets/404bd5c70040/1*iacfyTX_b3YTSzMcn2ldjw.png)

#### **GitHub Repo**
- In the world of GitHub Actions, all Actions (Workflow YAML files) must be stored in a Git Repo ( `REPO/.github/workflows/` )

#### GitHub Repo — Actions Secrets

Repo → Settings → Secrets and variables → Actions → Secrets.
- Stores Secret Keys and Tokens used in Action steps, e.g., Slack Bot Token, Apple Store Connect API .p8 Key
- **The contents of Secrets cannot be viewed in Action Logs and will be automatically obscured with \* \* \* \***
- Secrets cannot be viewed or edited; they can only be overwritten
- Secrets **currently only support plain text content and cannot upload files** 
**\-** For binary keys, refer to the [official steps to store them after converting with Base64 encoding](https://docs.github.com/en/actions/how-tos/security-for-github-actions/security-guides/using-secrets-in-github-actions#storing-base64-binary-blobs-as-secrets){:target="_blank"}.
\- For iOS development certificate storage methods, refer to the official tutorial: [Installing an Apple certificate on macOS runners for Xcode development](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development){:target="_blank"}
- Organization-level Secrets can be stored and shared across Repos.

#### GitHub Repo — Actions Variables

Repo → Settings → Secrets and variables → Actions → Variables.
- Stores commonly used variables in Action steps, e.g., simulator iOS version, working directory
- Variable contents can be viewed and edited
- Variable contents can be output in Action Logs
- Variables only support plain text but can also store JSON strings for parsing
- Organization-level Variables can be stored and shared across Repos.

#### GitHub Actions — Trigger
- **The most important starting point in GitHub Actions — Trigger Events (Conditions)**
- Only GitHub Actions that meet the trigger events will be executed
- A complete list of events can be [found in the official documentation](https://docs.github.com/en/actions/reference/events-that-trigger-workflows){:target="_blank"}
- It basically covers all event scenarios encountered in CI/CD and automation.
However, **if there are special scenarios without events, you can only use other events + conditions in Jobs or use Schedule to manually check**.
e.g., if there is no PR Merged event, you can only achieve it with `pull_request: closed` + Job `if: github.event.pull_request.merged == true`.

**Commonly Used Events:**
- `schedule` (cron): Scheduled execution (like crontab)
Can be used for automation: regularly checking PRs, packaging, executing automation scripts
**All executed in main / develop (Default Branch).**
- `pull_request:`: PR-related events
Triggered when a PR is opened, reopened, assigned, or has new Push Commits, etc.
- `issues`, `issue_comment`: Issue-related events
Triggered when an Issue is opened or has new comments, etc.
- `workflow_dispatch`: Manually triggered; fields can be set for user input, and GitHub Actions provides a simple form for users to fill in information.
e.g.:

![](/assets/404bd5c70040/1*XogIJsCbrNPerWBto_PG8w.png)

- `workflow_call`: Triggers another Action (Workflow) to execute tasks.
- `workflow_run`: Executes this task when another Action (Workflow) runs.

> _For more event types and configuration details, please [refer to the official documentation](https://docs.github.com/en/actions/reference/events-that-trigger-workflows){:target="_blank"}._

#### **GitHub Actions — Workflow**
- Also known as Action
- Written in YAML format, with files placed under `REPO/.github/workflows/`
- **The Workflow YAML files in the main branch take precedence**
- The most basic unit in GitHub Actions, each Workflow represents a CI/CD or automation operation
- Workflows can call other Workflows to execute tasks
(You can use this feature to separate core Workflows and called Workflows)
- It defines task names, execution strategies, trigger events, task work, and all Action-related settings
- Currently, file structure does not support subdirectories
- **Actions can be shared across Repos within the same organization, allowing for Action Workflow reuse**
- Actions are completely free (Public and Private Repos)

#### GitHub Actions — Workflow — Job
- The execution unit in GitHub Actions
- Defines what tasks are included in the Workflow
- Each Workflow can have multiple Jobs
- Each Job needs to specify which Runner Label to use, and the corresponding Runner machine will execute the task
- **Multiple Jobs are executed concurrently** (if there is an order, it can be constrained using `needs`)
- **Each Job should be considered an independent execution instance (each treated as a Sandbox)**; if a Job produces resource files for subsequent Jobs/Workflows, they need to Upload Artifacts or move to a shared output directory on self-hosted.
- After a Job is completed, it can Output strings for reference by other Jobs.
(e.g., execution result true or false)

#### GitHub Actions — Workflow — Job — Step
- The smallest execution unit in GitHub Actions
- The actual program that executes tasks within a Job
- Each Job can have multiple Steps
- **Multiple Steps are executed in order**
- After a Step is completed, it can Output strings for subsequent Steps to reference.
- **Steps can directly write shell script programs** 
You can reference [gh cli](https://cli.github.com/manual/gh){:target="_blank"}, current environment variables (e.g., to get PR numbers), and directly perform desired actions.

#### GitHub Actions — Workflow — Job — Reuse Action Step
- **You can directly reuse existing work steps packaged by various experts on the [Marketplace](https://github.com/marketplace?type=actions){:target="_blank"}.** 
For example: [Comment content to PR](https://github.com/marketplace/actions/comment-pull-request){:target="_blank"}.
- You can also package a series of task Steps into an Action GitHub Repo for reuse in other workflows.
- Public Repo Actions can be listed on the Marketplace.

**Packaging Actions supports:**
- **Docker Action** — Represents that GitHub Actions will pass environment variables to the Docker container, and you can handle them as needed, whether it's shell script, Java, PHP, etc.
- **JavaScript/TypeScript Action** — Directly use node.js to write GitHub Actions processing logic, and environment variables will also be passed for your reference.
e.g., [pozil/auto-assign-issue](https://github.com/pozil/auto-assign-issue/blob/v2/action.yml){:target="_blank"}
- **Composite (YAML)** — Pure YAML describes task steps (same as GitHub Actions — Workflow — Job — Step) and can declare which steps to perform or directly write shell scripts.
e.g., [ZhgChgLi/ZReviewTender](https://github.com/ZhgChgLi/ZReviewTender/blob/main/action.yml){:target="_blank"}

> _Due to space constraints, this article will not cover how to package GitHub Actions. For those interested, please refer to the official documentation: [tutorials/creating-a-composite-action](https://docs.github.com/en/actions/tutorials/creating-a-composite-action){:target="_blank"}._

#### GitHub Runner
- GitHub dispatches corresponding Jobs to Runners based on Runner Labels
- Runners only act as listeners, polling to listen for tasks dispatched by GitHub
- They only care about Jobs, not which Action (Workflow) it is
Thus, you may see that after Action A's Job-1 is completed, the next one may be Action B's Job-1, rather than waiting for all of Action A's Jobs to finish before switching to Action B.
- Runners can use GitHub Hosted Runners or Self-hosted Runners.

#### **GitHub Hosted Runner**
- Runners provided by GitHub; you can refer to the official Repo list:

[![](https://opengraph.githubassets.com/57c1706f7379544e2c6abd15daac659b29bbb4fb57da691fac9486b0099f5e81/actions/runner-images)](https://github.com/actions/runner-images){:target="_blank"}

![[Image List for June 2025](https://github.com/actions/runner-images){:target="_blank"}](/assets/404bd5c70040/1*KtQV4kDCWscEeaZ8jQI8Dg.png)

[Image List for June 2025](https://github.com/actions/runner-images){:target="_blank"}
- You can check what is pre-installed on the Runner:
e.g., [macos-14-arm64](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-arm64-Readme.md){:target="_blank"}

![[macos-14-arm64](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-arm64-Readme.md){:target="_blank"}](/assets/404bd5c70040/1*svXtXH78-TvK1C_XXCyYLA.png)

[macos-14-arm64](https://github.com/actions/runner-images/blob/main/images/macos/macos-14-arm64-Readme.md){:target="_blank"}
- For iOS development, it is recommended to use the -arm64 (M series) processor Runner for faster performance.
- Just attach the YAML Label from the table to the Job `run-on`, and you can use that Runner to execute tasks.
- **Public Repo pricing: Completely free with unlimited usage**
- **️** Private Repo free quota:
Free quota (varies by account; for GitHub Free as an example):
Usage: 2,000 minutes free per month
Storage: 500 MB
- **⚠️️Private Repo billing method:** 
**After exceeding the free quota, usage-based billing begins (with limits and notifications possible), and prices vary based on the operating system and core of the Runner:** 

![[about-billing-for-github-actions](https://docs.github.com/en/billing/managing-billing-for-your-products/about-billing-for-github-actions){:target="_blank"}](/assets/404bd5c70040/1*rkhRJN4ZRas_lDOJh-pjkQ.png)

[about-billing-for-github-actions](https://docs.github.com/en/billing/managing-billing-for-your-products/about-billing-for-github-actions){:target="_blank"}

You can see that the price for macOS is high due to the high equipment costs.
- Maximum concurrent task limits:

![[usage-limits-billing-and-administration](https://docs.github.com/en/actions/concepts/overview/usage-limits-billing-and-administration#usage-limits){:target="_blank"}](/assets/404bd5c70040/1*LU3zGSBe57NBVMfDwl0wdQ.png)

[usage-limits-billing-and-administration](https://docs.github.com/en/actions/concepts/overview/usage-limits-billing-and-administration#usage-limits){:target="_blank"}

> _We've gone off-topic here; our focus is on Self-hosted Runners._ 

#### Self-hosted Runner on In-house Server
- Use your own machine as a Runner
- **A physical machine can run multiple Runners concurrently to handle tasks**
- **Free unlimited usage** 
Only the cost of purchasing the machine, and you can use it indefinitely!
For example, if you calculate with a 32G RAM M4 Mini (≈NT$40,900), using GitHub Hosted Runners for a month would cost 500 USD; **buying one and setting it up would pay off in just over three months!**
- Supports Windows, macOS, Linux (x64/ARM/ARM64)
- **Runners can be shared across Repos within the same organization**
- **⚠️Currently: actions/cache, actions/upload-artifact, actions/download-artifact only support GitHub cloud services, meaning these contents will still be uploaded to GitHub servers and counted towards storage fees.** 
You can create shared directories on your own machine as a substitute.
- Self-hosted Runners also support [Docker, k8s](https://docs.github.com/en/actions/concepts/runners/about-actions-runner-controller){:target="_blank"}, but I haven't researched that.

> **_Setting up a Self-hosted Runner only takes a few steps (set up within 10 minutes) to start receiving tasks for execution (this article will cover this later)._** 

### Learning by Doing GitHub Actions — Case Implementation

"Better to act than to talk." The above explanations of terms and architectural processes may have left you a bit confused. Next, I will provide three functional examples to guide you through hands-on practice while explaining the concepts encountered, allowing you to learn about GitHub Actions through doing.

### Case — 1

Automatically label File Changes Size after creating a Pull Request to facilitate the Reviewer's work.
#### Result Image

![[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}](/assets/404bd5c70040/1*vjSWeu2zB-hmVpfziMDR5Q.png)

[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}
#### Operational Process
- User opens PR, reopens PR, or pushes new commits to PR
- Triggers GitHub Actions Workflow
- Shell script retrieves the number of file changes
- Determines the number of changes and labels the PR accordingly
- Completed

#### Hands-on Practice

Repo → Actions → New workflow → set up a workflow yourself.

**File Name:** `Automation-PullRequest.yml`

Action Workflows can be independent files for each task or grouped in the same file based on trigger events and purposes, as multiple Jobs execute concurrently. Additionally, **since GitHub Actions currently does not support directory structures, having fewer files and using hierarchical naming will make management easier**.

Here, I will place all PR-related Actions in the same Workflow.
#### `Automation-PullRequest.yml`
```yaml
# Workflow (Action) name
name: Pull Request Automation

# Title name in Actions Log
run-name: "[Pull Request Automation] ${{ github.event.pull_request.title || github.ref }}"

# Trigger events
on:
  # PR events
  pull_request:
    # PR - opened, reopened, new Push Commit
    types: [opened, synchronize, reopened]

# The same Concurrency Group will cancel any running Jobs if a new one is triggered
# For example, if a task triggered by a Push Commit hasn't executed yet and another Push Commit occurs, the previous task will be canceled
concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: true

# Job tasks
# Jobs will execute concurrently
jobs:
  # Job ID
  label-pr-by-file-count:
    # Job name (optional; setting it in the Log makes it easier to read)
    name: Label PR by changes file count

    # If this Job fails, it does not affect the entire Workflow, and other Jobs will continue
    continue-on-error: true
    
    # Set the maximum Timeout duration to prevent endless waiting in case of anomalies
    timeout-minutes: 10

    # Runner Label - Use GitHub Hosted Runner ubuntu-latest to execute the task
    # If it's a Private Repo, usage will be counted, which may incur costs
    runs-on: ubuntu-latest
```

```markdown
# Work Steps
# The work steps will be executed in order
steps:
  # Step Name
  - name: Get changed file count and apply label
    # Step ID (optional; if there are no subsequent Steps that need to reference Output, it does not need to be set)
    id: get-changed-files-count-by-gh
    # Inject external environment parameters into the execution stage
    env:
      # secrets.GITHUB_TOKEN is a Token automatically generated during GitHub Actions execution (identity of github-actions), no need to set it in Secrets, it has some GitHub Repo API Scopes permissions
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    # Shell script
    # The GitHub Hosted Runner has the gh cli pre-installed, no need to install it in the Job
    run: |
      # ${{ github }} is a variable reference automatically injected during GitHub Actions execution, which can be used to obtain runtime information
      
      # Get PR number:
      PR_NUMBER=${{ github.event.pull_request.number }}

      # Get Repo:
      REPO=${{ github.repository }}

      # Use GitHub API (gh cli) to get the number of changed files
      FILE_COUNT=$(gh pr view $PR_NUMBER --repo $REPO --json files --jq '.files | length')
      
      # Print Log
      echo "Changed file count: $FILE_COUNT"

      # Label logic
      if [ "$FILE_COUNT" -lt 5 ]; then
        LABEL="XS"
      elif [ "$FILE_COUNT" -lt 10 ]; then
        LABEL="S"
      elif [ "$FILE_COUNT" -lt 30 ]; then
        LABEL="M"
      elif [ "$FILE_COUNT" -lt 80 ]; then
        LABEL="L"
      elif [ "$FILE_COUNT" -lt 200 ]; then
        LABEL="XL"
      else
        LABEL="XXL"
      fi

      # Use GitHub API (gh cli) to remove the current Size Label
      EXISTING_LABELS=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json labels --jq '.labels[].name')
      for EXISTING in $EXISTING_LABELS; do
        case "$EXISTING" in
          XS|S|M|L|XL|XXL)
            echo "🧹 Removing existing label: $EXISTING"
            gh pr edit "$PR_NUMBER" --repo "$REPO" --remove-label "$EXISTING"
            ;;
        esac
      done

      # (Optional) Create the label if it does not exist
      if ! gh label list --repo "$REPO" | grep -q "^$LABEL"; then
        echo "🆕 Creating missing label: $LABEL"
        gh label create "$LABEL" --repo "$REPO" --description "Size label: $LABEL" --color "ededed"
      else
        echo "✅ Label '$LABEL' already exists"
      fi
      
      # Use GitHub API (gh cli) to apply the label
      gh pr edit $PR_NUMBER --repo $REPO --add-label "$LABEL"
```

After committing the file to the main branch of the Repo, opening a new PR will automatically trigger GitHub Actions:

![](/assets/404bd5c70040/1*wdAztL0BgPeSZdqXxqUEXg.png)

The Action execution status shows **Queued**, indicating that the task is waiting for the Runner to take over.

#### Execution Result

![[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}](/assets/404bd5c70040/1*-JoD8IQYHVrDqHmLmrXyaQ.png)

[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}

Once the execution is completed successfully, the corresponding label will be automatically applied to the PR! The record will show that it was labeled by `github-actions`.

**Complete Code: [Automation\-PullRequest\.yml](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/blob/main/.github/workflows/Automation-PullRequest.yml){:target="_blank"}**

#### Directly Using Pre-packaged Action Steps: [pascalgn/size\-label\-action](https://github.com/pascalgn/size-label-action/tree/main){:target="_blank"}

As mentioned earlier, you can directly use someone else's packaged Action. The task of labeling PR Size Label already has a ready-made solution available; the above is just for educational purposes, and you don't actually need to reinvent the wheel.

You can simply use it directly in the Action Workflow Job Step to complete the task:
```yaml
# Workflow(Action) Name
name: Pull Request Automation

# Trigger Events
on:
  # PR Events
  pull_request:
    # PR - When opened, reopened, or when there is a new Push Commit
    types: [opened, synchronize, reopened]

# If there is a new Job in the same Concurrency Group, it will cancel the running one
# For example, if a task triggered by a Push Commit has not executed yet and another Push Commit occurs, the previous task will be canceled
concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: true

# Job Work Items
# Jobs will run concurrently
jobs:
  # Job ID
  label-pr-by-file-count:
    # Job Name (optional; having it set makes logs easier to read)
    name: Label PR by changes file count

    # If this Job fails, it does not affect the entire Workflow, and other Jobs will continue
    continue-on-error: true
    
    # Set the maximum Timeout duration to prevent endless waiting in case of anomalies
    timeout-minutes: 10

    # Runner Label - Use GitHub Hosted Runner ubuntu-latest to execute the work
    # If it is a Private Repo, usage will be calculated, and exceeding may incur costs
    runs-on: ubuntu-latest

    # Work Steps
    # Work steps will be executed in order
    steps:
      # Step Name
      - name: Get changed file count and apply label
        # Step ID (optional; if there are no subsequent Steps that need to reference Output, it does not need to be set)
        id: get-changed-files-count-by-gh
        # Directly use someone else's packaged program
        uses: "pascalgn/size-label-action@v0.5.5"
        # Inject external environment parameters into the execution stage
        # Parameter naming and available parameters should refer to the documentation: https://github.com/pascalgn/size-label-action/tree/main
        env:
          # secrets.GITHUB_TOKEN is a Token automatically generated during GitHub Actions execution (identity of github-actions), no need to set it in Secrets, it has some GitHub Repo API Scopes permissions
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
```

[![](https://opengraph.githubassets.com/12cd04cddb9059ef9771b22b12a412e3655d2555b037268cdb3ece55f3d0cd18/pascalgn/size-label-action)](https://github.com/pascalgn/size-label-action/tree/main){:target="_blank"}

This packaged Action is a JavaScript Action, and you can refer to the actual execution code in the following file: [dist/index\.js](https://github.com/pascalgn/size-label-action/blob/main/dist/index.js){:target="_blank"}.

#### Supplement on name and run\-name:

![](/assets/404bd5c70040/1*zBmjm_3AU53NN0UhTrmOBQ.png)

- name: The name of the Action Workflow
- run\-name: The title name of the execution record (can include PR Title or Branch or Author…etc)
If it is an on:pull_request event, the default is the PR Title.

### Case — 2

After creating a Pull Request, if there is no Assignee, automatically assign the author to themselves and comment with a prompt. (This will only execute when initially created)
#### Result Image

![[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}](/assets/404bd5c70040/1*EL-0nQF7jhP34d6ZoSkJAg.png)

[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}

#### Operation Flow
- User opens PR
- Triggers GitHub Actions Workflow
- GitHub script retrieves assignee
- If there is no assignee, assign the author who opened the PR & comment with a message
- Done

#### Hands-On

Repo → Actions → New workflow → set up a workflow yourself.

**File Name:** `Automation-PullRequest.yml` (same as above)
#### `Automation-PullRequest.yml`
```yaml
# Workflow(Action) Name
name: Pull Request Automation

# Actions Log Title
run-name: "Pull Request Automation - Daily Checker"

# Trigger Events
on:
  # PR Events
  pull_request:
    # PR - When opened, reopened, or when there is a new Push Commit
    types: [opened, synchronize, reopened]

# If there is a new Job in the same Concurrency Group, it will cancel the running one
# For example, if a task triggered by a Push Commit has not executed yet and another Push Commit occurs, the previous task will be canceled
concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: true

# Job Work Items
# Jobs will run concurrently
jobs:
  # Job ID
  label-pr-by-file-count:
    # Please refer to the previous text, omitted....
  # ---------
  assign-self-if-no-assignee:
    name: Automatically assign to self if no assignee is specified
    # Since it is a shared trigger event, the Job itself determines that it will only execute when the Pull Request is Opened (initial creation), otherwise it will be Skipped
    if: github.event_name == 'pull_request' && github.event.action == 'opened'

    # If this Job fails, it does not affect the entire Workflow, and other Jobs will continue
    continue-on-error: true
    
    # Set the maximum Timeout duration to prevent endless waiting in case of anomalies
    timeout-minutes: 10
    
    # Runner Label - Use GitHub Hosted Runner ubuntu-latest to execute the work
    # If it is a Private Repo, usage will be calculated, and exceeding may incur costs
    runs-on: ubuntu-latest

    steps:
      - name: Assign self if No Assignee
        # Use GitHub Script (JavaScript) to write the script (Node.js environment)
        # Compared to writing it in Shell Script above, it is more convenient and visually appealing
        # There is no need to inject environment variables or GITHUB_TOKEN
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.pull_request; // If you want to support Issues as well, you can write it as context.payload.issue || context.payload.pull_request
            const assignees = issue.assignees || [];
            const me = context.actor;

            if (assignees.length === 0) {
              // Set Assignee to self
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                assignees: [me]
              });

              // Leave a message notification
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `🔧 No assignee was set, so I have assigned this to myself (@${me}).`
              });
            }
```

This time we demonstrate using GitHub Script (JavaScript) to write the script, which offers more flexibility and better syntax.

Of course, if you want to follow my previous suggestion of having each task in a separate file, you can remove the Job If... directly in the Action Workflow trigger condition:

`Automation-PullRequest-Auto-Assign.yml` **:**
```yaml
# Workflow(Action) Name
name: Pull Request Automation - Auto Assignee Self

# Trigger Events
on:
  # PR Events
  pull_request:
    # PR - When opened
    types: [opened]

jobs:
  assign-self-if-no-assignee:
    name: Automatically assign to self if no assignee is specified
    runs-on: ubuntu-latest
    steps:
      # Please refer to the previous text, omitted....
```

After committing the file to the main branch of the Repo, opening a new PR will automatically trigger GitHub Actions:

![](/assets/404bd5c70040/1*Y-A6owUibNEFBoRFHnqIYg.png)

Now there are two Jobs to execute!
#### Execution Result

![[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}](/assets/404bd5c70040/1*23muCVgUJKmZt746khBMFQ.png)

[Demo PR](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/pull/11){:target="_blank"}

Once the execution is completed successfully, if the PR has no Assignees, it will automatically assign the PR author and comment with a message. (All actions are performed under the identity of `github-actions`)

**Complete Code: [Automation\-PullRequest\.yml](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/blob/main/.github/workflows/Automation-PullRequest.yml){:target="_blank"}**

#### Testing Reopened PR

![](/assets/404bd5c70040/1*mcDa7TZjv6mO7HtwhOE-Vw.png)

You can see that only the Size Label Job will execute, while the Auto Assignee Job was Skipped.

> _This task also has a pre-packaged Action that can be reused directly; you can refer to: [pozil/auto\-assign\-issue](https://github.com/pozil/auto-assign-issue){:target="_blank"}._

### Case — 3

Automatically count the current number of PRs and how long they have been open every morning at 9 AM, sending notification messages to the Slack workgroup, and automatically closing PRs that have been open for more than 3 months.
#### Result Image

![](/assets/404bd5c70040/1*0stX9KpZi6PcXpG-90wyIg.png)

![](/assets/404bd5c70040/1*Nbg3r1zzhx24YIBEjPJnaw.png)

- The Slack workgroup receives reports automatically every morning
- Automatically closes PRs that have been open for more than 90 days

#### Operation Flow
- GitHub Actions triggers automatically every morning at 9 AM
- Triggers GitHub Actions Workflow
- GitHub script retrieves the list of open PRs and counts how many days they have been open
- Sends the statistical report message to Slack
- Closes PRs that have been open for more than 90 days
- Done

#### Hands-On

Repo → Actions → New workflow → set up a workflow yourself.

**File Name:** `Automation-PullRequest-Daily.yml`
#### Automation\-PullRequest\-Daily\.yml
```yaml
# Workflow(Action) Name
name: Pull Request Automation - Daily Checker

# Trigger Events
on:
  # Scheduled to run automatically
  # https://crontab.guru/
  # UTC Time
  schedule:
    # UTC 01:00 = 09:00 in UTC+8
    - cron: '0 1 * * *'
  # Manual trigger
  workflow_dispatch:

# Job Work Items
# Jobs will run concurrently
jobs:
  # Job ID
  calculate-pr-status:
    # Job Name (optional; having it set makes logs easier to read)
    name: Calculate PR Status
    # Runner Label - Use GitHub Hosted Runner ubuntu-latest to execute the work
    # If it is a Private Repo, usage will be calculated, and exceeding may incur costs
    runs-on: ubuntu-latest

    # Job Output
    outputs:
      pr_list: ${{ steps.pr-info.outputs.pr_list }}

    # Work Steps
    # Work steps will be executed in order
    steps:
      # Step Name
      - name: Fetch open PRs and calculate
        # Step external Output reference must be set
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            const now = new Date();
            const per_page = 100;
            let page = 1;
            let allPRs = [];
      
            while (true) {
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page,
                page,
              });
              if (prs.length === 0) break;
              allPRs = allPRs.concat(prs);
              if (prs.length < per_page) break;
              page++;
            }
      
            const result = allPRs.map(pr => {
              const created = new Date(pr.created_at);
              const daysOpen = Math.floor((now - created) / (1000 * 60 * 60 * 24));
              return {
                pr: pr.number.toString(),
                title: pr.title,
                idle: daysOpen
              };
            });
```

```markdown
// Set the output to accept only String
core.setOutput('pr_list', JSON.stringify(result));
# ----
send-pr-summary-message-to-slack:
  name: Send PR Summary Message to Slack
  # By default, jobs run concurrently. Using needs forces the current job to wait until the needed job is completed before executing.
  needs: [caculate-pr-status]
  runs-on: ubuntu-latest
  
  steps:
    - name: Generate Message
      # To reference the output from the previous step, it needs to be set.
      id: gen-msg
      uses: actions/github-script@v7
      with:
        script: |
          const prList = JSON.parse(`${{ needs.caculate-pr-status.outputs.pr_list }}`);
          const blocks = [];
    
          // Title
          blocks.push({
            type: "section",
            text: {
              type: "mrkdwn",
              text: `📬 *Open PR Report*\nTotal: *${prList.length}* PR(s)`
            }
          });
    
          // Each PR in a line
          for (const pr of prList) {
            blocks.push({
              type: "section",
              text: {
                type: "mrkdwn",
                text: `• <https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${pr.pr}|PR #${pr.pr}> *${pr.title}* - 🕒 ${pr.idle} day(s)`
              }
            });
          }

          // Set the output to accept only String
          core.setOutput('blocks', JSON.stringify(blocks));

          
    # Use the official Slack API GitHub Actions
    # https://tools.slack.dev/slack-github-action/sending-techniques/sending-data-slack-api-method/
    # Send message
    - name: Post text to a Slack channel
      uses: slackapi/slack-github-action@v2.1.0
      with:
        method: chat.postMessage
        token: ${{ secrets.SLACK_BOT_TOKEN }}
        payload: |
          channel: ${{ vars.SLACK_TEAM_CHANNEL_ID }}
          blocks: ${{ steps.gen-msg.outputs.blocks }}
# ----
auto-close-old-prs:
  name: Auto Close Old PRs
  needs: [caculate-pr-status]
  runs-on: ubuntu-latest

  steps:
    - name: Auto close PRs opened more than 90 days
      uses: actions/github-script@v7
      with:
        script: |
          const prList = JSON.parse(`${{ needs.caculate-pr-status.outputs.pr_list }}`);
          const oldPRs = prList.filter(pr => pr.idle > 90);

          for (const pr of oldPRs) {
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: parseInt(pr.pr),
              state: 'closed'
            });

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(pr.pr),
              body: `⚠️ This pull request has been automatically closed because it has been open for more than 90 days. Please reopen if needed.`
            });
          }
          console.log(`Closed ${oldPRs.length} PR(s)`);
```

In this example, we use:
- on: schedule Crontab to automatically trigger and workflow_dispatch to support manual triggering
- Job output/Step output (both can only be strings)
- Multiple jobs are concurrent by default but can use `needs` for time dependency
- Retrieve settings from Repo Secrets/Variables
- Connect to Slack API

**Repo Secrets — Add** `SLACK_BOT_TOKEN`

![](/assets/404bd5c70040/1*YC4DBHtKmX5XGgcSSzaE5A.png)

- For creating a Slack App and setting message permissions, you can refer to my [previous article](../bd94cc88f9c9/).

**Repo Variables — Add** `SLACK_TEAM_CHANNEL_ID`

![](/assets/404bd5c70040/1*X4gZ5_IRvsiehAL0O9AleQ.png)

After committing the file to the main branch of the Repo, return to Actions and manually trigger it:

> _It will automatically trigger daily in the future._

![](/assets/404bd5c70040/1*WNFKXl-QC2WGyaSWep5-DA.png)

Actions → Pull Request Automation — Daily Checker → Run workflow → Branch: main → Run workflow.

**After execution, you can click to view the execution status:**

![](/assets/404bd5c70040/1*4mvOxnd1uS4ZlxnNoNdHaQ.png)

![](/assets/404bd5c70040/1*BluzFgY2tM2E7DwoVq1jQw.png)

Due to the `needs` constraint, the job flow will be that `Calculate PR Status` completes first, and then `Auto Close Old PRs` and `Send PR Summary Message to Slack` will execute concurrently.
#### Execution Result

**After all tasks successfully execute, you can check the Slack message:**

![](/assets/404bd5c70040/1*0stX9KpZi6PcXpG-90wyIg.png)

Success 🚀🚀🚀

**Complete code: [Automation\-PullRequest\-Daily\.yml](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/blob/main/.github/workflows/Automation-PullRequest-Daily.yml){:target="_blank"}**
### Summary

> I hope the three examples above give you a preliminary understanding of GitHub Actions and inspire your automation workflow ideas. You can think of your own workflows (please be sure to refer to [trigger events](https://docs.github.com/en/actions/reference/events-that-trigger-workflows){:target="_blank"}), and then write scripts to execute; also remember to check the [**Marketplace**](https://github.com/marketplace?type=actions){:target="_blank"} for existing steps that you can use directly.

This article is just an introduction (even without checking out code). The next article, "[**CI/CD Practical Guide (3): Implementing CI and CD Workflows for App Projects Using GitHub Actions**](../4b001d2e8440/)," will introduce more complex and in-depth GitHub Actions Workflows.
#### GitHub Automation Extension Topics

GitHub can integrate with Slack to subscribe to PR update notifications, Push Default Branch notifications, etc.

![](/assets/404bd5c70040/1*BMTT4koRBIIsQ7_mklC86w.png)

**Question 1. GitHub messages cannot tag people, only tagging GitHub accounts, and Slack accounts do not receive notifications:**

![](/assets/404bd5c70040/1*Ddp0cEtXE10hScM1rozmtg.png)

![](/assets/404bd5c70040/1*uHGJ7l__AdYoWT9KpvihLQ.png)

[Slack App](https://slack.github.com/){:target="_blank"} or search for GitHub in Apps → Open the message window → complete the **Connect GitHub Account** step, so GitHub knows what your corresponding Slack UID is and can tag you.

**Question 2. Pull Request Reminder**

I remember this was originally a feature developed by a third party, but it was later integrated directly into GitHub. Don't foolishly write scripts using GitHub Actions for this!

![](/assets/404bd5c70040/1*BpMd2K0NBDE6xB1XzFY94Q.png)

> [**_GitHub's built-in feature is set by Team. You need to first add a Team for the organization, add the Repo to the Team, and then you can set up Pull Request Reminders._**](https://docs.github.com/en/organizations/organizing-members-into-teams/managing-scheduled-reminders-for-your-team){:target="_blank"}

- After entering the Slack Channel and rules, it will automatically send reminder messages and tag the Reviewer every day. You can refer to the setup [here](https://michaelheap.com/github-scheduled-reminders/){:target="_blank"}, and the result is as shown below:

![[https://michaelheap\.com/github\-scheduled\-reminders/](https://michaelheap.com/github-scheduled-reminders/){:target="_blank"}](/assets/404bd5c70040/1*kvqFXkIKIxP79Wm8vIaN0Q.png)

[https://michaelheap\.com/github\-scheduled\-reminders/](https://michaelheap.com/github-scheduled-reminders/){:target="_blank"}

**Question 4. GitHub PR messages, authors do not receive notifications:**

![](/assets/404bd5c70040/1*wmtXwXAcQZDXqInRd0ivPw.png)

> _This is a long-standing issue: the PR Slack message **actually does not notify the author when someone replies in threads for discussion**. The Slack message sent by GitHub only tags Reviewers, not Assignees or PR authors._

At this point, GitHub Actions can be used to create an automation tool. We can add a job to append the author tag at the end of the PR description, so that when the message is sent to Slack, it will also tag the author in Slack:
```bash
# Workflow(Action) name
name: Pull Request Automation
# Please refer to the previous text, omitted....

  # ---------
  append-author-to-pr-description:
    name: Append author to PR description
    # Since this is a shared trigger event, the job will determine itself when the Pull Request is Opened (first created) to execute the job; otherwise, it will be skipped.
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    
    # If this job fails, it does not affect the entire workflow, and other jobs will continue.
    continue-on-error: true
    
    # Set the maximum timeout duration to prevent endless waiting in case of abnormal situations.
    timeout-minutes: 10
    
    # Runner Label - Use GitHub Hosted Runner ubuntu-latest to execute the job.
    # If it is a Private Repo, usage will be calculated, and exceeding may incur costs.
    # However, such small automation tasks are not likely to exceed usage.
    runs-on: ubuntu-latest
    steps:
      - name: Append author to PR description
        env:
          # secrets.GITHUB_TOKEN is a token automatically generated during GitHub Actions execution, no need to set it in Secrets, and it has some GitHub Repo API Scopes permissions.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          AUTHOR_TAG: '@${{ github.event.pull_request.user.login }}'
        run: |
          PR_BODY=$(gh pr view $PR_NUMBER --repo ${{ github.repository }} --json body -q ".body")
          NEW_BODY=$(printf "%s\n\nCreated by %s" "$PR_BODY" "$AUTHOR_TAG")
          gh pr edit $PR_NUMBER --repo ${{ github.repository }} --body "$NEW_BODY"
```

**Complete code: [Automation\-PullRequest\.yml](https://github.com/ZhgChgLi/github-actions-ci-cd-demo/blob/main/.github/workflows/Automation-PullRequest.yml){:target="_blank"}**

When opening a PR, it will automatically append the author information at the end of the description, and the Slack message will also correctly tag the author:

![](/assets/404bd5c70040/1*UtTDtIQJ0vJks79UzCQSAQ.png)

![](/assets/404bd5c70040/1*MjVsFqE--xAq1zSQfCNVdQ.png)

**Question 5. GitHub sends too many notification emails, which is very disruptive:**

After setting up GitHub Repo notifications and Slack, you can go to your GitHub personal settings to turn off email notifications:

![](/assets/404bd5c70040/1*INgfO9B2bNFy-Nd1ZjnzOw.png)

#### Others

Actions currently do not have a directory structure, but you can pin (Pin) five Actions at the top of the Actions page; you can also use Disable to pause a specific Action.

![](/assets/404bd5c70040/1*ZD-5xkparhJqtnm2REeu6A.png)

You can check GitHub Actions usage and execution performance in Insights:

![](/assets/404bd5c70040/1*re91ZRtQ0frOF6GVJ-MKrw.png)

### Building and Switching to Self-hosted Runner

GitHub Actions has been developed, and the next step is to replace GitHub Hosted Runner with your own Self-hosted Runner.

> _GitHub Hosted Runner has a free quota of 2,000 minutes per month (starting), and running such small automation tasks does not take much time, and since it runs on Linux machines, the cost is low, it may not even reach the free limit; **there is no need to switch to Self-hosted Runner**. Changing the Runner also requires ensuring the Runner environment is correct (for example, GitHub Hosted Runner comes with gh cli, while self-hosted Runner needs to be installed properly), **this article is purely for teaching purposes to demonstrate this switch**._

> _If it is used for executing CI/CD tasks, then it is necessary to use Self-hosted Runner._

#### Adding Self-hosted Runner

> _This article takes **macOS M1** as an example._

![](/assets/404bd5c70040/1*mEInaj-tLaprMAa2OfowCw.png)

- Settings → Actions → Runners → New self-hosted runner.
- **Runner image:** macOS
- **Architecture**: M1, remember to select ARM64 for faster execution.

**Open a Terminal on your physical computer.**

**Follow the Download steps to complete on your local computer:**
```bash
# Create a Runner directory at your desired path
mkdir actions-runner && cd actions-runner
# Download the Runner image
curl -o actions-runner-osx-x64-2.325.0.tar.gz -L https://github.com/actions/runner/releases/download/v2.325.0/actions-runner-osx-x64-2.325.0.tar.gz

# Optional: Validate the hash
echo "0562bd934b27ca0c6d8a357df00809fbc7b4d5524d4aeb6ec152e14fd520a4c3  actions-runner-osx-x64-2.325.0.tar.gz" | shasum -a 256 -c

# Unzip
tar xzf ./actions-runner-osx-x64-2.325.0.tar.gz
```

> _The above is just a reference; it is recommended to follow the steps in your settings page to ensure you have the latest version of the Runner image._

![](/assets/404bd5c70040/1*Q0k0EPjrY2V4owseESe5lg.png)

**Configure Settings:**
```bash
# Please refer to the command on the settings page; the token will change over time.
./config.sh --url https://github.com/ORG/REPO --token XXX
```

You will be prompted to enter:
- Enter the name of the runner group to add this runner to: \[press Enter for Default\] **Just press Enter**
*Only runners registered at the organization level will have group functionality.
- Enter the name of runner: \[press Enter for ZhgChgLideMacBook-Pro\] **You can enter a desired runner name, e.g., `app-runner-1` or just press Enter.**
- This runner will have the following labels: ‘self-hosted’, ‘macOS’, ‘X64’
Enter any additional labels (e.g., label-1,label-2): \[press Enter to skip\] 
**Enter the desired runner label; you can enter multiple custom labels for convenience later.** 
As mentioned earlier, GitHub Actions/Runners find tasks based on corresponding labels, **if you only use the default label, the runner may pick up other runners in the organization to execute tasks, so it's safest to customize one.** 
Here, I randomly set a label `self-hosted-zhgchgli`.
- Enter name of work folder: \[press Enter for \_work\] **Just press Enter.**

When you see √ Settings Saved., it means the setup is complete.

![](/assets/404bd5c70040/1*yxLfii0rWhzsiFuYVmPgFw.png)

**Start the Runner:**
```bash
./run.sh
```

When you see √ Connected to GitHub, Listening for Jobs, it means it is now listening for Actions tasks:

![](/assets/404bd5c70040/1*1RmPPOosAoCxHA9tg_WE2w.png)

> **_Keep this Terminal window open to continuously receive tasks._** 

> **_🚀🚀🚀 You can open multiple Terminals on the same computer in different directories to run multiple Runners._** 

**Return to the Repo settings page to see the Runner waiting for tasks:**

![](/assets/404bd5c70040/1*jjq5NTPYMuC3gH3ey_VTtg.png)

**Status:**
- Idle: Idle, waiting for tasks
- Active: A task is currently executing
- Offline: The Runner is not online

#### Workflow (GitHub Actions) Runner Switching to Self-hosted Runner

Using `Automation-PullRequest.yml` as an example:
```yaml
# Please refer to the previous text, omitted....
jobs:
  label-pr-by-file-count:
    # Please refer to the previous text, omitted....
    runs-on: [self-hosted-zhgchgli]
    # Please refer to the previous text, omitted....
  # ---------
  assign-self-if-no-assignee:
    # Please refer to the previous text, omitted....
    runs-on: [self-hosted-zhgchgli]

    steps:
      # Please refer to the previous text, omitted....
```

After committing the file to the main branch of the Repo, reopen the PR to trigger and verify the Actions.

**Return to the Runner Terminal to see that a new task has come in, executing and showing the execution results:**

![](/assets/404bd5c70040/1*Hu0DxKQbenPmBEw8swv65A.png)

It failed because my local computer does not have the [gh cli](https://github.com/cli/cli){:target="_blank"} environment installed:

![](/assets/404bd5c70040/1*9xguacdPATIeEZdbFszmHw.png)

After installing gh on the physical computer using `brew install gh`, trigger the execution again:

![](/assets/404bd5c70040/1*TbkAt00K89Ysbix33dK8ZA.png)
```

```markdown
成功！現在這個任務就完全是使用我們自己的電腦在執行，不使用 GitHub Hosted Runner、不計費使用。

**我們可以點進去 Action Log 查看任務執行在的 Runner、機器是哪一個：**

![](/assets/404bd5c70040/1*oqLcWfn6cbWsCt9fVsrikQ.png)

#### runs\-on: \[ **Runner Label** \] 設定

這裡是 AND 不是 OR，GitHub Runner 暫不支援 OR 挑選 Runner 執行。

例如： `[self-hosted, macOS, app]` → 代表 Runner 要 **同時有** `self-hosted, macOS, app` 這 3 個 Labels 才會匹配接任務來執行。

如果一個 Job 想同時測試不同 Runner 環境下的結果可以使用 `matrix` 參數：
```yaml
jobs:
  test:
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        runner:
          - [self-hosted, linux, high-memory]
          - [self-hosted, macos, xcode-15]

    steps:
      - run: echo "Running on ${{ matrix.runner }}"
```

這樣這個 Job 會在下列兩個 Runner Labels Runner 中並行各執行一次：
- self\-hosted, linux, high\-memory
- self\-hosted, macos, xcode\-15

> **_Runner 暫不支援：_** 

> _\- OR 挑選 Runner_ 

> _\- Runner 權重設定_ 

#### 註冊 Runner 成 Service

可以參考官方文件「 [Configuring the self\-hosted runner application as a service](https://docs.github.com/en/actions/how-tos/hosting-your-own-runners/managing-self-hosted-runners/configuring-the-self-hosted-runner-application-as-a-service?platform=mac){:target="_blank"} 」將 Runner 直接註冊成系統 Service，這樣就能在背景執行\(不用開 Terminal 在前景\)、開機後也會自動啟動。

有多個 Runner 記得調整「 [Customizing the self\-hosted runner service](https://docs.github.com/en/actions/how-tos/hosting-your-own-runners/managing-self-hosted-runners/configuring-the-self-hosted-runner-application-as-a-service?platform=mac#customizing-the-self-hosted-runner-service-1){:target="_blank"} 」設定註冊不同名稱。

> _iOS 這邊我有一個待研究排除的問題， **就是我改用背景 Service 之後在 Archive 會遇到錯誤\(疑似是跟 keychain 權限有關\)** ，當時沒時間解決，就先用起前景 Terminal Runner 了。_ 

如果是傳統前景要做到開機自動啟動就要去 `~/Library/LaunchAgents` 新增一個自動啟動設定檔案：

`actions.runner.REPO.RUNNER_NAME.plist` ：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
 <dict>
  <key>Label</key>
  <string>actions.runner.REPO.RUNNER_NAME</string>
  <!-- 指定 Terminal.app 來啟動 -->
  <key>ProgramArguments</key>
  <array>
   <string>/usr/bin/open</string>
   <string>-a</string>
   <string>Terminal</string>
   <string>/Users/zhgchgli/Documents/actions-runner/run.sh</string>
  </array>
  <key>RunAtLoad</key>
  <true/>
  <key>WorkingDirectory</key>
  <string>/Users/zhgchgli/Documents/actions-runner</string>
 </dict>
</plist>
```

> _有興趣深入研究 DevOps 的朋友可參考官方 [k8s Runner](https://docs.github.com/en/actions/concepts/runners/about-actions-runner-controller#scaling-runners){:target="_blank"} 文件。_ 

#### 完整專案 Repo

[![](https://opengraph.githubassets.com/9cddb8a4244c635cf1c6a9499fc69e8307096eacf78bb1c6fd08fd7c3a9a0012/ZhgChgLi/github-actions-ci-cd-demo)](https://github.com/ZhgChgLi/github-actions-ci-cd-demo){:target="_blank"}

#### AI Can Help\!

![](/assets/404bd5c70040/1*JecNUCqujV1oeAvHA14X-g.png)

實測給 ChatGPT 完整的步驟跟時機點就能幫你寫好 GitHub Actions 直接使用\!

### 總結

現在你應該已經對 GitHub Actions \+ Self\-hosted Runner 有了一定程度的了解，下一篇我將開始以 App \(iOS\) CI/CD 為案例，手把手建置整套流程。

### 系列文章：
- [**CI/CD 實戰指南（一）：CI/CD 是什麼？如何透過 CI/CD 打造穩定高效的開發團隊？工具選擇？**](../c008a9e8ceca/)
- [**CI/CD 實戰指南（二）：GitHub Actions 與 self\-hosted Runner 使用與建置大全**](../404bd5c70040/)
- [**CI/CD 實戰指南（三）：使用 GitHub Actions 實作 App 專案的 CI 與 CD 工作流程**](../4b001d2e8440/)
- [**CI/CD 實戰指南（四）：使用 Google Apps Script Web App 串接 GitHub Actions 建置免費易用的打包工具平台**](../4273e57e7148/)

有任何問題及指教歡迎 [與我聯絡](https://www.zhgchg.li/contact){:target="_blank"} 。

_[Post](https://dev.zhgchg.li/ci-cd-%E5%AF%A6%E6%88%B0%E6%8C%87%E5%8D%97-%E4%BA%8C-github-actions-%E8%88%87-self-hosted-runner-%E4%BD%BF%E7%94%A8%E8%88%87%E5%BB%BA%E7%BD%AE%E5%A4%A7%E5%85%A8-404bd5c70040){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```