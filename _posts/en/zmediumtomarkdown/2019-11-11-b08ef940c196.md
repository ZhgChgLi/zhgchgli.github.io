---
title: "iOS Deferred Deep Link Implementation (Swift)"
author: "ZhgChgLi"
date: 2019-11-11T14:34:57.966+0000
last_modified_at: 2024-09-13T09:32:09.117+0000
categories: ["ZRealm Dev."]
tags: ["deeplink","ios-app-development","swift","universal-links","app-store"]
description: "Create a seamless app transition process that adapts to all scenarios."
image:
  path: /assets/b08ef940c196/1*P2saSHeIX7TZyCQY0StN1Q.jpeg
render_with_liquid: false
---

### iOS Deferred Deep Link Implementation (Swift)

Create a seamless app transition process that adapts to all scenarios.

### \[2022/07/22\] Update on Upcoming Changes in iOS 16

Starting from iOS â‰¥ 16, when the user does not actively paste, the app's attempt to read the clipboard will prompt a dialog box, requiring the user to allow access for the app to read clipboard information.

![[UIPasteBoardâ€™s privacy change in iOS 16](https://sarunw.com/posts/uipasteboard-privacy-change-ios16/){:target="_blank"}](/assets/b08ef940c196/0*E8h6Fy0H9_5jxhjV.png)

[UIPasteBoardâ€™s privacy change in iOS 16](https://sarunw.com/posts/uipasteboard-privacy-change-ios16/){:target="_blank"}
### \[2020/07/02\] Update
- [Due to updates in iOS 14, users will be prompted when reading the clipboard. Please refer to this article for implementation.](../8a04443024e2/)

#### Irrelevant

After graduating and serving in the military, I have been working for nearly three years, and my growth has plateaued. I started to enter a comfort zone, but fortunately, I decided to resign and take a fresh start.

While reading [Designing Your Life](https://www.books.com.tw/products/0010733134){:target="_blank"}, I re-evaluated my life plan. Although my technical skills are not exceptional, writing on Medium and sharing with others allows me to enter a "flow state" and gain a lot of energy. Recently, a friend asked about Deep Link issues, so I organized my research methods and replenished my energy in the process!
### Scenarios

First, letâ€™s clarify the actual application scenarios.

1\. When a user clicks a URL link (from Google search, FB post, Line link, etc.) while having the app installed, the app should directly open and display the target screen. If not installed, it should redirect to the App Store to install the app; **after installation, opening the app should reproduce the previously intended screen**.

[![iOS Deferred Deep Link Demo](/assets/b08ef940c196/249b_hqdefault.jpg "iOS Deferred Deep Link Demo")](https://www.youtube.com/watch?v=sY6-Q7BFUOM){:target="_blank"}

2\. Track app downloads and openings; we want to know how many people actually downloaded and opened the app from this promotional link.

3\. Special event entry points, for example, opening the app after downloading through a specific URL to receive rewards.
#### Support:

iOS â‰¥ 9
### What is the difference between Deferred Deep Link and Deep Link?
#### Pure Deep Link itself:

![](/assets/b08ef940c196/1*15arO4L94ZoEyOLtFARtsA.jpeg)

As you can see, the mechanism of iOS Deep Link only determines whether the app is installed; if it is, the app opens; if not, it does nothing.
#### First, we need to add a prompt for "if not, redirect to the App Store" to encourage users to install the app:

The **URL Scheme** part is controlled by the system and is generally used for internal app calls, which are rarely made public; because if the trigger point is in an area that you cannot control (e.g., Line link), it cannot be handled.

If the trigger point is on your own webpage, you can use some tricks to handle it. Please refer to [**here**](https://stackoverflow.com/questions/627916/check-if-url-scheme-is-supported-in-javascript){:target="_blank"}:
```xml
<html>
<head>
  <title>Redirect...</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script>
    var appurl = 'marry://open';
    var appstore = 'https://apps.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E6%9C%80%E5%A4%A7%E5%A9%9A%E7%A6%AE%E7%B1%8C%E5%82%99app/id1356057329';

    var timeout;
    function start() {
      window.location = appurl;
      timeout = setTimeout(function(){
        if(confirm('Would you like to install the Marry App now?')){
          document.location = appstore;
        }
      }, 1000);
    }

    window.onload = function() {
      start()
    }
  </script>
</head>
<body>

</body>
</html>
```

The general logic is **to call the URL Scheme, set a timeout, and if the page hasn't redirected by the time the timeout is reached, assume the Scheme is not installed and redirect to the App Store page** (though the experience is still poor as it may show an incorrect URL error message, just with an added automatic redirect).

**Universal Link** itself is a webpage; if there is no redirect, it defaults to being displayed in a web browser. If there is a web service available, it can directly redirect to the webpage; if not, it will redirect to the App Store page.

Websites with web services can add the following in the `<head></head>` section:
```xml
<meta name="apple-itunes-app" content="app-id=APPID, app-argument=page parameters">
```

![](/assets/b08ef940c196/1*nC1JytAwIwKU04EMBBvf0A.jpeg)

When using iPhone Safari to browse the webpage, an APP installation prompt will appear at the top, along with a button to open this page in the APP; the parameter `app-argument` is used to pass the page value and transmit it to the APP.

![Flowchart with "redirect to App Store if not available"](/assets/b08ef940c196/1*B-_5tIDWQpNO8NxpXQsEcA.jpeg)

Flowchart with "redirect to App Store if not available"
#### Perfecting Deep Link APP Handling:

What we want is not just "open the APP if the user has it installed," but also to connect the source information with the APP, allowing the APP to automatically display the target page's interface after opening.

**URL Scheme** can be handled in the AppDelegate with `func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -> Bool`:
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -> Bool {
    if url.scheme == "marry", let params = url.queryParameters {
      if params["type"] == "topic" {
        let VC = TopicViewController(topicID: params["id"])
        UIApplication.shared.keyWindow?.rootViewController?.present(VC, animated: true)
      }    
    }
    return true
}
```

**Universal Link** is handled in the AppDelegate with `func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -> Void) -> Bool`:
```swift
extension URL {
    /// test=1&a=b&c=d => ["test":"1","a":"b","c":"d"]
    /// Parses the URL query and converts it into a [String: String] dictionary
    public var queryParameters: [String: String]? {
        guard let components = URLComponents(url: self, resolvingAgainstBaseURL: true), let queryItems = components.queryItems else {
            return nil
        }
        
        var parameters = [String: String]()
        for item in queryItems {
            parameters[item.name] = item.value
        }
        
        return parameters
    }
    
}
```

First, here is an extension method for URL called queryParameters, which is used to conveniently convert the URL Query into a Swift Dictionary.
```swift
func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -> Void) -> Bool {
        
  if userActivity.activityType == NSUserActivityTypeBrowsingWeb, let webpageURL = userActivity.webpageURL {
    /// If the source is a universal link URL...
    let params = webpageURL.queryParameters
    
    if params["type"] == "topic" {
      let VC = TopicViewController(topicID: params["id"])
      UIApplication.shared.keyWindow?.rootViewController?.present(VC, animated: true)
    }
  }
  
  return true  
}
```

![](/assets/b08ef940c196/1*zhtWK56EqWpE91yTVu64Lg.jpeg)

Done!
#### What else is missing?

It seems perfect so far; we have handled all possible situations, so what else is missing?

![](/assets/b08ef940c196/1*ulrLKyvTKoChPScWD9wHyA.jpeg)

As shown in the image, if it is not installed -> APP Store installation -> APP Store opening, the data carried by the source will be interrupted, and the APP will not know the source, so it will only display the homepage; the user has to go back to the previous webpage and click to open again for the APP to navigate.

![](/assets/b08ef940c196/1*dFdvCRRdM3vrN3lnyG8Diw.jpeg)

> _Although this is not impossible, considering the bounce rate, an additional step means an additional layer of loss, and the user experience will not be smooth; moreover, users may not be that smart._

#### Key Points of This Article

What is a Deferred Deep Link? It is a link that allows our Deep Link to retain source data even after the APP Store installation.

According to Android engineers, Android itself has this feature, but it is not supported on iOS, and achieving this functionality is not user-friendly. Please continue reading.
### Deferred Deep Link

> _If you don't want to spend time doing it yourself, you can directly use [branch\.io](http://branch.io){:target="_blank"} or [Firebase Dynamic Links](https://firebase.google.com/docs/dynamic-links){:target="_blank"}. The method introduced in this article is the one used by Firebase._

**To achieve the effect of Deferred Deep Link, there are two methods available online:**

One method calculates a hash value based on user device, IP, environment, etc., and stores the data on the server at the webpage end; when the APP is opened after installation, it calculates in the same way, and if the values match, it retrieves the data to restore (the method used by branch\.io).

The other method, which this article will introduce, is similar to Firebase's approach; it uses the iPhone clipboard and the shared mechanism of Safari and APP Cookies, effectively storing data in the clipboard or Cookies, which the APP can read and use after installation.

![](/assets/b08ef940c196/1*VVahSlHV2N2jcIw4afzr2g.jpeg)

```
After clicking "Open," your clipboard will be automatically overwritten by JavaScript with the jump-related information: https://XXX.app.goo.gl/?link=https://XXX.net/topicID=1&type=topic
```

Those who have used Firebase Dynamic Links will surely be familiar with this opening jump page; once you understand the principle, you will know that this page cannot be removed from the process!

Additionally, Firebase does not provide options for style modification.
#### Support Level

First, letâ€™s talk about a pitfall, the support level issue; as mentioned earlier, it is "not user-friendly"!

![](/assets/b08ef940c196/1*LR3MSAcwjaoSQhwvtD2sUQ.png)

If the APP only considers iOS â‰¥ 10, it becomes much easier. The APP can implement clipboard access, and the Web can use JavaScript to overwrite information to the clipboard, then redirect to the APP Store for download.

iOS = 9 does not support JavaScript automatic clipboard access but supports **Safari and APP SFSafariViewController "Cookie sharing method."**

Additionally, the APP needs to secretly load SFSafariViewController in the background to access the Web, and then retrieve the Cookie information stored when the link was clicked.

> _The steps are cumbersome, and link clicks are limited to the Safari browser._

![[SFSafariViewController](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller){:target="_blank"}](/assets/b08ef940c196/1*tPXHlrQE3MdrjMzFbnS_4w.png)

[SFSafariViewController](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller){:target="_blank"}

> _According to official documentation, iOS 11 can no longer access the user's Safari Cookies. If there is a need in this regard, you can use SFAuthenticationSession, but this method cannot be executed in the background and will prompt the following dialog box every time before loading:_

```markdown
![_SFAuthenticationSession Prompt Window_](/assets/b08ef940c196/1*eisreftWPWn9PTCbuLQqdw.jpeg)

_SFAuthenticationSession Prompt Window_


> _Additionally, the app review does not allow placing SFSafariViewController in areas not visible to the user. \(Triggering it programmatically and then adding it as a subview is not easily detectable\)_ 




### Hands-On

Let's start simple, considering users on iOS â‰¥ 10, using the iPhone clipboard to transfer information.
#### Web Side:


![](/assets/b08ef940c196/1*P2saSHeIX7TZyCQY0StN1Q.jpeg)


We mimicked Firebase Dynamic Links and customized our own page, using the `clipboard.js` library to copy the information we want to send to the app `ï¼ˆmarry://topicID=1&type=topicï¼‰` to the clipboard when the user clicks "Go Now", and then using `location.href` to redirect to the App Store page.
#### App Side:

Read the clipboard value in AppDelegate or the main UIViewController:

`let pasteData = UIPasteboard.general.string`

It is recommended to wrap the information using URL Scheme for easier identification and data resolution:
```swift
if let pasteData = UIPasteboard.general.string, let url = URL(string: pasteData), url.scheme == "marry", let params = url.queryParameters {
    if params["type"] == "topic" {
      let VC = TopicViewController(topicID: params["id"])
      UIApplication.shared.keyWindow?.rootViewController?.present(VC, animated: true)
    }
}
```

Finally, after processing the action, use `UIPasteboard.general.string = â€œâ€` to clear the information from the clipboard.
### Hands-On â€” Support for iOS 9

Here comes the tricky part, supporting iOS 9. As mentioned earlier, since clipboard support is not available, we need to use **Cookie Intercommunication Method**.
#### Web Side:

The web side is relatively easy to handle; we just need to change it so that when the user clicks "Go Now", we store the information we want to send to the app in a Cookie `ï¼ˆmarry://topicID=1&type=topicï¼‰`, and then use `location.href` to redirect to the App Store page.

Here are two encapsulated JavaScript methods for handling Cookies to speed up development:
```javascript
/// name: Cookie name
/// val: Cookie value
/// day: Cookie expiration, default is 1 day
/// EX1: setcookie("iosDeepLinkData","marry://topicID=1&type=topic")
/// EX2: setcookie("hey","hi",365) = valid for one year
function setcookie(name, val, day) {
    var exdate = new Date();
    day = day || 1;
    exdate.setDate(exdate.getDate() + day);
    document.cookie = "" + name + "=" + val + ";expires=" + exdate.toGMTString();
}

/// getCookie("iosDeepLinkData") => marry://topicID=1&type=topic
function getCookie(name) {
    var arr = document.cookie.match(new RegExp("(^| )" + name + "=([^;]*)(;|$)"));
    if (arr != null) return decodeURI(arr[2]);
    return null;
}
```
#### App Side:

The most troublesome part of this article comes here.

As mentioned earlier, we need to secretly load an SFSafariViewController in the background in the main UIViewController without letting the user notice.
```

```markdown
**Another Pitfall:** When loading secretly, if the size of the View in SFSafariViewController for iOS â‰¥ 10 is set to less than 1, the opacity is set to less than 0.05, and it is set to isHidden, SFSafariViewController will **not load**.

> p.s iOS = 10 supports both Cookie and Clipboard.

![[https://stackoverflow\.com/questions/39019352/ios10\-sfsafariviewcontroller\-not\-working\-when\-alpha\-is\-set\-to\-0/39216788](https://stackoverflow.com/questions/39019352/ios10-sfsafariviewcontroller-not-working-when-alpha-is-set-to-0/39216788){:target="_blank"}](/assets/b08ef940c196/1*ab-6ppwHU72AsKKLYBitbw.png)

[https://stackoverflow\.com/questions/39019352/ios10\-sfsafariviewcontroller\-not\-working\-when\-alpha\-is\-set\-to\-0/39216788](https://stackoverflow.com/questions/39019352/ios10-sfsafariviewcontroller-not-working-when-alpha-is-set-to-0/39216788){:target="_blank"}

My approach here is to place a UIView above the main UIViewController with an arbitrary height, but aligned to the top of the main UIView, and then connect the IBOutlet `ï¼ˆsharedCookieViewï¼‰` to the Class; during viewDidLoad\( \), I initialize the SFSafariViewController and add its View to `sharedCookieView`, so it is actually displayed and loaded, but it runs out of the screen, making it invisible to the user ðŸŒ.

**What URL should the SFSafariViewController point to?**

Similar to the web sharing page, we need to create another page for reading Cookies, and place both pages under the same domain to avoid cross-domain Cookie issues. The page content will be attached later.
```swift
@IBOutlet weak var SharedCookieView: UIView!

override func viewDidLoad() {
    super.viewDidLoad()
    
    let url = URL(string:"http://app.marry.com.tw/loadCookie.html")
    let sharedCookieViewController = SFSafariViewController(url: url)
    VC.view.frame = CGRect(x: 0, y: 0, width: 200, height: 200)
    sharedCookieViewController.delegate = self
    
    self.addChildViewController(sharedCookieViewController)
    self.SharedCookieView.addSubview(sharedCookieViewController.view)
    
    sharedCookieViewController.beginAppearanceTransition(true, animated: false)
    sharedCookieViewController.didMove(toParentViewController: self)
    sharedCookieViewController.endAppearanceTransition()
}
```

`sharedCookieViewController.delegate = self`

`class HomeViewController: UIViewController, SFSafariViewControllerDelegate`

This Delegate needs to be added to capture the CallBack processing after loading is complete.

We can do this in:

`func safariViewController(_ controller: SFSafariViewController, didCompleteInitialLoad didLoadSuccessfully: Bool) {`
```

```markdown
Capture the loading completion event in the method.

At this point, you might think that all that's left is to read the cookies from the webpage in `didCompleteInitialLoad`!

I couldn't find a way to read the cookies from SFSafariViewController here; the methods found online all return empty.

> _Or you may need to use JavaScript to interact with the page content, asking JavaScript to read the cookies and return them to the UIViewController._ 

#### Tricky URL Scheme Method

Since iOS doesn't know how to obtain shared cookies, we can directly let the "cookie reading page" help us "read the cookies."

The `getCookie()` method from the JavaScript handling cookies mentioned earlier is used for this purpose. Our "cookie reading page" is a blank page (since the user won't see it), but in the JavaScript part, we need to read the cookies after the body onload:
```xml
<html>
<head>
  <title>Load iOS Deep Link Saved Cookie...</title>
  <script>
  function checkCookie() {
    var iOSDeepLinkData = getCookie("iOSDeepLinkData");
    if (iOSDeepLinkData && iOSDeepLinkData != '') {
        setcookie("iOSDeepLinkData", "", -1);
        window.location.href = iOSDeepLinkData; /// marry://topicID=1&type=topic
    }
  }
  </script>
</head>

<body onload="checkCookie();">

</body>

</html>
```

The actual principle summary is: when `HomeViewController viewDidLoad` is called, we add `SFSafariViewController` to stealthily load the `loadCookie.html` page, which checks and reads the previously stored cookies. If there are any, it clears them and then uses `window.location.href` to call and trigger the `URL Scheme` mechanism.

Thus, the corresponding callback handling will return to `AppDelegate` in `func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -> Bool` for processing.
### Done! Summary:

![](/assets/b08ef940c196/1*kp26TdlJBW5sVxw4zYa9Rg.jpeg)

If you find it cumbersome, you can directly use [branch.io](http://branch.io){:target="_blank"} or [Firebase Dynamic](https://firebase.google.com/docs/dynamic-links){:target="_blank"}; there's no need to reinvent the wheel. This is because of the need for interface customization and some complex requirements, so I had to build it myself.

Users on iOS 9 are already very rare, so if it's not necessary, you can ignore it; using the clipboard method is quick and efficient, and using the clipboard means you don't have to limit the link to be opened only in Safari!

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-deferred-deep-link-%E5%BB%B6%E9%81%B2%E6%B7%B1%E5%BA%A6%E9%80%A3%E7%B5%90%E5%AF%A6%E4%BD%9C-swift-b08ef940c196){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```
