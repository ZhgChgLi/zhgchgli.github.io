---
title: "iOS Deferred Deep Link Implementation (Swift)"
author: "ZhgChgLi"
date: 2019-11-11T14:34:57.966+0000
last_modified_at: 2024-09-13T09:32:09.117+0000
categories: ["ZRealm Dev."]
tags: ["deeplink","ios-app-development","swift","universal-links","app-store"]
description: "Hands-on creation of a seamless app redirection process for all scenarios"
image:
  path: /assets/b08ef940c196/1*P2saSHeIX7TZyCQY0StN1Q.jpeg
render_with_liquid: false
---

### iOS Deferred Deep Link Implementation \(Swift\)

Hands-on creation of a seamless app redirection process for all scenarios

### \[2022/07/22\] Update on Upcoming Changes in iOS 16

Starting from iOS ≥ 16, when the user does not actively paste, the app's attempt to read the clipboard will trigger a prompt asking for permission. The user must grant permission for the app to access clipboard information.

![[UIPasteBoard’s privacy change in iOS 16](https://sarunw.com/posts/uipasteboard-privacy-change-ios16/){:target="_blank"}](/assets/b08ef940c196/0*E8h6Fy0H9_5jxhjV.png)

[UIPasteBoard’s privacy change in iOS 16](https://sarunw.com/posts/uipasteboard-privacy-change-ios16/){:target="_blank"}
### \[2020/07/02\] Update
- [In response to the iOS 14 update, users will be prompted when accessing the clipboard. Please refer to this article for implementation.](../8a04443024e2/)

#### Irrelevant

After graduating and serving in the military, I've been working for almost three years now. My growth has plateaued, and I've started to settle into a comfort zone. Fortunately, I made the bold decision to resign and take a step back to reset.

While reading [Designing Your Life](https://www.books.com.tw/products/0010733134){:target="_blank"}, I reflected on my career and life. Although my technical skills aren't exceptional, writing on Medium and sharing with others allows me to enter a "flow state" and gain a lot of energy. Recently, a friend asked me about Deep Link issues, which prompted me to organize my research and also recharge my own energy!
### Scenarios

First, let's clarify the actual application scenarios.

1\. When a user clicks a URL link (from Google search, FB post, Line link, etc.) and has the app installed, it should directly open the app to display the target screen. If not installed, it should redirect to the App Store to install the app; **after installation, opening the app should reproduce the previously intended screen**.

[![iOS Deferred Deep Link Demo](/assets/b08ef940c196/249b_hqdefault.jpg "iOS Deferred Deep Link Demo")](https://www.youtube.com/watch?v=sY6-Q7BFUOM){:target="_blank"}

2\. Tracking app downloads and openings; we want to know how many users actually downloaded and opened the app from the promotional link.

3\. Special event entry points, for example, opening the app after downloading via a specific URL to receive rewards.
#### Support:

iOS ≥ 9
### What is the difference between Deferred Deep Link and Deep Link?
#### Pure Deep Link:

![](/assets/b08ef940c196/1*15arO4L94ZoEyOLtFARtsA.jpeg)

As you can see, the mechanism of iOS Deep Link only determines whether the app is installed. If it is, the app opens; if not, it does nothing.
#### First, we need to add a prompt for "redirect to the App Store if not installed" to inform the user to install the app:

The **URL Scheme** part is controlled by the system and is generally used for internal app calls, which are rarely made public; if the trigger point is in an area you cannot control (e.g., Line link), it cannot be processed.

If the trigger point is on your own webpage, you can use some tricks to handle it. Please refer to [**this link**](https://stackoverflow.com/questions/627916/check-if-url-scheme-is-supported-in-javascript){:target="_blank"}:
```xml
<html>
<head>
  <title>Redirect...</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script>
    var appurl = 'marry://open';
    var appstore = 'https://apps.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E6%9C%80%E5%A4%A7%E5%A9%9A%E7%A6%AE%E7%B1%8C%E5%82%99app/id1356057329';

    var timeout;
    function start() {
      window.location = appurl;
      timeout = setTimeout(function(){
        if(confirm('Would you like to install the Marry App now?')){
          document.location = appstore;
        }
      }, 1000);
    }

    window.onload = function() {
      start()
    }
  </script>
</head>
<body>

</body>
</html>
```

The basic logic is to **call the URL Scheme, then set a timeout. If the page hasn't redirected after the timeout, it assumes the scheme cannot be called, and redirects to the App Store page** (though the experience is still poor, and it may show an error message, but at least there's an automatic redirect).

**Universal Link** is essentially its own webpage. If it doesn't redirect, it defaults to displaying in a web browser. If you have web services, you can choose to directly open the webpage; if not, it will redirect to the App Store page.

Websites with web services can add the following in `<head></head>`:
```xml
<meta name="apple-itunes-app" content="app-id=APPID, app-argument=page-parameter">
```

![](/assets/b08ef940c196/1*nC1JytAwIwKU04EMBBvf0A.jpeg)

When browsing the webpage version on iPhone Safari, a prompt to install the app and a button to open this page in the app will appear at the top; the parameter `app-argument` is used to pass page values to the app.

![Flowchart for adding "redirect to the App Store if not installed"](/assets/b08ef940c196/1*B-_5tIDWQpNO8NxpXQsEcA.jpeg)

Flowchart for adding "redirect to the App Store if not installed"
#### Complete Deep Link Handling on the App Side:

What we want is not just "open the app if the user has it installed," but also to connect the source information with the app, allowing the app to automatically display the target page after opening.

The **URL Scheme** method can be handled in `func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -> Bool` in AppDelegate:
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -> Bool {
    if url.scheme == "marry", let params = url.queryParameters {
      if params["type"] == "topic" {
        let VC = TopicViewController(topicID: params["id"])
        UIApplication.shared.keyWindow?.rootViewController?.present(VC, animated: true)
      }    
    }
    return true
}
```

**Universal Link** is handled in `func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -> Void) -> Bool` in AppDelegate:
```swift
extension URL {
    /// test=1&a=b&c=d => ["test":"1","a":"b","c":"d"]
    /// Parses the URL query into a [String: String] dictionary
    public var queryParameters: [String: String]? {
        guard let components = URLComponents(url: self, resolvingAgainstBaseURL: true), let queryItems = components.queryItems else {
            return nil
        }
        
        var parameters = [String: String]()
        for item in queryItems {
            parameters[item.name] = item.value
        }
        
        return parameters
    }
    
}
```

First, here's a URL extension method `queryParameters` to conveniently convert the URL query into a Swift Dictionary.
```swift
func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -> Void) -> Bool {
        
  if userActivity.activityType == NSUserActivityTypeBrowsingWeb, let webpageURL = userActivity.webpageURL {
    /// If it's a universal link URL source...
    let params = webpageURL.queryParameters
    
    if params["type"] == "topic" {
      let VC = TopicViewController(topicID: params["id"])
      UIApplication.shared.keyWindow?.rootViewController?.present(VC, animated: true)
    }
  }
  
  return true  
}
```

![](/assets/b08ef940c196/1*zhtWK56EqWpE91yTVu64Lg.jpeg)

Done!
#### What else is missing?

It seems like we've covered everything, but what else is missing?

![](/assets/b08ef940c196/1*ulrLKyvTKoChPScWD9wHyA.jpeg)

As shown in the diagram, if the flow is not installed -> App Store installation -> App Store opening, the source data will be interrupted, and the app won't know the source, so it will only display the homepage; the user has to go back to the previous webpage and click to open again for the app to navigate to the page.

![](/assets/b08ef940c196/1*dFdvCRRdM3vrN3lnyG8Diw.jpeg)

> _While this is not impossible, considering the drop-off rate, adding an extra step increases the chance of losing users, and the user experience becomes less smooth; moreover, users may not be that savvy._ 

#### Entering the Main Point of the Article

What is Deferred Deep Link? It is a delayed deep link; it allows our Deep Link to extend to retain source data even after the app is installed from the App Store.

According to Android engineers, Android already has this feature, but it is not supported on iOS, and achieving this functionality is not user-friendly. Please continue reading.
### Deferred Deep Link

> _If you don't want to spend time implementing it yourself, you can directly use [branch.io](http://branch.io){:target="_blank"} or [Firebase Dynamic Links](https://firebase.google.com/docs/dynamic-links){:target="_blank"}; the method introduced in this article is the one used by Firebase._ 

**To achieve the effect of Deferred Deep Link, there are two methods available online:**

One method calculates a hash value based on user device, IP, environment, etc., and stores data on the server from the webpage; when the app is opened after installation, it calculates the value in the same way. If the values match, it retrieves the data (this is branch.io's approach).

The other method, which this article will introduce, is similar to Firebase's approach; it uses the iPhone clipboard and the shared mechanism between Safari and the app cookies, effectively storing data in the clipboard or cookies, which the app can read after installation.

![](/assets/b08ef940c196/1*VVahSlHV2N2jcIw4afzr2g.jpeg)

```
After clicking "Open," your clipboard will be automatically overwritten by JavaScript with the relevant redirect information: https://XXX.app.goo.gl/?link=https://XXX.net/topicID=1&type=topic
```

Those who have used Firebase Dynamic Links will be familiar with this redirect page; once you understand the principle, you'll realize this page cannot be removed from the flow!

Additionally, Firebase does not provide options for style modifications.
#### Support

First, let's discuss a pitfall regarding support; as mentioned earlier, it is "not user-friendly"!

![](/assets/b08ef940c196/1*LR3MSAcwjaoSQhwvtD2sUQ.png)

If the app only considers iOS ≥ 10, it becomes much easier. The app can implement clipboard access, and the web can use JavaScript to overwrite the clipboard information, then redirect to the App Store for download.

iOS = 9 does not support automatic clipboard access via JavaScript but does support **Cookie sharing between Safari and the app using SFSafariViewController**.

Additionally, the app needs to secretly load SFSafariViewController in the background to obtain the cookie information stored when the link was clicked.

> _The steps are cumbersome, and link clicks are limited to the Safari browser._ 

![[SFSafariViewController](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller){:target="_blank"}](/assets/b08ef940c196/1*tPXHlrQE3MdrjMzFbnS_4w.png)

[SFSafariViewController](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller){:target="_blank"}

> _According to official documentation, starting from iOS 11, it is no longer possible to access the user's Safari cookies. If you need this functionality, you can use SFAuthenticationSession, but this method cannot run in the background and will always prompt the following dialog before loading:_

![_SFAuthenticationSession Prompt Window_](/assets/b08ef940c196/1*eisreftWPWn9PTCbuLQqdw.jpeg)

_SFAuthenticationSession Prompt Window_

> _Moreover, app review does not allow placing SFSafariViewController in areas where users cannot see it. \(Triggering it programmatically and then adding it as a subview is not easily detectable\)_ 

### Hands-On Implementation

Let's start with the simpler case, considering only users on iOS ≥ 10, using the iPhone clipboard to transfer information.
#### Web Side:

![](/assets/b08ef940c196/1*P2saSHeIX7TZyCQY0StN1Q.jpeg)

We created a custom page mimicking Firebase Dynamic Links, using the `clipboard.js` library to copy the information we want to pass to the app to the clipboard `（marry://topicID=1&type=topic）` when the user clicks "Go Now," and then using `location.href` to redirect to the App Store page.
#### App Side:

In the AppDelegate or main UIViewController, read the clipboard value:

`let pasteData = UIPasteboard.general.string`

It is recommended to wrap the information using the URL Scheme for easier identification and data resolution:
```swift
if let pasteData = UIPasteboard.general.string, let url = URL(string: pasteData), url.scheme == "marry", let params = url.queryParameters {
    if params["type"] == "topic" {
      let VC = TopicViewController(topicID: params["id"])
      UIApplication.shared.keyWindow?.rootViewController?.present(VC, animated: true)
    }
}
```

Finally, after processing the action, use `UIPasteboard.general.string = ""` to clear the information from the clipboard.
### Hands-On Implementation — Supporting iOS 9

Now comes the tricky part, supporting iOS 9. As mentioned earlier, since clipboard access is not supported, we will use the **Cookie sharing method**.
#### Web Side:

The web side is relatively straightforward; we will change it so that when the user clicks "Go Now," we store the information we want to pass to the app in a cookie `（marry://topicID=1&type=topic）`, and then use `location.href` to redirect to the App Store page.

Here are two encapsulated JavaScript methods for handling cookies to speed up development:
```javascript
/// name: Cookie name
/// val: Cookie value
/// day: Cookie expiration, default is 1 day
/// EX1: setcookie("iosDeepLinkData","marry://topicID=1&type=topic")
/// EX2: setcookie("hey","hi",365) = valid for one year
function setcookie(name, val, day) {
    var exdate = new Date();
    day = day || 1;
    exdate.setDate(exdate.getDate() + day);
    document.cookie = "" + name + "=" + val + ";expires=" + exdate.toGMTString();
}

/// getCookie("iosDeepLinkData") => marry://topicID=1&type=topic
function getCookie(name) {
    var arr = document.cookie.match(new RegExp("(^| )" + name + "=([^;]*)(;|$)"));
    if (arr != null) return decodeURI(arr[2]);
    return null;
}
```
#### App Side:

This is the most complicated part of the article.

As mentioned earlier, we need to secretly load an SFSafariViewController in the background in the main UIViewController without the user noticing.

**Another pitfall:** The secret loading of SFSafariViewController will not work if its size is set to less than 1, its opacity is less than 0.05, or if it is set to hidden.

> p.s. iOS = 10 supports both Cookie and clipboard. 

![[https://stackoverflow\.com/questions/39019352/ios10\-sfsafariviewcontroller\-not\-working\-when\-alpha\-is\-set\-to\-0/39216788](https://stackoverflow.com/questions/39019352/ios10-sfsafariviewcontroller-not-working-when-alpha-is-set-to-0/39216788){:target="_blank"}](/assets/b08ef940c196/1*ab-6ppwHU72AsKKLYBitbw.png)

[https://stackoverflow\.com/questions/39019352/ios10\-sfsafariviewcontroller\-not\-working\-when\-alpha\-is\-set\-to\-0/39216788](https://stackoverflow.com/questions/39019352/ios10-sfsafariviewcontroller-not-working-when-alpha-is-set-to-0/39216788){:target="_blank"}

```markdown
---
title: iOS Deferred Deep Link Implementation
---

My approach here is to place a UIView at the top of the main page's UIViewController with an arbitrary height, aligning its bottom with the top of the main page's UIView. Then, I connect the IBOutlet `sharedCookieView` to the class. In the `viewDidLoad()` method, I initialize the SFSafariViewController and add its view to `sharedCookieView`. So, it actually shows that it has loaded, but it runs off the screen, making it invisible to the user 🌝.

**What URL should the SFSafariViewController point to?**

Similar to the web sharing page, we need to create another page for reading cookies and place both pages under the same domain to avoid cross-domain cookie issues. I will attach the page content later.
```swift
@IBOutlet weak var SharedCookieView: UIView!

override func viewDidLoad() {
    super.viewDidLoad()
    
    let url = URL(string:"http://app.marry.com.tw/loadCookie.html")
    let sharedCookieViewController = SFSafariViewController(url: url)
    VC.view.frame = CGRect(x: 0, y: 0, width: 200, height: 200)
    sharedCookieViewController.delegate = self
    
    self.addChildViewController(sharedCookieViewController)
    self.SharedCookieView.addSubview(sharedCookieViewController.view)
    
    sharedCookieViewController.beginAppearanceTransition(true, animated: false)
    sharedCookieViewController.didMove(toParentViewController: self)
    sharedCookieViewController.endAppearanceTransition()
}
```

`sharedCookieViewController.delegate = self`

`class HomeViewController: UIViewController, SFSafariViewControllerDelegate`

You need to add this delegate to capture the callback handling after the loading is complete.

We can capture the loading completion event in:

`func safariViewController(_ controller: SFSafariViewController, didCompleteInitialLoad didLoadSuccessfully: Bool) {`

At this point, you might think that the next step is to read the cookies from the webpage in `didCompleteInitialLoad`, and that would be done!

Here, I couldn't find a method to read cookies from SFSafariViewController; the methods found online return empty results.

> _Alternatively, you might need to use JavaScript to interact with the page content, asking JavaScript to read the cookies and return them to the UIViewController._ 

#### The Tricky URL Scheme Method

Since iOS doesn't know how to obtain shared cookies, we will let the "cookie reading page" help us "read the cookies."

The `getCookie()` method from the JavaScript cookie handling approach mentioned earlier is used for this. Our "cookie reading page" is just a blank page (since the user won't see it), but in the JavaScript part, we need to read the cookies after the body onload:
```xml
<html>
<head>
  <title>Load iOS Deep Link Saved Cookie...</title>
  <script>
  function checkCookie() {
    var iOSDeepLinkData = getCookie("iOSDeepLinkData");
    if (iOSDeepLinkData && iOSDeepLinkData != '') {
        setcookie("iOSDeepLinkData", "", -1);
        window.location.href = iOSDeepLinkData; /// marry://topicID=1&type=topic
    }
  }
  </script>
</head>

<body onload="checkCookie();">

</body>

</html>
```

The actual principle is summarized as follows: when `HomeViewController viewDidLoad` is called, we add the `SFSafariViewController` to stealthily load the `loadCookie.html` page. The `loadCookie.html` page checks for previously stored cookies; if found, it reads and clears them, then uses `window.location.href` to trigger the `URL Scheme` mechanism.

Thus, the corresponding callback handling will return to the `AppDelegate` in the `func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -> Bool` for processing.
### Completed! Summary:

![](/assets/b08ef940c196/1*kp26TdlJBW5sVxw4zYa9Rg.jpeg)

If you find this tedious, you can directly use [branch\.io](http://branch.io){:target="_blank"} or [Firebase Dynamic](https://firebase.google.com/docs/dynamic-links){:target="_blank"} without needing to reinvent the wheel. This approach is necessary due to interface customization and some complex requirements, so I had to build it myself.

Users on iOS 9 are already quite rare, so if it's not absolutely necessary, you can ignore it; using the clipboard method is quick and efficient, and it doesn't limit the link to being opened only in Safari!

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-deferred-deep-link-%E5%BB%B6%E9%81%B2%E6%B7%B1%E5%BA%A6%E9%80%A3%E7%B5%90%E5%AF%A6%E4%BD%9C-swift-b08ef940c196){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```