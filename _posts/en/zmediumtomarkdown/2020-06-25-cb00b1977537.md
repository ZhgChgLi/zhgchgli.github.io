---
title: "Summary of Decode Issues Encountered in Real-World Use of Codable (Part 2)"
author: "ZhgChgLi"
date: 2020-06-25T17:56:31.959+0000
last_modified_at: 2024-04-13T08:29:42.768+0000
categories: ["ZRealm Dev."]
tags: ["ios","ios-app-development","codable","json","core-data"]
description: "Reasonably handling Response Null field data, not necessarily rewriting init decoder"
image:
  path: /assets/cb00b1977537/1*zoN0YxCnWdvMs35FaP5tNA.jpeg
render_with_liquid: false
---

### Summary of Decode Issues Encountered in Real-World Use of Codable (Part 2)

Reasonably handling Response Null field data, not necessarily rewriting init decoder



![Photo by [Zan](https://unsplash.com/@zanilic?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/cb00b1977537/1*zoN0YxCnWdvMs35FaP5tNA.jpeg)

Photo by [Zan](https://unsplash.com/@zanilic?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Introduction

Following the previous article "[Summary of Decode Issues Encountered in Real-World Use of Codable](../1aa2f8445642/)", the development progress has continued, and new scenarios and issues have arisen. Therefore, this second part is written to continue documenting the situations encountered and the research thoughts for future reference.

The previous article mainly addressed the Decodable Mapping from JSON String to Entity Object. With the Entity Object, we can convert it into a Model Object for use within the program, and the View Model Object can handle data display logic, etc.; **on the other hand, we need to convert the Entity into NSManagedObject to store it in local Core Data**.
### Main Issue

Assuming our Song Entity structure is as follows:
```swift
struct Song: Decodable {
    var id: Int
    var name: String?
    var file: String?
    var converImage: String?
    var likeCount: Int?
    var like: Bool?
    var length: Int?
}
```

Since the API Endpoint does not necessarily return complete data fields (only the id is guaranteed), all fields except for id are optional. For example, when retrieving song information, it may return the complete structure, but when liking a song, it will only return the three related fields: `id`, `likeCount`, and `like`.

We hope that whatever fields are present in the API Response can be stored in Core Data, and if the data already exists, we will update the changed fields (incremental update).


> _However, the problem arises here: after Codable Decode into Entity Object, we cannot distinguish between **"the data field is intended to be set to nil" and "the Response did not provide it"**_ 




```
A Response:
{
  "id": 1,
  "file": null
}
```

For A Response and B Response, the file is null, but the meanings are different; A intends to set the file field to null (clearing the original data), while B simply did not provide the file field while updating other data.


> Developers in the Swift community have proposed [adding a null Strategy similar to date Strategy in JSONDecoder](https://forums.swift.org/t/pitch-jsondecoder-nulldecodingstrategy/13980){:target="_blank"} to help us distinguish between the above situations, but there are currently no plans to include it. 




#### Solution

As mentioned earlier, our structure is JSON String -> Entity Object -> NSManagedObject, so when we obtain the Entity Object, it is already the decoded result, and there is no raw data to manipulate. Of course, we could compare and operate with the original JSON String, but it would be better not to use Codable for that.

First, refer to the [previous article](../1aa2f8445642/) that uses an Associated Value Enum as a container for values.
```swift
enum OptionalValue<T: Decodable>: Decodable {
    case null
    case value(T)
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(T.self) {
            self = .value(value)
        } else {
            self = .null
        }
    }
}
```

Using generics, T is the actual data field type; .value(T) can hold the decoded value, while .null represents that the value is null.
```swift
struct Song: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case file
    }
    
    var id: Int
    var file: OptionalValue<String>?
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        self.id = try container.decode(Int.self, forKey: .id)
        
        if container.contains(.file) {
            self.file = try container.decode(OptionalValue<String>.self, forKey: .file)
        } else {
            self.file = nil
        }
    }
}

var jsonData = """
{
    "id":1
}
""".data(using: .utf8)!
var result = try! JSONDecoder().decode(Song.self, from: jsonData)
print(result)

jsonData = """
{
    "id":1,
    "file":null
}
""".data(using: .utf8)!
result = try! JSONDecoder().decode(Song.self, from: jsonData)
print(result)

jsonData = """
{
    "id":1,
    "file":\"https://test.com/m.mp3\"
}
""".data(using: .utf8)!
result = try! JSONDecoder().decode(Song.self, from: jsonData)
print(result)
```


> _The example is simplified to only include the `id` and `file` data fields._ 





The Song Entity overrides the decoding method, using the `contains(.KEY)` method to determine whether the response provides that field (regardless of the value). If it does, it decodes it into OptionalValue; the OptionalValue Enum will then decode the actual value we want. If the value is successfully decoded, it will be placed in .value(T), and if the provided value is null (or decoding fails), it will be placed in .null.
1. When the response provides a field & value: OptionalValue.value(VALUE)
2. When the response provides a field & the value is null: OptionalValue.null
3. When the response does not provide the field: nil



> _This way, we can distinguish whether a field is provided or not, allowing us to determine whether to update the field to null or not update this field when writing to Core Data._ 

#### Other Research — Double Optional ❌

Optional!Optional! is very suitable for handling this scenario in Swift.
```swift
struct Song: Decodable {
    var id: Int
    var name: String??
    var file: String??
    var converImage: String??
    var likeCount: Int??
    var like: Bool??
    var length: Int??
}
```
1. When the response provides a field & value: Optional(VALUE)
2. When the response provides a field & the value is null: Optional(nil)
3. When the response does not provide a field: nil

However, the .Codable JSONDecoder Decode treats both Double Optional and Optional with decodeIfPresent as Optional, and does not specifically handle Double Optional; thus, the result remains the same.

#### Other Research — Property Wrapper ❌

It was originally envisioned to use Property Wrapper for elegant encapsulation, for example:
```swift
@OptionalValue var file: String?
```

But before delving into the details, it was discovered that Codable Property fields marked with Property Wrapper must have that field in the API Response, otherwise a keyNotFound error will occur, even if the field is Optional.?????

There is also a [discussion thread](https://forums.swift.org/t/using-property-wrappers-with-codable/29804){:target="_blank"} on the official forum regarding this issue… it is expected to be fixed in the future.

> Therefore, when choosing packages like [BetterCodable](https://github.com/marksands/BetterCodable){:target="_blank"} and [CodableWrappers](https://github.com/GottaGetSwifty/CodableWrappers){:target="_blank"}, this current issue with Property Wrapper should be taken into consideration.

### Other Problem Scenarios
#### 1. How to Decode API Response Using 0/1 to Represent Bool?
```swift
import Foundation

struct Song: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case like
    }
    
    var id: Int
    var name: String?
    var like: Bool?
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try container.decode(Int.self, forKey: .id)
        self.name = try container.decodeIfPresent(String.self, forKey: .name)
        
        if let intValue = try container.decodeIfPresent(Int.self, forKey: .like) {
            self.like = (intValue == 1) ? true : false
        } else if let boolValue = try container.decodeIfPresent(Bool.self, forKey: .like) {
            self.like = boolValue
        }
    }
}

var jsonData = """
{
    "id": 1,
    "name": "告五人",
    "like": 0
}
""".data(using: .utf8)!
var result = try! JSONDecoder().decode(Song.self, from: jsonData)
print(result)
```


Building on the previous article, we can decode to `int`/`Bool` ourselves in `init Decode` and assign values, allowing the original fields to accept `0`/`1`/`true`/`false`.

#### 2. Do not want to rewrite init decoder every time

In situations where we do not want to manually create a decoder, we can override the original JSON decoder to extend its functionality.

We can create our own extension for [KeyedDecodingContainer](https://developer.apple.com/documentation/swift/keyeddecodingcontainer){:target="_blank"} to define public methods. Swift will prioritize executing our redefined methods within the module, overriding the original implementation from Foundation.

> **_This affects the entire module._**

> **_Also, it is not a true override; you cannot call super.decode, so be careful not to call yourself (EX: decode(Bool.Type, for: key) in decode(Bool.Type, for: key))_**

**There are two methods for decode:**
- **decode(Type, forKey:)** handles non-Optional data fields
- **decodeIfPresent(Type, forKey:)** handles Optional data fields

**Example 1. The main issue mentioned earlier can be directly extended:**
```swift
extension KeyedDecodingContainer {
    public func decodeIfPresent<T>(_ type: T.Type, forKey key: Self.Key) throws -> T? where T : Decodable {
        //better:
        switch type {
        case is OptionalValue<String>.Type,
             is OptionalValue<Int>.Type:
            return try? decode(type, forKey: key)
        default:
            return nil
        }
        // or just return try? decode(type, forKey: key)
    }
}

struct Song: Decodable {
    var id: Int
    var file: OptionalValue<String>?
}
```

The main issue is with Optional data fields and Decodable types, so we override the `decodeIfPresent<T: Decodable>` method.

Here, it is speculated that the original implementation of `decodeIfPresent` is that if the data is null or the response does not provide it, it will directly return nil and will not actually run decode.

Thus, the principle is simple: as long as the Decodable Type is `OptionalValue<T>`, we will decode it regardless of the situation to obtain different status results; however, it is also possible not to judge the Decodable Type, which means all Optional fields will attempt to decode.

**Example 2. Problem scenario 1 can also be expanded using this method:**
```swift
extension KeyedDecodingContainer {
    public func decodeIfPresent(_ type: Bool.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Bool? {
        if let intValue = try? decodeIfPresent(Int.self, forKey: key) {
            return (intValue == 1) ? (true) : (false)
        } else if let boolValue = try? decodeIfPresent(Bool.self, forKey: key) {
            return boolValue
        }
        return nil
    }
}

struct Song: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case like
    }
    
    var id: Int
    var name: String?
    var like: Bool?
}

var jsonData = """
{
    "id": 1,
    "name": "告五人",
    "like": 1
}
""".data(using: .utf8)!
var result = try! JSONDecoder().decode(Song.self, from: jsonData)
print(result)
```
### Conclusion

```markdown
I've used various tricks and techniques with Codable, but some of them are quite convoluted. This is mainly because the constraints of Codable are too strong, sacrificing much of the flexibility needed in real-world development. In the end, I even started to question why I chose Codable in the first place, as its advantages seem to diminish...

#### References
- [Perhaps you don't need to rewrite the init(from:) method](https://kemchenj.github.io/2018-07-09/){:target="_blank"}

### Reflection
- [A summary of the Decode issues encountered in practical use of Codable (Part 1)](../1aa2f8445642/)

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/%E7%8F%BE%E5%AF%A6%E4%BD%BF%E7%94%A8-codable-%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84-decode-%E5%95%8F%E9%A1%8C%E5%A0%B4%E6%99%AF%E7%B8%BD%E5%8C%AF-%E4%B8%8B-cb00b1977537){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```
