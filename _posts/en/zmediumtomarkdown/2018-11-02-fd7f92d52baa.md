---
title: "Handling Push Notification Permission Status from iOS 9 to iOS 12 (Swift)"
author: "ZhgChgLi"
date: 2018-11-02T15:23:44.057+0000
last_modified_at: 2024-04-13T07:25:31.183+0000
categories: ["ZRealm Dev."]
tags: ["ios","push-notification","observables","ios-app-development","swift"]
description: "Solutions for handling notification permission status and requesting permissions for iOS 9 to iOS 12"
image:
  path: /assets/fd7f92d52baa/1*fm_hG0GuT-BhSNTEB3Ht1g.jpeg
render_with_liquid: false
---

### Handling Push Notification Permission Status from iOS 9 to iOS 12 (Swift)

Solutions for handling notification permission status and requesting permissions for iOS 9 to iOS 12

### What to Do?

Following the previous article "[What? iOS 12 Can Send Push Notifications Without User Authorization (Swift)](https://medium.com/@zhgchgli/%E4%BB%80%E9%BA%BC-ios-12-%E4%B8%8D%E9%9C%80%E4%BD%BF%E7%94%A8%E8%80%85%E6%8E%88%E6%AC%8A%E5%B0%B1%E8%83%BD%E6%94%B6%E5%88%B0%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5-swift-ade9e745a4bf?fbclid=IwAR1AKi3io4Jt-rFFgrLWEFsmA0lKYVFUD7Dw9n9LpMa2zAzJCHeGGGgn9Vs){:target="_blank"}" which mentioned the optimization of the push notification permission acquisition process, we encountered new requirements after the optimizations discussed in the previous Murmur section:

![](/assets/fd7f92d52baa/1*fm_hG0GuT-BhSNTEB3Ht1g.jpeg)

1. If the user has disabled notifications, we can prompt them to enable it on a specific feature page.
2. After navigating to the settings page, if there are any actions to enable/disable notifications, the app should reflect the updated status upon returning.
3. If permission for push notifications has not been requested, we should ask for permission; if it has been asked but denied, we should show a prompt; if it has been asked and granted, the user can continue to operate.
4. Support for both iOS 9 and iOS 12 is required.

Items 1 to 3 are manageable; using the UserNotifications framework available in iOS 10 and later can adequately address these. The challenge lies in item 4, which requires support for iOS 9. Handling this with the older method of `registerUserNotificationSettings` is not straightforward; let's tackle this step by step!

### Approach and Structure:

First, declare a global `notificationStatus` object to store the notification permission status and add property observers on the pages that need to handle it (here I use [Observable](https://github.com/slazyk/Observable-Swift){:target="_blank"} for property change subscriptions; you can find suitable KVO or use Rx, ReactiveCocoa as needed).

In the `appDelegate`, handle the checking of push notification permission status and update the value of `notificationStatus` in the following methods: `didFinishLaunchingWithOptions` (when the app is initially opened), `applicationDidBecomeActive` (when returning from the background), and `didRegisterUserNotificationSettings` (handling push notification requests for iOS 9 and below). The pages that need to be processed will trigger and perform the corresponding actions (e.g., showing a notification disabled prompt).

#### 1. Declare the global `notificationStatus` object
```swift
enum NotificationStatusType {
     case authorized
     case denied
     case notDetermined
}
var notificationStatus: Observable<NotificationStatusType?> = Observable(nil)
```

The four states of `notificationStatus/NotificationStatusType` correspond to:
- nil = Object initialization… checking…
- notDetermined = User has not been asked whether to receive notifications
- authorized = User has been asked whether to receive notifications and pressed "Allow"
- denied = User has been asked whether to receive notifications and pressed "Don't Allow"

#### 2. Method to Check Notification Permission Status:
```swift
func checkNotificationPermissionStatus() {
    if #available(iOS 10.0, *) {
        UNUserNotificationCenter.current().getNotificationSettings { (settings) in
            DispatchQueue.main.async {
                // Note! Switch back to the main thread
                if settings.authorizationStatus == .authorized {
                    // Allowed
                    notificationStatus.value = NotificationStatusType.authorized
                } else if settings.authorizationStatus == .denied {
                    // Not allowed
                    notificationStatus.value = NotificationStatusType.denied
                } else {
                    // Not asked yet
                    notificationStatus.value = NotificationStatusType.notDetermined
                }
            }
        }
    } else {
        if UIApplication.shared.currentUserNotificationSettings?.types == []  {
            if let iOS9NotificationIsDetermined = UserDefaults.standard.object(forKey: "iOS9NotificationIsDetermined") as? Bool, iOS9NotificationIsDetermined == true {
                // Not asked yet
                notificationStatus.value = NotificationStatusType.notDetermined
            } else {
                // Not allowed
                notificationStatus.value = NotificationStatusType.denied
            }
        } else {
            // Allowed
            notificationStatus.value = NotificationStatusType.authorized
        }
    }
}
```

**This is not over yet!**  
Sharp-eyed friends should have noticed the custom UserDefaults "iOS9NotificationIsDetermined" in the judgment for ≤ iOS 9. What is it used for?

The main reason is that the method for checking push notification permissions in ≤ iOS 9 can only determine the current permissions by checking which ones are available. If it is empty, it means there is no permission, but it can also be blank if the permission has not been asked. This raises the question: has the user not been asked or have they been asked and denied?

Here, I used a custom UserDefaults "iOS9NotificationIsDetermined" as a judgment switch, and added it in the appDelegate's didRegisterUserNotificationSettings:
```swift
//appdelegate.swift:
func application(_ application: UIApplication, didRegister notificationSettings: UIUserNotificationSettings) {
    // For iOS 9 and below, this method will be triggered after the prompt asking whether to allow notifications is shown, regardless of whether the user presses allow or deny
    UserDefaults.standard.set("iOS9NotificationIsDetermined", true)
    checkNotificationPermissionStatus()
}
```

**After constructing the object for notification permission status and the method to check it, we also need to add the following in appDelegate…**
```swift
//appdelegate.swift
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {  
  checkNotificationPermissionStatus()
  return true
}
func applicationDidBecomeActive(_ application: UIApplication) {
  checkNotificationPermissionStatus()
}
```


The app should recheck the push notification status after returning from the background.

That covers the checking part. Next, let's look at how to handle the request for notification permissions if it hasn't been asked yet.
#### 3\. Request Notification Permission:
```swift
func requestNotificationPermission() {
    if #available(iOS 10.0, *) {
        let permissiones:UNAuthorizationOptions = [.badge, .alert, .sound]
        UNUserNotificationCenter.current().requestAuthorization(options: permissiones) { (granted, error) in
            DispatchQueue.main.async {
                checkNotificationPermissionStatus()
            }
        }
    } else {
        application.registerUserNotificationSettings(UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil))
        // The didRegisterUserNotificationSettings in appdelegate.swift will handle the subsequent callback
    }
}
```

Both checking and requesting have been handled. Now, let's see how to apply it.
#### 4\. Application (Static)
```php
if notificationStatus.value == NotificationStatusType.authorized {
    //OK!
} else if notificationStatus.value == NotificationStatusType.denied {
    //Not allowed
    // Here, the example shows a UIAlertController prompt, and clicking it can redirect to the settings page
    let alertController = UIAlertController(
        title: "Dear, you are currently unable to receive notifications",
        message: "Please enable the notification permission for Marriage App.",
        preferredStyle: .alert)
    let settingAction = UIAlertAction(
        title: "Go to Settings",
        style: .destructive,
        handler: {
            (action: UIAlertAction!) -> Void in
            if let bundleID = Bundle.main.bundleIdentifier, let url = URL(string: UIApplicationOpenSettingsURLString + bundleID) {
                UIApplication.shared.openURL(url)
            }
    })
    let okAction = UIAlertAction(
        title: "Cancel",
        style: .default,
        handler: {
            (action: UIAlertAction!) -> Void in
            //well....
    })
    alertController.addAction(okAction)
    alertController.addAction(settingAction)
    self.present(alertController, animated: true) {
        
    }
} else if notificationStatus.value == NotificationStatusType.notDetermined {
    //Not asked
    requestNotificationPermission()
}
```

> **Please note!! When jumping to the APP's "Settings" page, do not use** 
 

> UIApplication\.shared\.openURL\(URL\(string:”App\-Prefs:root=\\ \(bundleID\)”\) \)
 

> **to redirect, it will be rejected! It will be rejected! It will be rejected! (Personal experience)**

> This is a Private API 

#### 5. Application (Dynamic)

For the part that dynamically changes the status, since we are using the notificationStatus object as Observable, we can add a listener in viewDidLoad to monitor the status in real-time:
```swift
override func viewDidLoad() {
   super.viewDidLoad()
   notificationStatus.afterChange += { oldStatus,newStatus in
      if newStatus == NotificationStatusType.authorized {
       //print("❤️ Thank you for enabling notifications") 
      } else if newStatus == NotificationStatusType.denied {
       //print("😭 Boohoo")
      }
   }
}
```

> The above is just sample code; actual application and triggering can be adjusted as needed.

> **\*Please pay attention to memory management when using Observable for notificationStatus. It should be released when it needs to be released (to prevent memory leaks) and retained when it should not be released (to avoid losing the listener).** 

### Finally, here is the complete demo product:

![[Marriage App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}](/assets/fd7f92d52baa/1*_iVzlJLNQ7f0hO7IWxg1Zg.gif)

[Marriage App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}

_\*Since our project supports iOS 9 to iOS 12, we have not conducted any tests on iOS 8 and are uncertain about the level of support._

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/%E5%BE%9E-ios-9-%E5%88%B0-ios-12-%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5%E6%AC%8A%E9%99%90%E7%8B%80%E6%85%8B%E8%99%95%E7%90%86-swift-fd7f92d52baa){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
