---
title: "Handling Push Notification Permission Status from iOS 9 to iOS 12 (Swift)"
author: "ZhgChgLi"
date: 2018-11-02T15:23:44.057+0000
last_modified_at: 2024-04-13T07:25:31.183+0000
categories: ["ZRealm Dev."]
tags: ["ios","push-notification","observables","ios-app-development","swift"]
description: "Solutions for handling notification permission status and requesting permissions from iOS 9 to iOS 12"
image:
  path: /assets/fd7f92d52baa/1*fm_hG0GuT-BhSNTEB3Ht1g.jpeg
render_with_liquid: false
---

### Handling Push Notification Permission Status from iOS 9 to iOS 12 \(Swift\)

Solutions for handling notification permission status and requesting permissions from iOS 9 to iOS 12.

### What to Do?

Following up on the previous article "[What? iOS 12 Can Send Push Notifications Without User Authorization \(Swift\)](https://medium.com/@zhgchgli/%E4%BB%80%E9%BA%BC-ios-12-%E4%B8%8D%E9%9C%80%E4%BD%BF%E7%94%A8%E8%80%85%E6%8E%88%E6%AC%8A%E5%B0%B1%E8%83%BD%E6%94%B6%E5%88%B0%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5-swift-ade9e745a4bf?fbclid=IwAR1AKi3io4Jt-rFFgrLWEFsmA0lKYVFUD7Dw9n9LpMa2zAzJCHeGGGgn9Vs){:target="_blank"}" which discussed optimizing the process of obtaining push notification permissions, we encountered new requirements after the optimizations mentioned in the previous Murmur section:

![](/assets/fd7f92d52baa/1*fm_hG0GuT-BhSNTEB3Ht1g.jpeg)

1. If the user has disabled notifications, we should prompt them to enable it on a specific feature page.
2. After navigating to the settings page, if the user toggles notifications, the app should reflect the updated status upon returning.
3. If permission has not been requested, we should ask for it; if it has been asked but denied, we should show a prompt; if it has been asked and granted, the user can continue.
4. Support is required for both iOS 9 and iOS 12.

Items 1 to 3 are manageable; using the UserNotifications framework from iOS 10 onward can effectively address these. The challenge lies in item 4, as we need to support iOS 9, which requires using the older method `registerUserNotificationSettings`, making it a bit tricky. Let's tackle this step by step!

### Approach and Structure:

First, declare a global `notificationStatus` object to store the notification permission status and add property observers on the pages that need to handle it (I used [Observable](https://github.com/slazyk/Observable-Swift){:target="_blank"} for property change subscriptions; you can choose a suitable KVO or use Rx, ReactiveCocoa).

In the `appDelegate`, handle checking the push notification permission status and updating the `notificationStatus` value in the following methods: `didFinishLaunchingWithOptions` (when the app is initially opened), `applicationDidBecomeActive` (when returning from the background), and `didRegisterUserNotificationSettings` (for push notification handling on iOS 9 and below). The pages that need to handle this will trigger and perform the corresponding actions (e.g., showing a notification disabled prompt).

#### 1\. Declare the Global `notificationStatus` Object
```swift
enum NotificationStatusType {
     case authorized
     case denied
     case notDetermined
}
var notificationStatus: Observable<NotificationStatusType?> = Observable(nil)
```

The four states of `notificationStatus`/`NotificationStatusType` correspond to:
- nil = Object initializationâ€¦ checkingâ€¦
- notDetermined = User has not been asked whether to receive notifications
- authorized = User has been asked and clicked "Allow"
- denied = User has been asked and clicked "Don't Allow"

#### 2\. Build the Method to Check Notification Permission Status:
```swift
func checkNotificationPermissionStatus() {
    if #available(iOS 10.0, *) {
        UNUserNotificationCenter.current().getNotificationSettings { (settings) in
            DispatchQueue.main.async {
                // Note! Switch back to the main thread
                if settings.authorizationStatus == .authorized {
                    // Allowed
                    notificationStatus.value = NotificationStatusType.authorized
                } else if settings.authorizationStatus == .denied {
                    // Not allowed
                    notificationStatus.value = NotificationStatusType.denied
                } else {
                    // Not asked
                    notificationStatus.value = NotificationStatusType.notDetermined
                }
            }
        }
    } else {
        if UIApplication.shared.currentUserNotificationSettings?.types == []  {
            if let iOS9NotificationIsDetermined = UserDefaults.standard.object(forKey: "iOS9NotificationIsDetermined") as? Bool, iOS9NotificationIsDetermined == true {
                // Not asked
                notificationStatus.value = NotificationStatusType.notDetermined
            } else {
                // Not allowed
                notificationStatus.value = NotificationStatusType.denied
            }
        } else {
            // Allowed
            notificationStatus.value = NotificationStatusType.authorized
        }
    }
}
```

**This is not the end!** 
Sharp-eyed readers may have noticed the custom `UserDefaults` key "iOS9NotificationIsDetermined" in the check for iOS 9. What is it used for?

The main reason is that the method for checking push notification permissions on iOS 9 can only determine the current permissions based on what is available; if empty, it means no permission. However, if permission has not been asked, it will also be empty. This leads to the question: has the user not been asked, or have they been asked and clicked "Don't Allow"?

Here, I used a custom `UserDefaults` key `iOS9NotificationIsDetermined` as a toggle for judgment, and added the following in the `appDelegate`'s `didRegisterUserNotificationSettings`:
```swift
//appdelegate.swift:
func application(_ application: UIApplication, didRegister notificationSettings: UIUserNotificationSettings) {
    // For iOS 9 and below, this method is triggered after showing the prompt to allow notifications, regardless of whether the user clicks allow or deny
    UserDefaults.standard.set("iOS9NotificationIsDetermined", true)
    checkNotificationPermissionStatus()
}
```

**After constructing the notification permission status object and the checking method, we also need to add the following in the `appDelegate`:**
```swift
//appdelegate.swift
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {  
  checkNotificationPermissionStatus()
  return true
}
func applicationDidBecomeActive(_ application: UIApplication) {
  checkNotificationPermissionStatus()
}
```

The app should check the push notification status again when it is first launched and when returning from the background.

That covers the checking part. Next, let's see how to handle requesting notification permissions.
#### 3\. Request Notification Permission:
```swift
func requestNotificationPermission() {
    if #available(iOS 10.0, *) {
        let permissions: UNAuthorizationOptions = [.badge, .alert, .sound]
        UNUserNotificationCenter.current().requestAuthorization(options: permissions) { (granted, error) in
            DispatchQueue.main.async {
                checkNotificationPermissionStatus()
            }
        }
    } else {
        application.registerUserNotificationSettings(UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil))
        // The earlier appdelegate.swift's didRegisterUserNotificationSettings will handle the subsequent callback
    }
}
```

Both checking and requesting have been handled. Now let's see how to apply this.
#### 4\. Application \(Static\)
```php
if notificationStatus.value == NotificationStatusType.authorized {
    // OK!
} else if notificationStatus.value == NotificationStatusType.denied {
    // Not allowed
    // This example shows a UIAlertController prompt that, when clicked, can redirect to the settings page
    let alertController = UIAlertController(
        title: "Dear user, you are currently unable to receive notifications",
        message: "Please enable notification permissions for the app.",
        preferredStyle: .alert)
    let settingAction = UIAlertAction(
        title: "Go to Settings",
        style: .destructive,
        handler: {
            (action: UIAlertAction!) -> Void in
            if let bundleID = Bundle.main.bundleIdentifier, let url = URL(string: UIApplicationOpenSettingsURLString + bundleID) {
                UIApplication.shared.openURL(url)
            }
    })
    let okAction = UIAlertAction(
        title: "Cancel",
        style: .default,
        handler: {
            (action: UIAlertAction!) -> Void in
            // well....
    })
    alertController.addAction(okAction)
    alertController.addAction(settingAction)
    self.present(alertController, animated: true) {
        
    }
} else if notificationStatus.value == NotificationStatusType.notDetermined {
    // Not asked
    requestNotificationPermission()
}
```

> **Please note!! When navigating to the app's "Settings" page, do not use** 
> 
> `UIApplication.shared.openURL(URL(string:"App-Prefs:root=\\ \(bundleID\)")`
> 
> **to redirect, as it will lead to rejection! (personal experience)** 
> 
> **This is a Private API.**

#### 5\. Application \(Dynamic\)

For dynamically changing the status, since we are using `Observable` for the `notificationStatus` object, we can add a listener in `viewDidLoad` to monitor the status:
```swift
override func viewDidLoad() {
   super.viewDidLoad()
   notificationStatus.afterChange += { oldStatus, newStatus in
      if newStatus == NotificationStatusType.authorized {
       //print("â¤ï¸ Thank you for enabling notifications") 
      } else if newStatus == NotificationStatusType.denied {
       //print("ðŸ˜­ Oh no")
      }
   }
}
```

> The above is just sample code; actual application and triggers can be adjusted as needed.

> **\* When using `Observable` for `notificationStatus`, please pay attention to memory management. It should be released when necessary (to prevent memory leaks) and retained when it should not be released (to avoid losing the listener).**

### Finally, hereâ€™s the complete demo product:

![[Wedding App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}](/assets/fd7f92d52baa/1*_iVzlJLNQ7f0hO7IWxg1Zg.gif)

[Wedding App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}

_\* Since our project supports iOS 9 to iOS 12, we have not conducted any tests on iOS 8 and are unsure of the support level._

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/%E5%BE%9E-ios-9-%E5%88%B0-ios-12-%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5%E6%AC%8A%E9%99%90%E7%8B%80%E6%85%8B%E8%99%95%E7%90%86-swift-fd7f92d52baa){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._