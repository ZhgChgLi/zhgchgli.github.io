---
title: "Handling Push Notification Permission Status from iOS 9 to iOS 12 (Swift)"
author: "ZhgChgLi"
date: 2018-11-02T15:23:44.057+0000
last_modified_at: 2024-04-13T07:25:31.183+0000
categories: ["ZRealm Dev."]
tags: ["ios","push-notification","observables","ios-app-development","swift"]
description: "Solutions for handling notification permission status and requesting permissions for iOS 9 to iOS 12"
image:
  path: /assets/fd7f92d52baa/1*fm_hG0GuT-BhSNTEB3Ht1g.jpeg
render_with_liquid: false
---

### Handling Push Notification Permission Status from iOS 9 to iOS 12 \(Swift\)

Solutions for handling notification permission status and requesting permissions for iOS 9 to iOS 12

### What to Do?

Following up on the previous article "[What? iOS 12 Can Send Push Notifications Without User Authorization \(Swift\)](https://medium.com/@zhgchgli/%E4%BB%80%E9%BA%BC-ios-12-%E4%B8%8D%E9%9C%80%E4%BD%BF%E7%94%A8%E8%80%85%E6%8E%88%E6%AC%8A%E5%B0%B1%E8%83%BD%E6%94%B6%E5%88%B0%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5-swift-ade9e745a4bf?fbclid=IwAR1AKi3io4Jt-rFFgrLWEFsmA0lKYVFUD7Dw9n9LpMa2zAzJCHeGGGgn9Vs){:target="_blank"}" which discussed optimizing the process of obtaining push notification permissions, we encountered new requirements after the optimizations mentioned in the previous Murmur section:

![](/assets/fd7f92d52baa/1*fm_hG0GuT-BhSNTEB3Ht1g.jpeg)

1. If the user has disabled notifications, we should prompt them to enable it on specific feature pages.
2. After navigating to the settings page, if the user toggles notifications, the app should reflect this change upon returning.
3. If permission has not been requested, we should ask for it; if it has been requested but denied, we should show a prompt; if it has been requested and granted, the user can continue.
4. Support is required for both iOS 9 and iOS 12.

The first three points are manageable, as the UserNotifications framework introduced in iOS 10 can handle them well. The challenge lies in the fourth point, which requires support for iOS 9. Handling this with the older method `registerUserNotificationSettings` is not straightforward; let's tackle this step by step!

### Approach and Structure:

First, declare a global `notificationStatus` object to store the notification permission status and add property observers on the pages that need to handle it (I used [Observable](https://github.com/slazyk/Observable-Swift){:target="_blank"} for property change subscriptions, but you can use suitable KVO or Rx, ReactiveCocoa as needed).

In the `appDelegate`, handle checking the push notification permission status and updating the `notificationStatus` value in the following methods: `didFinishLaunchingWithOptions` (when the app is initially opened), `applicationDidBecomeActive` (when returning from the background), and `didRegisterUserNotificationSettings` (for push notification requests on iOS 9 and below). This will trigger the necessary handling on the relevant pages (e.g., showing a notification disabled prompt).

#### 1\. Declare the Global `notificationStatus` Object
```swift
enum NotificationStatusType {
     case authorized
     case denied
     case notDetermined
}
var notificationStatus: Observable<NotificationStatusType?> = Observable(nil)
```

The four states of `notificationStatus`/`NotificationStatusType` correspond to:
- nil = Object initialized… checking…
- notDetermined = User has not been asked whether to receive notifications
- authorized = User has been asked and clicked "Allow"
- denied = User has been asked and clicked "Don't Allow"

#### 2\. Build the Method to Check Notification Permission Status:
```swift
func checkNotificationPermissionStatus() {
    if #available(iOS 10.0, *) {
        UNUserNotificationCenter.current().getNotificationSettings { (settings) in
            DispatchQueue.main.async {
                // Note! Switch back to the main thread
                if settings.authorizationStatus == .authorized {
                    // Allowed
                    notificationStatus.value = NotificationStatusType.authorized
                } else if settings.authorizationStatus == .denied {
                    // Not allowed
                    notificationStatus.value = NotificationStatusType.denied
                } else {
                    // Not asked
                    notificationStatus.value = NotificationStatusType.notDetermined
                }
            }
        }
    } else {
        if UIApplication.shared.currentUserNotificationSettings?.types == []  {
            if let iOS9NotificationIsDetermined = UserDefaults.standard.object(forKey: "iOS9NotificationIsDetermined") as? Bool, iOS9NotificationIsDetermined == true {
                // Not asked
                notificationStatus.value = NotificationStatusType.notDetermined
            } else {
                // Not allowed
                notificationStatus.value = NotificationStatusType.denied
            }
        } else {
            // Allowed
            notificationStatus.value = NotificationStatusType.authorized
        }
    }
}
```

**But that's not all!** 
Sharp-eyed readers may have noticed the custom UserDefaults key "iOS9NotificationIsDetermined" in the checks for iOS 9. What is it used for?

The main reason is that the method for checking push notification permissions on iOS 9 can only determine the current permissions based on what is available. If it’s empty, it means there is no permission, but it can also be empty if the user has not been asked for permission. This creates a dilemma: did the user not ask, or did they ask and deny?

Here, I used a custom UserDefaults key `iOS9NotificationIsDetermined` as a toggle for judgment, and added it in the `didRegisterUserNotificationSettings` method in `appDelegate`:
```swift
//appdelegate.swift:
func application(_ application: UIApplication, didRegister notificationSettings: UIUserNotificationSettings) {
    // For iOS 9 and below, this method is triggered after the prompt asking whether to allow notifications is shown, regardless of whether the user clicks allow or deny
    UserDefaults.standard.set("iOS9NotificationIsDetermined", true)
    checkNotificationPermissionStatus()
}
```

**After constructing the notification permission status object and the checking method, we also need to add the following in `appDelegate`:**
```swift
//appdelegate.swift
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {  
  checkNotificationPermissionStatus()
  return true
}
func applicationDidBecomeActive(_ application: UIApplication) {
  checkNotificationPermissionStatus()
}
```

The app should check the push notification status again when it starts and when returning from the background.

That's the checking part. Next, let's see how to handle requesting notification permissions.
#### 3\. Request Notification Permission:
```swift
func requestNotificationPermission() {
    if #available(iOS 10.0, *) {
        let permissions: UNAuthorizationOptions = [.badge, .alert, .sound]
        UNUserNotificationCenter.current().requestAuthorization(options: permissions) { (granted, error) in
            DispatchQueue.main.async {
                checkNotificationPermissionStatus()
            }
        }
    } else {
        application.registerUserNotificationSettings(UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil))
        // The didRegisterUserNotificationSettings in appdelegate.swift will handle the subsequent callback
    }
}
```

The checks and requests are all handled; now let's see how to apply this.
#### 4\. Application \(Static\)
```php
if notificationStatus.value == NotificationStatusType.authorized {
    // OK!
} else if notificationStatus.value == NotificationStatusType.denied {
    // Not allowed
    // Here, the example shows a UIAlertController prompt, and upon clicking, it can redirect to the settings page
    let alertController = UIAlertController(
        title: "Dear user, you are currently unable to receive notifications",
        message: "Please enable notification permissions for the app.",
        preferredStyle: .alert)
    let settingAction = UIAlertAction(
        title: "Go to Settings",
        style: .destructive,
        handler: {
            (action: UIAlertAction!) -> Void in
            if let bundleID = Bundle.main.bundleIdentifier, let url = URL(string: UIApplicationOpenSettingsURLString + bundleID) {
                UIApplication.shared.openURL(url)
            }
    })
    let okAction = UIAlertAction(
        title: "Cancel",
        style: .default,
        handler: {
            (action: UIAlertAction!) -> Void in
            // well....
    })
    alertController.addAction(okAction)
    alertController.addAction(settingAction)
    self.present(alertController, animated: true) {
        
    }
} else if notificationStatus.value == NotificationStatusType.notDetermined {
    // Not asked
    requestNotificationPermission()
}
```

> **Please note!! When navigating to the app's "Settings" page, do not use** 
> 
> `UIApplication.shared.openURL(URL(string:"App-Prefs:root=\(bundleID)")`
> 
> **This method will lead to rejection! It will lead to rejection! It will lead to rejection! (From personal experience)** 
> 
> **This is a Private API**

#### 5\. Application \(Dynamic\)

For dynamically changing the status, since we are using `Observable` for the `notificationStatus` object, we can add a listener in `viewDidLoad` to monitor the status:
```swift
override func viewDidLoad() {
   super.viewDidLoad()
   notificationStatus.afterChange += { oldStatus, newStatus in
      if newStatus == NotificationStatusType.authorized {
       //print("❤️ Thank you for enabling notifications") 
      } else if newStatus == NotificationStatusType.denied {
       //print("😭 Oh no")
      }
   }
}
```

> The above is just sample code; actual application and triggers can be adjusted as needed.

> **\* When using Observable for `notificationStatus`, please pay attention to memory management. It should be released when no longer needed (to prevent memory leaks), and retained when it should not be released (to avoid losing the listener).**

### Finally, here’s the complete demo product:

![[Marriage App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}](/assets/fd7f92d52baa/1*_iVzlJLNQ7f0hO7IWxg1Zg.gif)

[Marriage App](https://itunes.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E4%B8%8D%E6%89%BE%E6%9C%80%E8%B2%B4-%E5%8F%AA%E6%89%BE%E6%9C%80%E5%B0%8D/id1356057329?ls=1&mt=8){:target="_blank"}

_\* Since our project supports iOS 9 to iOS 12, we have not conducted any tests on iOS 8 and are unsure of the support level._

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/%E5%BE%9E-ios-9-%E5%88%B0-ios-12-%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5%E6%AC%8A%E9%99%90%E7%8B%80%E6%85%8B%E8%99%95%E7%90%86-swift-fd7f92d52baa){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._