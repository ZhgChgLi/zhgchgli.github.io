---
author: ZhgChgLi
categories:
- ZRealm Development
date: 2021-03-23T17:09:34.747+0000
description: Developers facing challenges in push notification analytics can leverage
  Firebase Firestore and Functions to rapidly build and test scalable API services,
  boosting development efficiency and data accuracy.
image:
  path: /assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg
last_modified_at: 2024-04-13T16:34:17.362+0000
render_with_liquid: false
tags:
- iOS App Development
- Firebase
- Google Cloud Platform
- Notifications
- iOS
title: Firebase Firestore + Functions｜Build Testable API Services Fast for Push Notification
  Analytics
---

### Quickly Build a Testable API Service Using Firebase Firestore + Functions

When Push Notification Statistics Meet Firebase Firestore + Functions

![Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg)

Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}

### Preface

#### Precise Push Notification Statistics Function

Recently, we wanted to add a feature to the app. Before implementation, we could only use the success or failure of sending data from the backend to APNS/FCM as the push notification base and record push notification clicks to calculate the "click-through rate." However, this method is very inaccurate because the base includes many invalid devices, such as deleted apps (which may not become invalid immediately) and devices with push permissions turned off, all of which still return a success response when posting from the backend.

After iOS 10, you can implement a Notification Service Extension to secretly call an API for statistics when the push notification banner appears. The advantage is high accuracy, as the call only happens when the user actually sees the notification banner. If the app is deleted, notifications are turned off, or banners are disabled, no action occurs. The banner appearance equals a push notification shown, which serves as the base for calculating an accurate click-through rate by comparing it with the number of clicks.

> *For detailed principles and implementation methods, please refer to the previous article: "[i **OS ≥ 10 Notification Service Extension Application (Swift)**](../cb6eba52a342/)"*

> *Currently, testing shows the app's loss rate is likely 0%. A common real-world example is Line's point-to-point message encryption (push notifications are encrypted and only decrypted on the phone before display).*

#### Question

The app side's workload is actually not that big. Both iOS and Android only need to implement similar functions (but Android is more complicated if targeting the Chinese market, as it requires implementing push notification frameworks for multiple platforms). The bigger challenge lies in backend and server load handling, because sending push notifications simultaneously calls APIs to log records, which can max out the server’s max connections. This issue is even worse if using RDBMS to store records. If there is data loss in statistics, it usually happens at this stage.

> *Here, you can record logs by writing to files and display statistics when querying.*

> *Also, thinking later about the scenario of going out and coming back at the same time, the volume might not be as large as imagined; because push notifications are not sent all at once in hundreds of thousands or millions, but in batches of a few at a time; as long as it can handle the number of requests sent and received in batches simultaneously!*

### Prototype

Due to the issues considered earlier, the backend requires significant effort to research and modify, and the market may not necessarily care about the results; so we decided to first use available resources to create a prototype to test the waters.

Here, we chose Firebase services commonly used by apps, including Functions and Firestore features.

#### Firebase Functions

[Functions](https://developers.google.com/learn/topics/functions){:target="_blank"} is a serverless service provided by Google. You only need to write the program logic, and Google automatically handles the servers and runtime environment, so you don't have to worry about server scaling or traffic issues.

[Firebase Functions](https://firebase.google.com/docs/functions){:target="_blank"} are actually Google Cloud Functions but can only be written in JavaScript (node.js). I haven't tried it, but if you use Google Cloud Functions with other languages and also import Firebase services, I think it should work as well.

Used in an API, it means I can write a node.js file to get a physical URL (e.g., my-project.cloudfunctions.net/getUser) and implement the logic to obtain Request information and provide the corresponding Response.

> *Previously wrote an article about Google Functions: "[Using Python + Google Cloud Platform + Line Bot to Automate Routine Tasks](../70a1409b149a/)"*

> *Firebase Functions require enabling a Blaze project (pay as you go) to use.*

![](/assets/9659db1357e4/1*YqIJ1tr2Ay-oLVjSSU0zUg.png)

#### Firebase Firestore

[Firebase Firestore](https://firebase.google.com/docs/firestore){:target="_blank"} is a NoSql database used to store and manage data.

By integrating Firebase Functions, you can import Firestore during the request to operate the database, then respond to the user, enabling the creation of a simple Restful API service!

> Let's start hands-on practice!

### Installing Node.js Environment

It is recommended to use NVM, a Node.js version management tool, for installation and management (similar to using pyenv for Python).

Go to the NVM Github project and copy the installation shell script:

[![](https://repository-images.githubusercontent.com/612230/53a0c44a-1f6e-4f8d-918f-89762fafe369)](https://github.com/nvm-sh/nvm#installing-and-updating){:target="_blank"}

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh \| bash
```

If an error occurs during installation, please make sure you have a `~/.bashrc` or `~/.zshrc` file. If not, create one using `touch ~/.bashrc` or `touch ~/.zshrc`, then run the install script again.

Next, you can use `nvm install node` to install the latest version of node.js.

![](/assets/9659db1357e4/1*5fxz4HD9q4feAqO0zXbojg.png)

You can run `npm --version` to verify that npm is installed successfully and check its version:

![](/assets/9659db1357e4/1*VHZMRFIDzFA9AxmsDNqNlA.png)

### Deploy Firebase Functions

#### Install Firebase-tools:

```bash
npm install -g firebase-tools
```

![](/assets/9659db1357e4/1*POfMR0p1600iYqy8rzQkTQ.png)

After successful installation, please enter the following for first-time use:

```bash
firebase login
```

![](/assets/9659db1357e4/1*kqeECyXVPOq1cpKvcdOBeA.png)

Complete Firebase login authentication.

Start Project:

```bash
firebase init
```

![](/assets/9659db1357e4/1*Xx2grpX2PZb3wEFt9mQbNw.png)

Note the path where Firebase init is located:

```
You're about to initialize a Firebase project in this directory:
```

Here you can choose which Firebase CLI tools to install. Use the "↑" and "↓" keys to navigate and the "spacebar" to select; you can choose to install only "Functions" or select "Firestore" as well.

**=== Functions Setup**

![](/assets/9659db1357e4/1*2gd9pAIdLAkJRhROpJtPKA.png)

- Language Selection: "**JavaScript**"

- Regarding "use ESLint to catch probable bugs and enforce style" syntax style checking, **YES / NO both are acceptable**.

- install dependencies with npm? **YES**

**===Emulators Setup**

![](/assets/9659db1357e4/1*xHWp195BZIZdXyUd-ub78g.png)

You can test Functions and Firestore features and settings locally without affecting usage limits and without waiting for deployment to go live.

> *Install according to personal needs. I installed it but didn't use it... because it's just a minor feature.*

### Coding!

Go to the path noted above, find the `functions` folder, and open the `index.js` file inside with an editor.

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
admin.initializeApp();

exports.hello = functions.https.onRequest((req, res) => {
    const targetID = req.query.targetID
    const action = req.body.action
    const name = req.body.name

    res.send({"targetID": targetID, "action": action, "name": name});
    return
})
```

Paste the above content. We defined a route interface `/hello` that returns URL **Query** `?targetID=`, **POST** `action`, and `name` parameter information.

After editing & saving, return to the console:

```bash
firebase deploy
```

> ***Remember to run the `firebase deploy` command after every modification for the changes to take effect.***

Start verification & deploy to Firebase…

![](/assets/9659db1357e4/1*hUdvD4ANKD3s73mLWNZZOQ.png)

You might need to wait a moment. After `Deploy complete!`, your first Request & Response webpage will be ready!

At this point, you can return to the Firebase -> Functions page:

![](/assets/9659db1357e4/1*SY4iJZL6gDEZ5AEcepIpMA.png)

You will see the interface and URL location just written.

Copy the URL below and paste it into PostMan to test:

![](/assets/9659db1357e4/1*OMfLkdg12QHsp-yc9RkKvA.png)

> *Remember to select `x-www-form-urlencoded` for the POST Body.*

**Success!**

### Log

We can use in the code:

```javascript
functions.logger.log("log:", value);
```

Perform log recording.

You can view the log results in Firebase -> Functions -> Logs:

![](/assets/9659db1357e4/1*Wi-4MbPh2tVJ_utdhzN4_A.png)

### Example Goal

> Create an API for adding, updating, deleting, querying articles, and liking posts

We aim to achieve the functionality design of a Restful API, so we can no longer use the pure Path method from the example above. Instead, we need to use the `Express` framework to accomplish this.

#### POST Add New Article

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Insert
app.post('/', async (req, res) => { // The POST here refers to the HTTP Method POST
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null \|\| content == null \|\| author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"Added successfully!"});
});

exports.post= functions.https.onRequest(app); // The POST here refers to the /post path
```

Now we switch to using Express to handle network requests. Here, we first add a POST method for the `/` path. The last line indicates that all paths are under `/post`. Next, we will add APIs for update and delete.

After successfully deploying with `firebase deploy`, return to Post Man to test:

![](/assets/9659db1357e4/1*yVAjhlr6wLdONeG7nY0VEw.png)

After a successful Postman request, you can check Firebase -> Firestore to verify if the data has been correctly written:

![](/assets/9659db1357e4/1*xYVrRdFro3bQVHx05JUaTw.png)

#### PUT Edit Article

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Update
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"}); 
    } else if (title == null \|\| content == null \|\| author == null) {
        return res.status(400).send({"message":"Invalid parameters!"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"Update successful!"});
});

exports.post= functions.https.onRequest(app);
```

Deployment & testing method is the same as adding; remember to change the Post Man HTTP method to `PUT`.

#### DELETE Delete Article

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Delete
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Post not found!"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"Post deleted successfully!"});
})

exports.post= functions.https.onRequest(app);
```

Deployment & testing method is the same as adding; remember to change the Post Man HTTP Method to `DELETE`.

Add, modify, and delete are done, now let's do the query!

#### SELECT Query Articles

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Select List
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// Select One
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

exports.post= functions.https.onRequest(app);
```

![](/assets/9659db1357e4/1*n_mI4l1EmhpWK8M_FbrzbQ.png)

Deployment & testing method is the same as adding. Remember to change the Post Man HTTP Method to `GET` and switch the `Body` back to `none`.

#### InsertOrUpdate?

Sometimes we need to update when a value exists and add when it doesn't. In this case, we can use `set` with `merge: true`:

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// InsertOrUpdate
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"Successfully added!"});
});

exports.post= functions.https.onRequest(app);
```

Here, using adding a tag as an example, the deployment & testing method is the same as adding. You can see that Firestore does not repeatedly add new data.

![](/assets/9659db1357e4/1*qkTMGjC0EkrMO85-6pQFwg.png)

#### Article Like Counter

Assuming our article data now includes a `likeCount` field to record the number of likes, how should we proceed?

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Like Post
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Post not found!"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"Like successful!"});
});

exports.post= functions.https.onRequest(app);
```

Using the `increment` variable allows you to directly perform the action of retrieving the value and adding 1.

#### High Traffic Article Like Counter

Because Firestore has [write speed limits](https://cloud.google.com/firestore/quotas?hl=zh-tw#soft_limits){:target="_blank"}:

![](/assets/9659db1357e4/1*U9ubGe3M8XEdx9XGAV8nfA.png)

**A document can only be written once per second**, so when there are many likes, simultaneous requests may become very slow.

The official solution "[Distributed counters](https://cloud.google.com/firestore/docs/solutions/counters#node.js_2){:target="_blank"}" is not very complex technically. It simply uses multiple distributed likeCount fields to count, then sums them up when reading.

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Distributed counters Like Post
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Post not found!"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"Like successful!"});
});


exports.post= functions.https.onRequest(app);
```

![](/assets/9659db1357e4/1*GhNEcWUjgvYRYCMBk1DayA.png)

The above method distributes fields to record the Count, avoiding slow writes; however, having too many distributed fields increases read costs ($$), but it should still be cheaper than adding a new record each time a like is made.

#### Using the Siege Tool for Stress Testing

Install `siege` using `brew`

```bash
brew install siege
```

*p.s If you get brew: command not found, please install the [brew](https://brew.sh/index_zh-tw){:target="_blank"} package manager first*:

```bash
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
```

After installation, you can run:

```bash
siege -c 100 -r 1 -H 'Content-Type: application/json' 'https://us-central1-project.cloudfunctions.net/post/like/id POST {}'
```

Perform stress testing:

- `-c 100` ：100 tasks running concurrently

- `-r 1` ：Execute 1 request per task run

- `-H ‘Content-Type: application/json’` ：Add this when using POST requests

- `‘https://us-central1-project.cloudfunctions.net/post/like/id POST {}’` ：POST URL, Post Body (ex: `{“name”:”1234”}` )

After execution, you can see the results:

![](/assets/9659db1357e4/1*BUcMfJJ4x_mgK0HHLc6C4g.png)

`successful_transactions: 100` means 100 transactions were all successful.

**You can check Firebase -> Firestore to see if there is any Loss Data:**

![](/assets/9659db1357e4/1*wd5z743Zp9xtjKhhcMaVOg.png)

> Success!

#### Complete Example Code

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Insert
app.post('/', async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null \|\| content == null \|\| author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"Added successfully!"});
});

// Update
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Post not found!"}); 
    } else if (title == null \|\| content == null \|\| author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"Updated successfully!"});
});

// Delete
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Post not found!"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"Deleted successfully!"});
});

// Select List
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// Select One
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Post not found!"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

// InsertOrUpdate
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"Added successfully!"});
});

// Like Post
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Post not found!"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"Like successful!"});
});

// Distributed counters Like Post
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Post not found!"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"Like successful!"});
});


exports.post= functions.https.onRequest(app);
```

### Back to the topic, push notification statistics

Back to what we initially wanted to do: push notification statistics.

index.js:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

const vaildPlatformTypes = ["iOS","Android"]
const vaildActionTypes = ["clicked","received"]

// Insert Log
app.post('/', async (req, res) => {
    const increment = admin.firestore.FieldValue.increment(1);
    const platformType = req.body.platformType;
    const pushID = req.body.pushID;
    const actionType =  req.body.actionType;

    if (!vaildPlatformTypes.includes(platformType) \|\| pushID == undefined \|\| !vaildActionTypes.includes(actionType)) {
        return res.status(400).send({"message":"Parameter error!"});
    } else {
        await admin.firestore().collection(platformType).doc(actionType+"_"+pushID).collection("shards").doc((Math.floor(Math.random()*10)+1).toString())
        .set({count: increment}, {merge: true})
        res.status(201).send({"message":"Record successful!"});
    }
});

// View Log
app.get('/:type/:id', async (req, res) => {
    // received
    const receivedDocs = await admin.firestore().collection(req.params.type).doc("received_"+req.params.id).collection("shards").get();
    var received = 0;
    receivedDocs.forEach(doc => {
      received += doc.data().count;
    });

    // clicked
    const clickedDocs = await admin.firestore().collection(req.params.type).doc("clicked_"+req.params.id).collection("shards").get();
    var clicked = 0;
    clickedDocs.forEach(doc => {
        clicked += doc.data().count;
    });
    
    res.status(200).send({"received":received,"clicked":clicked});
});

exports.notification = functions.https.onRequest(app);
```

#### Add Push Notification Record

![](/assets/9659db1357e4/1*3koe6QBxF9oOhBDqjF5mhA.png)

#### View Push Notification Statistics

```
https://us-centra1-xxx.cloudfunctions.net/notification/iOS/1
```

![](/assets/9659db1357e4/1*SStEkNoDjiL7pffC2pHDkQ.png)

Also created an interface to track push notification statistics.

#### Pitfalls

> *Because I was not very familiar with node.js usage, at first when adding data I forgot to add `await`. Combined with write speed limits, this caused data loss under high traffic conditions…*

![](/assets/9659db1357e4/1*dVsBhKJQ3qqxlSvv-mCENA.png)

### Pricing

Don't forget to refer to the pricing strategies of Firebase Functions & Firestore.

#### Functions

- <https://cloud.google.com/functions/pricing?hl=zh-tw>{:target="_blank"}

![](/assets/9659db1357e4/1*76yRqeDyrp0kFmGHN4ZNXg.png)

![Computation Time](/assets/9659db1357e4/1*G_At8v80BQl81EUqPuUIbQ.png)

Processing Time

![Network](/assets/9659db1357e4/1*iXk7oKFidHfzRVwrDvKX0A.png)

Internet

> *Cloud Functions offers a permanent free tier for compute time resources, including GB-seconds and GHz-seconds of compute time. Besides 2 million invocations, the free tier also provides 400,000 GB-seconds and 200,000 GHz-seconds of compute time, along with 5 GB of internet egress per month.*

#### Firestore

- <https://cloud.google.com/firestore/pricing?hl=zh-tw>{:target="_blank"}

![](/assets/9659db1357e4/1*ylduiqevk4WH-eNc8EOpvQ.png)

- [Calculation Example](https://cloud.google.com/firestore/docs/billing-example?hl=zh-tw){:target="_blank"}

> ***Prices may change at any time. Please refer to the official website for the latest information.***

### Conclusion

As stated in the title, "For Testing Purposes," "For Testing Purposes," "For Testing Purposes," it is not recommended to use the above services in a production environment or as the core of a product launch.

#### Expensive and Hard to Migrate

I once heard that a fairly large service was built using Firebase. However, as data and traffic grew, the costs skyrocketed. Migrating was also very difficult; the code was manageable, but moving the data was extremely hard. It can only be said that saving a little money early on led to huge losses later, which was not worth it.

#### For Testing Only

For the above reasons, I personally recommend using Firebase Functions + Firestore API services only for testing or prototype product demonstrations.

#### More Features

Functions can also integrate Authentication and Storage (file upload), but I haven't explored these parts.

### References

- <https://firebase.google.com/docs/firestore/query-data/queries>{:target="_blank"}

- <https://coder.tw/?p=7198>{:target="_blank"}

- <https://firebase.google.com/docs/firestore/solutions/counters#node.js_1>{:target="_blank"}

- <https://javascript.plainenglish.io/firebase-cloud-functions-tutorial-creating-a-rest-api-8cbc51479f80>{:target="_blank"}

### Further Reading

- [Automate Routine Tasks with Python + Google Cloud Platform + Line Bot](../70a1409b149a/)

- [i **OS ≥ 10 Notification Service Extension Application (Swift)**](../cb6eba52a342/)

- [Forward Gmail Emails to Slack Using Google Apps Script](../d414bdbdb8c9/)

If you have any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

*[Post](https://medium.com/zrealm-ios-dev/%E4%BD%BF%E7%94%A8-firebase-firestore-functions-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8F%AF%E4%BE%9B%E6%B8%AC%E8%A9%A6%E7%9A%84-api-%E6%9C%8D%E5%8B%99-9659db1357e4){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*