---
title: "Quickly Build a Testable API Service Using Firebase Firestore + Functions"
author: "ZhgChgLi"
date: 2021-03-23T17:09:34.747+0000
last_modified_at: 2024-04-13T16:34:17.362+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","firebase","google-cloud-platform","notifications","ios"]
description: "When push notification statistics meet Firebase Firestore + Functions"
image:
  path: /assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg
render_with_liquid: false
---

### Quickly Build a Testable API Service Using Firebase Firestore + Functions

When push notification statistics meet Firebase Firestore + Functions



![Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg)

Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Introduction
#### Accurate Push Notification Statistics

Recently, I wanted to implement a feature for the app. Before implementation, we could only rely on the success or failure of posting data to APNS/FCM from the backend as the basis for push notifications and record clicks to calculate the "click-through rate"; however, this method is actually very inaccurate, as the base includes many invalid devices, such as those where the app has been deleted (which may not immediately become inactive) or where push notification permissions have been turned off, all of which still receive successful responses during backend posting.

Since iOS 10, we can use the Notification Service Extension to secretly call an API for statistics when the push notification banner appears; the advantage is that it is very accurate, as it only calls when the user sees the push notification banner. If the app is deleted, notifications are turned off, or the banner does not appear, there will be no action. The appearance of the banner indicates that the push message has been displayed, and using this as the basis for push notifications, along with the click count, allows us to obtain an "accurate click-through rate."


> _For detailed principles and implementation methods, please refer to the previous article: "[i **OS ≥ 10 Notification Service Extension Application (Swift)**](../cb6eba52a342/)"_ 





> _Currently, testing shows that the app's loss rate should be 0%. A common application, like Line's point-to-point message encryption and decryption (the push message is encrypted and only decrypted when the phone receives it, then displayed)._ 




#### Issues

The workload on the app side is actually not significant; both iOS and Android only need to implement similar functionalities (but for Android, if considering the Chinese market, it becomes more complicated, as a push notification framework needs to be implemented for each platform). The larger workload is on the backend, which has to handle server pressure, as sending a push notification will simultaneously call the API to return records, which may overwhelm the server's max connections. If using RDBMS to store records, it could be even more severe. If there is a loss in the statistics, it often occurs at this stage.


> _Here, logging to a file can be used for record-keeping, and statistics can be generated when needed._ 





> _Additionally, upon further reflection, the simultaneous return scenario may not be as large as imagined; since push notifications are not sent all at once in bulk, but rather in smaller batches. As long as the system can handle the number of records sent out in batches and returned simultaneously, it should be sufficient!_ 




### Prototype

Due to the considerations mentioned in the issues, the backend needs to invest effort in research and modification, and the market may not necessarily care about the effectiveness of the implementation; therefore, I thought it would be best to create a prototype using available resources to test the waters.

Here, I chose Firebase services, which are commonly used by apps, specifically the Functions and Firestore features.
#### Firebase Functions

[Functions](https://developers.google.com/learn/topics/functions){:target="_blank"} is a serverless service provided by Google, where you only need to write the program logic, and Google automatically manages the server and execution environment for you, without worrying about server scaling and traffic issues.


[Firebase Functions](https://firebase.google.com/docs/functions){:target="_blank"} is essentially Google Cloud Functions but can only be written in JavaScript (node.js). I haven't tried it, but I think if you choose to write in another language using Google Cloud Functions and also import Firebase services, it should work as well.

For APIs, I can write a node.js file to get a physical URL (e.g., my-project.cloudfunctions.net/getUser), and then write the logic to obtain Request information and provide the corresponding Response.

> _I previously wrote an article about Google Functions titled " [Using Python + Google Cloud Platform + Line Bot to Automate Routine Tasks](../70a1409b149a/) "_

> _Firebase Functions must be enabled in a Blaze project (pay as you go) to be used._

![](/assets/9659db1357e4/1*YqIJ1tr2Ay-oLVjSSU0zUg.png)

#### Firebase Firestore

[Firebase Firestore](https://firebase.google.com/docs/firestore){:target="_blank"} is a NoSQL database used to store and manage data.

By combining Firebase Functions, you can import Firestore during a Request to operate the database and then respond to the user, allowing you to build a simple Restful API service!

> Let's get started with hands-on practice!

### Install node.js Environment

It is recommended to use NVM, a node.js version management tool for installation and management (similar to how Python uses pyenv).

Copy the installation shell script from the NVM GitHub project:

[![](https://repository-images.githubusercontent.com/612230/53a0c44a-1f6e-4f8d-918f-89762fafe369)](https://github.com/nvm-sh/nvm#installing-and-updating){:target="_blank"}

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash
```

If there are errors during the installation process, please ensure that you have a `~/.bashrc` or `~/.zshrc` file. If not, you can create one using `touch ~/.bashrc` or `touch ~/.zshrc` and then run the install script again.

Then you can use `nvm install node` to install the latest version of node.js.

![](/assets/9659db1357e4/1*5fxz4HD9q4feAqO0zXbojg.png)

You can run `npm --version` to confirm that npm has been successfully installed and check the installed version:

![](/assets/9659db1357e4/1*VHZMRFIDzFA9AxmsDNqNlA.png)

### Deploy Firebase Functions
#### Install Firebase-tools:
```bash
npm install -g firebase-tools
```

![](/assets/9659db1357e4/1*POfMR0p1600iYqy8rzQkTQ.png)

After successful installation, please log in for the first time by entering:
```bash
firebase login
```

![](/assets/9659db1357e4/1*kqeECyXVPOq1cpKvcdOBeA.png)

Complete the Firebase login verification.

Initialize the project:
```bash
firebase init
```

![](/assets/9659db1357e4/1*Xx2grpX2PZb3wEFt9mQbNw.png)

Note the path where Firebase init is located:
```
You're about to initialize a Firebase project in this directory:
```

Here you can choose which Firebase CLI tools to install. Use the "↑" and "↓" keys to navigate and the "spacebar" to select; you can choose to install only "Functions" or select "Firestore" as well.

```markdown
**=== Functions Setup**


![](/assets/9659db1357e4/1*2gd9pAIdLAkJRhROpJtPKA.png)

- Language selection: **JavaScript**
- Regarding "use ESLint to catch probable bugs and enforce style" syntax style check, **YES / NO are both acceptable**.
- Install dependencies with npm? **YES**


**===Emulators Setup**


![](/assets/9659db1357e4/1*xHWp195BZIZdXyUd-ub78g.png)


You can test Functions and Firestore features and settings in the local environment, which will not count towards usage and does not require waiting for deployment to test.


> _Install as per personal needs; I have it installed but not used... because it's just a small feature._ 




### Coding\!

Go to the path noted above, find the `functions folder`, and open the `index.js` file with an editor.

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
admin.initializeApp();

exports.hello = functions.https.onRequest((req, res) => {
    const targetID = req.query.targetID
    const action = req.body.action
    const name = req.body.name

    res.send({"targetID": targetID, "action": action, "name": name});
    return
})
```

Paste the above content; we define a path interface `/hello` that will return URL **Query** `?targetID=`, **POST** `action`, and `name` parameter information.

After modifying and saving, return to the console:
```bash
firebase deploy
```


> **_Remember to run the `firebase deploy` command after each modification for it to take effect._** 





Start validating & deploying to Firebase…


![](/assets/9659db1357e4/1*hUdvD4ANKD3s73mLWNZZOQ.png)


You may need to wait a moment; after `Deploy complete!`, your first Request & Response webpage is complete!

At this point, you can return to the Firebase -> Functions page:


![](/assets/9659db1357e4/1*SY4iJZL6gDEZ5AEcepIpMA.png)


You will see the interface and URL location you just wrote.

Copy the URL below and paste it into PostMan for testing:


![](/assets/9659db1357e4/1*OMfLkdg12QHsp-yc9RkKvA.png)



> _Remember to select `x-www-form-urlencoded` for the POST Body._ 





**Success!**
### Log

We can use in the code:
```javascript
functions.logger.log("log:", value);
```

To perform log recording.

And you can view the log results in Firebase -> Functions -> Logs:


![](/assets/9659db1357e4/1*Wi-4MbPh2tVJ_utdhzN4_A.png)

### Example Goal


> Create an API that can add, modify, delete, query articles, and like them.




We hope to achieve the functionality design of a Restful API, so we cannot use the pure Path method from the above example; we need to switch to using the `Express` framework to achieve this.
#### POST Add Article

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Insert
app.post('/', async (req, res) => { // The POST here refers to the HTTP Method POST
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null || content == null || author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"Added successfully!"});
});

exports.post= functions.https.onRequest(app); // The POST here refers to the /post path
```


Now we will use Express to handle network requests. First, let's add a POST method for the path `/`, with the last line indicating that the path is under `/post`. Next, we will add APIs for updating and deleting.

After successfully deploying with `firebase deploy`, return to Postman for testing:


![](/assets/9659db1357e4/1*yVAjhlr6wLdONeG7nY0VEw.png)


After successfully posting in Postman, you can check Firebase -> Firestore to see if the data has been written correctly:


![](/assets/9659db1357e4/1*xYVrRdFro3bQVHx05JUaTw.png)

#### PUT Update Article

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Update
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"}); 
    } else if (title == null || content == null || author == null) {
        return res.status(400).send({"message":"Invalid parameters!"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"Update successful!"});
});

exports.post= functions.https.onRequest(app);
```

The deployment and testing method is the same as adding, remember to change the Postman HTTP Method to `PUT`.
#### DELETE Delete Article

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Delete
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"Article deleted successfully!"});
})

exports.post= functions.https.onRequest(app);
```

The deployment and testing method is the same as adding, remember to change the Postman HTTP Method to `DELETE`.


The addition, modification, and deletion are complete; let's proceed with the query!
#### SELECT Query Articles

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Select List
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// Select One
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

exports.post= functions.https.onRequest(app);
```


![](/assets/9659db1357e4/1*n_mI4l1EmhpWK8M_FbrzbQ.png)


The deployment and testing methods are the same as for addition; remember to change the Post Man HTTP Method to `GET` and set the `Body` back to `none`.
#### InsertOrUpdate?

Sometimes we need to update when a value exists and add when a value does not exist. In this case, we can use `set` with `merge: true`:

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// InsertOrUpdate
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"Successfully added!"});
});

exports.post= functions.https.onRequest(app);
```

Here, we take adding a tag as an example. The deployment and testing methods are the same as for addition, and you can see that Firestore will not repeatedly add new data.


![](/assets/9659db1357e4/1*qkTMGjC0EkrMO85-6pQFwg.png)

#### Article Like Counter

Suppose our article data now has an additional `likeCount` field to record the number of likes; what should we do?

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Like Post
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"Liked successfully!"});
});

exports.post= functions.https.onRequest(app);
```

```markdown
Using the `increment` variable allows you to directly perform the action of retrieving the value and adding +1.
#### High Traffic Article Like Counter

Due to Firestore's [write speed limits](https://cloud.google.com/firestore/quotas?hl=en#soft_limits){:target="_blank"}:

![](/assets/9659db1357e4/1*U9ubGe3M8XEdx9XGAV8nfA.png)

**A document can only be written to once per second**, so when there are many people liking the post, simultaneous requests may become very slow.

The official solution, "[Distributed counters](https://cloud.google.com/firestore/docs/solutions/counters#node.js_2){:target="_blank"}," is not particularly complex; it simply involves using several distributed likeCount fields for counting, and then summing them up when reading.

index.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Distributed counters Like Post
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"Like successful!"});
});


exports.post= functions.https.onRequest(app);
```

![](/assets/9659db1357e4/1*GhNEcWUjgvYRYCMBk1DayA.png)

This is how to distribute fields to record counts to avoid slow writes; however, if there are too many distributed fields, it will increase the reading cost ($$), but it should still be cheaper than adding a new record every time someone likes.
#### Using Siege Tool for Stress Testing

Install `siege` using `brew`
```bash
brew install siege
```

_p.s If you encounter brew: command not found, please first install the [brew](https://brew.sh/index_en){:target="_blank"} package management tool_:
```bash
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
```

After installation, you can run:
```bash
siege -c 100 -r 1 -H 'Content-Type: application/json' 'https://us-central1-project.cloudfunctions.net/post/like/id POST {}'
```

Conducting stress tests:
- `-c 100`: 100 tasks executing simultaneously
- `-r 1`: each task executes 1 request
- `-H ‘Content-Type: application/json’`: required for POST requests
- `‘https://us-central1-project.cloudfunctions.net/post/like/id POST {}’`: POST URL, Post Body (ex: `{“name”:”1234”}`)
```

Here is the translated text:

---

After execution, you can see the results:

![](/assets/9659db1357e4/1*BUcMfJJ4x_mgK0HHLc6C4g.png)

`successful_transactions: 100` indicates that all 100 executions were successful.

**You can check Firebase -> Firestore to see if there is any Loss Data:**

![](/assets/9659db1357e4/1*wd5z743Zp9xtjKhhcMaVOg.png)

> Success!

#### Complete Example Code

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Insert
app.post('/', async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null || content == null || author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"Successfully added!"});
});

// Update
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"}); 
    } else if (title == null || content == null || author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"Successfully modified!"});
});

// Delete
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"Article deleted successfully!"});
});

// Select List
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// Select One
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

// InsertOrUpdate
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"Successfully added!"});
});

// Like Post
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"Liked successfully!"});
});

// Distributed counters Like Post
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"Liked successfully!"});
});

exports.post= functions.https.onRequest(app);
```
### Returning to the topic, push notification statistics


Returning to what we initially wanted to do, the push notification statistics feature.

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

const vaildPlatformTypes = ["iOS","Android"]
const vaildActionTypes = ["clicked","received"]

// Insert Log
app.post('/', async (req, res) => {
    const increment = admin.firestore.FieldValue.increment(1);
    const platformType = req.body.platformType;
    const pushID = req.body.pushID;
    const actionType =  req.body.actionType;

    if (!vaildPlatformTypes.includes(platformType) || pushID == undefined || !vaildActionTypes.includes(actionType)) {
        return res.status(400).send({"message":"Parameter error!"});
    } else {
        await admin.firestore().collection(platformType).doc(actionType+"_"+pushID).collection("shards").doc((Math.floor(Math.random()*10)+1).toString())
        .set({count: increment}, {merge: true})
        res.status(201).send({"message":"Record successful!"});
    }
});

// View Log
app.get('/:type/:id', async (req, res) => {
    // received
    const receivedDocs = await admin.firestore().collection(req.params.type).doc("received_"+req.params.id).collection("shards").get();
    var received = 0;
    receivedDocs.forEach(doc => {
      received += doc.data().count;
    });

    // clicked
    const clickedDocs = await admin.firestore().collection(req.params.type).doc("clicked_"+req.params.id).collection("shards").get();
    var clicked = 0;
    clickedDocs.forEach(doc => {
        clicked += doc.data().count;
    });
    
    res.status(200).send({"received":received,"clicked":clicked});
});

exports.notification = functions.https.onRequest(app);
```
#### Add Push Notification Record


![](/assets/9659db1357e4/1*3koe6QBxF9oOhBDqjF5mhA.png)

#### View Push Notification Statistics
```
https://us-centra1-xxx.cloudfunctions.net/notification/iOS/1
```


![](/assets/9659db1357e4/1*SStEkNoDjiL7pffC2pHDkQ.png)


Additionally, an interface for statistics on push notification numbers was created.
#### Pitfalls


> _Due to being unfamiliar with the usage of node\.js, I initially struggled and did not add `await` when adding data, combined with write speed limitations, which led to Data Loss under high traffic conditions…_

```markdown
![](/assets/9659db1357e4/1*dVsBhKJQ3qqxlSvv-mCENA.png)

### Pricing

Don't forget to refer to the pricing strategies for Firebase Functions & Firestore.
#### Functions
- [https://cloud\.google\.com/functions/pricing?hl=zh\-tw](https://cloud.google.com/functions/pricing?hl=zh-tw){:target="_blank"}

![](/assets/9659db1357e4/1*76yRqeDyrp0kFmGHN4ZNXg.png)

![Compute Time](/assets/9659db1357e4/1*G_At8v80BQl81EUqPuUIbQ.png)

Compute Time

![Network](/assets/9659db1357e4/1*iXk7oKFidHfzRVwrDvKX0A.png)

Network

> _Cloud Functions offers a permanent free tier for compute time resources, which includes GB/second and GHz/second of compute time. In addition to 2 million invocations, the free tier also provides 400,000 GB/second and 200,000 GHz/second of compute time, as well as 5 GB of internet egress traffic per month._

#### Firestore
- [https://cloud\.google\.com/firestore/pricing?hl=zh\-tw](https://cloud.google.com/firestore/pricing?hl=zh-tw){:target="_blank"}

![](/assets/9659db1357e4/1*ylduiqevk4WH-eNc8EOpvQ.png)

- [Calculation Example](https://cloud.google.com/firestore/docs/billing-example?hl=zh-tw){:target="_blank"}

> **_Prices may change at any time, please refer to the official website for the latest information._**

### Conclusion

As the title suggests, "For Testing," "For Testing," "For Testing," it is not recommended to use the above services in a production environment, or even as the core of a product launch.
#### Expensive and Difficult to Migrate

I once heard that a fairly large service was built using Firebase services, and later on, the data and traffic became substantial, leading to exorbitant costs; migrating was also very difficult. The code was manageable, but the data was extremely hard to move. One could say that saving a little money in the early stages resulted in huge losses later on, which is not worth it.
#### For Testing Only

For the reasons above, I personally suggest that API services built with Firebase Functions + Firestore be used only for testing or prototype product demonstrations.
#### More Features

Functions can also integrate with Authentication and Storage, but I haven't researched that part.
### References
- [https://firebase\.google\.com/docs/firestore/query\-data/queries](https://firebase.google.com/docs/firestore/query-data/queries){:target="_blank"}
- [https://coder\.tw/?p=7198](https://coder.tw/?p=7198){:target="_blank"}
- [https://firebase\.google\.com/docs/firestore/solutions/counters\#node\.js\_1](https://firebase.google.com/docs/firestore/solutions/counters#node.js_1){:target="_blank"}
- [https://javascript\.plainenglish\.io/firebase\-cloud\-functions\-tutorial\-creating\-a\-rest\-api\-8cbc51479f80](https://javascript.plainenglish.io/firebase-cloud-functions-tutorial-creating-a-rest-api-8cbc51479f80){:target="_blank"}

### Further Reading
- [Using Python + Google Cloud Platform + Line Bot to Automate Routine Tasks](../70a1409b149a/)
- [i **OS ≥ 10 Notification Service Extension Application (Swift)**](../cb6eba52a342/)
- [Using Google Apps Script to Forward Gmail Messages to Slack](../d414bdbdb8c9/)
```

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/%E4%BD%BF%E7%94%A8-firebase-firestore-functions-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8F%AF%E4%BE%9B%E6%B8%AC%E8%A9%A6%E7%9A%84-api-%E6%9C%8D%E5%8B%99-9659db1357e4){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
