---
title: "Quickly Build a Testable API Service Using Firebase Firestore + Functions"
author: "ZhgChgLi"
date: 2021-03-23T17:09:34.747+0000
last_modified_at: 2024-04-13T16:34:17.362+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","firebase","google-cloud-platform","notifications","ios"]
description: "When push notification statistics meet Firebase Firestore + Functions"
image:
  path: /assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg
render_with_liquid: false
---

### Quickly Build a Testable API Service Using Firebase Firestore \+ Functions

When push notification statistics meet Firebase Firestore \+ Functions

![Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/9659db1357e4/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg)

Photo by [Carlos Muza](https://unsplash.com/@kmuza?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Introduction
#### Accurate Push Notification Statistics

Recently, I wanted to implement a feature for the app. Before it was implemented, we could only rely on the backend to post data to APNS/FCM to determine the success of push notifications and record clicks to calculate the "click-through rate." However, this method is quite inaccurate, as the base includes many invalid devices, such as those where the app has been deleted (which may not immediately become inactive) or where push notification permissions have been turned off, all of which still receive a success response from the backend post.

Since iOS 10, we can use the Notification Service Extension to secretly call an API for statistics when the push notification banner appears. The advantage is that it is very accurate; the API is only called when the user sees the push notification banner. If the app is deleted, notifications are turned off, or the banner is not displayed, there will be no action taken. The banner appearing is equivalent to the push notification message being displayed, and using this as the base for push notifications, along with the click count, allows us to obtain an "accurate click-through rate."

> _For detailed principles and implementation methods, refer to the previous article: "[i **OS ≥ 10 Notification Service Extension Application \(Swift\)**](../cb6eba52a342/)"_

> _Currently, testing shows that the app's loss rate should be 0%. Common applications like Line use point-to-point encryption for messages (the push notification message is encrypted and only decrypted when received on the phone)._

#### Issues

The workload on the app side is actually not significant; both iOS and Android only need to implement similar features (though Android can be more complicated if considering the Chinese market, as it requires implementing push notification frameworks for different platforms). The larger workload is on the backend, which has to handle server pressure, as sending a push notification will simultaneously call the API to log the record, which could overwhelm the server's maximum connections. If an RDBMS is used to store records, the situation could be even more severe. If a loss in statistics is detected, it often occurs at this stage.

> _Here, logging can be done by writing to a file, and statistics can be generated when querying._

> _Additionally, upon further reflection, the simultaneous return of requests may not be as large as initially imagined; push notifications are not sent all at once in batches of hundreds of thousands, but rather in smaller batches. As long as the system can handle the number of requests sent and returned simultaneously, it should be fine!_

### Prototype

Due to the considerations mentioned earlier, the backend needs to invest effort in research and modification, and the market may not necessarily care about the results produced. Therefore, I thought it would be best to create a prototype using available resources to test the waters.

Here, I chose Firebase services that are commonly used in apps, specifically Functions and Firestore.
#### Firebase Functions

[Functions](https://developers.google.com/learn/topics/functions){:target="_blank"} is a serverless service provided by Google. You only need to write the program logic, and Google automatically sets up the server and execution environment for you, so you don't have to worry about server scaling or traffic issues.

[Firebase Functions](https://firebase.google.com/docs/functions){:target="_blank"} is essentially Google Cloud Functions but can only be written in JavaScript (node.js). I haven't tried it, but if you use Google Cloud Functions with another programming language and import Firebase services, I believe it should work as well.

For APIs, I can write a node.js file to get a physical URL (e.g., my-project.cloudfunctions.net/getUser), write the logic to obtain request information, and provide the corresponding response.

> _I previously wrote an article about Google Functions: "[Using Python + Google Cloud Platform + Line Bot to Automate Routine Tasks](../70a1409b149a/)"_

> _Firebase Functions must be enabled in a Blaze project (pay as you go) to use them._

![](/assets/9659db1357e4/1*YqIJ1tr2Ay-oLVjSSU0zUg.png)

#### Firebase Firestore

[Firebase Firestore](https://firebase.google.com/docs/firestore){:target="_blank"} is a NoSQL database used to store and manage data.

By combining Firebase Functions, you can import Firestore during a request to manipulate the database and then respond to the user, allowing you to build a simple RESTful API service!

> Let's get started with implementation!

### Install Node.js Environment

I recommend using NVM, a version management tool for Node.js (similar to how Python uses pyenv).

Go to the NVM GitHub project and copy the installation shell script:

[![](https://repository-images.githubusercontent.com/612230/53a0c44a-1f6e-4f8d-918f-89762fafe369)](https://github.com/nvm-sh/nvm#installing-and-updating){:target="_blank"}

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash
```

If an error occurs during installation, please ensure that you have a `~/.bashrc` or `~/.zshrc` file. If not, you can create one using `touch ~/.bashrc` or `touch ~/.zshrc`, and then run the install script again.

Then you can use `nvm install node` to install the latest version of Node.js.

![](/assets/9659db1357e4/1*5fxz4HD9q4feAqO0zXbojg.png)

You can run `npm --version` to confirm that npm was installed successfully and check the version:

![](/assets/9659db1357e4/1*VHZMRFIDzFA9AxmsDNqNlA.png)

### Deploy Firebase Functions
#### Install Firebase-tools:
```bash
npm install -g firebase-tools
```

![](/assets/9659db1357e4/1*POfMR0p1600iYqy8rzQkTQ.png)

After successful installation, please enter the following command for the first time:
```bash
firebase login
```

![](/assets/9659db1357e4/1*kqeECyXVPOq1cpKvcdOBeA.png)

Complete the Firebase login verification.

Start the project:
```bash
firebase init
```

![](/assets/9659db1357e4/1*Xx2grpX2PZb3wEFt9mQbNw.png)

Note the path where Firebase init is located:
```
You're about to initialize a Firebase project in this directory:
```

Here, you can choose which Firebase CLI tools to install. Use the "↑" and "↓" keys to navigate and the "spacebar" to select; you can choose to install only "Functions" or also include "Firestore."

**=== Functions Setup**

![](/assets/9659db1357e4/1*2gd9pAIdLAkJRhROpJtPKA.png)

- Choose the language as "**JavaScript**"
- Regarding "use ESLint to catch probable bugs and enforce style," you can choose **YES / NO**.
- Install dependencies with npm? **YES**

**=== Emulators Setup**

![](/assets/9659db1357e4/1*xHWp195BZIZdXyUd-ub78g.png)

You can test Functions and Firestore features in a local environment without counting against usage and without having to wait for deployment to test.

> _Install as per personal needs; I have it installed but haven't used it... because it's just a small feature._

### Coding!

Go to the noted path above, find the `functions folder`, and open the `index.js` file with an editor.

index.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
admin.initializeApp();

exports.hello = functions.https.onRequest((req, res) => {
    const targetID = req.query.targetID
    const action = req.body.action
    const name = req.body.name

    res.send({"targetID": targetID, "action": action, "name": name});
    return
})
```

Paste the above content; we define a path interface `/hello` that will return URL **Query** `?targetID=`, **POST** `action`, and `name` parameter information.

After modifying and saving, return to the console:
```bash
firebase deploy
```

> **_Remember to run the `firebase deploy` command after every modification for it to take effect._**

Start validating and deploying to Firebase…

![](/assets/9659db1357e4/1*hUdvD4ANKD3s73mLWNZZOQ.png)

You may need to wait a moment; after `Deploy complete!`, your first Request & Response webpage is ready!

At this point, you can return to the Firebase -> Functions page:

![](/assets/9659db1357e4/1*SY4iJZL6gDEZ5AEcepIpMA.png)

You will see the interface and URL location you just wrote.

Copy the URL below and paste it into PostMan for testing:

![](/assets/9659db1357e4/1*OMfLkdg12QHsp-yc9RkKvA.png)

> _Remember to select `x-www-form-urlencoded` for the POST Body._

**Success!**
### Log

We can use the following in the code:
```javascript
functions.logger.log("log:", value);
```

To log records.

You can view the log results in Firebase -> Functions -> Logs:

![](/assets/9659db1357e4/1*Wi-4MbPh2tVJ_utdhzN4_A.png)

### Example Goal

> Create an API that can add, modify, delete, and query articles and likes.

We hope to achieve the functionality design of a RESTful API, so we cannot use the pure path method from the above example; we need to use the `Express` framework to accomplish this.
#### POST Add Article

index.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Insert
app.post('/', async (req, res) => { // The POST here refers to the HTTP Method POST
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null || content == null || author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"Added successfully!"});
});

exports.post= functions.https.onRequest(app); // The POST here refers to the /post path
```

Now we are using Express to handle network requests, and we have added a POST method for the path `/`. The last line indicates that all paths are under `/post`, and we will add APIs for modification and deletion next.

After deploying successfully with `firebase deploy`, return to PostMan for testing:

![](/assets/9659db1357e4/1*yVAjhlr6wLdONeG7nY0VEw.png)

After successfully posting in PostMan, you can check Firebase -> Firestore to see if the data has been written correctly:

![](/assets/9659db1357e4/1*xYVrRdFro3bQVHx05JUaTw.png)

#### PUT Modify Article

index.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Update
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"}); 
    } else if (title == null || content == null || author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"Modified successfully!"});
});

exports.post= functions.https.onRequest(app);
```

Deploy and test as you did for adding; remember to change the PostMan HTTP Method to `PUT`.
#### DELETE Remove Article

index.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Delete
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"Article deleted successfully!"});
})

exports.post= functions.https.onRequest(app);
```

Deploy and test as you did for adding; remember to change the PostMan HTTP Method to `DELETE`.

With the addition, modification, and deletion completed, let's move on to querying!
#### SELECT Query Articles

index.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Select List
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// Select One
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

exports.post= functions.https.onRequest(app);
```

![](/assets/9659db1357e4/1*n_mI4l1EmhpWK8M_FbrzbQ.png)

Deploy and test as you did for adding; remember to change the PostMan HTTP Method to `GET` and set the `Body` back to `none`.
#### InsertOrUpdate?

Sometimes we need to update when a value exists and add when it does not. In this case, we can use `set` with `merge: true`:

index.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// InsertOrUpdate
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"Added successfully!"});
});

exports.post= functions.https.onRequest(app);
```

Here, using the example of adding a tag, deploy and test as you did for adding, and you will see that Firestore does not keep adding new data repeatedly.

![](/assets/9659db1357e4/1*qkTMGjC0EkrMO85-6pQFwg.png)

#### Article Like Counter

Assuming our article data now has an additional `likeCount` field to record the number of likes, how should we handle this?

index.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Like Post
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"Liked successfully!"});
});

exports.post= functions.https.onRequest(app);
```

Using the `increment` variable allows us to directly perform the action of retrieving the value and adding 1 to it.
#### High Traffic Article Like Counter

Because Firestore has [write speed limits](https://cloud.google.com/firestore/quotas?hl=zh-tw#soft_limits){:target="_blank"}:

![](/assets/9659db1357e4/1*U9ubGe3M8XEdx9XGAV8nfA.png)

**A document can only be written to once per second**, so when many people like an article, simultaneous requests may become slow.

```markdown
The official solution provided for " [Distributed counters](https://cloud.google.com/firestore/docs/solutions/counters#node.js_2){:target="_blank"} " isn't particularly advanced; it simply involves using several distributed `likeCount` fields for counting, and then summing them up when reading.

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Distributed counters Like Post
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"Like successful!"});
});


exports.post= functions.https.onRequest(app);
```


![](/assets/9659db1357e4/1*GhNEcWUjgvYRYCMBk1DayA.png)


This is how distributed fields are used to record counts to avoid slow writes; however, having too many distributed fields can increase read costs \($$\), but it should still be cheaper than adding a new record every time someone likes a post.
#### Using Siege Tool for Stress Testing

Install `siege` using `brew`
```bash
brew install siege
```

_p\.s If you encounter brew: command not found, please install the [brew](https://brew.sh/index_zh-tw){:target="_blank"} package manager first:_
```bash
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
```

After installation, you can run:
```bash
siege -c 100 -r 1 -H 'Content-Type: application/json' 'https://us-central1-project.cloudfunctions.net/post/like/id POST {}'
```

To perform stress testing:
- `-c 100`: 100 tasks executing simultaneously
- `-r 1`: each task executes 1 request
- `-H ‘Content-Type: application/json’`: required for POST requests
- `‘https://us-central1-project.cloudfunctions.net/post/like/id POST {}’`: POST URL, Post Body \(ex: `{“name”:”1234”}` \)


After execution, you can see the results:


![](/assets/9659db1357e4/1*BUcMfJJ4x_mgK0HHLc6C4g.png)


`successful_transactions: 100` indicates that all 100 executions were successful.

**You can check Firebase -> Firestore to see if there is any data loss:**


![](/assets/9659db1357e4/1*wd5z743Zp9xtjKhhcMaVOg.png)



> Success! 



#### Complete Example Code

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

// Insert
app.post('/', async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;

    if (title == null || content == null || author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author, "created_at": new Date()};
    await admin.firestore().collection('posts').add(post);
    res.status(201).send({"message":"Successfully added!"});
});

// Update
app.put("/:id", async (req, res) => {
    const title = req.body.title;
    const content = req.body.content;
    const author = req.body.author;
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"}); 
    } else if (title == null || content == null || author == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var post = {"title":title, "content":content, "author": author};
    await admin.firestore().collection('posts').doc(req.params.id).update(post);
    res.status(200).send({"message":"Successfully modified!"});
});

// Delete
app.delete("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    await admin.firestore().collection("posts").doc(req.params.id).delete();
    res.status(200).send({"message":"Article deleted successfully!"});
});

// Select List
app.get('/', async (req, res) => {
    const posts = await admin.firestore().collection('posts').get();
    var result = [];
    posts.forEach(doc => {
      let id = doc.id;
      let data = doc.data();
      result.push({"id":id, ...data})
    });
    res.status(200).send({"result":result});
});

// Select One
app.get("/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    res.status(200).send({"result":{"id":doc.id, ...doc.data()}});
});

// InsertOrUpdate
app.post("/tag", async (req, res) => {
    const name = req.body.name;

    if (name == null) {
        return res.status(400).send({"message":"Parameter error!"});
    }

    var tag = {"name":name};
    await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true});
    res.status(201).send({"message":"Successfully added!"});
});

// Like Post
app.post("/like/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true});
    res.status(201).send({"message":"Like successful!"});
});

// Distributed counters Like Post
app.post("/like2/:id", async (req, res) => {
    const doc = await admin.firestore().collection('posts').doc(req.params.id).get();
    const increment = admin.firestore.FieldValue.increment(1)

    if (!doc.exists) {
        return res.status(404).send({"message":"Article not found!"});
    }

    //1~10
    await admin.firestore().collection('posts').doc(req.params.id).collection("likeCounter").doc("likeCount_"+(Math.floor(Math.random()*10)+1).toString())
    .set({count: increment}, {merge: true});
    res.status(201).send({"message":"Like successful!"});
});


exports.post= functions.https.onRequest(app);
```
### Returning to the Main Topic: Push Notification Statistics

Back to what we initially wanted to do, the push notification statistics feature.

index\.js:
```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const app = express();

admin.initializeApp();
app.use(cors({ origin: true }));

const validPlatformTypes = ["iOS","Android"]
const validActionTypes = ["clicked","received"]

// Insert Log
app.post('/', async (req, res) => {
    const increment = admin.firestore.FieldValue.increment(1);
    const platformType = req.body.platformType;
    const pushID = req.body.pushID;
    const actionType =  req.body.actionType;

    if (!validPlatformTypes.includes(platformType) || pushID == undefined || !validActionTypes.includes(actionType)) {
        return res.status(400).send({"message":"Parameter error!"});
    } else {
        await admin.firestore().collection(platformType).doc(actionType+"_"+pushID).collection("shards").doc((Math.floor(Math.random()*10)+1).toString())
        .set({count: increment}, {merge: true})
        res.status(201).send({"message":"Record successful!"});
    }
});

// View Log
app.get('/:type/:id', async (req, res) => {
    // received
    const receivedDocs = await admin.firestore().collection(req.params.type).doc("received_"+req.params.id).collection("shards").get();
    var received = 0;
    receivedDocs.forEach(doc => {
      received += doc.data().count;
    });

    // clicked
    const clickedDocs = await admin.firestore().collection(req.params.type).doc("clicked_"+req.params.id).collection("shards").get();
    var clicked = 0;
    clickedDocs.forEach(doc => {
        clicked += doc.data().count;
    });
    
    res.status(200).send({"received":received,"clicked":clicked});
});

exports.notification = functions.https.onRequest(app);
```
#### Adding Push Notification Records


![](/assets/9659db1357e4/1*3koe6QBxF9oOhBDqjF5mhA.png)

#### Viewing Push Notification Statistics
```
https://us-centra1-xxx.cloudfunctions.net/notification/iOS/1
```


![](/assets/9659db1357e4/1*SStEkNoDjiL7pffC2pHDkQ.png)


Additionally, an interface for statistics on push notification numbers has been created.
#### Pitfalls


> _Due to my unfamiliarity with Node\.js usage, I initially struggled with adding data without using `await`, combined with write speed limitations, leading to data loss under high traffic conditions…_ 






![](/assets/9659db1357e4/1*dVsBhKJQ3qqxlSvv-mCENA.png)

### Pricing

Don't forget to refer to the pricing strategies for Firebase Functions & Firestore.
#### Functions
- [https://cloud\.google\.com/functions/pricing?hl=zh\-tw](https://cloud.google.com/functions/pricing?hl=zh-tw){:target="_blank"}



![](/assets/9659db1357e4/1*76yRqeDyrp0kFmGHN4ZNXg.png)



![Compute Time](/assets/9659db1357e4/1*G_At8v80BQl81EUqPuUIbQ.png)

Compute Time


![Network](/assets/9659db1357e4/1*iXk7oKFidHfzRVwrDvKX0A.png)

Network


> _Cloud Functions offers a permanent free tier for compute time resources, which includes GB/second and GHz/second of compute time. In addition to 2 million invocations, the free tier also provides 400,000 GB/second and 200,000 GHz/second of compute time, as well as 5 GB of internet egress traffic per month._ 




#### Firestore
- [https://cloud\.google\.com/firestore/pricing?hl=zh\-tw](https://cloud.google.com/firestore/pricing?hl=zh-tw){:target="_blank"}



![](/assets/9659db1357e4/1*ylduiqevk4WH-eNc8EOpvQ.png)

- [Pricing Example](https://cloud.google.com/firestore/docs/billing-example?hl=zh-tw){:target="_blank"}



> **_Prices may change at any time, please refer to the official website for the latest information._** 




### Conclusion

As the title suggests, "For testing purposes only," it is not advisable to use the above services in a production environment or as the core of a product launch.
#### Expensive and Difficult to Migrate

I have heard of a fairly large service that was built using Firebase services, and later on, due to high data and traffic, the costs skyrocketed; migrating was also very difficult. The code was manageable, but the data was extremely hard to move; it can only be said that saving a little money in the early stages led to significant losses later on, which is not worth it.
#### For Testing Only

For the reasons above, I personally recommend using APIs built with Firebase Functions + Firestore only for testing or prototype product demonstrations.
#### More Features

Functions can also integrate with Authentication and Storage, but I haven't researched that part.
### References
- [https://firebase\.google\.com/docs/firestore/query\-data/queries](https://firebase.google.com/docs/firestore/query-data/queries){:target="_blank"}
- [https://coder\.tw/?p=7198](https://coder.tw/?p=7198){:target="_blank"}
- [https://firebase\.google\.com/docs/firestore/solutions/counters\#node\.js\_1](https://firebase.google.com/docs/firestore/solutions/counters#node.js_1){:target="_blank"}
- [https://javascript\.plainenglish\.io/firebase\-cloud\-functions\-tutorial\-creating\-a\-rest\-api\-8cbc51479f80](https://javascript.plainenglish.io/firebase-cloud-functions-tutorial-creating-a-rest-api-8cbc51479f80){:target="_blank"}

### Further Reading
- [Using Python + Google Cloud Platform + Line Bot to Automate Routine Tasks](../70a1409b149a/)
- [i **OS ≥ 10 Notification Service Extension Application (Swift)**](../cb6eba52a342/)
- [Using Google Apps Script to Forward Gmail Messages to Slack](../d414bdbdb8c9/)



If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.



_[Post](https://medium.com/zrealm-ios-dev/%E4%BD%BF%E7%94%A8-firebase-firestore-functions-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8F%AF%E4%BE%9B%E6%B8%AC%E8%A9%A6%E7%9A%84-api-%E6%9C%8D%E5%8B%99-9659db1357e4){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```