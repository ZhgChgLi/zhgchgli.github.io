---
title: "Behavior Change in NSAttributedString Attributes Range Merging in iOS ≥ 18"
author: "ZhgChgLi"
date: 2024-09-20T13:03:42.359+0000
last_modified_at: 2024-09-20T13:03:42.359+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","nsattributedstring","ios-18","ios","swift"]
description: "Starting from iOS ≥ 18, NSAttributedString attributes range merging will reference Equatable."
image:
  path: /assets/9e43897d99fc/1*PJ_qm75Yz_7y0UUBk8X6bg.jpeg
render_with_liquid: false
---

### Behavior Change in NSAttributedString Attributes Range Merging in iOS ≥ 18

Starting from iOS ≥ 18, NSAttributedString attributes range merging will reference Equatable.



![Photo by [C M](https://unsplash.com/@ubahnverleih?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}](/assets/9e43897d99fc/1*PJ_qm75Yz_7y0UUBk8X6bg.jpeg)

Photo by [C M](https://unsplash.com/@ubahnverleih?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}
#### Cause of the Issue


[![](https://repository-images.githubusercontent.com/602927147/57ce75c1-8548-449c-b44a-f4b0451ed5ea)](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}


After the release of iOS 18 on September 17, 2024, developers reported that the open-source project [ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} was crashing when parsing certain HTML.

I was a bit confused by this issue because the program had no problems before, and it only started crashing with iOS 18, which seemed illogical. It should be due to some adjustments in the underlying Foundation of iOS 18.
#### Crash Trace

After tracing the code, the crash point was identified as occurring when iterating over the `.breaklinePlaceholder` attributes and performing deletion operations on the range:
```
mutableAttributedString.enumerateAttribute(.breaklinePlaceholder, in: NSMakeRange(0, NSMakeRange(0, mutableAttributedString.string.utf16.count))) { value, range, _ in
  // ...if condition...
  // mutableAttributedString.deleteCharacters(in: preRange)
  // ...if condition...
  // mutableAttributedString.deleteCharacters(in: range)
}
```

`.breaklinePlaceholder` is a custom NSAttributedString.Key that I created to mark HTML tag information, optimizing the use of line break characters:
```swift
struct BreaklinePlaceholder: OptionSet {
    let rawValue: Int

    static let tagBoundaryPrefix = BreaklinePlaceholder(rawValue: 1)
    static let tagBoundarySuffix = BreaklinePlaceholder(rawValue: 2)
    static let breaklineTag = BreaklinePlaceholder(rawValue: 3)
}

extension NSAttributedString.Key {
    static let breaklinePlaceholder: NSAttributedString.Key = .init("breaklinePlaceholder")
}
```

> **_But the core issue is not here_** _because before iOS 17, the input `mutableAttributedString` would not have any issues when performing the above operations; this indicates that the input data content has changed in iOS 18._ 

#### NSAttributedString attributes: \[NSAttributedString\.Key: Any?\]

Before delving into the issue, let's introduce the **merging mechanism** of NSAttributedString attributes.

NSAttributedString attributes will **automatically compare adjacent Range Attributes objects with the same .key to see if they are identical; if they are, they will be merged into the same Attribute.** For example:
```swift
let mutableAttributedString = NSMutableAttributedString(string: "", attributes: nil)
mutableAttributedString.append(NSAttributedString(string: "<div>", attributes: [.font: UIFont.systemFont(ofSize: 14)]))
mutableAttributedString.append(NSAttributedString(string: "<div>", attributes: [.font: UIFont.systemFont(ofSize: 14)]))
mutableAttributedString.append(NSAttributedString(string: "<p>", attributes: [.font: UIFont.systemFont(ofSize: 14)]))
mutableAttributedString.append(NSAttributedString(string: "Test", attributes: [.font: UIFont.systemFont(ofSize: 12)]))
```

**Final Attributes merge result:**
```swift
<div><div><p>{
    NSFont = "<UICTFont: 0x101d13400> font-family: \".SFUI-Regular\"; font-weight: normal; font-style: normal; font-size: 14.00pt";
}Test{
    NSFont = "<UICTFont: 0x101d13860> font-family: \".SFUI-Regular\"; font-weight: normal; font-style: normal; font-size: 12.00pt";
}
```

When `enumerateAttribute(.breaklinePlaceholder...)` is called, the following result is obtained:
```swift
NSRange {0, 13}: <UICTFont: 0x101d13400> font-family: ".SFUI-Regular"; font-weight: normal; font-style: normal; font-size: 14.00pt
NSRange {13, 4}: <UICTFont: 0x101d13860> font-family: ".SFUI-Regular"; font-weight: normal; font-style: normal; font-size: 12.00pt
```
#### NSAttributedString attributes merging — Speculated underlying implementation

It is speculated that the underlying implementation uses `Set<Hashable>` as the Attributes container, which automatically excludes identical Attribute objects.

However, for convenience, the `NSAttributedString attributes: [NSAttributedString.Key: Any?]` Value objects are declared as `Any?` Type, which does not restrict Hashable.

Thus, it is speculated that the system, at the underlying level, conforms to `as? Hashable` and then uses Set to manage the merged objects.

> **_The difference in adjustments for iOS ≥ 18 is speculated to be an implementation issue at this underlying level._** 

Here is an example using our custom `.breaklinePlaceholder` Attributes:
```swift
struct BreaklinePlaceholder: Equatable {
    let rawValue: Int

    static let tagBoundaryPrefix = BreaklinePlaceholder(rawValue: 1)
    static let tagBoundarySuffix = BreaklinePlaceholder(rawValue: 2)
    static let breaklineTag = BreaklinePlaceholder(rawValue: 3)
}

extension NSAttributedString.Key {
    static let breaklinePlaceholder: NSAttributedString.Key = .init("breaklinePlaceholder")
}

//

let mutableAttributedString = NSMutableAttributedString(string: "", attributes: nil)
mutableAttributedString.append(NSAttributedString(string: "<div>", attributes: [.breaklinePlaceholder: NSAttributedString.Key.BreaklinePlaceholder.tagBoundaryPrefix]))
mutableAttributedString.append(NSAttributedString(string: "<div>", attributes: [.breaklinePlaceholder: NSAttributedString.Key.BreaklinePlaceholder.tagBoundaryPrefix]))
mutableAttributedString.append(NSAttributedString(string: "<p>", attributes: [.breaklinePlaceholder: NSAttributedString.Key.BreaklinePlaceholder.tagBoundaryPrefix]))
mutableAttributedString.append(NSAttributedString(string: "Test", attributes: nil))
```
#### Attributes merge result before iOS ≤ 17:
```bash
<div>{
    breaklinePlaceholder = "NSAttributedStringCrash.BreaklinePlaceholder(rawValue: 1)";
}<div>{
    breaklinePlaceholder = "NSAttributedStringCrash.BreaklinePlaceholder(rawValue: 1)";
}<p>{
    breaklinePlaceholder = "NSAttributedStringCrash.BreaklinePlaceholder(rawValue: 1)";
}Test{
}
```
#### Attributes merge result for iOS ≥ 18:
```xml
<div><div><p>{
    breaklinePlaceholder = "NSAttributedStringCrash.BreaklinePlaceholder(rawValue: 1)";
}Test{
}
```

> **_It can be seen that the same program produces different results on different versions of iOS, which ultimately leads to unexpected handling logic in the subsequent `enumerateAttribute(.breaklinePlaceholder..)` causing crashes._** 

#### ⭐️ iOS ≥ 18 NSAttributedString attributes: \[NSAttributedString\.Key: Any?\] will reference Equatable more often ==⭐️

![Comparison of iOS 17/18 regarding the implementation of Equatable/Hashable](/assets/9e43897d99fc/1*0TKpBawJoLZUbUKwovRUJQ.png)

Comparison of iOS 17/18 regarding the implementation of Equatable/Hashable

> **_⭐️⭐️ iOS ≥ 18 will reference `Equatable` more often, while iOS ≤ 17 will not.⭐️⭐️_** 

Combining the above, the `NSAttributedString attributes: [NSAttributedString.Key: Any?]` Value object is declared as `Any?` Type. **Based on observational results, iOS ≥ 18 will first reference `Equatable` to determine equality, and then use `Hashable` Set to manage objects.**
### Conclusion

> NSAttributedString attributes: \[NSAttributedString\.Key: Any?\] when merging Range Attributes, iOS ≥ 18 will reference Equatable more often, which is different from previous versions. 

Additionally, starting from iOS 18, if only `Equatable` is declared, the XCode Console will also output a Warning:

> **_Obj\-C \` \-hash\` invoked on a Swift value of type \`BreaklinePlaceholder\` that is Equatable but not Hashable; this can lead to severe performance problems\._** 

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-18-nsattributedstring-attributes-range-%E5%90%88%E4%BD%B5%E7%9A%84%E4%B8%80%E5%80%8B%E8%A1%8C%E7%82%BA%E6%94%B9%E8%AE%8A-9e43897d99fc){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
