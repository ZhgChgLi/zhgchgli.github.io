---
title: "AppStore APP’s Reviews Bot Insights"
author: "ZhgChgLi"
date: 2021-04-21T15:16:31.071+0000
last_modified_at: 2024-04-13T16:38:28.675+0000
categories: ["ZRealm Dev."]
tags: ["slackbot","ios-app-development","ruby","fastlane","automator"]
description: "Create a Slack bot for tracking APP reviews"
image:
  path: /assets/cb0c68c33994/1*BMCG3cu21W5MbODBbhI-sA.jpeg
render_with_liquid: false
---

### AppStore APP’s Reviews Slack Bot Insights

Using Ruby + Fastlane - SpaceShip to create a Slack bot for tracking APP reviews



![Photo by [Austin Distel](https://unsplash.com/@austindistel?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/cb0c68c33994/1*BMCG3cu21W5MbODBbhI-sA.jpeg)

Photo by [Austin Distel](https://unsplash.com/@austindistel?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
#### Not Knowing the Price of Rice

![[Example of AppReviewBot](https://appreviewbot.com){:target="_blank"}](/assets/cb0c68c33994/1*Iv6qvrBfyv3bU1NK1hPVHg.png)

[Example of AppReviewBot](https://appreviewbot.com){:target="_blank"}

I recently learned that the bot for forwarding the latest APP reviews in Slack requires a fee; I always thought this feature was free. The costs range from $5 to $200 per month, as various platforms do not solely focus on the "App Review Bot" functionality. They also offer data statistics, records, unified backends, and comparisons with competitors, among other services. The fees are based on the services each platform can provide. The Review Bot is just one part of their offerings, but I only want to use this feature, and paying for additional services seems quite wasteful.
### Problem

Initially, I used the free open-source tool [TradeMe/ReviewMe](https://github.com/TradeMe/ReviewMe){:target="_blank"} for Slack notifications, but this tool has not been maintained for years. Occasionally, Slack would send out some old reviews, which was quite alarming (many bugs have long been fixed, leading us to think there were new issues!), for reasons unknown.

So I considered looking for other tools or methods to replace it.
### TL;DR \[2022/08/10\] Update:

I have now redesigned the App Reviews Bot using the brand new [App Store Connect API](../f1365e51902c/) and rebranded it as "[ZReviewTender — a free and open-source App Reviews monitoring bot](../e36e48bb9265/)."

====
### 2022/07/20 Update

[App Store Connect API now supports reading and managing Customer Reviews](../f1365e51902c/), and the App Store Connect API natively supports accessing App reviews, **no longer requiring** Fastlane — Spaceship to fetch reviews from the backend.
### Principle Exploration

With motivation in place, let's explore the principles to achieve the goal.
#### Official API ❌

Apple provides the [App Store Connect API](https://developer.apple.com/app-store-connect/api/){:target="_blank"}, but it does not offer a feature to fetch reviews.

\[2022/07/20 Update\]: [App Store Connect API now supports reading and managing Customer Reviews](../f1365e51902c/)
#### Public URL API (RSS) ⚠️

Apple provides a public APP review [RSS subscription URL](https://rss.itunes.apple.com/zh-tw){:target="_blank"}, and in addition to RSS XML, it also offers a JSON format.
```plaintext
https://itunes.apple.com/COUNTRY_CODE/rss/customerreviews/id=APP_ID/page=1/sortBy=mostRecent/json
```
- COUNTRY_CODE: Refer to [this document](https://help.apple.com/app-store-connect/#/dev997f9cf7c){:target="_blank"}.
- APP_ID: Go to the App's web version, and you will get the URL: https://apps\.apple\.com/tw/app/APP_Name/id **12345678**, where the number after id is the App ID (purely numeric).
- page: You can request pages 1 to 10; requests beyond that will not be fulfilled.
- sortBy: `mostRecent/json` requests the latest reviews in JSON format; you can change it to `mostRecent/xml` for XML format.

**The evaluation data is returned as follows:**

rss\.json:
```json
{
  "author": {
    "uri": {
      "label": "https://itunes.apple.com/tw/reviews/id123456789"
    },
    "name": {
      "label": "test"
    },
    "label": ""
  },
  "im:version": {
    "label": "4.27.1"
  },
  "im:rating": {
    "label": "5"
  },
  "id": {
    "label": "123456789"
  },
  "title": {
    "label": "A wonderful existence!"
  },
  "content": {
    "label": "Life is worth it~",
    "attributes": {
      "type": "text"
    }
  },
  "link": {
    "attributes": {
      "rel": "related",
      "href": "https://itunes.apple.com/tw/review?id=123456789&type=Purple%20Software"
    }
  },
  "im:voteSum": {
    "label": "0"
  },
  "im:contentType": {
    "attributes": {
      "term": "Application",
      "label": "Application"
    }
  },
  "im:voteCount": {
    "label": "0"
  }
}
```

**Advantages:**
1. Publicly accessible without authentication steps
2. Simple and easy to use

**Disadvantages:**
1. This RSS API is very outdated and has not been updated
2. The information returned about the reviews is too limited (no comment time, has the review been edited?, has there been a response?)
3. Encountered data corruption issues (the last few pages occasionally show old data)
4. Access limited to 10 pages

> _The biggest problem we encountered is 3; however, it is uncertain whether this is an issue with the [Bot tool](https://github.com/TradeMe/ReviewMe){:target="_blank"} we are using or if there is a problem with the RSS URL data._

#### Private URL API ✅

This method is somewhat unconventional and was a sudden inspiration I discovered; however, after referencing other Review Bot practices, I found that many websites use this method as well, so there should be no problem. I saw tools doing this 4-5 years ago, but I didn't delve into it at that time.

**Advantages:**
1. Same data as Apple's backend
2. Data is complete and up-to-date
3. Allows for more detailed filtering
4. Deeply integrated APP tools also use this method (AppRadar/AppReviewBot…)

**Disadvantages:**
1. Unofficially published method (unconventional)
2. Due to Apple's implementation of two-step login, the login session needs to be updated regularly.

**Step One — Sniffing the API that loads review blocks from App Store Connect backend:**

![](/assets/cb0c68c33994/1*74lbicQ_vPzrLfm1imk7Pg.png)

The Apple backend is accessed by calling:
```plaintext
https://appstoreconnect.apple.com/WebObjects/iTunesConnect.woa/ra/apps/APP_ID/platforms/ios/reviews?index=0&sort=REVIEW_SORT_ORDER_MOST_RECENT
```

This endpoint retrieves the list of reviews:

![](/assets/cb0c68c33994/1*I00Znmzaivm_-7ous0-4Pw.png)

index = pagination offset, with a maximum of 100 entries displayed at once.

**The evaluation data is returned as follows:**

private\.json:
```json
{
  "value": {
    "id": 123456789,
    "rating": 5,
    "title": "A wonderful existence!",
    "review": "Life is worth it~",
    "created": null,
    "nickname": "test",
    "storeFront": "TW",
    "appVersionString": "4.27.1",
    "lastModified": 1618836654000,
    "helpfulViews": 0,
    "totalViews": 0,
    "edited": false,
    "developerResponse": null
  },
  "isEditable": true,
  "isRequired": false,
  "errorKeys": null
}
```


After testing, it was found that you only need to include `cookie: myacinfo=<Token>` to spoof the request and obtain the data:


![](/assets/cb0c68c33994/1*b_vINNRMrAIQrkuouN7X1Q.png)


With the API available and the required headers known, the next step is to find a way to automate the retrieval of this cookie information from the backend.

**Step Two — Universal Fastlane**

Since Apple now implements full Two-Step Verification, automating login verification has become more cumbersome. Fortunately, the clever tool [Fastlane](https://docs.fastlane.tools/best-practices/continuous-integration/){:target="_blank"} has implemented not only the standard App Store Connect API and iTMSTransporter but also web authentication (including two-step verification). We can directly use the Fastlane command:
```bash
fastlane spaceauth -u <App Store Connect Account (Email)>
```

This command will complete the web login verification (including two-step verification) and store the cookie in the FASTLANE_SESSION file.

You will receive a string similar to the following:
```
!ruby/object:HTTP::Cookie
name: myacinfo  value: <token>  
domain: apple.com for_domain: true  path: "/"  
secure: true  httponly: true  expires: max_age: 
created_at: 2021-04-21 20:42:36.818821000 +08:00  
accessed_at: 2021-04-21 22:02:45.923016000 +08:00
!ruby/object:HTTP::Cookie
name: <hash>  value: <token>
domain: idmsa.apple.com for_domain: true  path: "/"
secure: true  httponly: true  expires: max_age: 2592000
created_at: 2021-04-19 23:21:05.851853000 +08:00
accessed_at: 2021-04-21 20:42:35.735921000 +08:00
```

By using `myacinfo = value`, you can obtain the review list.

**Step Three — SpaceShip**

I initially thought Fastlane could only help us up to this point, and that we would have to manually connect the flow from Fastlane to retrieve the cookie and then call the API. However, after some exploration, I discovered that Fastlane's module for authentication, `SpaceShip`, has even more powerful features!


![`SpaceShip`](/assets/cb0c68c33994/1*OlYQLNXAOk1oNqDP7LSlrA.png)

`SpaceShip`

Inside SpaceShip, there is already a method packaged for retrieving the review list: [**Class: Spaceship::TunesClient::get\_reviews**](https://www.rubydoc.info/gems/spaceship/0.39.0/Spaceship/TunesClient#get_reviews-instance_method){:target="_blank"}!
```ruby
app = Spaceship::Tunes::login(appstore_account, appstore_password)
reviews = app.get_reviews(app_id, platform, storefront, versionId = '')
```

\*storefront = region

**Step Four — Assembly**

Both Fastlane and SpaceShip are written in Ruby, so we will also use Ruby to create this Bot tool.

We can create a file named `reviewBot.rb`, and when compiling and executing, simply enter in the Terminal:
```bash
ruby reviewBot.rb
```

That's it. _\( *For more Ruby environment issues, please refer to the tips at the end of this document\)_

**First**, since the original get\_reviews parameters do not meet our needs, I want the review data for all regions and all versions, without filtering, and supporting pagination:

extension\.rb:
```ruby
# Extension Spaceship->TunesClient
module Spaceship
  class TunesClient < Spaceship::Client
    def get_recent_reviews(app_id, platform, index)
      r = request(:get, "ra/apps/#{app_id}/platforms/#{platform}/reviews?index=#{index}&sort=REVIEW_SORT_ORDER_MOST_RECENT")
      parse_response(r, 'data')['reviews']
     end
  end
end
```


So we expanded a method in TunesClient, where the parameters only include app\_id, platform = `ios` ( **all lowercase** ), and index = pagination offset.

**Next, assemble the login authentication and fetch the review list:**

get\_recent\_reviews\.rb:
```ruby
index = 0
breakWhile = true
while breakWhile
  app = Spaceship::Tunes::login(APPStoreConnect account (Email), APPStoreConnect password)
  reviews = app.get_recent_reviews($app_id, $platform, index)
  if reviews.length() <= 0
    breakWhile = false
    break
  end
  reviews.each { |review|
    index += 1
    puts review["value"]
  }
end
```

Use while to iterate through all pages, terminating when there is no content.

**Next, we need to add a record of the last latest timestamp, only notifying the latest messages that have not been notified:**

lastModified\.rb:
```ruby
lastModified = 0
if File.exists?(".lastModified")
  lastModifiedFile = File.open(".lastModified")
  lastModified = lastModifiedFile.read.to_i
end
newLastModified = lastModified
isFirst = true
messages = []

index = 0
breakWhile = true
while breakWhile
  app = Spaceship::Tunes::login(APPStoreConnect account (Email), APPStoreConnect password)
  reviews = app.get_recent_reviews($app_id, $platform, index)
  if reviews.length() <= 0
    breakWhile = false
    break
  end
  reviews.each { |review|
    index += 1
    if isFirst
      isFirst = false
      newLastModified = review["value"]["lastModified"]
    end

    if review["value"]["lastModified"] > lastModified && lastModified != 0  
      # Do not send notification on the first use
      messages.append(review["value"])
    else
      breakWhile = false
      break
    end
  }
end

messages.sort! { |a, b|  a["lastModified"] <=> b["lastModified"] }
messages.each { |message|
    notify_slack(message)
}

File.write(".lastModified", newLastModified, mode: "w+")
```

Simply use a `.lastModified` to record the time obtained during the last execution.

_\*Do not send notifications on the first use, otherwise it will flood notifications at once._

**Final step, combine the push notification message & send it to Slack:**

slack\.rb:
```ruby
# Slack Bot
def notify_slack(review)
  rating = review["rating"].to_i
  color = rating >= 4 ? "good" : (rating >= 2 ? "warning" : "danger")
  like = review["helpfulViews"].to_i > 0 ? " - #{review["helpfulViews"]} :thumbsup:" : ""
  date = review["edited"] == false ? "Created at: #{Time.at(review["lastModified"].to_i / 1000).to_datetime}" : "Updated at: #{Time.at(review["lastModified"].to_i / 1000).to_datetime}"
  
    
  isResponse = ""
  if review["developerResponse"] != nil && review["developerResponse"]['lastModified'] < review["lastModified"]
    isResponse = " (Response is outdated)"
  end
  
  edited = review["edited"] == false ? "" : ":memo: User updated review#{isResponse}："

  stars = "★" * rating + "☆" * (5 - rating)
  attachments = {
    :pretext => edited,
    :color => color,
    :fallback => "#{review["title"]} - #{stars}#{like}",
    :title => "#{review["title"]} - #{stars}#{like}",
    :text => review["review"],
    :author_name => review["nickname"],
    :footer => "iOS - v#{review["appVersionString"]} - #{review["storeFront"]} - #{date} - <https://appstoreconnect.apple.com/apps/APP_ID/appstore/activity/ios/ratingsResponses|Go To App Store>"
  }
  payload = {
   :attachments => [attachments],
   :icon_emoji => ":storm_trooper:",
   :username => "ZhgChgLi iOS Review Bot"
  }.to_json
  cmd = "curl -X POST --data-urlencode 'payload=#{payload}' SLACK_WEB_HOOK_URL"
  system(cmd, :err => File::NULL)
  puts "#{review["id"]} send Notify Success!"
 end
```

```ruby
require "Spaceship"
require 'json'
require 'date'

# Config
$slack_web_hook = "The web hook URL for target notifications"
$slack_debug_web_hook = "The notification web hook URL when the bot encounters an error"
$appstore_account = "APPStoreConnect account (Email)"
$appstore_password = "APPStoreConnect password"
$app_id = "APP_ID"
$platform = "ios"

# Extension Spaceship->TunesClient
module Spaceship
  class TunesClient < Spaceship::Client
    def get_recent_reviews(app_id, platform, index)
      r = request(:get, "ra/apps/#{app_id}/platforms/#{platform}/reviews?index=#{index}&sort=REVIEW_SORT_ORDER_MOST_RECENT")
      parse_response(r, 'data')['reviews']
     end
  end
end

# Slack Bot
def notify_slack(review)
  rating = review["rating"].to_i
  color = rating >= 4 ? "good" : (rating >= 2 ? "warning" : "danger")
  like = review["helpfulViews"].to_i > 0 ? " - #{review["helpfulViews"]} :thumbsup:" : ""
  date = review["edited"] == false ? "Created at: #{Time.at(review["lastModified"].to_i / 1000).to_datetime}" : "Updated at: #{Time.at(review["lastModified"].to_i / 1000).to_datetime}"
  
    
  isResponse = ""
  if review["developerResponse"] != nil && review["developerResponse"]['lastModified'] < review["lastModified"]
    isResponse = " (The customer service response is outdated)"
  end
  
  edited = review["edited"] == false ? "" : ":memo: User updated the review#{isResponse}："

  stars = "★" * rating + "☆" * (5 - rating)
  attachments = {
    :pretext => edited,
    :color => color,
    :fallback => "#{review["title"]} - #{stars}#{like}",
    :title => "#{review["title"]} - #{stars}#{like}",
    :text => review["review"],
    :author_name => review["nickname"],
    :footer => "iOS - v#{review["appVersionString"]} - #{review["storeFront"]} - #{date} - <https://appstoreconnect.apple.com/apps/APP_ID/appstore/activity/ios/ratingsResponses|Go To App Store>"
  }
  payload = {
   :attachments => [attachments],
   :icon_emoji => ":storm_trooper:",
   :username => "ZhgChgLi iOS Review Bot"
  }.to_json
  cmd = "curl -X POST --data-urlencode 'payload=#{payload}' #{$slack_web_hook}"
  system(cmd, :err => File::NULL)
  puts "#{review["id"]} send Notify Success!"
 end

begin
    lastModified = 0
    if File.exists?(".lastModified")
      lastModifiedFile = File.open(".lastModified")
      lastModified = lastModifiedFile.read.to_i
    end
    newLastModified = lastModified
    isFirst = true
    messages = []

    index = 0
    breakWhile = true
    while breakWhile
      app = Spaceship::Tunes::login($appstore_account, $appstore_password)
      reviews = app.get_recent_reviews($app_id, $platform, index)
      if reviews.length() <= 0
        breakWhile = false
        break
      end
      reviews.each { |review|
        index += 1
        if isFirst
          isFirst = false
          newLastModified = review["value"]["lastModified"]
        end

        if review["value"]["lastModified"] > lastModified && lastModified != 0  
          # Do not send notifications for the first use
          messages.append(review["value"])
        else
          breakWhile = false
          break
        end
      }
    end
    
    messages.sort! { |a, b|  a["lastModified"] <=> b["lastModified"] }
    messages.each { |message|
        notify_slack(message)
    }
    
    File.write(".lastModified", newLastModified, mode: "w+")
rescue => error
    attachments = {
        :color => "danger",
        :title => "AppStoreReviewBot Error occurs!",
        :text => error,
        :footer => "*Due to Apple's technical limitations, the precise review scraping function needs to be reconfigured approximately every month. Thank you for your understanding.*"
    }
    payload = {
        :attachments => [attachments],
        :icon_emoji => ":storm_trooper:",
        :username => "ZhgChgLi iOS Review Bot"
    }.to_json
    cmd = "curl -X POST --data-urlencode 'payload=#{payload}' #{$slack_debug_web_hook}"
    system(cmd, :err => File::NULL)
    puts error
end
```

Additionally, a `begin...rescue` (try...catch) protection has been added. If an error occurs, a Slack notification will be sent to remind us to check (most likely due to session expiration).

> **_Finally, just add this script to crontab/schedule or any scheduling tool for regular execution!_**

**Effect Image:**

![](/assets/cb0c68c33994/1*B0xW1CXU-avz2j8_ny3Ang.jpeg)

### Free Alternatives
1. [AppFollow](https://appfollow.io/){:target="_blank"}: Uses Public URL API (RSS), it's just barely usable.
2. [feedis.io](https://feedis.io/product/proxime/features){:target="_blank"}: Uses Private URL API, requires you to provide your username and password.
3. [TradeMe/ReviewMe](https://github.com/TradeMe/ReviewMe){:target="_blank"}: Self-hosted service (node.js), we originally used this but encountered the aforementioned issues.
4. [JonSnow](https://github.com/saiday/JonSnow){:target="_blank"}: Self-hosted service (GO), supports one-click deployment to Heroku, author: [@saiday](https://twitter.com/saiday){:target="_blank"}

### Friendly Reminder

1. ⚠️ For the Private URL API method, if you use an account with two-factor authentication, you will need to re-verify every 30 days at most, and there is currently no solution; if you can create an account without two-factor authentication, you can use it without any hassle.

![[#important-note-about-session-duration](https://docs.fastlane.tools/best-practices/continuous-integration/#important-note-about-session-duration){:target="_blank"}](/assets/cb0c68c33994/1*EE2J5HmdiIogMwC3Iiy0KA.png)

[#important-note-about-session-duration](https://docs.fastlane.tools/best-practices/continuous-integration/#important-note-about-session-duration){:target="_blank"}

2. ⚠️ Whether free, paid, or self-hosted as mentioned in this article; do not use a developer account. Be sure to create a separate App Store Connect account with permissions limited to "Customer Support" to prevent security issues.

3. It is recommended to use [rbenv](https://gist.github.com/sandyxu/8aceec7e436a6ab9621f){:target="_blank"} for Ruby management, as the system's built-in version 2.6 can easily cause conflicts.

4. If you encounter GEM or Ruby environment errors on macOS Catalina, you can refer to [this reply](https://github.com/orta/cocoapods-keys/issues/198#issuecomment-510909030){:target="_blank"} for a solution.

### Problem Solved!

Through this journey, I gained a better understanding of how the Slack Bot operates and how the iOS App Store scrapes review content. Additionally, I also dabbled in Ruby! It’s quite enjoyable to write!

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/appstore-apps-reviews-bot-%E9%82%A3%E4%BA%9B%E4%BA%8B-cb0c68c33994){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
