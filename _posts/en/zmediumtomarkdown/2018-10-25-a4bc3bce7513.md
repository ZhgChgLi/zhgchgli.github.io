---
title: "Things About iOS UUID (Swift/iOS ‚â• 6)"
author: "ZhgChgLi"
date: 2018-10-25T14:26:20.002+0000
last_modified_at: 2024-04-13T07:21:43.386+0000
categories: ["ZRealm Dev."]
tags: ["iplayground","swift","ios-app-development","uuid","idfv"]
description: "iPlayground 2018 is back & things about UUID"
image:
  path: /assets/a4bc3bce7513/1*gEmmuDOD92d2b2fLp4AKsw.jpeg
render_with_liquid: false
---

### Things About iOS UUID \(Swift/iOS ‚â• 6\)

iPlayground 2018 is back & things about UUID

### Introduction:

Last Saturday and Sunday, I attended the [iPlayground](https://iplayground.io/){:target="_blank"} Apple Software Developers Conference. The information about this event was passed on by a colleague, and I wasn't clear about it before going.

![](/assets/a4bc3bce7513/1*gEmmuDOD92d2b2fLp4AKsw.jpeg)

After two days, the entire event and schedule were smooth, with the agenda covering:
1. Fun topics: Bicycles, Decaying Code, the Evolution of iOS/API, Where's Waldo \(CoreML Vision\)
2. Practical topics: Testing types \(XCUITest, Dependency Injection\), Alternatives for Animation Effects with SpriteKit, GraphQL
3. Real skills: In-depth breakdown of Swift, iOS Jailbreak/Tweak Development, Redux

The bicycle project left a deep impression, using an iPhone as a sensor to detect the rotation of the bicycle pedals, allowing the presenter to ride a bike on stage while switching slides \(the main goal was to create an open-source version of Zwift, and many pitfalls were shared, such as Client/Server communication, latency issues, and magnetic field interference\).

The topic of Decaying Dirty Code resonated with me, making me smile inwardly; technical debt accumulates like this, as development schedules are tight, leading to quick but poorly structured solutions. Future developers may not have time to refactor, resulting in even more accumulation; eventually, it may only be possible to scrap that path entirely.

In the testing section \(Design Patterns in XCUITest\), a [senior from KKBOX](https://www.facebook.com/TestingWithKK/){:target="_blank"} openly shared their methods, code examples, and the pitfalls they encountered along with solutions. This session was the most helpful for our work; testing is an area I have always wanted to strengthen, and I can go back and study it thoroughly.

During the Lighting Talk, I really wanted to share from the audience üòÇ I need to prepare earlier next time!

The official party after the event had great food and drinks, and it was enjoyable to hear the heartfelt words from the seniors, making it a relaxed and fun experience while also absorbing many soft skills for the workplace.

![NTU Backstage Cafe](/assets/a4bc3bce7513/1*Xwk_96lVKcMKgeL7IOC70g.jpeg)

NTU Backstage Cafe

I just learned that this was the first session, and I feel honored to have participated. Kudos to all the staff and speakers for their hard work!

The purpose of attending the seminar is to: **broaden** knowledge, absorb new insights, understand the ecosystem, and encounter topics that are usually not touched upon, as well as **deepen** understanding. For topics I am already familiar with, I aim to see if there are any overlooked areas or other methods I haven't discovered.

I took many notes to review and study later.
### Things About UUID

After attending, I immediately applied what I learned to the APP; this session was led by senior Zonble, and I was amazed to hear about the journey from iPhone OS 2 to iOS 12; since I entered the field later, I started writing from iOS 11/Swift 4, so I missed the chaotic period when Apple modified the APIs.

Thinking about it, it's quite reasonable that UUIDs can be obtained and then blocked; if used for good purposes: identifying user devices, advertising, or utilizing uniqueness for third-party advertising operations. However, if a vendor intends to do harm, they could use this mechanism to trace back and understand the owner of the device. \(For example, if someone has travel apps + Taipei bus + BMW app + baby care, it could be inferred that they often travel, have children, and live in Taipei, among other information\). Coupled with personal data entered in apps, the potential applications are unimaginable.

However, this also affects many law-abiding users, such as those who originally used UUIDs as data decryption keys or for device identification, which have been significantly impacted. I truly admire the engineers from that period; the repercussions would certainly lead to complaints from bosses and users, forcing them to quickly find alternative solutions.
#### Alternatives:

This article focuses on obtaining UUIDs to identify unique device values. If you want to find alternatives to know which apps a user has installed, you can refer to the following keywords for methods: [UIPasteboard pasteboardWithName: create: \(using the clipboard to share between apps\)](https://link.medium.com/YTheNPnHH7){:target="_blank"}, canOpenURL: info\.plist LSApplicationQueriesSchemes \(using canOpenURL to check if an app is installed, which must be listed in info\.plist, with a maximum of 50 entries\).
1. Using MAC Address as UUID, but this was later banned.
2. [Finger Printing \(Canvas/User-Agent‚Ä¶\)](https://medium.com/@ravielakshmanan/web-browser-uniqueness-and-fingerprinting-7eac3c381805){:target="_blank"}: I haven't researched this, but this method is mainly used to generate the same UUID for Safari and apps, [Deferred Deep Linking](https://www.jianshu.com/p/fa48387d56ea){:target="_blank"} \(for delayed deep linking\) using [AmIUnique?](https://amiunique.org/){:target="_blank"}.
3. [**ID** entifier **F** or **V** endor](https://www.jianshu.com/p/b810d7e007ad){:target="_blank"} \(IDFV\): Currently the mainstream solutionüèÜ. The concept is that Apple generates UUIDs for users based on the prefix of your Bundle ID. The same prefix will generate the same UUID, for example: com\.518\.work/com\.518\.job will receive the same UUID on the same device. As stated in the original text, ID For Vendor, Apple considers apps with the same prefix to be from the same vendor, so sharing UUIDs is permitted.

#### **ID** entifier **F** or **V** endor \(IDFV\)Ôºö
```swift
let DEVICE_UUID:String = UIDevice.current.identifierForVendor?.uuidString ?? UUID().uuidString
```

**Note:** When all apps from the same vendor are removed and then reinstalled, a new UUID will be generated \(** If both com\.518\.work and com\.518\.job are deleted, reinstalling com\.518\.work will generate a new UUID **\)** 
**Similarly, if you only have one app, deleting and reinstalling it will generate a new UUID.**

Due to this characteristic, our company's other apps use Key-Chain to solve this problem. After listening to the speaker's advice, I have verified that this approach is correct!

**The process is as follows:**


![Key\-Chain UUIDÊ¨Ñ‰ΩçÊúâÂÄºÊôÇÂèñÂÄºÔºåÁÑ°ÂâáÂèñIDFAÁöÑUUIDÂÄº‰∏¶ÂõûÂØ´](/assets/a4bc3bce7513/1*-8rufG1QW-J5tn6ZadT17A.jpeg)

Retrieve the value from the Key-Chain UUID field if it has a value; if not, take the UUID value from IDFA and write it back.

Key-Chain writing method:
```swift
if let data = DEVICE_UUID.data(using: .utf8) {
    let query = [
        kSecClass as String       : kSecClassGenericPassword as String,
        kSecAttrAccount as String : "DEVICE_UUID",
        kSecValueData as String   : data ] as [String : Any]
    
    SecItemDelete(query as CFDictionary)
    SecItemAdd(query as CFDictionary, nil)
}
```

Key-Chain reading method:
```swift
let query = [
    kSecClass as String       : kSecClassGenericPassword,
    kSecAttrAccount as String : "DEVICE_UUID",
    kSecReturnData as String  : kCFBooleanTrue,
    kSecMatchLimit as String  : kSecMatchLimitOne ] as [String : Any]

var dataTypeRef: AnyObject? = nil
let status: OSStatus = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
if status == noErr,let dataTypeRef = dataTypeRef as? Data,let uuid = String(data:dataTypeRef, encoding: .utf8) {
   //uuid
} 
```

If you find Key-Chain operations too cumbersome, you can encapsulate them yourself or use third-party libraries.
#### Complete CODE:
```swift
let DEVICE_UUID:String = {
    let query = [
        kSecClass as String       : kSecClassGenericPassword,
        kSecAttrAccount as String : "DEVICE_UUID",
        kSecReturnData as String  : kCFBooleanTrue,
        kSecMatchLimit as String  : kSecMatchLimitOne ] as [String : Any]
    
    var dataTypeRef: AnyObject? = nil
    let status: OSStatus = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
    if status == noErr,let dataTypeRef = dataTypeRef as? Data,let uuid = String(data:dataTypeRef, encoding: .utf8) {
        return uuid
    } else {
        let DEVICE_UUID:String = UIDevice.current.identifierForVendor?.uuidString ?? UUID().uuidString
        if let data = DEVICE_UUID.data(using: .utf8) {
            let query = [
                kSecClass as String       : kSecClassGenericPassword as String,
                kSecAttrAccount as String : "DEVICE_UUID",
                kSecValueData as String   : data ] as [String : Any]
        
            SecItemDelete(query as CFDictionary)
            SecItemAdd(query as CFDictionary, nil)
        }
        return DEVICE_UUID
    }
}()
```

```markdown
Because I need to reference it in other Extension Targets, I directly encapsulated it as a closure parameter for use.

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-uuid-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B-swift-ios-6-a4bc3bce7513){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```
