---
author: ZhgChgLi
categories:
- ZRealm Dev.
date: 2018-10-25T14:26:20.002+0000
description: Discover how iOS developers solve device identification challenges using
  UUID in Swift, ensuring reliable app performance and user tracking across iOS versions.
image:
  path: /assets/a4bc3bce7513/1*gEmmuDOD92d2b2fLp4AKsw.jpeg
last_modified_at: 2024-04-13T07:21:43.386+0000
render_with_liquid: false
tags:
- english
- iplayground
- swift
- ios app development
- uuid
- idfv
title: iOS UUID ExplainedÔΩúSwift Techniques for Unique Device Identification
---

### All About iOS UUID (Swift/iOS ‚â• 6)

iPlayground 2018 Returns & The Story of UUIDs

### Preface:

Last Saturday and Sunday, I attended the [iPlayground](https://iplayground.io/){:target="_blank"} Apple software developer conference. A colleague passed the event information to me, and I wasn't familiar with it before going.

![](/assets/a4bc3bce7513/1*gEmmuDOD92d2b2fLp4AKsw.jpeg)

After two days, the entire event and schedule ran smoothly. The agenda included:

1. Fun: Bicycles, Withering Code, iOS/API Evolution, Where's Wally (CoreML Vision)

2. Practical: Testing types (XCUITest, dependency injection), alternatives to SpriteKit for animation effects, GraphQL

3. Kung Fu: In-Depth Analysis of Swift, iOS Jailbreak/Tweak Development, Redux

Bicycle Project was impressive, using an iPhone as a sensor to detect pedal rotation. The presenter rode the bike on stage to switch slides (the main goal was to create an open-source version of Zwift, and they also shared many pitfalls, such as Client/Server communication, latency issues, and magnetic interference).

Withering Dirty Code; it resonates deeply and brings a knowing smile; technical debt accumulates this way‚Äîrushed development leads to quick but poor architecture, and successors have no time to refactor, so it piles up more and more; in the end, sometimes the only option is to abandon that path entirely.

Test Classes (Design Patterns in XCUITest) [KKBOX Seniors](https://www.facebook.com/TestingWithKK/){:target="_blank"} openly share their methods, code examples, common pitfalls, and solutions without holding anything back. This session is one of the most helpful for our work. Testing is an area I have always wanted to improve, so I can go back and study it thoroughly.

I really wanted to go on stage and share during the Lighting Talk session while listening from the audience üòÇ Next time, I need to prepare earlier!

The official party after the event offered generous drinks, food, and venue. Listening to the honest stories from senior colleagues was not only relaxed and fun but also a great way to gain valuable workplace soft skills.

![NTU Backend Cafe](/assets/a4bc3bce7513/1*Xwk_96lVKcMKgeL7IOC70g.jpeg)

NTU Backend Cafe

I just found out this is the first edition. I‚Äôm truly honored to participate. Thanks to all the staff and speakers for their hard work!

The purpose of attending a seminar is essentially to: **broaden your horizons** by absorbing new knowledge, understanding the ecosystem, and encountering topics you don‚Äôt usually engage with, and **deepen your expertise** by reviewing familiar topics to see if you‚Äôve missed anything or discovered alternative approaches.

I took many notes to review and study at my own pace later.

### All About UUIDs

Because I immediately applied it to the app after listening; this class was taught by senior Zonble. When I heard about development from iPhone OS 2 to iOS 12, I was amazed. Since I started late in the industry, I began coding from iOS 11/Swift 4, so I didn't experience the chaotic period when Apple changed APIs.

It's quite reasonable that UUIDs can be blocked; if used properly, they help identify user devices, support advertising, or enable third parties to perform unique ad targeting. However, if a company has malicious intent, they can use this mechanism to backtrack and learn about the phone owner. For example, if you have travel apps, Taipei bus apps, BMW apps, and baby care apps installed, they can infer that you often travel abroad, have children, and live in Taipei. Combined with personal data you enter in apps, the potential misuse is unimaginable.

But this also affected many legitimate users. For example, those who used UUID as the data decryption key for users or as a device identifier were greatly impacted. I really admire the engineers from that time‚Äîthey had to quickly come up with alternative solutions while dealing with furious bosses and users.

#### Alternative solutions:

This article focuses on obtaining the UUID to identify a device uniquely. If you want alternatives to find out which apps a user has installed, you can refer to the following keyword search methods: [UIPasteboard pasteboardWithName: create: (using the clipboard to share data between apps)](https://link.medium.com/YTheNPnHH7){:target="_blank"}, canOpenURL:, info.plist LSApplicationQueriesSchemes (using canOpenURL to check if an app is installed, must be listed in info.plist, up to 50 entries).

1. Using MAC Address as UUID, but later got banned

2. [Finger Printing (Canvas/User-Agent‚Ä¶)](https://medium.com/@ravielakshmanan/web-browser-uniqueness-and-fingerprinting-7eac3c381805){:target="_blank"}: Not researched, but mainly used to generate the same UUID for Safari and the app, used for [Deferred Deep Linking](https://www.jianshu.com/p/fa48387d56ea){:target="_blank"}  
   [AmIUnique?](https://amiunique.org/){:target="_blank"}

3. [**ID**entifier **F**or **V**endor](https://www.jianshu.com/p/b810d7e007ad){:target="_blank"} (IDFV): The current mainstream solution üèÜ  
   The concept is that Apple generates a UUID for the user based on the Bundle ID prefix. Apps with the same Bundle ID prefix will get the same UUID on the same device. For example: com.518.work / com.518.job will receive the same UUID on the same device.  
   As the original term "ID For Vendor" suggests, Apple treats apps with the same prefix as from the same vendor, so sharing the UUID is allowed.

#### **ID**entifier **F**or **V**endor (IDFV):

```swift
let DEVICE_UUID:String = UIDevice.current.identifierForVendor?.uuidString ?? UUID().uuidString
```

**Note: When all apps from the same vendor are removed and then reinstalled, a new UUID will be generated (** if both com.518.work and com.518.job are deleted, reinstalling com.518.work will generate a new UUID **)**  
**Similarly, if you have only one app, deleting and reinstalling it will generate a new UUID**

Because of this feature, our company's other apps use Key-Chain to solve this problem. After listening to the senior speaker's advice, we confirmed that this approach is correct!

**Process as follows:**

![When the Key-Chain UUID field has a value, use it; otherwise, use the IDFA UUID value and write it back](/assets/a4bc3bce7513/1*-8rufG1QW-J5tn6ZadT17A.jpeg)

When the Key-Chain UUID field has a value, use it; otherwise, take the IDFA UUID value and write it back.

Key-Chain Writing Method:

```swift
if let data = DEVICE_UUID.data(using: .utf8) {
    let query = [
        kSecClass as String       : kSecClassGenericPassword as String,
        kSecAttrAccount as String : "DEVICE_UUID",
        kSecValueData as String   : data ] as [String : Any]
    
    SecItemDelete(query as CFDictionary) // Delete existing item
    SecItemAdd(query as CFDictionary, nil) // Add new item
}
```

Key-Chain Reading Method:

```swift
let query = [
    kSecClass as String       : kSecClassGenericPassword,
    kSecAttrAccount as String : "DEVICE_UUID",
    kSecReturnData as String  : kCFBooleanTrue,
    kSecMatchLimit as String  : kSecMatchLimitOne ] as [String : Any]

var dataTypeRef: AnyObject? = nil
let status: OSStatus = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
if status == noErr,let dataTypeRef = dataTypeRef as? Data,let uuid = String(data:dataTypeRef, encoding: .utf8) {
   //uuid
} 
```

If you find Key-Chain operations too cumbersome, you can encapsulate them yourself or use third-party libraries.

#### Complete CODE:

```swift
let DEVICE_UUID:String = {
    let query = [
        kSecClass as String       : kSecClassGenericPassword,
        kSecAttrAccount as String : "DEVICE_UUID",
        kSecReturnData as String  : kCFBooleanTrue,
        kSecMatchLimit as String  : kSecMatchLimitOne ] as [String : Any]
    
    var dataTypeRef: AnyObject? = nil
    let status: OSStatus = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
    if status == noErr,let dataTypeRef = dataTypeRef as? Data,let uuid = String(data:dataTypeRef, encoding: .utf8) {
        return uuid
    } else {
        let DEVICE_UUID:String = UIDevice.current.identifierForVendor?.uuidString ?? UUID().uuidString
        if let data = DEVICE_UUID.data(using: .utf8) {
            let query = [
                kSecClass as String       : kSecClassGenericPassword as String,
                kSecAttrAccount as String : "DEVICE_UUID",
                kSecValueData as String   : data ] as [String : Any]
        
            SecItemDelete(query as CFDictionary)
            SecItemAdd(query as CFDictionary, nil)
        }
        return DEVICE_UUID
    }
}()
```

Because I need to reference it in other Extension Targets as well, I directly wrapped it as a closure parameter for use.

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

*[Post](https://medium.com/zrealm-ios-dev/ios-uuid-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B-swift-ios-6-a4bc3bce7513){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*