---
title: "iOS UIViewController Transition Matters"
author: "ZhgChgLi"
date: 2020-01-11T18:41:06.640+0000
last_modified_at: 2024-04-13T08:06:12.951+0000
categories: ["ZRealm Dev."]
tags: ["ios","ios-app-development","swift","uiviewcontroller","mobile-app-development"]
description: "A comprehensive explanation of the pull-down to dismiss, pull-up to appear, and full-page swipe to go back effects in UIViewController."
image:
  path: /assets/14cee137c565/1*6IQTrlT4vIKR-NjLRsvZ-A.gif
render_with_liquid: false
---

### iOS UIViewController Transition Matters

A comprehensive explanation of the pull-down to dismiss, pull-up to appear, and full-page swipe to go back effects in UIViewController.

### Introduction


![](/assets/14cee137c565/1*6IQTrlT4vIKR-NjLRsvZ-A.gif)


I have always been curious about how commonly used apps like Facebook, Line, and Spotify implement effects such as "pull down to dismiss a presented UIViewController," "pull up to fade in a UIViewController," and "full-page gesture swipe to go back."

These effects are not built-in; the pull-down to dismiss feature only received system card style support starting from iOS ≥ 13.
#### Exploration Journey

I couldn't find practical implementations of these features, possibly due to not using the right keywords or the information being hard to find. The resources I found were vague and scattered, so I had to piece things together.

Initially, while researching, I discovered the `UIPresentationController` API. Without delving deeper into other resources, I used this method along with `UIPanGestureRecognizer` to crudely achieve the pull-down to dismiss effect; I always felt something was off and that there had to be a better way.

Recently, while working on a new project, I came across [an article by a great author](https://imnotyourson.com/draggable-view-controller-interactive-view-controller/){:target="_blank"} that broadened my perspective and revealed other APIs that offer more elegant and flexible solutions.

> _This article serves as a personal record and aims to help friends who share the same confusion._ 
 

> _The content is a bit lengthy; if you find it tedious, you can scroll down to see the examples or directly download the GitHub project to study!_ 




### iOS 13 Card Style Presentation

First, let's discuss the built-in effects in the latest system.
After iOS ≥ 13, the default `modalPresentationStyle` effect of `UIViewController.present(_:animated:completion:)` is `UIModalPresentationAutomatic`, which presents the view in card style. If you want to maintain the previous full-screen presentation, you need to explicitly specify `UIModalPresentationFullScreen`.

![Built-in calendar add effect](/assets/14cee137c565/1*j0NeJfAuR2fXP56KWglS7Q.gif)

Built-in calendar add effect
#### How to Cancel Pull-Down Dismiss? Confirmation to Close?

A better user experience should allow checking for unsaved input when triggering a pull-down dismiss. If there is data, the user should be prompted whether to discard the action and leave.

Apple has already thought of this for us; we just need to implement the methods in `UIAdaptivePresentationControllerDelegate`.
```swift
import UIKit

class DetailViewController: UIViewController {
    private var onEdit:Bool = true;
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Set the delegate
        self.presentationController?.delegate = self
        // If UIViewController is embedded in a UINavigationController:
        // self.navigationController?.presentationController?.delegate = self
        
        // Cancel pull-down dismiss method (1):
        self.isModalInPresentation = true;
        
    }
    
}

// Delegate implementation
extension DetailViewController: UIAdaptivePresentationControllerDelegate {
    // Cancel pull-down dismiss method (2):
    func presentationControllerShouldDismiss(_ presentationController: UIPresentationController) -> Bool {
        return false;
    }
    
    // When the pull-down dismiss is canceled, the pull gesture is triggered
    func presentationControllerDidAttemptToDismiss(_ presentationController: UIPresentationController) {
        if (onEdit) {
          let alert = UIAlertController(title: "Data not saved", message: nil, preferredStyle: .actionSheet)
          alert.addAction(UIAlertAction(title: "Discard and Leave", style: .default) { _ in
              self.dismiss(animated: true)
          })
          alert.addAction(UIAlertAction(title: "Continue Editing", style: .cancel, handler: nil))
          self.present(alert, animated: true)      
        } else {
          self.dismiss(animated: true, completion: nil)
        }
    }
}
```

```markdown
To cancel the dismissal by pulling down, you can either set the `isModalInPresentation` variable of the `UIViewController` to false or implement the `UIAdaptivePresentationControllerDelegate` method `presentationControllerShouldDismiss` and return `true`. Either option works.

The method `UIAdaptivePresentationControllerDelegate presentationControllerDidAttemptToDismiss` is only called when **the pull-down dismissal is canceled**.

#### By the way…

The card style presentation page is considered a `Sheet` by the system, which behaves differently from `FullScreen`.

> _Assuming today that the `RootViewController` is `HomeViewController`_

> _In card style presentation \(UIModalPresentationAutomatic\):_

> When `HomeViewController` _presents `DetailViewController`…_

> `HomeViewController` **_will not trigger `viewWillDisappear` / `viewDidDisappear`._**

> _When `DetailViewController` is dismissed…_

> `HomeViewController` **_will not trigger `viewWillAppear` / `viewDidAppear`._**

> _⚠️ **Since XCODE 11, iOS ≥ 13 apps packaged will default to using card style presentation \(UIModalPresentationAutomatic\)**_

> _**If you previously placed some logic in `viewWillAppear`/`viewWillDisappear`/`viewDidAppear`/`viewDidDisappear`, be sure to check it carefully!** ⚠️_

> After reviewing the built-in system features, let's look at the main event of this article! How to implement these effects yourself?

### Where can transition animations be done?

First, let's organize where window switching transition animations can be performed.

![UITabBarController/UIViewController/UINavigationController](/assets/14cee137c565/1*G0us0AtYJCy3va1sh_bWhQ.gif)

UITabBarController/UIViewController/UINavigationController
#### Switching in UITabBarController

We can set the `delegate` in `UITabBarController` and implement the `animationControllerForTransitionFrom` method to apply custom transition effects to the content when switching `UITabBarController`.

The system defaults to no animation, and the image above shows a fade-in and fade-out transition effect.
```swift
import UIKit

class MainTabBarViewController: UITabBarController {

    override func viewDidLoad() {
        super.viewDidLoad()
        self.delegate = self
        
    }
    
}

extension MainTabBarViewController: UITabBarControllerDelegate {
    func tabBarController(_ tabBarController: UITabBarController, animationControllerForTransitionFrom fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        //return UIViewControllerAnimatedTransitioning
    }
}
```
#### Present/Dismiss of UIViewController

Naturally, when presenting or dismissing a `UIViewController`, you can specify the animation effects to apply; otherwise, this article wouldn't exist XD. However, it is worth mentioning that if you simply want to create a present animation without gesture control, you can directly use `UIPresentationController` for convenience and speed \(see reference materials at the end\).
```

The system defaults to appearing with a slide up and disappearing with a slide down! If you customize it, you can add effects like fade-in, rounded corners, and control over the appearance position, among others.
```swift
import UIKit

class HomeAddViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        self.modalPresentationStyle = .custom
        self.transitioningDelegate = self
    }
    
}

extension HomeAddViewController: UIViewControllerTransitioningDelegate {
    
    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        // Return nil to use the default animation
        return //UIViewControllerAnimatedTransitioning animation to apply when presenting
    }
    
    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        // Return nil to use the default animation
        return //UIViewControllerAnimatedTransitioning animation to apply when dismissing
    }
}
```


> _Any `UIViewController` can implement `transitioningDelegate` to specify `Present/Dismiss` animations; `UITabBarViewController`, `UINavigationController`, `UITableViewController`, etc. can all do this._




#### When Pushing/Popping with UINavigationController

`UINavigationController` is probably the least likely to require animation changes, as the system's default left swipe to appear and right swipe to return animation is already the best effect. Customizing this part might be used to create seamless left and right switching effects for `UIViewController`.

Since we want to enable gesture-based returns for the entire page, we need to implement a custom POP animation, so we need to create a return animation effect ourselves.
```swift
import UIKit

class HomeNavigationController: UINavigationController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.delegate = self
    }

}

extension HomeNavigationController: UINavigationControllerDelegate {
    func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        
        if operation == .pop {
            return //UIViewControllerAnimatedTransitioning animation to apply when returning
        } else if operation == .push {
            return //UIViewControllerAnimatedTransitioning animation to apply when pushing
        }
        
        // Return nil to use the default animation
        return nil
    }
}
```
### Interactive vs Non-Interactive Animations?

Before discussing animation implementation and gesture control, let's first clarify what interactive and non-interactive mean.

```markdown
**Interactive Animation:** Gesture-triggered animations, such as UIPanGestureRecognizer

**Non-interactive Animation:** System-called animations, such as self.present()

### How to Implement Animation Effects?

After discussing where animations can be applied, let's look at how to create animation effects.

We need to implement the `UIViewControllerAnimatedTransitioning` protocol and animate the view within it.

#### General Transition Animation: UIView.animate

Directly use `UIView.animate` for animation handling. At this point, the `UIViewControllerAnimatedTransitioning` needs to implement the `transitionDuration` method to inform the duration of the animation and the `animateTransition` method to implement the animation content.

```swift
import UIKit

class SlideFromLeftToRightTransition: NSObject, UIViewControllerAnimatedTransitioning {
    
    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
        return 0.4
    }
    
    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
        
        // Available parameters:
        // Get the view content of the target UIViewController to be presented:
        let toView = transitionContext.view(forKey: .to)
        // Get the target UIViewController to be presented:
        let toViewController = transitionContext.viewController(forKey: .to)
        // Get the initial frame information of the target UIViewController's view:
        let toInitalFrame = transitionContext.initialFrame(for: toViewController!)
        // Get the final frame information of the target UIViewController's view:
        let toFinalFrame = transitionContext.finalFrame(for: toViewController!)
        
        // Get the current UIViewController's view content:
        let fromView = transitionContext.view(forKey: .from)
        // Get the current UIViewController:
        let fromViewController = transitionContext.viewController(forKey: .from)
        // Get the initial frame information of the current UIViewController's view:
        let fromInitalFrame = transitionContext.initialFrame(for: fromViewController!)
        // Get the final frame information of the current UIViewController's view: (can obtain the final frame from the previous display animation during the closing animation)
        let fromFinalFrame = transitionContext.finalFrame(for: fromViewController!)
        
        // toView.frame.origin.y = UIScreen.main.bounds.size.height
        
        UIView.animate(withDuration: transitionDuration(using: transitionContext), delay: 0, options: [.curveLinear], animations: {
            // toView.frame.origin.y = 0
        }) { (_) in
            if (!transitionContext.transitionWasCancelled) {
                // Animation was not interrupted
            }
            
            // Inform the system that the animation is complete
            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
        }
        
    }
    
}
```

> **_To and From:_** 
 

> _Assuming today `HomeViewController` needs to `Present/Push` `DetailViewController`,_ 
 

> _From = HomeViewController / To = DetailViewController_ 
 

> _When `DetailViewController` needs to `Dismiss/Pop`,_ 
 

> _From = DetailViewController / To = HomeViewController_ 





⚠️⚠️⚠️⚠️⚠️


> _It is officially recommended to use the view from `transitionContext.view` instead of using \.view from `transitionContext.viewController`._ 
 

> _However, there is an issue when performing Present/Dismiss animations with `modalPresentationStyle = .custom`;_ 
 

> _Using `transitionContext.view(forKey: .from)` during Present will return **nil**,_ 
 

> _and using `transitionContext.view(forKey: .to)` during Dismiss will also return **nil**;_ 
 

> _You still need to get the value from viewController\.view._ 





⚠️⚠️⚠️⚠️⚠️


> `transitionContext.completeTransition(!transitionContext.transitionWasCancelled)` _must be called to complete the animation, otherwise the **screen will freeze**;_ 
 

> _However, if `UIView.animate` has no executable animations, it will not call `completion`, causing the aforementioned method to not be called; therefore, it is essential to ensure that the animation will execute (EX: y from 100 to 0)._ 





ℹ️ℹ️ℹ️ℹ️ℹ️


> _For `ToView/FromView` involved in the animation, if the view is complex or there are issues during the animation; you can use `snapshotView(afterScreenUpdates:)` to take a screenshot for animation display. First, take a screenshot and then `transitionContext.containerView.addSubview(snapShotView)` to add it to the layer, then hide the original `ToView/FromView (isHidden = true)`, and at the end of the animation, call `snapShotView.removeFromSuperview()` and restore the original `ToView/FromView (isHidden = true)`._ 




#### Interruptible and Continuable Transition Animations: UIViewPropertyAnimator

Additionally, you can use the new animation class introduced in **iOS ≥ 10** to implement animation effects. 
Choose based on personal preference or the level of detail required for the animation. 
Although the official recommendation is to use `UIViewPropertyAnimator` for interactive animations, **both interactive and non-interactive (gesture-controlled) animations can generally use UIView\.animate**; 
`UIViewPropertyAnimator` allows for interruptible and continuable transition animations, although I am not sure where it can be practically applied. Interested friends can refer to [this article](https://juejin.im/post/5c3aa7ff518825551e285b8d){:target="_blank"}.
```swift
import UIKit

class FadeInFadeOutTransition: NSObject, UIViewControllerAnimatedTransitioning {
    
    private var animatorForCurrentTransition: UIViewImplicitlyAnimating?

    func interruptibleAnimator(using transitionContext: UIViewControllerContextTransitioning) -> UIViewImplicitlyAnimating {
        
        // Return the current transition animator if it exists
        if let animatorForCurrentTransition = animatorForCurrentTransition {
            return animatorForCurrentTransition
        }
        
        // Parameters are the same as mentioned earlier
        
        //fromView.frame.origin.y = 100
        
        let animator = UIViewPropertyAnimator(duration: transitionDuration(using: transitionContext), curve: .linear)
        
        animator.addAnimations {
            //fromView.frame.origin.y = 0
        }
        
        animator.addCompletion { (position) in
            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
        }
        
        // Hold onto the animator
        self.animatorForCurrentTransition = animator
        return animator
    }
    
    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
        return 0.4
    }
    
    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
        // If it's non-interactive, this will run, so let it also run the interactive animation
        let animator = self.interruptibleAnimator(using: transitionContext)
        animator.startAnimation()
    }
    
    func animationEnded(_ transitionCompleted: Bool) {
        // Animation completed, clear
        self.animatorForCurrentTransition = nil
    }
    
}
```

> _In interactive situations (which will be detailed later regarding control), the `interruptibleAnimator` method will be used for animations; in non-interactive situations, the `animateTransition` method will still be used._ 

> _Due to the ability to continue and interrupt, the `interruptibleAnimator` may be called repeatedly; therefore, we need to use a global variable for access and return._ 

**Murmur…**  
Actually, I initially wanted to switch entirely to the new `UIViewPropertyAnimator` and recommend everyone to use the new one, but I encountered a strange issue: when performing a full-page gesture back pop animation, if the gesture is released and the animation returns to its original position, the items in the Navigation Bar above will briefly fade in and out... I couldn't find a solution, but using `UIView.animate` doesn't have this problem; if there's something I missed, feel free to let me know&lt;\( \_ \_ \)&gt;.

![Problem image; + button is for the previous page](/assets/14cee137c565/1*cVg7iZ_rFC2nxm2H5ET1Gg.gif)

Problem image; + button is for the previous page

So just to be safe, let's stick with the old method!

In practice, individual classes will be created based on different animation effects. If you find it cluttered, you can refer to the bundled solution at the end of the article; or group the same coherent (Present+Dismii) animations together.  
#### transitionCoordinator

Additionally, if more detailed control is needed, for example, if a certain component inside the ViewController needs to change in coordination with the transition animation; you can use `transitionCoordinator` in `UIViewController` for collaboration. I didn't use this part; if you're interested, you can refer to [this article](https://kemchenj.github.io/2018-12-24/){:target="_blank"}.  
### How to control animations?

This is what was previously mentioned as "interactive," which is essentially gesture control; this is the most important section of this article, as what we want to achieve is the linkage between gesture operations and transition animations to accomplish the desired pull-down close and full-page return functionality.  
#### Control delegate setup:

Similar to the previous `ViewController` delegate animation design, the class handling interaction also needs to inform the `ViewController` in the delegate.

**UITabBarController: None**  
**UINavigationController (Push/Pop):**  
```swift
import UIKit

class HomeNavigationController: UINavigationController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.delegate = self
    }

}

extension HomeNavigationController: UINavigationControllerDelegate {
    func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        
        if operation == .pop {
            return //UIViewControllerAnimatedTransitioning animation to apply when returning
        } else if operation == .push {
            return //UIViewControllerAnimatedTransitioning animation to apply when pushing
        }
        //Return nil to use the default animation
        return nil
    }
    
    //Add interactive delegate method:
    func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
        //Here we cannot determine if it's Pop or Push, we can only judge from the animation itself
        if animationController is animation applied when pushing {
            return //UIPercentDrivenInteractiveTransition method for controlling push animation interaction
        } else if animationController is animation applied when returning {
            return //UIPercentDrivenInteractiveTransition method for controlling pop animation interaction
        }
        //Return nil to not perform interactive handling
        return nil
    }
}
```

```markdown
**UIViewController (Present/Dismiss):**
```swift
import UIKit

class HomeAddViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        self.modalPresentationStyle = .custom
        self.transitioningDelegate = self
    }
    
}

extension HomeAddViewController: UIViewControllerTransitioningDelegate {
    
    func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
        //return nil means no interactive handling
        return //UIPercentDrivenInteractiveTransition method for controlling interaction during dismissal
    }
    
    func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
        //return nil means no interactive handling
        return //UIPercentDrivenInteractiveTransition method for controlling interaction during presentation
    }
    
    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        //Returning nil means using the default animation
        return //UIViewControllerAnimatedTransitioning animation to apply during presentation
    }
    
    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        //Returning nil means using the default animation
        return //UIViewControllerAnimatedTransitioning animation to apply during dismissal
    }
    
}
```

⚠️⚠️⚠️⚠️⚠️


> _Implementing the interactionControllerFor... methods means that even if the animation is non-interactive (e.g., system calls for transitions like self.present), these methods will still be called for handling; what we need to control is the `wantsInteractiveStart` parameter inside (explained below)._ 




#### Animation Interactive Handling Class UIPercentDrivenInteractiveTransition:

Next, let's discuss the core implementation of `UIPercentDrivenInteractiveTransition`.
```swift
import UIKit

class PullToDismissInteractive: UIPercentDrivenInteractiveTransition {
    
    //The UIView that will control the interactive gesture
    private var interactiveView: UIView!
    //The current UIViewController
    private var presented: UIViewController!
    //The threshold percentage after which the action will be completed, otherwise it will revert
    private let thredhold: CGFloat = 0.4
    
    //Different transition effects may require different information, customizable
    convenience init(_ presented: UIViewController, _ interactiveView: UIView) {
        self.init()
        self.interactiveView = interactiveView
        self.presented = presented
        setupPanGesture()
        
        //Default value, informing the system that the current animation is non-interactive
        wantsInteractiveStart = false
    }

    private func setupPanGesture() {
        let panGesture = UIPanGestureRecognizer(target: self, action: #selector(handlePan(_:)))
        panGesture.maximumNumberOfTouches = 1
        panGesture.delegate = self
        interactiveView.addGestureRecognizer(panGesture)
    }

    @objc func handlePan(_ sender: UIPanGestureRecognizer) {
        switch sender.state {
        case .began:
            //Reset gesture position
            sender.setTranslation(.zero, in: interactiveView)
            //Inform the system that the current interaction is triggered by a gesture
            wantsInteractiveStart = true
            
            //Call the transition effect to be performed when the gesture begins (it won't execute immediately, the system will hold it)
            //If the transition effect has a corresponding animation, it will jump to UIViewControllerAnimatedTransitioning for processing
            // animated must be true, otherwise there will be no animation
            
            //Dismiss:
            self.presented.dismiss(animated: true, completion: nil)
            //Present:
            //self.present(presenting, animated: true)
            //Push:
            //self.navigationController.push(presenting)
            //Pop:
            //self.navigationController.pop(animated: true)
        
        case .changed:
            //Calculate the gesture's sliding position corresponding to the animation completion percentage 0~1
            //The actual calculation method varies depending on the type of animation
            let translation = sender.translation(in: interactiveView)
            guard translation.y >= 0 else {
                sender.setTranslation(.zero, in: interactiveView)
                return
            }
            let percentage = abs(translation.y / interactiveView.bounds.height)
            
            //Update UIViewControllerAnimatedTransitioning animation percentage
            update(percentage)
        case .ended:
            //When the gesture is released, check if the completion percentage exceeds the threshold
            wantsInteractiveStart = false
            if percentComplete >= thredhold {
              //Yes, inform that the animation is complete
              finish()
            } else {
              //No, inform that the animation should revert
              cancel()
            }
        case .cancelled, .failed:
          //On cancellation or error
          wantsInteractiveStart = false
          cancel()
        default:
          wantsInteractiveStart = false
          return
        }
    }
}

//When there are UIScrollView components (UITableView/UICollectionView/WKWebView...) within UIViewController, prevent gesture conflicts
//When the UIScrollView component inside has scrolled to the top, enable the gesture operation for interactive transitions
extension PullToDismissInteractive: UIGestureRecognizerDelegate {
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        if let scrollView = otherGestureRecognizer.view as? UIScrollView {
            if scrollView.contentOffset.y <= 0 {
                return true
            } else {
                return false
            }
        }
        return true
    }
    
}
```

```markdown
[_*Supplementary points on the reason for sender\.setTranslation\( \.zero, in:interactiveView\) &lt;_](https://stackoverflow.com/questions/29558622/pan-gesture-why-need-settranslation-to-zero){:target="_blank"}

We need to implement different Classes based on the effects of different gesture operations; if it is the same continuous operation (Present + Dismiss), it can also be packaged together.

⚠️⚠️⚠️⚠️⚠️


> `wantsInteractiveStart` _**must be in a valid state**; if `wantsInteractiveStart = false` is indicated during the interactive animation, it will cause the screen to freeze;_ 
 

> _You need to exit and re-enter the APP to restore it properly._ 





⚠️⚠️⚠️⚠️⚠️


> _The **isUserInteractionEnabled = true** for interactiveView is also essential_ 
 

> _You can add more settings to ensure this!_ 




### Combination

Once we set up the `Delegate` here and create the `Class`, we can achieve the functionality we want.
Without further ado, let's jump straight to the completed example.
### Custom Pull Down Close Page Effect

The advantage of a custom pull-down is that it supports all iOS versions on the market, allows control over the cover percentage, controls the trigger close position, and customizes animation effects.


![Tap the upper right corner + Present page](/assets/14cee137c565/1*Wz8y5UJSgS0IUN86upSqLw.gif)

Tap the upper right corner + Present page

This is an example of `HomeViewController` presenting `HomeAddViewController` and `HomeAddViewController` dismissing.
```
import UIKit

class HomeViewController: UIViewController {

    @IBAction func addButtonTapped(_ sender: Any) {
        guard let homeAddViewController = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(identifier: "HomeAddViewController") as? HomeAddViewController else {
            return
        }
        
        // The transitioningDelegate can specify whether the target ViewController or the current ViewController handles it
        homeAddViewController.transitioningDelegate = homeAddViewController
        homeAddViewController.modalPresentationStyle = .custom
        self.present(homeAddViewController, animated: true, completion: nil)
    }

}
import UIKit

class HomeAddViewController: UIViewController {

    private var pullToDismissInteractive:PullToDismissInteractive!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Bind transition interactive information
        self.pullToDismissInteractive = PullToDismissInteractive(self, self.view)
    }
    
}

extension HomeAddViewController: UIViewControllerTransitioningDelegate {
    
    func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
        return pullToDismissInteractive
    }
    
    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        return PresentAndDismissTransition(false)
    }
    
    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        return PresentAndDismissTransition(true)
    }
    
    func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
        // No Present gesture operation here
        return nil
    }
}
import UIKit

class PullToDismissInteractive: UIPercentDrivenInteractiveTransition {
    
    private var interactiveView: UIView!
    private var presented: UIViewController!
    private var completion:(() -> Void)?
    private let thredhold: CGFloat = 0.4
    
    convenience init(_ presented: UIViewController, _ interactiveView: UIView,_ completion:(() -> Void)? = nil) {
        self.init()
        self.interactiveView = interactiveView
        self.completion = completion
        self.presented = presented
        setupPanGesture()
        
        wantsInteractiveStart = false
    }

    private func setupPanGesture() {
        let panGesture = UIPanGestureRecognizer(target: self, action: #selector(handlePan(_:)))
        panGesture.maximumNumberOfTouches = 1
        panGesture.delegate = self
        interactiveView.addGestureRecognizer(panGesture)
    }

    @objc func handlePan(_ sender: UIPanGestureRecognizer) {
        switch sender.state {
        case .began:
            sender.setTranslation(.zero, in: interactiveView)
            wantsInteractiveStart = true
            
            self.presented.dismiss(animated: true, completion: self.completion)
        case .changed:
            let translation = sender.translation(in: interactiveView)
            guard translation.y >= 0 else {
                sender.setTranslation(.zero, in: interactiveView)
                return
            }

            let percentage = abs(translation.y / interactiveView.bounds.height)
            update(percentage)
        case .ended:
            if percentComplete >= thredhold {
                finish()
            } else {
                wantsInteractiveStart = false
                cancel()
            }
        case .cancelled, .failed:
            wantsInteractiveStart = false
            cancel()
        default:
            wantsInteractiveStart = false
            return
        }
    }
}

extension PullToDismissInteractive: UIGestureRecognizerDelegate {
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        if let scrollView = otherGestureRecognizer.view as? UIScrollView {
            if scrollView.contentOffset.y <= 0 {
                return true
            } else {
                return false
            }
        }
        return true
    }
    
}
```


This achieves the effect shown in the image. Here, I don't want to complicate the code too much for the sake of teaching, so the code is quite messy and has plenty of room for optimization and integration.


> **_It's worth mentioning…_** 


> _For iOS ≥ 13, if you encounter a UITextView in the View content, during the pull-down close animation, the text content of the UITextView will appear blank during the animation; causing a flicker in the experience [\(video example\)](https://twitter.com/zhgchgli/status/1207851671553892352){:target="_blank"} …_ 


> _The solution here is to use `snapshotView(afterScreenUpdates:)` to take a snapshot during the animation instead of the original View layer._ 




### Full-Screen Right Swipe Back

While searching for a solution that allows a gesture for right swipe back across the entire screen, I found a **tricky** method:
Directly add a `UIPanGestureRecognizer` to the screen and set both the `target` and `action` to the native `interactivePopGestureRecognizer`, `action:handleNavigationTransition`.
[_\*For detailed methods, click here&lt;_](https://juejin.im/entry/5795809dd342d30059ed5c60){:target="_blank"}

That's right! It looks very much like a Private API, and it feels like it would be rejected during review; plus, it's uncertain whether Swift can use it, as it likely relies on Runtime features unique to Objective-C.
#### Let's stick to the formal approach:

Using the method from this article, we handle the `navigationController` POP return ourselves; by adding a full-screen right swipe gesture control along with a custom right swipe animation, we can achieve this!

Other details are omitted; here are the key animation and interaction handling classes:
```
import UIKit

class SwipeBackInteractive: UIPercentDrivenInteractiveTransition {
    
    private var interactiveView: UIView!
    private var navigationController: UINavigationController!

    private let thredhold: CGFloat = 0.4
    
    convenience init(_ navigationController: UINavigationController, _ interactiveView: UIView) {
        self.init()
        self.interactiveView = interactiveView
        
        self.navigationController = navigationController
        setupPanGesture()
        
        wantsInteractiveStart = false
    }

    private func setupPanGesture() {
        let panGesture = UIPanGestureRecognizer(target: self, action: #selector(handlePan(_:)))
        panGesture.maximumNumberOfTouches = 1
        interactiveView.addGestureRecognizer(panGesture)
    }

    @objc func handlePan(_ sender: UIPanGestureRecognizer) {
        
        switch sender.state {
        case .began:
            sender.setTranslation(.zero, in: interactiveView)
            wantsInteractiveStart = true
            
            self.navigationController.popViewController(animated: true)
        case .changed:
            let translation = sender.translation(in: interactiveView)
            guard translation.x >= 0 else {
                sender.setTranslation(.zero, in: interactiveView)
                return
            }

            let percentage = abs(translation.x / interactiveView.bounds.width)
            update(percentage)
        case .ended:
            if percentComplete >= thredhold {
                finish()
            } else {
                wantsInteractiveStart = false
                cancel()
            }
        case .cancelled, .failed:
            wantsInteractiveStart = false
            cancel()
        default:
            wantsInteractiveStart = false
            return
        }
    }
}
```
### Pull-Up Fade-In UIViewController


Pulling up to fade in and pulling down to close on the View creates a transition effect similar to that of a Spotify player!

This part is a bit tedious, but the principle is the same, so I won't post it here. Interested friends can refer to the GitHub example content.

As for what to pay attention to, it's mainly **ensuring that the animation uses “\.curveLinear linear” during the pull-up fade-in; otherwise, there will be issues with the pull-up not being responsive**; the degree of pull and the position displayed are not proportional.
### Completed!


![Completion Image](/assets/14cee137c565/1*RRAVb3p7mZpUCNOpd64-Pw.gif)

Completion Image


> This article is quite long and took me a lot of time to organize and produce. Thank you for your patience in reading it. 



#### Full GitHub Example Download:


[![](https://opengraph.githubassets.com/af405b87d71ea95f59b19f5de94bda740a12566ddf86eb5a9b34d2271d53bb20/zhgchgli0718/UIViewControllerTransitionDemo)](https://github.com/zhgchgli0718/UIViewControllerTransitionDemo){:target="_blank"}


**References:**
1. [Draggable view controller? Interactive view controller!](https://imnotyourson.com/draggable-view-controller-interactive-view-controller/){:target="_blank"}
2. [Systematic Study of iOS Animation Part Four: Transition Animation of View Controllers](https://juejin.im/post/5c24745b6fb9a049d5198ce5#18-%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BD%AC%E5%9C%BA){:target="_blank"}
3. [Systematic Study of iOS Animation Part Five: Using UIViewPropertyAnimator](https://juejin.im/post/5c3aa7ff518825551e285b8d){:target="_blank"}
4. [Using UIPresentationController to Create a Simple and Beautiful Bottom Popup Control](https://juejin.im/post/5a9651d25188257a5911f666){:target="_blank"} \(This can be used directly for Present animation effects\)


**If you need to refer to elegant code encapsulation:**
1. Swift: [https://github\.com/Kharauzov/SwipeableCards](https://github.com/Kharauzov/SwipeableCards){:target="_blank"}
2. Objective\-C: [https://github\.com/saiday/DraggableViewControllerDemo](https://github.com/saiday/DraggableViewControllerDemo){:target="_blank"}



If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.



_[Post](https://medium.com/zrealm-ios-dev/ios-uiviewcontroller-%E8%BD%89%E5%A0%B4%E4%BA%8C%E4%B8%89%E4%BA%8B-14cee137c565){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
