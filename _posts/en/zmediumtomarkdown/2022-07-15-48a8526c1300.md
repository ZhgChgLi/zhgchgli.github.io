---
title: "Get Insurance for Multilingual Strings in iOS!"
author: "ZhgChgLi"
date: 2022-07-15T10:10:04.867+0000
last_modified_at: 2024-04-14T02:14:31.859+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","localization","unit-testing","xcode","swift"]
description: "Ensure that the Localizable.strings file is not accidentally corrupted"
image:
  path: /assets/48a8526c1300/1*G2UsVr02o122GxI2o1WbQQ.jpeg
render_with_liquid: false
---

### Get Insurance for Multilingual Strings in iOS!

Use SwifGen & UnitTest to ensure the safety of multilingual operations



![Photo by [Mick Haupt](https://unsplash.com/es/@rocinante_11?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/48a8526c1300/1*G2UsVr02o122GxI2o1WbQQ.jpeg)

Photo by [Mick Haupt](https://unsplash.com/es/@rocinante_11?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Problem
#### Plain Text Files


![](/assets/48a8526c1300/1*9hxfi00_HcXy0wUMIyU8gA.png)


iOS handles multilingual strings through plain text files called Localizable\.strings, unlike Android, which manages them via XML format. This creates a risk of accidentally corrupting or omitting language files during daily development, compounded by the fact that multilingual issues are not checked at Build Time. Problems are often only discovered after deployment when users from a specific region report them, significantly undermining user confidence.

In a previous painful case, developers became so accustomed to writing in Swift that they forgot to add `;` to Localizable\.strings, causing all subsequent strings to break for that language after the missing `;`. A last-minute hotfix was needed to avert disaster.
#### **Multilingual Issues Will Directly Display Keys to Users**


![](/assets/48a8526c1300/1*BwaK_5ac2gxAmrzt4w-oBA.png)


As shown in the image above, if the `DESCRIPTION` Key is omitted, the app will directly display `DESCRIPTION` to the user.
### Checking Requirements
- Correct format check for Localizable\.strings (line endings must include `;`, valid Key-Value pairs)
- Multilingual Keys used in the code must have corresponding definitions in the Localizable\.strings file
- Each language in the Localizable\.strings file must have corresponding Key-Value records
- The Localizable\.strings file must not have duplicate Keys (otherwise Values may be accidentally overwritten)

### Solution
#### Use Swift to Write a Comprehensive Checking Tool

The previous approach was to "[Directly Use Swift to Write Shell Scripts in Xcode!](../41c49a75a743/)" referencing the [Localize 🏁](https://github.com/freshOS/Localize){:target="_blank"} tool to develop a Command Line Tool in Swift for checking multilingual files externally, then placing the script in the Build Phases Run Script to execute checks at Build Time.

**Advantages:** 
The checking program is injected externally, independent of the project, allowing checks to be executed without Xcode or building the project. The checking functionality can pinpoint the exact line in which file; it can also perform formatting functions (sorting multilingual Keys A-Z).

**Disadvantages:** 
Increased Build Time (approximately +3 mins), process divergence, and difficulties in handover and maintenance if the script has issues or needs adjustments based on project structure. Since this part is not within the project, only those who added this check know the entire logic, making it hard for other collaborators to engage with it.


> Interested readers can refer to the previous article. This article mainly introduces a method to achieve checks on Localizable\.strings using XCode 13 + SwiftGen + UnitTest.

```markdown
#### XCode 13 Built-in Build Time Check for Localizable\.strings File Format Validity

![](/assets/48a8526c1300/1*p28LgNGZYh6S8T2s2UH8lg.png)

After upgrading to XCode 13, a built-in feature for checking the format validity of Localizable\.strings files during build time has been added. The testing specifications are quite comprehensive; aside from missing `;`, any extraneous meaningless strings will also be blocked.

#### Using SwiftGen to Replace the Original NSLocalizedString String Access Method

[SwiftGen](https://github.com/SwiftGen/SwiftGen){:target="_blank"} helps us change the original NSLocalizedString string access method to object access, preventing accidental typos or forgetting to declare keys.

[![](https://repository-images.githubusercontent.com/39166950/1826ed00-d6cf-11ea-9736-34829910d1e6)](https://github.com/SwiftGen/SwiftGen){:target="_blank"}

SwiftGen is also a Command Line Tool; however, this tool is quite popular in the industry and has comprehensive documentation and community resources for maintenance, so there’s no need to worry about maintenance issues after introducing this tool.

[**Installation**](https://github.com/SwiftGen/SwiftGen#installation){:target="_blank"}

You can choose the installation method based on your environment or CI/CD service settings. Here, the demo will use the most straightforward CocoaPods installation.

> Please note that SwiftGen is not actually CocoaPods; it does not have any dependencies on the code in your project. Using CocoaPods to install SwiftGen is simply a way to download this Command Line Tool executable.

In the `podfile`, add the swiftgen pod:
```plaintext
pod 'SwiftGen', '~> 6.0'
```

**Init**

After running `pod install`, open Terminal and `cd` to your project:
```bash
/L10NTests/Pods/SwiftGen/bin/swiftGen config init
```

This initializes the `swiftgen.yml` configuration file and opens it:
```yaml
strings:
  - inputs:
      - "L10NTests/Supporting Files/zh-Hant.lproj/Localizable.strings"
    outputs:
      templateName: structured-swift5
      output: "L10NTests/Supporting Files/SwiftGen-L10n.swift"
      params:
        enumName: "L10n"
```

Paste and modify it to fit your project format:

**inputs:** Location of the project's language files (it is recommended to specify the language file for DevelopmentLocalization)

**outputs:** 
**output:** Location of the converted Swift file
**params: enumName:** Object name
**templateName:** Conversion template

You can run `swiftGen template list` to obtain the list of built-in templates.

![flat v\.s\. structured](/assets/48a8526c1300/1*J5ZOMW6BC-fDqSlh-My2Pg.jpeg)

flat v\.s\. structured

The difference is that if the key style is `XXX.YYY.ZZZ`, the flat template will convert it to camel case; the structured template will convert it to an object in the original style `XXX.YYY.ZZZ`.

Pure Swift projects can directly use the built-in templates, but if it is a mixed Swift and Objective-C project, you will need to customize the template yourself:

`flat-swift5-objc.stencil` :
```php
// swiftlint:disable all
// Generated using SwiftGen — https://github.com/SwiftGen/SwiftGen

{% if tables.count > 0 %}
{% set accessModifier %}{% if param.publicAccess %}public{% else %}internal{% endif %}{% endset %}
import Foundation

// swiftlint:disable superfluous_disable_command file_length implicit_return

// MARK: - Strings

{% macro parametersBlock types %}{% filter removeNewlines:"leading" %}
  {% for type in types %}
    {% if type == "String" %}
    _ p{{forloop.counter}}: Any
    {% else %}
    _ p{{forloop.counter}}: {{type}}
    {% endif %}
    {{ ", " if not forloop.last }}
  {% endfor %}
{% endfilter %}{% endmacro %}
{% macro argumentsBlock types %}{% filter removeNewlines:"leading" %}
  {% for type in types %}
    {% if type == "String" %}
    String(describing: p{{forloop.counter}})
    {% elif type == "UnsafeRawPointer" %}
    Int(bitPattern: p{{forloop.counter}})
    {% else %}
    p{{forloop.counter}}
    {% endif %}
    {{ ", " if not forloop.last }}
  {% endfor %}
{% endfilter %}{% endmacro %}
{% macro recursiveBlock table item %}
  {% for string in item.strings %}
  {% if not param.noComments %}
  {% for line in string.translation|split:"\n" %}
  /// {{line}}
  {% endfor %}
  {% endif %}
  {% if string.types %}
  {{accessModifier}} static func {{string.key|swiftIdentifier:"pretty"|lowerFirstWord|escapeReservedKeywords}}({% call parametersBlock string.types %}) -> String {
    return {{enumName}}.tr("{{table}}", "{{string.key}}", {% call argumentsBlock string.types %})
  }
  {% elif param.lookupFunction %}
  {# custom localization function is mostly used for in-app lang selection, so we want the loc to be recomputed at each call for those (hence the computed var) #}
  {{accessModifier}} static var {{string.key|swiftIdentifier:"pretty"|lowerFirstWord|escapeReservedKeywords}}: String { return {{enumName}}.tr("{{table}}", "{{string.key}}") }
  {% else %}
  {{accessModifier}} static let {{string.key|swiftIdentifier:"pretty"|lowerFirstWord|escapeReservedKeywords}} = {{enumName}}.tr("{{table}}", "{{string.key}}")
  {% endif %}
  {% endfor %}
  {% for child in item.children %}
  {% call recursiveBlock table child %}
  {% endfor %}
{% endmacro %}
// swiftlint:disable function_parameter_count identifier_name line_length type_body_length
{% set enumName %}{{param.enumName|default:"L10n"}}{% endset %}
@objcMembers {{accessModifier}} class {{enumName}}: NSObject {
  {% if tables.count > 1 or param.forceFileNameEnum %}
  {% for table in tables %}
  {{accessModifier}} enum {{table.name|swiftIdentifier:"pretty"|escapeReservedKeywords}} {
    {% filter indent:2 %}{% call recursiveBlock table.name table.levels %}{% endfilter %}
  }
  {% endfor %}
  {% else %}
  {% call recursiveBlock tables.first.name tables.first.levels %}
  {% endif %}
}
// swiftlint:enable function_parameter_count identifier_name line_length type_body_length

// MARK: - Implementation Details

extension {{enumName}} {
  private static func tr(_ table: String, _ key: String, _ args: CVarArg...) -> String {
    {% if param.lookupFunction %}
    let format = {{ param.lookupFunction }}(key, table)
    {% else %}
    let format = {{param.bundle|default:"BundleToken.bundle"}}.localizedString(forKey: key, value: nil, table: table)
    {% endif %}
    return String(format: format, locale: Locale.current, arguments: args)
  }
}
{% if not param.bundle and not param.lookupFunction %}

// swiftlint:disable convenience_type
private final class BundleToken {
  static let bundle: Bundle = {
    #if SWIFT_PACKAGE
    return Bundle.module
    #else
    return Bundle(for: BundleToken.self)
    #endif
  }()
}
// swiftlint:enable convenience_type
{% endif %}
{% else %}
// No string found
{% endif %}
```

Here is the translated text while preserving the original Markdown format:

---

The above provides a template collected from the internet and customized to be compatible with Swift and OC. You can create a `flat-swift5-objc.stencil` file and paste the content or [click here to download the \.zip directly](https://gist.github.com/zhgchgli0718/34cc6af6366add93f16632efd5575691/archive/bcccc0fb7367c8f9e58b8453446f0a52631aa8d1.zip){:target="_blank"}.

When using a customized template, you will not use `templateName`, but instead change the declaration to `templatePath`:

`swiftgen.yml` :
```yaml
strings:
  - inputs:
      - "L10NTests/Supporting Files/zh-Hant.lproj/Localizable.strings"
    outputs:
      templatePath: "path/to/flat-swift5-objc.stencil"
      output: "L10NTests/Supporting Files/SwiftGen-L10n.swift"
      params:
        enumName: "L10n"
```

Specify the `templatePath` to the location of the \.stencil template in your project.

**Generator**

After setting it up, you can return to the Terminal and manually run:
```bash
/L10NTests/Pods/SwiftGen/bin/swiftGen
```

Execute the conversion. After the first conversion, please manually drag the converted result file \(SwiftGen\-L10n\.swift\) into the project from Finder for the program to use.

**Run Script**

![](/assets/48a8526c1300/1*jbpXqjsF9kROgIqRQG9JcA.png)

In the project settings \-> Build Phases \-> \+ \-> New Run Script Phase \-> paste:
```bash
if [[ -f "${PODS_ROOT}/SwiftGen/bin/swiftgen" ]]; then
  echo "${PODS_ROOT}/SwiftGen/bin/swiftgen"
  "${PODS_ROOT}/SwiftGen/bin/swiftgen"
else
  echo "warning: SwiftGen is not installed. Run 'pod install --repo-update' to install it."
fi
```

This way, the Generator will run every time you build the project, producing the latest conversion results.

**How to use in CodeBase?**

![](/assets/48a8526c1300/1*8AiJIfqe5C1r9ESbfF-Y7w.png)

```swift
L10n.homeTitle
L10n.homeDescription("ZhgChgLi") // with arg
```

> With Object Access, it is impossible to have typos or situations where keys used in the code are not declared in the Localizable\.strings file.

> However, SwiftGen can only specify generating from a certain language, so it cannot prevent the situation where a key exists in the generated language but is forgotten in other languages; this situation needs to be protected using the UnitTest below.

**Conversion**

Conversion is the most challenging part of this issue because in a completed project that heavily uses `NSLocalizedString`, converting it to the new `L10n.XXX` format is necessary. If there are statements with parameters, it becomes even more complex with `String(format: NSLocalizedString`. Additionally, if there is mixed OC, one must consider that OC syntax differs from Swift.

There is no special solution; you can only write a Command Line Tool yourself. You can refer to the [previous article](../41c49a75a743/) for using Swift to scan the project directory and parse out `NSLocalizedString` with Regex to write a small tool for conversion.

It is recommended to convert one scenario at a time, ensuring it can build before converting the next.
- Swift \-> `NSLocalizedString` without parameters
- Swift \-> `NSLocalizedString` with parameters
- OC \-> `NSLocalizedString` without parameters
- OC \-> `NSLocalizedString` with parameters

#### Use UnitTest to check for missing keys and duplicates between language files and the main language file.

We can read the contents of the `.strings` file from the Bundle by writing a UniTest and test it.

**Reading `.strings` from Bundle and converting it to an object:**
```swift
class L10NTestsTests: XCTestCase {
    
    private var localizations: [Bundle: [Localization]] = [:]
    
    override func setUp() {
        super.setUp()
        
        let bundles = [Bundle(for: type(of: self))]
        
        //
        bundles.forEach { bundle in
            var localizations: [Localization] = []
            
            bundle.localizations.forEach { lang in
                var localization = Localization(lang: lang)
                
                if let lprojPath = bundle.path(forResource: lang, ofType: "lproj"),
                   let lprojBundle = Bundle(path: lprojPath) {
                    
                    let filesInLPROJ = (try? FileManager.default.contentsOfDirectory(atPath: lprojBundle.bundlePath)) ?? []
                    localization.localizableStringFiles = filesInLPROJ.compactMap { fileFullName -> L10NTestsTests.Localization.LocalizableStringFile? in
                        let fileName = URL(fileURLWithPath: fileFullName).deletingPathExtension().lastPathComponent
                        let fileExtension = URL(fileURLWithPath: fileFullName).pathExtension
                        guard fileExtension == "strings" else { return nil }
                        guard let path = lprojBundle.path(forResource: fileName, ofType: fileExtension) else { return nil }
                        
                        return L10NTestsTests.Localization.LocalizableStringFile(name: fileFullName, path: path)
                    }
                    
                    localization.localizableStringFiles.enumerated().forEach { (index, localizableStringFile) in
                        if let fileContent = try? String(contentsOfFile: localizableStringFile.path, encoding: .utf8) {
                            let lines = fileContent.components(separatedBy: .newlines)
                            let pattern = "\"(.*)\"(\\s*)(=){1}(\\s*)\"(.+)\";"
                            let regex = try? NSRegularExpression(pattern: pattern, options: [])
                            let values = lines.compactMap { line -> Localization.LocalizableStringFile.Value? in
                                let range = NSRange(location: 0, length: (line as NSString).length)
                                guard let matches = regex?.firstMatch(in: line, options: [], range: range) else { return nil }
                                let key = (line as NSString).substring(with: matches.range(at: 1))
                                let value = (line as NSString).substring(with: matches.range(at: 5))
                                return Localization.LocalizableStringFile.Value(key: key, value: value)
                            }
                            localization.localizableStringFiles[index].values = values
                        }
                    }
                    
                    localizations.append(localization)
                }
            }
            
            self.localizations[bundle] = localizations
        }
    }
}

private extension L10NTestsTests {
    struct Localization: Equatable {
        struct LocalizableStringFile {
            struct Value {
                let key: String
                let value: String
            }
            
            let name: String
            let path: String
            var values: [Value] = []
        }
        
        let lang: String
        var localizableStringFiles: [LocalizableStringFile] = []
        
        static func == (lhs: Self, rhs: Self) -> Bool {
            return lhs.lang == rhs.lang
        }
    }
}
```

```markdown
We defined a `Localization` to store the extracted data, looking for `lproj` in the `Bundle`, then finding the `.strings` files within it, and using regular expressions to convert multilingual statements into objects to be placed back into `Localization` for subsequent testing purposes.

**Here are a few points to note:**
- Use `Bundle(for: type(of: self))` to obtain resources from the Test Target.
- Remember to set the Test Target's [STRINGS_FILE_OUTPUT_ENCODING](https://developer.apple.com/forums/thread/71779){:target="_blank"} to `UTF-8`, otherwise reading the file content using String will fail (the default will be Binary).
- The reason for using String instead of NSDictionary is that we need to test for duplicate keys; using NSDictionary would overwrite duplicate keys during reading.
- Remember to add the `.strings` file to the Test Target.

![](/assets/48a8526c1300/1*ERr-ef6R7dFHo1ucU6cPOQ.png)

**TestCase 1. Test for duplicate key definitions within the same .strings file:**
```swift
func testNoDuplicateKeysInSameFile() throws {
    localizations.forEach { (_, localizations) in
        localizations.forEach { localization in
            localization.localizableStringFiles.forEach { localizableStringFile in
                let keys = localizableStringFile.values.map { $0.key }
                let uniqueKeys = Set(keys)
                XCTAssertTrue(keys.count == uniqueKeys.count, "Localized Strings File: \(localizableStringFile.path) has duplicated keys.")
            }
        }
    }
}
```

Input:

![](/assets/48a8526c1300/1*cB5nXv1wWPzbjAOrKQ835w.png)

Result:

![](/assets/48a8526c1300/1*6qIgcx0EkK7j_R17d6ljuw.png)

**TestCase 2. Check for missing/redundant keys compared to DevelopmentLocalization language:**
```swift
func testCompareWithDevLangHasMissingKey() throws {
    localizations.forEach { (bundle, localizations) in
        let developmentLang = bundle.developmentLocalization ?? "en"
        if let developmentLocalization = localizations.first(where: { $0.lang == developmentLang }) {
            let othersLocalization = localizations.filter { $0.lang != developmentLang }
            
            developmentLocalization.localizableStringFiles.forEach { developmentLocalizableStringFile in
                let developmentLocalizableKeys = Set(developmentLocalizableStringFile.values.map { $0.key })
                othersLocalization.forEach { otherLocalization in
                    if let otherLocalizableStringFile = otherLocalization.localizableStringFiles.first(where: { $0.name == developmentLocalizableStringFile.name }) {
                        let otherLocalizableKeys = Set(otherLocalizableStringFile.values.map { $0.key })
                        if developmentLocalizableKeys.count < otherLocalizableKeys.count {
                            XCTFail("Localized Strings File: \(otherLocalizableStringFile.path) has redundant keys.")
                        } else if developmentLocalizableKeys.count > otherLocalizableKeys.count {
                            XCTFail("Localized Strings File: \(otherLocalizableStringFile.path) has missing keys.")
                        }
                    } else {
                        XCTFail("Localized Strings File not found in Lang: \(otherLocalization.lang)")
                    }
                }
            }
        } else {
            XCTFail("developmentLocalization not found in Bundle: \(bundle)")
        }
    }
}
```

```markdown
Input: \(Compared to DevelopmentLocalization, other languages lack declaration keys\)

![](/assets/48a8526c1300/1*RwO-ploDVoExJmhHRpBXiA.png)

Output:

![](/assets/48a8526c1300/1*Mdt01WLvX2KBtwUhThxOSQ.png)

Input: \(DevelopmentLocalization does not have this key, but it appears in other languages\)

![](/assets/48a8526c1300/1*RwO-ploDVoExJmhHRpBXiA.png)

Output:

![](/assets/48a8526c1300/1*Fr-w-PXEx2N_ftYjfXTa9w.png)

### Summary

In summary, we use:
- The new version of XCode to ensure the correctness of the .strings file format ✅
- SwiftGen to ensure that the CodeBase does not reference multi-language incorrectly or without declaration ✅
- UnitTest to ensure the correctness of multi-language content ✅

[![](https://opengraph.githubassets.com/5e3a8099a333f9bf5a74339f82426afdd235c5a6ca6b9910196a4b961eb2b31a/zhgchgli0718/L10NTests)](https://github.com/zhgchgli0718/L10NTests){:target="_blank"}

#### Advantages:
- Fast execution speed, does not slow down Build Time
- Maintained by any iOS developer

### Advanced
#### Localized File Format

This solution cannot be achieved; we still need to use the original [Command Line Tool written in Swift to achieve it](../41c49a75a743/), but the format part can be done in git pre-commit; if there are no diff adjustments, it will not be done to avoid running it every time we build:
```bash
#!/bin/sh

diffStaged=${1:-\-\-staged} # use $1 if exist, default --staged.

git diff --diff-filter=d --name-only $diffStaged | grep -e 'Localizable.*\.\(strings\|stringsdict\)$' | \
  while read line; do
    // do format for ${line}
done
```
#### \.stringdict

The same principle can also be applied to `.stringdict`
#### CI/CD

SwiftGen does not need to be placed in the build phase, because it runs every time we build, and the code will only appear after the build is complete. It can be changed to generate only when there are adjustments.
#### Clearly identify which key is wrong

The UnitTest program can be optimized to output exactly which key is Missing/Redundant/Duplicate.
#### Use third-party tools to completely free engineers from multi-language work

As mentioned in the previous "[2021 Pinkoi Tech Career Talk — Secrets of an Efficient Engineering Team](../11f6c8568154/)" presentation, in large teams, multi-language work can be divided through third-party services, reducing dependencies in multi-language work.

![](/assets/48a8526c1300/1*YQi4ti2_MfUapUSRKnF5dg.png)

Engineers only need to define the keys, and the multi-language content will be automatically imported from the platform during the CI/CD phase, reducing the manual maintenance stage and minimizing errors.
### Special Thanks

![[Wei Cao](https://www.linkedin.com/in/wei-cao-67b5b315a/){:target="_blank"}, iOS Developer @ Pinkoi](/assets/48a8526c1300/1*CCGSKp2-BvATpDAuRiRuRQ.jpeg)

[Wei Cao](https://www.linkedin.com/in/wei-cao-67b5b315a/){:target="_blank"}, iOS Developer @ Pinkoi

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-%E7%82%BA%E5%A4%9A%E8%AA%9E%E7%B3%BB%E5%AD%97%E4%B8%B2%E8%B2%B7%E4%BB%BD%E4%BF%9D%E9%9A%AA%E5%90%A7-48a8526c1300){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```

It seems there is no Markdown content provided for translation. Please provide the text you would like me to translate.
