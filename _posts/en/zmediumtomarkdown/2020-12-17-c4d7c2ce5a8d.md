---
title: "iOS App Version Numbers Explained"
author: "ZhgChgLi"
date: 2020-12-17T14:33:08.230+0000
last_modified_at: 2024-04-13T08:39:36.458+0000
categories: ["ZRealm Dev."]
tags: ["ios","ios-app-development","software-engineering","version-control","software-development"]
description: "Version number rules and comparison solutions"
image:
  path: /assets/c4d7c2ce5a8d/1*73CuWIMwmWT1ZsJB8K_q5g.jpeg
render_with_liquid: false
---

### iOS App Version Numbers Explained

Version number rules and comparison solutions



![Photo by [James Yarema](https://unsplash.com/@jamesyarema?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/c4d7c2ce5a8d/1*73CuWIMwmWT1ZsJB8K_q5g.jpeg)

Photo by [James Yarema](https://unsplash.com/@jamesyarema?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Introduction

Every iOS app developer encounters two numbers: the Version Number and the Build Number. Recently, I happened to come across a requirement related to version numbers, specifically to prompt users to rate the app based on version number checks. I also explored some details about version numbers; at the end of this document, I will include my comprehensive solution for version number checks.


![[XCode Help](https://help.apple.com/xcode/mac/current/#/devba7f53ad4){:target="_blank"}](/assets/c4d7c2ce5a8d/1*xV13V7U8_SyvK_znwlg1yQ.png)

[XCode Help](https://help.apple.com/xcode/mac/current/#/devba7f53ad4){:target="_blank"}
### Semantic Versioning x\.y\.z

First, let’s introduce the concept of [Semantic Versioning](https://semver.org/lang/zh-TW/){:target="_blank"}, which aims to address issues related to software dependencies and management, such as those we frequently encounter with Cocoapods. For instance, if I am using Moya 4\.0, which depends on Alamofire 2\.0\.0, and Alamofire gets updated—whether it’s a new feature, a bug fix, or a complete architectural overhaul (incompatible with the old version)—without a common consensus on versioning, it can become chaotic, as you won’t know which versions are compatible or upgradable.

**Semantic versioning consists of three parts:** `x.y.z`
- x: Major version \(major\): When you make incompatible API changes
- y: Minor version \(minor\): When you add functionality in a backward-compatible manner
- z: Patch version \(patch\): When you make backward-compatible bug fixes


**General Rules:**
- Must be non-negative integers
- No leading zeros
- Versions starting with 0\.y\.z are for initial development and should not be used for official releases
- Increment numerically


**Comparison Method:**


> _First compare the major version; if they are equal, then compare the minor version; if those are equal, then compare the patch version._ 
 

> _ex: 1\.0\.0 &lt; 2\.0\.0 &lt; 2\.1\.0 &lt; 2\.1\.1_ 





Additionally, you can append "pre-release version information \(ex: 1\.0\.1\-alpha\)" or "build metadata \(ex: 1\.0\.0\-alpha\+001\)" after the patch version, but iOS app version numbers do not allow these formats to be uploaded to the App Store, so I won’t elaborate further. For more details, please refer to [Semantic Versioning](https://semver.org/lang/zh-TW/){:target="_blank"}.

✅: 1\.0\.1, 1\.0\.0, 5\.6\.7
❌: 01\.5\.6, a1\.2\.3, 2\.005\.6
#### Practical Use

Regarding practical use in iOS app version control, since we only serve as markers for release app versions, there are no dependency issues with other apps or software. Therefore, the definitions for practical use can vary by team. Below are my personal thoughts:
- x: Major version \(major\): When there are significant updates (multiple page interface overhauls, major features launched)
- y: Minor version \(minor\): When optimizing or enhancing existing features (adding small features under a major functionality)
- z: Patch version \(patch\): When fixing bugs in the current version

Generally, the revision number is only modified for emergency fixes (Hot Fixes), and under normal circumstances, it remains at 0; if a new version is released, it can be reset to 0.

> _EX: First version release (1.0.0) -> Strengthening the first version's features (1.1.0) -> Discovering issues that need fixing (1.1.1) -> Discovering issues again (1.1.2) -> Continuing to strengthen the first version's features (1.2.0) -> Complete overhaul (2.0.0) -> Discovering issues that need fixing (2.0.1) … and so on._

### Version Number vs. Build Number
#### Version Number (APP Version Number)
- For App Store and external identification
- Property List Key: `CFBundleShortVersionString`
- Content can only consist of numbers and "."
- It is officially recommended to use semantic versioning in the x.y.z format
- 2020121701, 2.0, 2.0.0.1 are all acceptable
(There will be a summary table below that statistics the naming conventions of app version numbers on the App Store)
- Cannot exceed 18 characters
- Incorrect formats can build & run but cannot be packaged and uploaded to the App Store
- Can only increment, cannot repeat, cannot decrement

> _It is generally customary to use semantic versioning in the x.y.z or x.y format._

#### Build Number
- Used for internal development processes and stage identification, not made public to users
- Used for identification when packaging and uploading to the App Store (the same build number cannot be packaged and uploaded again)
- Property List Key: `CFBundleVersion`
- Content can only consist of numbers and "."
- It is officially recommended to use semantic versioning in the x.y.z format
- 1, 2020121701, 2.0, 2.0.0.1 are all acceptable
- Cannot exceed 18 characters
- Incorrect formats can build & run but cannot be packaged and uploaded to the App Store
- Under the same APP version number, it cannot be repeated; conversely, different APP version numbers can be repeated
ex: 1.0.0 build: 1.0.0, 1.1.0 build: 1.0.0 ✅

> _It is generally customary to use dates and numbers (each new version starts from 0), and to use CI/fastlane to automatically increment the build number during packaging._

![](/assets/c4d7c2ce5a8d/1*JhWpjENUxBxtr1_KCi2cBQ.png)

I have made a brief statistic of the version number formats of apps on the rankings, as shown in the image above.

Generally, x.y.z is still the main format.
### Version Number Comparison and Judgment Method

Sometimes we need to use version numbers for judgment, for example: if it is lower than x.y.z, then prompt for a mandatory update; if it equals a certain version, prompt for an invitation to rate. At this time, we need a function to compare two version strings.
#### Simple Method
```swift
let version = "1.0.0"
print(version.compare("1.0.0", options: .numeric) == .orderedSame) // true 1.0.0 = 1.0.0
print(version.compare("1.22.0", options: .numeric) == .orderedAscending) // true 1.0.0 < 1.22.0
print(version.compare("0.0.9", options: .numeric) == .orderedDescending) // true 1.0.0 > 0.0.9
print(version.compare("2", options: .numeric) == .orderedAscending) // true 1.0.0 < 2
```

You can also write a String Extension:
```swift
extension String {
    func versionCompare(_ otherVersion: String) -> ComparisonResult {
        return self.compare(otherVersion, options: .numeric)
    }
}
```

⚠️ However, be aware that if the formats are different, the judgment of equality may be incorrect:
```swift
let version = "1.0.0"
version.compare("1", options: .numeric) //.orderedDescending
```

In reality, we know that 1 == 1.0.0, but using this method of judgment will yield `.orderedDescending`; you can [refer to this article for padding zeros before comparison](https://sarunw.com/posts/how-to-compare-two-app-version-strings-in-swift/){:target="_blank"}; under normal circumstances, once we select the APP version format, it should not change, x.y.z should always be used as x.y.z, not switching between x.y.z and x.y.
#### Complex Method


You can directly use an existing library: [mrackwitz/Version](https://github.com/mrackwitz/Version){:target="_blank"} Below is a reconstruction of the wheel.

In a complex manner, we follow the semantic versioning format x\.y\.z as the specification, using Regex for string parsing and implementing comparison operators ourselves. In addition to the basic =/>/≥/<≤ operators, we also implemented the ~> operator (similar to the version specification method in Cocoapods) and support static input.

**The definition of the ~> operator is:**

Greater than or equal to this version but less than this version (the previous major version number + 1)
```
EX:
~> 1.2.1: (1.2.1 <= version < 1.3) 1.2.3,1.2.4...
~> 1.2: (1.2 <= version < 2) 1.3,1.4,1.5,1.3.2,1.4.1...
~> 1: (1 <= version < 2) 1.1.2,1.2.3,1.5.9,1.9.0...
```
1. **First, we need to define the Version object:**

```swift
@objcMembers
class Version: NSObject {
    private(set) var major: Int
    private(set) var minor: Int
    private(set) var patch: Int

    override var description: String {
        return "\(self.major),\(self.minor),\(self.patch)"
    }

    init(_ major: Int, _ minor: Int, _ patch: Int) {
        self.major = major
        self.minor = minor
        self.patch = patch
    }

    init(_ string: String) throws {
        let result = try Version.parse(string: string)
        self.major = result.version.major
        self.minor = result.version.minor
        self.patch = result.version.patch
    }

    static func parse(string: String) throws -> VersionParseResult {
        let regex = "^(?:(>=|>|<=|<|~>|=|!=){1}\\s*)?(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)$"
        let result = string.groupInMatches(regex)

        if result.count == 4 {
            //start with operator...
            let versionOperator = VersionOperator(string: result[0])
            guard versionOperator != .unSupported else {
                throw VersionUnSupported()
            }
            let major = Int(result[1]) ?? 0
            let minor = Int(result[2]) ?? 0
            let patch = Int(result[3]) ?? 0
            return VersionParseResult(versionOperator, Version(major, minor, patch))
        } else if result.count == 3 {
            //unSpecified operator...
            let major = Int(result[0]) ?? 0
            let minor = Int(result[1]) ?? 0
            let patch = Int(result[2]) ?? 0
            return VersionParseResult(.unSpecified, Version(major, minor, patch))
        } else {
            throw VersionUnSupported()
        }
    }
}

//Supported Objects
@objc class VersionUnSupported: NSObject, Error { }

@objc enum VersionOperator: Int {
    case equal
    case notEqual
    case higherThan
    case lowerThan
    case lowerThanOrEqual
    case higherThanOrEqual
    case optimistic

    case unSpecified
    case unSupported

    init(string: String) {
        switch string {
        case ">":
            self = .higherThan
        case "<":
            self = .lowerThan
        case "<=":
            self = .lowerThanOrEqual
        case ">=":
            self = .higherThanOrEqual
        case "~>":
            self = .optimistic
        case "=":
            self = .equal
        case "!=":
            self = .notEqual
        default:
            self = .unSupported
        }
    }
}

@objcMembers
class VersionParseResult: NSObject {
    var versionOperator: VersionOperator
    var version: Version
    init(_ versionOperator: VersionOperator, _ version: Version) {
        self.versionOperator = versionOperator
        self.version = version
    }
}
```


The Version is essentially a storage for major, minor, and patch components, with a static parsing method for external calls. It can accept formats like `1.0.0` or `≥1.0.1`, making it convenient for string parsing and configuration file parsing.
```
Input: 1.0.0 => Output: .unSpecified, Version(1.0.0)
Input: ≥ 1.0.1 => Output: .higherThanOrEqual, Version(1.0.0)
```

The Regex is modified based on the reference provided in the "[Semantic Versioning Specification](https://semver.org/lang/zh-TW/#%E6%9C%89%E5%BB%BA%E8%AD%B0%E7%94%A8%E6%96%BC%E6%AA%A2%E6%9F%A5%E8%AA%9E%E6%84%8F%E5%8C%96%E7%89%88%E6%9C%AC%E7%9A%84%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E5%BC%8Fregex%E5%97%8E){:target="_blank"}":
```
^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
```

[![](https://regex101.com/preview/r/vkijKf/1/)](https://regex101.com/r/vkijKf/1/){:target="_blank"}

> _\*Considering the project involves mixed Objective-C, it is declared as @objcMembers for compatibility with OC, and we have compromised by using OC-compatible syntax._ 

> _\(In fact, you can directly use enum: String for VersionOperator and tuple/struct for Result\)_ 

> _\*If the implemented object derives from NSObject, remember to implement \!= when implementing Comparable/Equatable ==, as the original NSObject \!= operation may not yield the expected result._ 

**2\. Implementing Comparable Methods:**
```swift
extension Version: Comparable {
    static func < (lhs: Version, rhs: Version) -> Bool {
        if lhs.major < rhs.major {
            return true
        } else if lhs.major == rhs.major {
            if lhs.minor < rhs.minor {
                return true
            } else if lhs.minor == rhs.minor {
                if lhs.patch < rhs.patch {
                    return true
                }
            }
        }

        return false
    }

    static func == (lhs: Version, rhs: Version) -> Bool {
        return lhs.major == rhs.major && lhs.minor == rhs.minor && lhs.patch == rhs.patch
    }

    static func != (lhs: Version, rhs: Version) -> Bool {
        return !(lhs == rhs)
    }

    static func ~> (lhs: Version, rhs: Version) -> Bool {
        let start = Version(lhs.major, lhs.minor, lhs.patch)
        let end = Version(lhs.major, lhs.minor, lhs.patch)

        if end.patch >= 0 {
            end.minor += 1
            end.patch = 0
        } else if end.minor > 0 {
            end.major += 1
            end.minor = 0
        } else {
            end.major += 1
        }
        return start <= rhs && rhs < end
    }

    func compareWith(_ version: Version, operator: VersionOperator) -> Bool {
        switch `operator` {
        case .equal, .unSpecified:
            return self == version
        case .notEqual:
            return self != version
        case .higherThan:
            return self > version
        case .lowerThan:
            return self < version
        case .lowerThanOrEqual:
            return self <= version
        case .higherThanOrEqual:
            return self >= version
        case .optimistic:
            return self ~> version
        case .unSupported:
            return false
        }
    }
}
```


In fact, it is to implement the judgment logic mentioned earlier, and finally open a method called `compareWith` to conveniently allow external parties to directly input the parsing results to obtain the final judgment.

**Usage Example:**
```swift
let shouldAskUserFeedbackVersion = ">= 2.0.0"
let currentVersion = "3.0.0"
do {
  let result = try Version.parse(shouldAskUserFeedbackVersion)
  result.version.compareWith(currentVersion, result.operator) // true
} catch {
  print("version string parse error!")
}
```

**Or…**
```
Version(1,0,0) >= Version(0,0,9) //true...
```


> _Supports `>/≥/</≤/=/!=/~>` operators._ 




### Next Steps

Test cases…
```swift
import XCTest

class VersionTests: XCTestCase {
    func testHigher() throws {
        let version = Version(3, 12, 1)
        XCTAssertEqual(version > Version(2, 100, 120), true)
        XCTAssertEqual(version > Version(3, 12, 0), true)
        XCTAssertEqual(version > Version(3, 10, 0), true)
        XCTAssertEqual(version >= Version(3, 12, 1), true)

        XCTAssertEqual(version > Version(3, 12, 1), false)
        XCTAssertEqual(version > Version(3, 12, 2), false)
        XCTAssertEqual(version > Version(4, 0, 0), false)
        XCTAssertEqual(version > Version(3, 13, 1), false)
    }

    func testLower() throws {
        let version = Version(3, 12, 1)
        XCTAssertEqual(version < Version(2, 100, 120), false)
        XCTAssertEqual(version < Version(3, 12, 0), false)
        XCTAssertEqual(version < Version(3, 10, 0), false)
        XCTAssertEqual(version <= Version(3, 12, 1), true)

        XCTAssertEqual(version < Version(3, 12, 1), false)
        XCTAssertEqual(version < Version(3, 12, 2), true)
        XCTAssertEqual(version < Version(4, 0, 0), true)
        XCTAssertEqual(version < Version(3, 13, 1), true)
    }

    func testEqual() throws {
        let version = Version(3, 12, 1)
        XCTAssertEqual(version == Version(3, 12, 1), true)
        XCTAssertEqual(version == Version(3, 12, 21), false)
        XCTAssertEqual(version != Version(3, 12, 1), false)
        XCTAssertEqual(version != Version(3, 12, 2), true)
    }

    func testOptimistic() throws {
        let version = Version(3, 12, 1)
        XCTAssertEqual(version ~> Version(3, 12, 1), true) //3.12.1 <= $0 < 3.13.0
        XCTAssertEqual(version ~> Version(3, 12, 9), true) //3.12.1 <= $0 < 3.13.0
        XCTAssertEqual(version ~> Version(3, 13, 0), false) //3.12.1 <= $0 < 3.13.0
        XCTAssertEqual(version ~> Version(3, 11, 1), false) //3.12.1 <= $0 < 3.13.0
        XCTAssertEqual(version ~> Version(3, 13, 1), false) //3.12.1 <= $0 < 3.13.0
        XCTAssertEqual(version ~> Version(2, 13, 0), false) //3.12.1 <= $0 < 3.13.0
        XCTAssertEqual(version ~> Version(3, 11, 100), false) //3.12.1 <= $0 < 3.13.0
    }

    func testVersionParse() throws {
        let unSpecifiedVersion = try? Version.parse(string: "1.2.3")
        XCTAssertNotNil(unSpecifiedVersion)
        XCTAssertEqual(unSpecifiedVersion!.version == Version(1, 2, 3), true)
        XCTAssertEqual(unSpecifiedVersion!.versionOperator, .unSpecified)

        let optimisticVersion = try? Version.parse(string: "~> 1.2.3")
        XCTAssertNotNil(optimisticVersion)
        XCTAssertEqual(optimisticVersion!.version == Version(1, 2, 3), true)
        XCTAssertEqual(optimisticVersion!.versionOperator, .optimistic)

        let higherThanVersion = try? Version.parse(string: "> 1.2.3")
        XCTAssertNotNil(higherThanVersion)
        XCTAssertEqual(higherThanVersion!.version == Version(1, 2, 3), true)
        XCTAssertEqual(higherThanVersion!.versionOperator, .higherThan)

        XCTAssertThrowsError(try Version.parse(string: "!! 1.2.3")) { error in
            XCTAssertEqual(error is VersionUnSupported, true)
        }
    }
}
```


Currently, I plan to further optimize the Version, adjust performance testing, organize and package it, and then run the process to create my own Cocoapods.

However, there is already a comprehensive [Version](https://github.com/mrackwitz/Version){:target="_blank"} handling Pod projects, so there is no need to reinvent the wheel; I just want to streamline the creation process XD.

I might also submit a PR for the existing wheel to implement `~>`.

### References:
- [Xcode Help](https://help.apple.com/xcode/mac/current/#/devba7f53ad4){:target="_blank"}
- [Semantic Versioning 2.0.0](https://semver.org/lang/zh-TW/spec/v2.0.0.html){:target="_blank"}
- [How to compare two app version strings in Swift](https://sarunw.com/posts/how-to-compare-two-app-version-strings-in-swift/){:target="_blank"}
- [mrackwitz/Version](https://github.com/mrackwitz/Version){:target="_blank"}



If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.



_[Post](https://medium.com/zrealm-ios-dev/ios-app-%E7%89%88%E6%9C%AC%E8%99%9F%E9%82%A3%E4%BA%9B%E4%BA%8B-c4d7c2ce5a8d){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
