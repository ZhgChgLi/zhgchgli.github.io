---
title: "The Journey of Manually Creating an HTML Parser"
author: "ZhgChgLi"
date: 2023-03-11T17:09:22.165+0000
last_modified_at: 2023-08-05T16:15:39.420+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","html-parsing","nsattributedstring","html","rendering"]
description: "The development record of ZMarkupParser HTML to NSAttributedString rendering engine"
image:
  path: /assets/2724f02f6e7/1*A0yXupXW9-F9ZWe4gp2ObA.jpeg
pin: true
render_with_liquid: false
---

### The Journey of Manually Creating an HTML Parser

The development record of ZMarkupParser HTML to NSAttributedString rendering engine


Tokenization conversion of HTML String, normalization processing, generation of Abstract Syntax Tree, application of Visitor Pattern / Builder Pattern, and some miscellaneous discussions…
#### Continuation

Last year, I published an article titled “[ **TL;DR** ] [Implementing iOS NSAttributedString HTML Render](../a8c2d26cc734/)”, which briefly introduced how to use XMLParser to parse HTML and convert it into NSAttributedString.Key. The structure and ideas in the article were quite disorganized, as it was merely a record of the issues I encountered previously, and I did not spend much time researching this topic at that time.
### Convert HTML String to NSAttributedString

Revisiting this topic, we need to convert the HTML string provided by the API into NSAttributedString and apply the corresponding styles to display it in UITextView/UILabel.

e.g. `<b>Test<a>Link</a></b>` should be displayed as **Test [Link](https://blog.zhgchg.li){:target="_blank"}**
- Note 1
It is not recommended to use HTML as a rendering medium for communication between the app and data, as the HTML specification is too flexible. The app cannot support all HTML styles, and there is no official HTML conversion rendering engine.
- Note 2
Starting from iOS 14, you can use the official native AttributedString to parse Markdown or introduce the apple/swift-markdown Swift Package to parse Markdown.
- Note 3
Due to the large scale of our company's project and the long-term use of HTML as a medium, we cannot fully switch to Markdown or other markup languages at this time.
- **Note 4** 
**The HTML here is not intended to display an entire HTML webpage; it is merely used as a style for rendering string styles in Markdown.** 
**(To render an entire page with complex HTML including images and tables, you still need to use WebView loadHTML)**



> It is strongly recommended to use Markdown as the string rendering medium language. If your project faces the same dilemma as mine and you have to use HTML without an elegant tool for converting to NSAttributedString, please proceed with caution. 





> Friends who remember the previous article can jump directly to the ZhgChgLi / ZMarkupParser section. 




#### NSAttributedString.DocumentType.html

The methods found online for converting HTML to NSAttributedString require us to directly use the options provided by NSAttributedString to render HTML. Here is an example:
```swift
let htmlString = "<b>Test<a>Link</a></b>"
let data = htmlString.data(using: String.Encoding.utf8)!
let attributedOptions:[NSAttributedString.DocumentReadingOptionKey: Any] = [
  .documentType :NSAttributedString.DocumentType.html,
  .characterEncoding: String.Encoding.utf8.rawValue
]
let attributedString = try! NSAttributedString(data: data, options: attributedOptions, documentAttributes: nil)
```

```markdown
**Problems with this approach:**
- Poor performance: This method renders styles through WebView Core and then switches back to the Main Thread for UI display; rendering over 300 characters takes 0.03 seconds.
- Text loss: For example, marketing copy may use `<Congratulation!>`, which will be treated as an HTML tag and removed.
- Lack of customization: For instance, it is not possible to specify the degree of boldness in NSAttributedString corresponding to HTML bold.
- [iOS ≥ 12 has sporadic crashing issues with no official solution](https://developer.apple.com/forums/thread/115405){:target="_blank"}
- In iOS 15, there were [numerous crashes](../a8c2d26cc734/), and testing found that under low battery conditions, it crashes 100% of the time (fixed in iOS ≥ 15.2).
- Long strings cause crashes; testing shows that inputting strings longer than 54,600+ characters results in a 100% crash (EXC_BAD_ACCESS).

The most painful issue for us remains the crashing problem. From the release of iOS 15 until the fix in 15.2, the app was consistently plagued by this issue. Data shows that from March 11, 2022, to June 8, 2022, it caused over 2.4K crashes, affecting more than 1.4K users.

This crashing issue has existed since iOS 12; iOS 15 just hit a bigger pitfall, but I suspect the fix in iOS 15.2 is merely a patch, and the official cannot eliminate it completely.

The second issue is performance. As a string style Markup Language, it is heavily used in UILabel/UITextView in the app. As mentioned earlier, a single label takes 0.03 seconds, and when multiplied across multiple UILabel/UITextView, it results in a laggy user experience.

#### XMLParser

The second solution is introduced in the [previous article](../a8c2d26cc734/), which uses XMLParser to parse into corresponding NSAttributedString keys and apply styles.

You can refer to the implementation of [SwiftRichString](https://github.com/malcommac/SwiftRichString){:target="_blank"} and the content of [the previous article](../a8c2d26cc734/).

> The previous article merely explored the possibility of using XMLParser to parse HTML and perform corresponding conversions, completing an experimental implementation, but it was not designed as a well-structured and extensible "tool."

**Problems with this approach:**
- Error tolerance of 0: `<br>` / `<Congratulation!>` / `<b>Bold<i>Bold+Italic</b>Italic</i>` 
The above three HTML scenarios may cause XMLParser to throw an error and display a blank screen.
- Using XMLParser, the HTML string must fully comply with XML rules and cannot display normally with error tolerance like a browser or NSAttributedString.DocumentType.html.

#### Standing on the Shoulders of Giants

Neither of the above two solutions elegantly solves the HTML problem, so I began searching for existing solutions.
- [johnxnguyen](https://github.com/johnxnguyen){:target="_blank"} / [Down](https://github.com/johnxnguyen/Down){:target="_blank"} 
Only supports inputting Markdown to convert to Any (XML/NSAttributedString…), but does not support inputting HTML for conversion.
- [malcommac](https://github.com/malcommac){:target="_blank"} / [SwiftRichString](https://github.com/malcommac/SwiftRichString){:target="_blank"} 
The underlying implementation uses XMLParser, and the aforementioned cases also exhibit the same error tolerance of 0 issue.
- [scinfu](https://github.com/scinfu){:target="_blank"} / [SwiftSoup](https://github.com/scinfu/SwiftSoup){:target="_blank"} 
Only supports HTML Parser (Selector) [does not support conversion to NSAttributedString](https://github.com/scinfu/SwiftSoup/issues/127){:target="_blank"}.

> After searching extensively, the results are similar to the projects mentioned above. Orz, there are no giants' shoulders to stand on.

### ZhgChgLi/ZMarkupParser
```

```markdown
[![](https://repository-images.githubusercontent.com/602927147/57ce75c1-8548-449c-b44a-f4b0451ed5ea)](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

Without the shoulders of giants, I had to become a giant myself, so I developed an HTML String to NSAttributedString tool.

Developed using pure Swift, it parses HTML tags through Regex and performs tokenization to analyze and correct tag validity (fixing unclosed tags & misplaced tags), then converts it into an abstract syntax tree. Finally, using the Visitor Pattern, it maps HTML tags to abstract styles to obtain the final NSAttributedString result; it does not rely on any parser libraries.
#### Features
- Supports HTML rendering (to NSAttributedString) / Stripper (removing HTML tags) / Selector functionality
- Higher performance than `NSAttributedString.DocumentType.html`
- Automatically analyzes and corrects tag validity (fixing unclosed tags & misplaced tags)
- Supports dynamic style settings from `style="color:red..."`
- Supports custom style specifications, such as how bold should be **bold**
- Supports flexible extensible tags or custom tags and attributes

> For detailed introduction and installation instructions, please refer to this article: "[**ZMarkupParser HTML String to NSAttributedString Tool**](../a5643de271e4/)"

You can directly [git clone the project](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} and open the `ZMarkupParser.xcworkspace` project, select the `ZMarkupParser-Demo` target, and build & run to play around.

![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*PzYcnSkW7qKeJBkaiNTKjQ.gif)

[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}
### Technical Details

Next, I would like to share the technical details regarding the development of this tool.

![Overview of Operation Process](/assets/2724f02f6e7/1*YF5L7gefMCMwU1wmnGgy6A.png)

Overview of Operation Process

The above image shows the general operation process, and the following articles will introduce it step by step along with the code.

> ⚠️️️️️️ This article will simplify the demo code as much as possible, reducing abstraction and performance considerations, focusing on explaining the operational principles; for the final results, please refer to the project [Source Code](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}.

### Code — Tokenization

> a.k.a parser, parsing

When it comes to HTML rendering, the most important aspect is the parsing stage. In the past, HTML was parsed as XML using XMLParser; however, it could not overcome the fact that everyday HTML usage is not 100% XML compliant, which leads to parser errors and cannot be dynamically corrected.

After ruling out the use of XMLParser, the only option left in Swift is to use Regex for matching and parsing.

Initially, I didn't think too much and thought I could directly use regex to extract "paired" HTML tags, then recursively find HTML tags layer by layer until completion; however, this approach does not solve the problem of nested HTML tags or support for fault tolerance with misplaced tags. Therefore, we changed our strategy to extract "single" HTML tags and record whether they are Start Tags, Close Tags, or Self-Closing Tags, along with other strings to form the parsed result array.

**The structure of Tokenization is as follows:**
```swift
enum HTMLParsedResult {
    case start(StartItem) // <a>
    case close(CloseItem) // </a>
    case selfClosing(SelfClosingItem) // <br/>
    case rawString(NSAttributedString)
}

extension HTMLParsedResult {
    class SelfClosingItem {
        let tagName: String
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?
        
        init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) {
            self.tagName = tagName
            self.tagAttributedString = tagAttributedString
            self.attributes = attributes
        }
    }
    
    class StartItem {
        let tagName: String
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?

        // Start Tag may be an abnormal HTML Tag or normal text e.g. <Congratulation!>, after subsequent normalization, if it is found to be an isolated Start Tag, it is marked as True.
        var isIsolated: Bool = false
        
        init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) {
            self.tagName = tagName
            self.tagAttributedString = tagAttributedString
            self.attributes = attributes
        }
        
        // For subsequent normalization automatic padding correction
        func convertToCloseParsedItem() -> CloseItem {
            return CloseItem(tagName: self.tagName)
        }
        
        // For subsequent normalization automatic padding correction
        func convertToSelfClosingParsedItem() -> SelfClosingItem {
            return SelfClosingItem(tagName: self.tagName, tagAttributedString: self.tagAttributedString, attributes: self.attributes)
        }
    }
    
    class CloseItem {
        let tagName: String
        init(tagName: String) {
            self.tagName = tagName
        }
    }
}
```

**The regular expression used is as follows:**
```ruby
<(?:(?<closeTag>\/)?(?<tagName>[A-Za-z0-9]+)(?<tagAttributes>(?:\s*(\w+)\s*=\s*(["|']).*?\5)*)\s*(?<selfClosingTag>\/)?>)
```

\-&gt; [Online Regex101 Playground](https://regex101.com/r/aBrID8/1){:target="_blank"}
- closeTag: Matches &lt; `/` a&gt;
- tagName: Matches &lt; `a` &gt; or , &lt;/ `a` &gt;
- tagAttributes: Matches &lt;a `href=”https://zhgchg.li” style=”color:red”` &gt;
- selfClosingTag: Matches &lt;br `/` &gt;

> \*This regular expression can be further optimized and will be addressed later.

> Additional information about the regular expression is provided in the latter part of the article for those interested.

**Combined, it becomes:**
```swift
var tokenizationResult: [HTMLParsedResult] = []

let expression = try? NSRegularExpression(pattern: pattern, options: expressionOptions)
let attributedString = NSAttributedString(string: "<a>Li<b>nk</a>Bold</b>")
let totalLength = attributedString.string.utf16.count // utf-16 support emoji
var lastMatch: NSTextCheckingResult?

// Start Tags Stack, First In Last Out (FILO)
// Check if the HTML string needs subsequent normalization to correct misalignment or add Self-Closing Tag
var stackStartItems: [HTMLParsedResult.StartItem] = []
var needForamatter: Bool = false

expression.enumerateMatches(in: attributedString.string, range: NSMakeRange(0, totoalLength)) { match, _, _ in
  if let match = match {
    // Check the string between tags or to the first tag
    // e.g. Test<a>Link</a>zzz<b>bold</b>Test2 - > Test,zzz
    let lastMatchEnd = lastMatch?.range.upperBound ?? 0
    let currentMatchStart = match.range.lowerBound
    if currentMatchStart > lastMatchEnd {
      let rawStringBetweenTag = attributedString.attributedSubstring(from: NSMakeRange(lastMatchEnd, (currentMatchStart - lastMatchEnd)))
      tokenizationResult.append(.rawString(rawStringBetweenTag))
    }

    // <a href="https://zhgchg.li">, </a>
    let matchAttributedString = attributedString.attributedSubstring(from: match.range)
    // a, a
    let matchTag = attributedString.attributedSubstring(from: match.range(withName: "tagName"))?.string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    // false, true
    let matchIsEndTag = matchResult.attributedString(from: match.range(withName: "closeTag"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == "/"
    // href="https://zhgchg.li", nil
    // Use regex to extract HTML attributes, to [String: String], please refer to Source Code
    let matchTagAttributes = parseAttributes(matchResult.attributedString(from: match.range(withName: "tagAttributes")))
    // false, false
    let matchIsSelfClosingTag = matchResult.attributedString(from: match.range(withName: "selfClosingTag"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == "/"

    if let matchAttributedString = matchAttributedString,
       let matchTag = matchTag {
        if matchIsSelfClosingTag {
          // e.g. <br/>
          tokenizationResult.append(.selfClosing(.init(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes)))
        } else {
          // e.g. <a> or </a>
          if matchIsEndTag {
            // e.g. </a>
            // Retrieve the position of the same TagName from the Stack, starting from the last
            if let index = stackStartItems.lastIndex(where: { $0.tagName == matchTag }) {
              // If not the last one, it indicates misalignment or a missing closing tag
              if index != stackStartItems.count - 1 {
                  needForamatter = true
              }
              tokenizationResult.append(.close(.init(tagName: matchTag)))
              stackStartItems.remove(at: index)
            } else {
              // Extra close tag e.g </a>
              // Does not affect subsequent processing, simply ignore
            }
          } else {
            // e.g. <a>
            let startItem: HTMLParsedResult.StartItem = HTMLParsedResult.StartItem(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes)
            tokenizationResult.append(.start(startItem))
            // Push to Stack
            stackStartItems.append(startItem)
          }
        }
     }

    lastMatch = match
  }
}

// Check the ending RawString
// e.g. Test<a>Link</a>Test2 - > Test2
if let lastMatch = lastMatch {
  let currentIndex = lastMatch.range.upperBound
  if totoalLength > currentIndex {
    // There are remaining strings
    let resetString = attributedString.attributedSubstring(from: NSMakeRange(currentIndex, (totoalLength - currentIndex)))
    tokenizationResult.append(.rawString(resetString))
  }
} else {
  // lastMatch = nil, indicates no tags found, all are plain text
  let resetString = attributedString.attributedSubstring(from: NSMakeRange(0, totoalLength))
  tokenizationResult.append(.rawString(resetString))
}

// Check if the Stack is empty, if not, it indicates there are Start Tags without corresponding End Tags
// Mark as isolated Start Tags
for stackStartItem in stackStartItems {
  stackStartItem.isIsolated = true
  needForamatter = true
}

print(tokenizationResult)
// [
//    .start("a",["href":"https://zhgchg.li"])
//    .rawString("Li")
//    .start("b",nil)
//    .rawString("nk")
//    .close("a")
//    .rawString("Bold")
//    .close("b")
// ]
```

```markdown
![The operation flow is shown in the image above](/assets/2724f02f6e7/1*U50CX56M_xy1EXZKb69YeA.png)

The operation flow is shown in the image above.

Ultimately, a Tokenization result array will be obtained.


> Corresponding to the original code in [HTMLStringToParsedResultProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLStringToParsedResultProcessor.swift){:target="_blank"} implementation 




### Normalization — Normalization


> a\.k\.a Formatter, normalization 





Following the previous step of obtaining the preliminary parsing results, if normalization is still needed during parsing, this step is required to automatically correct HTML Tag issues.

**There are three types of HTML Tag issues:**
- HTML Tag but missing Close Tag: e.g. `<br>`
- Regular text being treated as HTML Tag: e.g. `<Congratulation!>`
- HTML Tag misalignment issues: e.g. `<a>Li<b>nk</a>Bold</b>`


The correction method is also quite simple; we need to traverse the elements of the Tokenization result and attempt to fill in the gaps.


![The operation flow is shown in the image above](/assets/2724f02f6e7/1*Wk-U_sQuvLo1OJhcE1BQPQ.png)

The operation flow is shown in the image above.
```swift
var normalizationResult = tokenizationResult

// Start Tags Stack, First In Last Out (FILO)
var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []
var itemIndex = 0
while itemIndex < newItems.count {
    switch newItems[itemIndex] {
    case .start(let item):
        if item.isIsolated {
            // If it is an isolated Start Tag
            if WC3HTMLTagName(rawValue: item.tagName) == nil && (item.attributes?.isEmpty ?? true) {
                // If it is not a WCS defined HTML Tag & has no HTML Attribute
                // Refer to Source Code for WC3HTMLTagName Enum
                // Considered as regular text being treated as HTML Tag
                // Change to raw string type
                normalizationResult[itemIndex] = .rawString(item.tagAttributedString)
            } else {
                // Otherwise, change to self-closing tag, e.g. <br> -> <br/>
                normalizationResult[itemIndex] = .selfClosing(item.convertToSelfClosingParsedItem())
            }
            itemIndex += 1
        } else {
            // Normal Start Tag, add to Stack
            stackExpectedStartItems.append(item)
            itemIndex += 1
        }
    case .close(let item):
        // Encounter Close Tag
        // Get the Tags between Start Stack Tag and this Close Tag
        // e.g <a><u><b>[CurrentIndex]</a></u></b> -> gap 0
        // e.g <a><u><b>[CurrentIndex]</a></u></b> -> gap b,u

        let reversedStackExpectedStartItems = Array(stackExpectedStartItems.reversed())
        guard let reversedStackExpectedStartItemsOccurredIndex = reversedStackExpectedStartItems.firstIndex(where: { $0.tagName == item.tagName }) else {
            itemIndex += 1
            continue
        }
        
        let reversedStackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItems.prefix(upTo: reversedStackExpectedStartItemsOccurredIndex))
        
        // Gap 0 indicates the tag is not misaligned
        guard reversedStackExpectedStartItemsOccurred.count != 0 else {
            // is pair, pop
            stackExpectedStartItems.removeLast()
            itemIndex += 1
            continue
        }
        
        // If there are other gaps, automatically insert the missing Tags
        // e.g <a><u><b>[CurrentIndex]</a></u></b> ->
        // e.g <a><u><b>[CurrentIndex]</b></u></a><b></u></u></b>
        let stackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItemsOccurred.reversed())
        let afterItems = stackExpectedStartItemsOccurred.map({ HTMLParsedResult.start($0) })
        let beforeItems = reversedStackExpectedStartItemsOccurred.map({ HTMLParsedResult.close($0.convertToCloseParsedItem()) })
        normalizationResult.insert(contentsOf: afterItems, at: newItems.index(after: itemIndex))
        normalizationResult.insert(contentsOf: beforeItems, at: itemIndex)
        
        itemIndex = newItems.index(after: itemIndex) + stackExpectedStartItemsOccurred.count
        
        // Update Start Stack Tags
        // e.g. -> b,u
        stackExpectedStartItems.removeAll { startItem in
            return reversedStackExpectedStartItems.prefix(through: reversedStackExpectedStartItemsOccurredIndex).contains(where: { $0 === startItem })
        }
    case .selfClosing, .rawString:
        itemIndex += 1
    }
}

print(normalizationResult)
// [
//    .start("a",["href":"https://zhgchg.li"])
//    .rawString("Li")
//    .start("b",nil)
//    .rawString("nk")
//    .close("b")
//    .close("a")
//    .start("b",nil)
//    .rawString("Bold")
//    .close("b")
// ]
```

> Corresponding to the implementation in the original code at [HTMLParsedResultFormatterProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLParsedResultFormatterProcessor.swift){:target="_blank"} 

### Abstract Syntax Tree

> a\.k\.a AST, Abstract Tree 

After the data preprocessing of Tokenization & Normalization is completed, the next step is to convert the results into an abstract tree🌲.

![As shown above](/assets/2724f02f6e7/1*40z0o7R0OROURWCQVDmKrw.png)

As shown above

Converting to an abstract tree facilitates our future operations and expansions, such as implementing Selector functionality or performing other transformations, like HTML to Markdown; or if we want to add Markdown to NSAttributedString in the future, we only need to implement Markdown's Tokenization & Normalization to achieve that.

**First, we define a Markup Protocol with Child & Parent properties to record information about leaves and branches:**
```swift
protocol Markup: AnyObject {
    var parentMarkup: Markup? { get set }
    var childMarkups: [Markup] { get set }
    
    func appendChild(markup: Markup)
    func prependChild(markup: Markup)
    func accept<V: MarkupVisitor>(_ visitor: V) -> V.Result
}

extension Markup {
    func appendChild(markup: Markup) {
        markup.parentMarkup = self
        childMarkups.append(markup)
    }
    
    func prependChild(markup: Markup) {
        markup.parentMarkup = self
        childMarkups.insert(markup, at: 0)
    }
}
```

Additionally, by using the [Visitor Pattern](../ba5773a7bfea/), each style property is defined as an object Element, and different Visit strategies are used to obtain individual application results.
```swift
protocol MarkupVisitor {
    associatedtype Result
        
    func visit(markup: Markup) -> Result
    
    func visit(_ markup: RootMarkup) -> Result
    func visit(_ markup: RawStringMarkup) -> Result
    
    func visit(_ markup: BoldMarkup) -> Result
    func visit(_ markup: LinkMarkup) -> Result
    //...
}

extension MarkupVisitor {
    func visit(markup: Markup) -> Result {
        return markup.accept(self)
    }
}
```

**Basic Markup Nodes:**
```swift
// Root node
final class RootMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

// Leaf node
final class RawStringMarkup: Markup {
    let attributedString: NSAttributedString
    
    init(attributedString: NSAttributedString) {
        self.attributedString = attributedString
    }
    
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}
```

**Definition of Markup Style Nodes:**
```swift
// Branch Node:

// Link Style
final class LinkMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

// Bold Style
final class BoldMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []
    
    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}
```


> Corresponding implementation of [Markup](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/Markup){:target="_blank"} in the original code 





Before converting to an abstract tree, we still need to…
#### MarkupComponent

**Because our tree structure does not depend on any data structure (for example, a node/LinkMarkup should have URL information to proceed with rendering).**  
**To address this, we define a separate container to store tree nodes and related data information:**
```swift
protocol MarkupComponent {
    associatedtype T
    var markup: Markup { get }
    var value: T { get }
    
    init(markup: Markup, value: T)
}

extension Sequence where Iterator.Element: MarkupComponent {
    func value(markup: Markup) -> Element.T? {
        return self.first(where:{ $0.markup === markup })?.value as? Element.T
    }
}
```


> Corresponding implementation of [MarkupComponent](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/MarkupComponent){:target="_blank"} in the original code 





Markup can also be declared as `Hashable`, allowing values to be stored directly in a Dictionary `[Markup: Any]`, but this means Markup cannot be used as a general type and must be prefixed with `any Markup`.  
#### HTMLTag & HTMLTagName & HTMLTagNameVisitor

We also abstract the HTML Tag Name part, allowing users to decide which Tags need to be processed, facilitating future expansions. For example, the `<strong>` Tag Name can correspond to `BoldMarkup`.
```
public protocol HTMLTagName {
    var string: String { get }
    func accept<V: HTMLTagNameVisitor>(_ visitor: V) -> V.Result
}

public struct A_HTMLTagName: HTMLTagName {
    public let string: String = WC3HTMLTagName.a.rawValue
    
    public init() {
        
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}

public struct B_HTMLTagName: HTMLTagName {
    public let string: String = WC3HTMLTagName.b.rawValue
    
    public init() {
        
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}
```

> The implementation corresponds to [HTMLTagNameVisitor](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTagNameVisitor.swift){:target="_blank"} in the original code.

> Additionally, refer to the W3C wiki which lists the HTML tag name enum: [WC3HTMLTagName\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/WC3HTMLTagName.swift){:target="_blank"}.

**HTMLTag is simply a container object, as we want to allow external specification of the styles corresponding to HTML Tags, so we declare a container to hold them together:**
```swift
struct HTMLTag {
    let tagName: HTMLTagName
    let customStyle: MarkupStyle? // The Render section will explain this later
    
    init(tagName: HTMLTagName, customStyle: MarkupStyle? = nil) {
        self.tagName = tagName
        self.customStyle = customStyle
    }
}
```

> The implementation corresponds to [HTMLTag](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTag.swift3){:target="_blank"} in the original code.

#### HTMLTagNameToHTMLMarkupVisitor
```swift
struct HTMLTagNameToMarkupVisitor: HTMLTagNameVisitor {
    typealias Result = Markup
    
    let attributes: [String: String]?
    
    func visit(_ tagName: A_HTMLTagName) -> Result {
        return LinkMarkup()
    }
    
    func visit(_ tagName: B_HTMLTagName) -> Result {
        return BoldMarkup()
    }
    //...
}
```

> The implementation corresponds to [HTMLTagNameToHTMLMarkupVisitor](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagNameToHTMLMarkupVisitor.swift){:target="_blank"} in the original code.

#### Convert to Abstract Tree with HTML Data

We need to convert the normalized HTML data results into an abstract tree. First, declare a data structure called MarkupComponent that can hold HTML data:
```swift
struct HTMLElementMarkupComponent: MarkupComponent {
    struct HTMLElement {
        let tag: HTMLTag
        let tagAttributedString: NSAttributedString
        let attributes: [String: String]?
    }
    
    typealias T = HTMLElement
    
    let markup: Markup
    let value: HTMLElement
    init(markup: Markup, value: HTMLElement) {
        self.markup = markup
        self.value = value
    }
}
```

**Convert to Markup Abstract Tree:**
```swift
var htmlElementComponents: [HTMLElementMarkupComponent] = []
let rootMarkup = RootMarkup()
var currentMarkup: Markup = rootMarkup

let htmlTags: [String: HTMLTag]
init(htmlTags: [HTMLTag]) {
  self.htmlTags = Dictionary(uniqueKeysWithValues: htmlTags.map{ ($0.tagName.string, $0) })
}

// Start Tags Stack, ensure correct pop tag
// Normalization has already been done, so there should be no errors, just ensuring
var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []
for thisItem in from {
    switch thisItem {
    case .start(let item):
        let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes)
        let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName))
        // Use Visitor to ask for the corresponding Markup
        let markup = visitor.visit(tagName: htmlTag.tagName)
        
        // Add itself as a leaf node of the current branch
        // It becomes the current branch node
        htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes)))
        currentMarkup.appendChild(markup: markup)
        currentMarkup = markup
        
        stackExpectedStartItems.append(item)
    case .selfClosing(let item):
        // Directly add as a leaf node of the current branch
        let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes)
        let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName))
        let markup = visitor.visit(tagName: htmlTag.tagName)
        htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes)))
        currentMarkup.appendChild(markup: markup)
    case .close(let item):
        if let lastTagName = stackExpectedStartItems.popLast()?.tagName,
           lastTagName == item.tagName {
            // When encountering a Close Tag, go back to the previous level
            currentMarkup = currentMarkup.parentMarkup ?? currentMarkup
        }
    case .rawString(let attributedString):
        // Directly add as a leaf node of the current branch
        currentMarkup.appendChild(markup: RawStringMarkup(attributedString: attributedString))
    }
}

// print(htmlElementComponents)
// [(markup: LinkMarkup, (tag: a, attributes: ["href":"zhgchg.li"]...)]
```

```markdown
![The operation result is shown in the image above](/assets/2724f02f6e7/1*D-oMszCDzsBpUYnCEWGKHQ.png)

The operation result is shown in the image above


> Corresponding to the original code in [HTMLParsedResultToHTMLElementWithRootMarkupProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLParsedResultToHTMLElementWithRootMarkupProcessor.swift){:target="_blank"} implementation 




#### At this point, we have actually completed the functionality of the Selector 🎉
```swift
public class HTMLSelector: CustomStringConvertible {
    
    let markup: Markup
    let componets: [HTMLElementMarkupComponent]
    init(markup: Markup, componets: [HTMLElementMarkupComponent]) {
        self.markup = markup
        self.componets = componets
    }
    
    public func filter(_ htmlTagName: String) -> [HTMLSelector] {
        let result = markup.childMarkups.filter({ componets.value(markup: $0)?.tag.tagName.isEqualTo(htmlTagName) ?? false })
        return result.map({ .init(markup: $0, componets: componets) })
    }

    //...
}
```

We can filter the leaf node objects layer by layer.


> Corresponding to the original code in [HTMLSelector](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLSelector.swift){:target="_blank"} implementation 




### Parser — HTML to MarkupStyle \(Abstract of NSAttributedString\.Key\)

Next, we need to complete the conversion of HTML to MarkupStyle \(NSAttributedString\.Key\).

NSAttributedString uses NSAttributedString\.Key Attributes to set the text style. We abstract all fields of NSAttributedString\.Key to correspond to MarkupStyle, MarkupStyleColor, MarkupStyleFont, and MarkupStyleParagraphStyle.

**Purpose:**
- The original structure of Attributes is `[NSAttributedString.Key: Any?]`. If exposed directly, it is difficult to control the values provided by users. Incorrect values can cause crashes, such as `.font: 123`.
- Styles need to be inheritable, for example, `<a><b>test</b></a>`, where the style of the string "test" inherits from the link's bold (bold + link); exposing the Dictionary directly makes it hard to manage inheritance rules.
- Encapsulate iOS/macOS (UIKit/AppKit) related objects.

#### MarkupStyle Struct
```swift
public struct MarkupStyle {
    public var font: MarkupStyleFont
    public var paragraphStyle: MarkupStyleParagraphStyle
    public var foregroundColor: MarkupStyleColor? = nil
    public var backgroundColor: MarkupStyleColor? = nil
    public var ligature: NSNumber? = nil
    public var kern: NSNumber? = nil
    public var tracking: NSNumber? = nil
    public var strikethroughStyle: NSUnderlineStyle? = nil
    public var underlineStyle: NSUnderlineStyle? = nil
    public var strokeColor: MarkupStyleColor? = nil
    public var strokeWidth: NSNumber? = nil
    public var shadow: NSShadow? = nil
    public var textEffect: String? = nil
    public var attachment: NSTextAttachment? = nil
    public var link: URL? = nil
    public var baselineOffset: NSNumber? = nil
    public var underlineColor: MarkupStyleColor? = nil
    public var strikethroughColor: MarkupStyleColor? = nil
    public var obliqueness: NSNumber? = nil
    public var expansion: NSNumber? = nil
    public var writingDirection: NSNumber? = nil
    public var verticalGlyphForm: NSNumber? = nil
    //...

    // Inherit from...
    // Default: when fields are nil, fill in from the current data object
    mutating func fillIfNil(from: MarkupStyle?) {
        guard let from = from else { return }
        
        var currentFont = self.font
        currentFont.fillIfNil(from: from.font)
        self.font = currentFont
        
        var currentParagraphStyle = self.paragraphStyle
        currentParagraphStyle.fillIfNil(from: from.paragraphStyle)
        self.paragraphStyle = currentParagraphStyle
        //..
    }

    // MarkupStyle to NSAttributedString.Key: Any
    func render() -> [NSAttributedString.Key: Any] {
        var data: [NSAttributedString.Key: Any] = [:]
        
        if let font = font.getFont() {
            data[.font] = font
        }

        if let ligature = self.ligature {
            data[.ligature] = ligature
        }
        //...
        return data
    }
}

public struct MarkupStyleFont: MarkupStyleItem {
    public enum FontWeight {
        case style(FontWeightStyle)
        case rawValue(CGFloat)
    }
    public enum FontWeightStyle: String {
        case ultraLight, light, thin, regular, medium, semibold, bold, heavy, black
        // ...
    }
    
    public var size: CGFloat?
    public var weight: FontWeight?
    public var italic: Bool?
    //...
}

public struct MarkupStyleParagraphStyle: MarkupStyleItem {
    public var lineSpacing: CGFloat? = nil
    public var paragraphSpacing: CGFloat? = nil
    public var alignment: NSTextAlignment? = nil
    public var headIndent: CGFloat? = nil
    public var tailIndent: CGFloat? = nil
    public var firstLineHeadIndent: CGFloat? = nil
    public var minimumLineHeight: CGFloat? = nil
    public var maximumLineHeight: CGFloat? = nil
    public var lineBreakMode: NSLineBreakMode? = nil
    public var baseWritingDirection: NSWritingDirection? = nil
    public var lineHeightMultiple: CGFloat? = nil
    public var paragraphSpacingBefore: CGFloat? = nil
    public var hyphenationFactor: Float? = nil
    public var usesDefaultHyphenation: Bool? = nil
    public var tabStops: [NSTextTab]? = nil
    public var defaultTabInterval: CGFloat? = nil
    public var textLists: [NSTextList]? = nil
    public var allowsDefaultTighteningForTruncation: Bool? = nil
    public var lineBreakStrategy: NSParagraphStyle.LineBreakStrategy? = nil
    //...
}

public struct MarkupStyleColor {
    let red: Int
    let green: Int
    let blue: Int
    let alpha: CGFloat
    //...
}
```

```markdown
> Implementation corresponding to [MarkupStyle](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/Core/MarkupStyle){:target="_blank"} in the original code.

> Additionally, it also references the W3C wiki, which lists the corresponding color name text & color R, G, B enum: [MarkupStyleColorName\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyleColorName.swift){:target="_blank"}.

#### HTMLTagStyleAttribute & HTMLTagStyleAttributeVisitor

Here, I would like to mention these two objects, as HTML Tags are allowed to be styled with CSS; we apply the same abstraction as HTMLTagName once again to HTML Style Attributes.

For example, HTML might give: `<a style="color:red;font-size:14px">RedLink</a>`, which indicates that this link should be set to red and have a size of 14px.
```
public protocol HTMLTagStyleAttribute {
    var styleName: String { get }
    
    func accept<V: HTMLTagStyleAttributeVisitor>(_ visitor: V) -> V.Result
}

public protocol HTMLTagStyleAttributeVisitor {
    associatedtype Result
    
    func visit(styleAttribute: HTMLTagStyleAttribute) -> Result
    func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -> Result
    func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -> Result
    //...
}

public extension HTMLTagStyleAttributeVisitor {
    func visit(styleAttribute: HTMLTagStyleAttribute) -> Result {
        return styleAttribute.accept(self)
    }
}
```

> Implementation corresponding to [HTMLTagStyleAttribute](https://github.com/ZhgChgLi/ZMarkupParser/tree/main/Sources/ZMarkupParser/HTML/HTMLTag/HTMLTagStyleAttribute){:target="_blank"} in the original code.

#### HTMLTagStyleAttributeToMarkupStyleVisitor
```swift
struct HTMLTagStyleAttributeToMarkupStyleVisitor: HTMLTagStyleAttributeVisitor {
    typealias Result = MarkupStyle?
    
    let value: String
    
    func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -> Result {
        // Regular expression to extract Color Hex or Mapping from HTML Pre-defined Color Name, please refer to Source Code
        guard let color = MarkupStyleColor(string: value) else { return nil }
        return MarkupStyle(foregroundColor: color)
    }
    
    func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -> Result {
        // Regular expression to extract 10px -> 10, please refer to Source Code
        guard let size = self.convert(fromPX: value) else { return nil }
        return MarkupStyle(font: MarkupStyleFont(size: CGFloat(size)))
    }
    // ...
}
```

> The implementation corresponds to the [HTMLTagAttributeToMarkupStyleVisitor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagAttributeToMarkupStyleVisitor.swift){:target="_blank"} in the original code.

The value of `init` is the value of the attribute, converted to the corresponding MarkupStyle field according to the visit type.
#### HTMLElementMarkupComponentMarkupStyleVisitor

After introducing the MarkupStyle object, we need to convert the results from Normalization's HTMLElementComponents into MarkupStyle.
```swift
// MarkupStyle strategy
public enum MarkupStylePolicy {
    case respectMarkupStyleFromCode // Prioritize styles from Code, fill in with HTML Style Attributes
    case respectMarkupStyleFromHTMLStyleAttribute // Prioritize styles from HTML Style Attributes, fill in with Code
}

struct HTMLElementMarkupComponentMarkupStyleVisitor: MarkupVisitor {

    typealias Result = MarkupStyle?
    
    let policy: MarkupStylePolicy
    let components: [HTMLElementMarkupComponent]
    let styleAttributes: [HTMLTagStyleAttribute]

    func visit(_ markup: BoldMarkup) -> Result {
        // .bold is just the default style defined in MarkupStyle, please refer to the Source Code
        return defaultVisit(components.value(markup: markup), defaultStyle: .bold)
    }
    
    func visit(_ markup: LinkMarkup) -> Result {
        // .link is just the default style defined in MarkupStyle, please refer to the Source Code
        var markupStyle = defaultVisit(components.value(markup: markup), defaultStyle: .link) ?? .link
        
        // Get the corresponding HtmlElement for LinkMarkup from HtmlElementComponents
        // Find the href parameter from the attributes in HtmlElement (HTML with URL String)
        if let href = components.value(markup: markup)?.attributes?["href"] as? String,
           let url = URL(string: href) {
            markupStyle.link = url
        }
        return markupStyle
    }

    // ...
}

extension HTMLElementMarkupComponentMarkupStyleVisitor {
    // Get the specified custom MarkupStyle from the HTMLTag container
    private func customStyle(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?) -> MarkupStyle? {
        guard let customStyle = htmlElement?.tag.customStyle else {
            return nil
        }
        return customStyle
    }
    
    // Default action
    func defaultVisit(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?, defaultStyle: MarkupStyle? = nil) -> Result {
        var markupStyle: MarkupStyle? = customStyle(htmlElement) ?? defaultStyle
        // Get the corresponding HtmlElement for LinkMarkup from HtmlElementComponents
        // Check if there is a `Style` Attribute in the HtmlElement's attributes
        guard let styleString = htmlElement?.attributes?["style"],
              styleAttributes.count > 0 else {
            // None
            return markupStyle
        }

        // There are Style Attributes
        // Split the Style Value string into an array
        // font-size:14px;color:red -> ["font-size":"14px","color":"red"]
        let styles = styleString.split(separator: ";").filter { $0.trimmingCharacters(in: .whitespacesAndNewlines) != "" }.map { $0.split(separator: ":") }
        
        for style in styles {
            guard style.count == 2 else {
                continue
            }
            // e.g font-size
            let key = style[0].trimmingCharacters(in: .whitespacesAndNewlines)
            // e.g. 14px
            let value = style[1].trimmingCharacters(in: .whitespacesAndNewlines)
            
            if let styleAttribute = styleAttributes.first(where: { $0.isEqualTo(styleName: key) }) {
                // Use the previously mentioned HTMLTagStyleAttributeToMarkupStyleVisitor to convert back to MarkupStyle
                let visitor = HTMLTagStyleAttributeToMarkupStyleVisitor(value: value)
                if var thisMarkupStyle = visitor.visit(styleAttribute: styleAttribute) {
                    // When the Style Attribute has a returned value..
                    // Merge with the previous MarkupStyle result
                    thisMarkupStyle.fillIfNil(from: markupStyle)
                    markupStyle = thisMarkupStyle
                }
            }
        }
        
        // If there is a default Style
        if var defaultStyle = defaultStyle {
            switch policy {
                case .respectMarkupStyleFromHTMLStyleAttribute:
                  // Style Attribute MarkupStyle takes precedence, then
                  // Merge with the defaultStyle result
                    markupStyle?.fillIfNil(from: defaultStyle)
                case .respectMarkupStyleFromCode:
                  // defaultStyle takes precedence, then
                  // Merge with the Style Attribute MarkupStyle result
                  defaultStyle.fillIfNil(from: markupStyle)
                  markupStyle = defaultStyle
            }
        }
        
        return markupStyle
    }
}
```

> The implementation corresponds to [HTMLTagAttributeToMarkupStyleVisitor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLTagAttributeToMarkupStyleVisitor.swift){:target="_blank"} in the original code.

We will define some default styles in [MarkupStyle](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyle%2BExtension.swift){:target="_blank"}, and some Markup will use the default style if no desired style is specified for the Tag from the external Code.

**There are two style inheritance strategies:**
- respectMarkupStyleFromCode:
  Use the default style as the primary; then see what styles can be supplemented from the Style Attributes, ignoring if there is already a value.
- respectMarkupStyleFromHTMLStyleAttribute:
  Use the Style Attributes as the primary; then see what styles can be supplemented from the default styles, ignoring if there is already a value.

#### HTMLElementWithMarkupToMarkupStyleProcessor

Convert the normalization results into AST & MarkupStyleComponent.

**Declare a new MarkupComponent to store the corresponding MarkupStyle:**
```swift
struct MarkupStyleComponent: MarkupComponent {
    typealias T = MarkupStyle
    
    let markup: Markup
    let value: MarkupStyle
    init(markup: Markup, value: MarkupStyle) {
        self.markup = markup
        self.value = value
    }
}
```

**Simple traversal of the Markup Tree & HTMLElementMarkupComponent structure:**
```swift
let styleAttributes: [HTMLTagStyleAttribute]
let policy: MarkupStylePolicy
    
func process(from: (Markup, [HTMLElementMarkupComponent])) -> [MarkupStyleComponent] {
  var components: [MarkupStyleComponent] = []
  let visitor = HTMLElementMarkupComponentMarkupStyleVisitor(policy: policy, components: from.1, styleAttributes: styleAttributes)
  walk(markup: from.0, visitor: visitor, components: &components)
  return components
}
    
func walk(markup: Markup, visitor: HTMLElementMarkupComponentMarkupStyleVisitor, components: inout [MarkupStyleComponent]) {
        
  if let markupStyle = visitor.visit(markup: markup) {
    components.append(.init(markup: markup, value: markupStyle))
  }
        
  for markup in markup.childMarkups {
    walk(markup: markup, visitor: visitor, components: &components)
  }
}

// print(components)
// [(markup: LinkMarkup, MarkupStyle(link: https://zhgchg.li, color: .blue)]
// [(markup: BoldMarkup, MarkupStyle(font: .init(weight: .bold))]
```

```markdown
> Corresponding to the implementation in the original code [HTMLElementWithMarkupToMarkupStyleProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/Processor/HTMLElementWithMarkupToMarkupStyleProcessor.swift){:target="_blank"}

![The flow result is shown in the image above](/assets/2724f02f6e7/1*JEMBNdbQcBgDQ49jFw4ePQ.png)

The flow result is shown in the image above
### Render — Convert To NSAttributedString

Now that we have the HTML Tag abstract tree structure and the corresponding MarkupStyle for the HTML Tag, the final step is to produce the final NSAttributedString rendering result.
#### MarkupNSAttributedStringVisitor

visit markup to NSAttributedString
```swift
struct MarkupNSAttributedStringVisitor: MarkupVisitor {
    typealias Result = NSAttributedString
    
    let components: [MarkupStyleComponent]
    // root / base MarkupStyle, specified externally, for example, to specify the size of the entire string
    let rootStyle: MarkupStyle?
    
    func visit(_ markup: RootMarkup) -> Result {
        // Look down at the RawString object
        return collectAttributedString(markup)
    }
    
    func visit(_ markup: RawStringMarkup) -> Result {
        // Return Raw String
        // Collect all MarkupStyle in the chain
        // Apply Style to NSAttributedString
        return applyMarkupStyle(markup.attributedString, with: collectMarkupStyle(markup))
    }
    
    func visit(_ markup: BoldMarkup) -> Result {
        // Look down at the RawString object
        return collectAttributedString(markup)
    }
    
    func visit(_ markup: LinkMarkup) -> Result {
        // Look down at the RawString object
        return collectAttributedString(markup)
    }
    // ...
}

private extension MarkupNSAttributedStringVisitor {
    // Apply Style to NSAttributedString
    func applyMarkupStyle(_ attributedString: NSAttributedString, with markupStyle: MarkupStyle?) -> NSAttributedString {
        guard let markupStyle = markupStyle else { return attributedString }
        let mutableAttributedString = NSMutableAttributedString(attributedString: attributedString)
        mutableAttributedString.addAttributes(markupStyle.render(), range: NSMakeRange(0, mutableAttributedString.string.utf16.count))
        return mutableAttributedString
    }

    func collectAttributedString(_ markup: Markup) -> NSMutableAttributedString {
        // collect from downstream
        // Root -> Bold -> String("Bold")
        //      \
        //       > String("Test")
        // Result: Bold Test
        // Recursively look for raw strings layer by layer, visit and combine to form the final NSAttributedString
        return markup.childMarkups.compactMap({ visit(markup: $0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in
            partialResult.append(attributedString)
            return partialResult
        }
    }
    
    func collectMarkupStyle(_ markup: Markup) -> MarkupStyle? {
        // collect from upstream
        // String("Test") -> Bold -> Italic -> Root
        // Result: style: Bold+Italic
        // Layer by layer, look for the parent tag's markupstyle
        // Then inherit styles layer by layer
        var currentMarkup: Markup? = markup.parentMarkup
        var currentStyle = components.value(markup: markup)
        while let thisMarkup = currentMarkup {
            guard let thisMarkupStyle = components.value(markup: thisMarkup) else {
                currentMarkup = thisMarkup.parentMarkup
                continue
            }

            if var thisCurrentStyle = currentStyle {
                thisCurrentStyle.fillIfNil(from: thisMarkupStyle)
                currentStyle = thisCurrentStyle
            } else {
                currentStyle = thisMarkupStyle
            }

            currentMarkup = thisMarkup.parentMarkup
        }
        
        if var currentStyle = currentStyle {
            currentStyle.fillIfNil(from: rootStyle)
            return currentStyle
        } else {
            return rootStyle
        }
    }
}
```

> Implementation corresponding to the original code in [MarkupNSAttributedStringVisitor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/Processor/MarkupNSAttributedStringVisitor.swift){:target="_blank"} 

![The operation process and results are shown in the above image](/assets/2724f02f6e7/1*gJA_6uM5tQw2kUJsqIssuw.png)

The operation process and results are shown in the above image.

**Ultimately, we can obtain:**


![](/assets/2724f02f6e7/1*LOXfC8yYg2JCeoCH5m7kGA.png)

```swift
Li{
    NSColor = "Blue";
    NSFont = "<UICTFont: 0x145d17600> font-family: \".SFUI-Regular\"; font-weight: normal; font-style: normal; font-size: 13.00pt";
    NSLink = "https://zhgchg.li";
}nk{
    NSColor = "Blue";
    NSFont = "<UICTFont: 0x145d18710> font-family: \".SFUI-Semibold\"; font-weight: bold; font-style: normal; font-size: 13.00pt";
    NSLink = "https://zhgchg.li";
}Bold{
    NSFont = "<UICTFont: 0x145d18710> font-family: \".SFUI-Semibold\"; font-weight: bold; font-style: normal; font-size: 13.00pt";
}
```


> 🎉🎉🎉🎉 Completed 🎉🎉🎉🎉 




At this point, we have completed the entire conversion process from HTML String to NSAttributedString.
#### Stripper — Stripping HTML Tags

The part for stripping HTML tags is relatively simple, requiring only:
```swift
func attributedString(_ markup: Markup) -> NSAttributedString {
  if let rawStringMarkup = markup as? RawStringMarkup {
    return rawStringMarkup.attributedString
  } else {
    return markup.childMarkups.compactMap({ attributedString($0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in
      partialResult.append(attributedString)
      return partialResult
    }
  }
}
```


> Implementation corresponding to the original code in [MarkupStripperProcessor\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/Processor/MarkupStripperProcessor.swift){:target="_blank"} 





Similar to Render, but purely returns the content after finding RawStringMarkup.
#### Extend — Dynamic Extension

To cover all HTML Tags/Style Attributes, a dynamic extension interface was created for easy direct object expansion from the code.
```swift
public struct ExtendTagName: HTMLTagName {
    public let string: String
    
    public init(_ w3cHTMLTagName: WC3HTMLTagName) {
        self.string = w3cHTMLTagName.rawValue
    }
    
    public init(_ string: String) {
        self.string = string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagNameVisitor {
        return visitor.visit(self)
    }
}
// to
final class ExtendMarkup: Markup {
    weak var parentMarkup: Markup? = nil
    var childMarkups: [Markup] = []

    func accept<V>(_ visitor: V) -> V.Result where V : MarkupVisitor {
        return visitor.visit(self)
    }
}

//----

public struct ExtendHTMLTagStyleAttribute: HTMLTagStyleAttribute {
    public let styleName: String
    public let render: ((String) -> (MarkupStyle?)) // Dynamically change MarkupStyle using closure
    
    public init(styleName: String, render: @escaping ((String) -> (MarkupStyle?))) {
        self.styleName = styleName
        self.render = render
    }
    
    public func accept<V>(_ visitor: V) -> V.Result where V : HTMLTagStyleAttributeVisitor {
        return visitor.visit(self)
    }
}
```
#### ZHTMLParserBuilder

Finally, we use the Builder Pattern to allow external modules to quickly construct the objects required by ZMarkupParser and ensure Access Level Control.
```swift
public final class ZHTMLParserBuilder {
    
    private(set) var htmlTags: [HTMLTag] = []
    private(set) var styleAttributes: [HTMLTagStyleAttribute] = []
    private(set) var rootStyle: MarkupStyle?
    private(set) var policy: MarkupStylePolicy = .respectMarkupStyleFromCode
    
    public init() {
        
    }
    
    public static func initWithDefault() -> Self {
        var builder = Self.init()
        for htmlTagName in ZHTMLParserBuilder.htmlTagNames {
            builder = builder.add(htmlTagName)
        }
        for styleAttribute in ZHTMLParserBuilder.styleAttributes {
            builder = builder.add(styleAttribute)
        }
        return builder
    }
    
    public func set(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle?) -> Self {
        return self.add(htmlTagName, withCustomStyle: markupStyle)
    }
    
    public func add(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle? = nil) -> Self {
        // Only one instance of the same tagName can exist
        htmlTags.removeAll { htmlTag in
            return htmlTag.tagName.string == htmlTagName.string
        }
        
        htmlTags.append(HTMLTag(tagName: htmlTagName, customStyle: markupStyle))
        
        return self
    }
    
    public func add(_ styleAttribute: HTMLTagStyleAttribute) -> Self {
        styleAttributes.removeAll { thisStyleAttribute in
            return thisStyleAttribute.styleName == styleAttribute.styleName
        }
        
        styleAttributes.append(styleAttribute)
        
        return self
    }
    
    public func set(rootStyle: MarkupStyle) -> Self {
        self.rootStyle = rootStyle
        return self
    }
    
    public func set(policy: MarkupStylePolicy) -> Self {
        self.policy = policy
        return self
    }
    
    public func build() -> ZHTMLParser {
        // ZHTMLParser init is only accessible internally; it cannot be directly initialized externally
        // It can only be initialized through ZHTMLParserBuilder
        return ZHTMLParser(htmlTags: htmlTags, styleAttributes: styleAttributes, policy: policy, rootStyle: rootStyle)
    }
}
```

> Corresponding to the implementation in the original code at [ZHTMLParserBuilder\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/ZHTMLParserBuilder.swift){:target="_blank"} 

**initWithDefault will by default include all implemented HTMLTagName/Style Attributes**
```swift
public extension ZHTMLParserBuilder {
    static var htmlTagNames: [HTMLTagName] {
        return [
            A_HTMLTagName(),
            B_HTMLTagName(),
            BR_HTMLTagName(),
            DIV_HTMLTagName(),
            HR_HTMLTagName(),
            I_HTMLTagName(),
            LI_HTMLTagName(),
            OL_HTMLTagName(),
            P_HTMLTagName(),
            SPAN_HTMLTagName(),
            STRONG_HTMLTagName(),
            U_HTMLTagName(),
            UL_HTMLTagName(),
            DEL_HTMLTagName(),
            TR_HTMLTagName(),
            TD_HTMLTagName(),
            TH_HTMLTagName(),
            TABLE_HTMLTagName(),
            IMG_HTMLTagName(handler: nil),
            // ...
        ]
    }
}

public extension ZHTMLParserBuilder {
    static var styleAttributes: [HTMLTagStyleAttribute] {
        return [
            ColorHTMLTagStyleAttribute(),
            BackgroundColorHTMLTagStyleAttribute(),
            FontSizeHTMLTagStyleAttribute(),
            FontWeightHTMLTagStyleAttribute(),
            LineHeightHTMLTagStyleAttribute(),
            WordSpacingHTMLTagStyleAttribute(),
            // ...
        ]
    }
}
```

ZHTMLParser init is only accessible internally; it cannot be directly initialized from outside and can only be initialized through ZHTMLParserBuilder.

**ZHTMLParser encapsulates Render/Selector/Stripper operations:**
```swift
public final class ZHTMLParser: ZMarkupParser {
    let htmlTags: [HTMLTag]
    let styleAttributes: [HTMLTagStyleAttribute]
    let rootStyle: MarkupStyle?

    internal init(...) {
    }
    
    // Get link style attributes
    public var linkTextAttributes: [NSAttributedString.Key: Any] {
        // ...
    }
    
    public func selector(_ string: String) -> HTMLSelector {
        // ...
    }
    
    public func selector(_ attributedString: NSAttributedString) -> HTMLSelector {
        // ...
    }
    
    public func render(_ string: String) -> NSAttributedString {
        // ...
    }
    
    // Allow rendering of NSAttributedString within nodes using HTMLSelector results
    public func render(_ selector: HTMLSelector) -> NSAttributedString {
        // ...
    }
    
    public func render(_ attributedString: NSAttributedString) -> NSAttributedString {
        // ...
    }
    
    public func stripper(_ string: String) -> String {
        // ...
    }
    
    public func stripper(_ attributedString: NSAttributedString) -> NSAttributedString {
        // ...
    }
    
  // ...
}
```

```markdown
> The implementation corresponding to the original code in [ZHTMLParser\.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/HTML/ZHTMLParser.swift){:target="_blank"} 

#### UIKit Issues

The result of NSAttributedString is most commonly displayed in UITextView, but note:
- The link style in UITextView is uniformly determined by the `linkTextAttributes` setting and does not consider the settings of NSAttributedString\.Key, and individual style settings are not possible; hence the existence of the `ZMarkupParser.linkTextAttributes` property.
- UILabel currently has no way to change the link style, and since UILabel does not have TextStorage, if you want to load NSTextAttachment images, you need to separately capture the UILabel.

```swift
public extension UITextView {
    func setHtmlString(_ string: String, with parser: ZHTMLParser) {
        self.setHtmlString(NSAttributedString(string: string), with: parser)
    }
    
    func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) {
        self.attributedText = parser.render(string)
        self.linkTextAttributes = parser.linkTextAttributes
    }
}
public extension UILabel {
    func setHtmlString(_ string: String, with parser: ZHTMLParser) {
        self.setHtmlString(NSAttributedString(string: string), with: parser)
    }
    
    func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) {
        let attributedString = parser.render(string)
        attributedString.enumerateAttribute(NSAttributedString.Key.attachment, in: NSMakeRange(0, attributedString.string.utf16.count), options: []) { (value, effectiveRange, nil) in
            guard let attachment = value as? ZNSTextAttachment else {
                return
            }
            
            attachment.register(self)
        }
        
        self.attributedText = attributedString
    }
}
```

Thus, UIKit has been extended, allowing external calls to simply use `setHTMLString()` to complete the binding.
#### Complex Rendering Items— Item List

Record of the implementation regarding item lists.

**Using `<ol>` / `<ul>` to wrap `<li>` in HTML to represent item lists:**
```xml
<ul>
    <li>ItemA</li>
    <li>ItemB</li>
    <li>ItemC</li>
    //...
</ul>
```

Using the same parsing method as before, we can obtain other list items in `visit(_ markup: ListItemMarkup)` to know the current list index (thanks to being converted into AST).
```swift
func visit(_ markup: ListItemMarkup) -> Result {
  let siblingListItems = markup.parentMarkup?.childMarkups.filter({ $0 is ListItemMarkup }) ?? []
  let position = (siblingListItems.firstIndex(where: { $0 === markup }) ?? 0)
}
```

```markdown
NSParagraphStyle has an NSTextList object that can be used to display list items, but in practice, it cannot customize the width of the whitespace (I personally think the whitespace is too large). If there is whitespace between the bullet point and the string, it will cause the line break to trigger there, resulting in a somewhat strange display, as shown in the image below:

![](/assets/2724f02f6e7/1*jvIgDjO4DNAKpPZF1balmw.png)

The Beter part can potentially be implemented through [setting headIndent, firstLineHeadIndent, NSTextTab](https://www.objc.io/issues/9-strings/string-rendering/){:target="_blank"}, but testing has found that if the string is too long or the size changes, it still cannot present the result perfectly.

Currently, it only achieves an acceptable level by manually combining the list item strings and inserting them at the front of the string.

We only use NSTextList.MarkerFormat to generate the list item symbols, rather than directly using NSTextList.

**The list symbol support can be referenced at:** [MarkupStyleList.swift](https://github.com/ZhgChgLi/ZMarkupParser/blob/main/Sources/ZMarkupParser/Core/MarkupStyle/MarkupStyleList.swift){:target="_blank"}

**Final display result: (** `<ol><li>` **)**

![](/assets/2724f02f6e7/1*yM3VROfUNgnEBfIYwYwPnQ.png)

#### Complex Rendering Items — Table

Similar to the implementation of list items, but for tables.

**In HTML, use `<table>` to wrap `<tr>` table rows -> wrap `<td>/<th>` to represent table columns:**
```xml
<table>
  <tr>
    <th>Company</th>
    <th>Contact</th>
    <th>Country</th>
  </tr>
  <tr>
    <td>Alfreds Futterkiste</td>
    <td>Maria Anders</td>
    <td>Germany</td>
  </tr>
  <tr>
    <td>Centro comercial Moctezuma</td>
    <td>Francisco Chang</td>
    <td>Mexico</td>
  </tr>
</table>
```

The native `NSAttributedString.DocumentType.html` is implemented using the private macOS API `NSTextBlock` to display, thus fully showing the HTML table style and content.

> A bit of cheating! We cannot use private APIs 🥲 

```swift
    func visit(_ markup: TableColumnMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        let siblingColumns = markup.parentMarkup?.childMarkups.filter({ $0 is TableColumnMarkup }) ?? []
        let position = (siblingColumns.firstIndex(where: { $0 === markup }) ?? 0)
        
        // Whether to specify the desired width from the outside, can set .max to avoid truncating string
        var maxLength: Int? = markup.fixedMaxLength
        if maxLength == nil {
            // If not specified, find the string length of the first row in the same column as the max length
            if let tableRowMarkup = markup.parentMarkup as? TableRowMarkup,
               let firstTableRow = tableRowMarkup.parentMarkup?.childMarkups.first(where: { $0 is TableRowMarkup }) as? TableRowMarkup {
                let firstTableRowColumns = firstTableRow.childMarkups.filter({ $0 is TableColumnMarkup })
                if firstTableRowColumns.indices.contains(position) {
                    let firstTableRowColumnAttributedString = collectAttributedString(firstTableRowColumns[position])
                    let length = firstTableRowColumnAttributedString.string.utf16.count
                    maxLength = length
                }
            }
        }
        
        if let maxLength = maxLength {
            // If the column exceeds maxLength, then truncate the string
            if attributedString.string.utf16.count > maxLength {
                attributedString.mutableString.setString(String(attributedString.string.prefix(maxLength))+"...")
            } else {
                attributedString.mutableString.setString(attributedString.string.padding(toLength: maxLength, withPad: " ", startingAt: 0))
            }
        }
        
        if position < siblingColumns.count - 1 {
            // Add whitespace as spacing, external can specify the width of spacing in terms of number of spaces
            attributedString.append(makeString(in: markup, string: String(repeating: " ", count: markup.spacing)))
        }
        
        return attributedString
    }
    
    func visit(_ markup: TableRowMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        attributedString.append(makeBreakLine(in: markup)) // Add line break, for details please refer to Source Code
        return attributedString
    }
    
    func visit(_ markup: TableMarkup) -> Result {
        let attributedString = collectAttributedString(markup)
        attributedString.append(makeBreakLine(in: markup)) // Add line break, for details please refer to Source Code
        attributedString.insert(makeBreakLine(in: markup), at: 0) // Add line break, for details please refer to Source Code
        return attributedString
    }
```

**The final presentation effect is as shown in the figure below:**


![](/assets/2724f02f6e7/1*Dft7H2BbeyWIO-dH4QpuSw.png)


not perfect, but acceptable\.
#### Complex Rendering Items — Image

Ultimately, the biggest challenge is loading remote images into NSAttributedString.

**Using `<img>` in HTML to represent images:**
```xml
<img src="https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg" width="300" height="125"/>
```

You can specify the desired display size using the `width` / `height` HTML attributes.

Displaying images in NSAttributedString is much more complex than expected; there isn't a good implementation. Previously, when working on [UITextView text wrapping](../e37d66ea1146/), I encountered some pitfalls, but this time, after further research, I found that there still isn't a perfect solution.

For now, let's ignore the issue that NSTextAttachment cannot be reused to free memory natively, and focus on implementing the download of images from remote sources into NSTextAttachment and then into NSAttributedString, along with automatic content updates.

**This series of operations has been broken down into another small project for easier optimization and reuse in other projects:**


[![](https://opengraph.githubassets.com/5c63c82d77259bfe295dc17bf3eedc073f2e23dbd9598642813af0bcecb5b701/ZhgChgLi/ZNSTextAttachment)](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"}


The main reference is the series of articles on [Asynchronous NSTextAttachments](https://www.cocoanetics.com/2016/09/asynchronous-nstextattachment-1/){:target="_blank"}, but I replaced the final content update part (the UI needs to be refreshed after the download is complete) and added Delegate/DataSource for external extension.

![The operational flow and relationships are shown in the figure above](/assets/2724f02f6e7/1*JZ8IVVNj9B2l-UBemGbAig.png)

The operational flow and relationships are shown in the figure above
- Declare a ZNSTextAttachmentable object, encapsulating the NSTextStorage object (provided by UITextView) and the UILabel itself (UILabel does not have NSTextStorage).
The operation method is to implement replace attributedString from NSRange\. \( `func replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment)` \)
- The principle of implementation is to first use `ZNSTextAttachment` to wrap imageURL, PlaceholderImage, and the size information to be displayed, then directly display the image using the placeholder.
- When the system needs this image on the screen, it will call the `image(forBounds…` method, at which point we start downloading the Image Data.
- The DataSource allows external control over how to download or implement Image Cache Policy, with the default using URLSession to request image Data.
- After the download is complete, create a new `ZResizableNSTextAttachment` and implement the logic for custom image size in `attachmentBounds(for…`.
- Call the `replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment)` method to replace the position of `ZNSTextAttachment` with `ZResizableNSTextAttachment`.
- Emit a didLoad Delegate notification, allowing external connections when needed.
- Completed



> **For detailed code, please refer to [Source Code](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"}** . 





The reason for not using `NSLayoutManager.invalidateLayout(forCharacterRange: range, actualCharacterRange: nil)` or `NSLayoutManager.invalidateDisplay(forCharacterRange: range)` to refresh the UI is that I found the UI did not display updates correctly; since we already know the range, directly triggering the replacement of NSAttributedString ensures the UI updates correctly.

Here is the translated Markdown content:

```xml
<span style="color:red">Hello</span>HelloHello <br />
<img src="https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg"/>
```

![](/assets/2724f02f6e7/1*bl65v-SVOK3H9ajR-Ksg6w.png)

### Testing & Continuous Integration

In this project, in addition to writing Unit Tests, a Snapshot Test was also established for integration testing, making it easier to conduct a comprehensive comparison of the final NSAttributedString.

The main functional logic has Unit Tests along with integration tests, and the final [Test Coverage](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"} is around **85%**.

![[ZMarkupParser — codecov](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*wV6BZcEGYuT9B9Xy4QzI0w.png)

[ZMarkupParser — codecov](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}
#### Snapshot Test

[![](https://opengraph.githubassets.com/b3cc52a5b949767e4cb0af82145ed6474334d3235bd785ee1f7891c6b65fd69a/pointfreeco/swift-snapshot-testing)](https://github.com/pointfreeco/swift-snapshot-testing){:target="_blank"}

**Directly import the framework for use:**
```swift
import SnapshotTesting
// ...
func testShouldKeppNSAttributedString() {
  let parser = ZHTMLParserBuilder.initWithDefault().build()
  let textView = UITextView()
  textView.frame.size.width = 390
  textView.isScrollEnabled = false
  textView.backgroundColor = .white
  textView.setHtmlString("html string...", with: parser)
  textView.layoutIfNeeded()
  assertSnapshot(matching: textView, as: .image, record: false)
}
// ...
```

![](/assets/2724f02f6e7/1*hLPeaOTOviA0jTPNOPu1hg.png)

Directly compare the final result to ensure that the adjustments made during integration are correct.
#### Codecov Test Coverage

Integrate [Codecov.io](https://about.codecov.io){:target="_blank"} (free for Public Repo) to evaluate Test Coverage; just install the Codecov GitHub App & configure it.

[![](https://storage.googleapis.com/codecov-cdn/static/Codecov-icon-600x600.png)](https://app.codecov.io/gh/ZhgChgLi/ZMarkupParser){:target="_blank"}

After setting up Codecov <-> GitHub Repo, you can also add a `codecov.yml` file in the root directory of the project.
```yaml
comment:                  # this is a top-level key
  layout: "reach, diff, flags, files"
  behavior: default
  require_changes: false  # if true: only post the comment if coverage changes
  require_base: no        # [yes :: must have a base report to post]
  require_head: yes       # [yes :: must have a head report to post]
```

```markdown
The configuration file enables automatic commenting of CI results on the content after each PR is issued.

![](/assets/2724f02f6e7/1*AcKpF4dijglahV-iVYLvvA.png)

#### Continuous Integration

Github Action, CI integration: `ci.yml`
```yaml
name: CI

on:
  workflow_dispatch:
  pull_request:
    types: [opened, reopened]
  push:
    branches:
    - main

jobs:
  build:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v3
      - name: spm build and test
        run: |
          set -o pipefail
          xcodebuild test -workspace ZMarkupParser.xcworkspace -testPlan ZMarkupParser -scheme ZMarkupParser -enableCodeCoverage YES -resultBundlePath './scripts/TestResult.xcresult' -destination 'platform=iOS Simulator,name=iPhone 14,OS=16.1' build test | xcpretty
      - name: Codecov
        uses: codecov/codecov-action@v3.1.1
        with:
          xcode: true
          xcode_archive_path: './scripts/TestResult.xcresult'
```

This configuration runs build and test when a PR is opened/reopened or when pushing to the main branch, and finally uploads the test coverage report to Codecov.
#### Regex

Regarding regular expressions, each time they are used, they are refined further; this time, not much was actually used, but I researched how to write a regex to extract paired HTML tags.

Some cheat sheet notes from what I learned this time…
- `?:` allows \( \) to match group results without capturing them
e\.g\. `(?:https?:\/\/)?(?:www\.)?example\.com` will return the entire URL in `https://www.example.com` instead of `https://`, `www`
- `.+?` matches non-greedily \(returns the closest match\)
e\.g\. `<.+?>` will return `<a>`, `</a>` in `<a>test</a>` instead of the entire string
- `(?=XYZ)` matches any string until the string `XYZ` appears; note that another similar one `[^XYZ]` represents any string until the character `X or Y or Z` appears
e\.g\. `(?:__)(.+?(?=__))(?:__)` \(any string until `__`\) will match `test`
- `?R` recursively looks for values that match the same rule
e\.g\. `\((?:[^()]|((?R)))+\)` will match `(simple)`, `(and(nested))`, `(nested)` in `(simple) (and(nested))`
- `?<GroupName>` … `\k<GroupName>` matches the previous Group Name
e\.g\. `(?<tagName><a>).*(\k<GroupName>)`
- `(?(X)yes|no)` matches the condition `yes` if the `X`th match result has a value \(can also use Group Name\), otherwise matches `no`
**Swift does not support this temporarily**

**Other good Regex articles:**
- [Swift Regex Quick Reference](https://onevcat.com/2022/11/swift-regex/){:target="_blank"}
- [How Do Regular Expressions Work?](https://mp.weixin.qq.com/s/i_C4ATnajxRDGlTA8dJDHg){:target="_blank"} \-&gt; **Can refer to this when optimizing the regex performance of this project later**
- [Case of Regex Errors Leading to Infinite Searches, Ultimately Causing Server Failures](https://juejin.cn/post/6850418120390082574){:target="_blank"}
- [Regex101 for querying all regex rules in the lower right corner](https://regex101.com){:target="_blank"}
```

#### Swift Package Manager & Cocoapods

This is also my first time developing with SPM & Cocoapods… quite interesting, SPM is really convenient; however, if both projects depend on the same package, one of them might not find the package when you open both projects, resulting in a build failure...

Cocoapods has uploaded ZMarkupParser but I haven't tested if it works properly, because I'm using SPM 😝.
#### ChatGPT

From my actual development experience, I find it most useful when assisting with polishing the README; I haven't felt any significant benefits in development so far; because when asking mid-senior level questions, they can't provide a precise answer and sometimes give incorrect answers (I encountered some regex rules where the answers were not quite correct), so in the end, I still return to Google to find the correct answers.

Not to mention asking it to write code, unless it's simple code generation objects; otherwise, don't fantasize that it can directly complete an entire tool architecture. _\(At least for now, it seems that Copilot might be more helpful in writing code\)_

However, it can provide some general directions for knowledge blind spots, allowing us to quickly understand how certain things should be done; sometimes, when the grasp is too low, it's actually quite difficult to quickly locate the correct direction on Google, and at that time, ChatGPT is quite helpful.
### Declaration

After more than three months of research and development, I am exhausted, but I still want to declare that this approach is merely a feasible result obtained from my research, and it may not be the best solution, or there may still be areas for optimization. This project is more like a stone to attract jade, hoping to achieve a perfect answer for Markup Language to NSAttributedString, **everyone is very welcome to contribute; many aspects still need the power of the crowd to improve**.
### Contributing


![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} [⭐](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*kXjJQnSIJ7x-lSIYtacRrQ.jpeg)

[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} [⭐](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

Here are some areas I think could be improved at this moment (2023/03/12), which I will later document in the Repo:
1. Performance/algorithm optimization, although it's faster and more stable than the native `NSAttributedString.DocumentType.html`; there is still much room for optimization, and I believe the performance is definitely not as good as XMLParser; I hope that one day it can achieve the same performance while maintaining customization and automatic error correction.
2. Support for more HTML tags and style attribute conversion parsing.
3. Further optimization of [ZNSTextAttachment](https://github.com/ZhgChgLi/ZNSTextAttachment){:target="_blank"}, achieving reuse capability and memory release; may need to study CoreText.
4. Support for Markdown parsing, as the underlying abstraction is not limited to HTML; therefore, as long as the front-end Markdown to Markup object is built, Markdown parsing can be completed; hence I named it ZMarkupParser instead of ZHTMLParser, hoping that one day it can also support Markdown to NSAttributedString.
5. Support for Any to Any, e.g., HTML to Markdown, Markdown to HTML, as we have the original AST tree (Markup object), so implementing conversion between any Markup is possible.
6. Implement the css `!important` feature to enhance the inheritance strategy of MarkupStyle.
7. Strengthen HTML Selector functionality, currently just the most basic filter functionality.
8. So many more, welcome to open an [issue](https://github.com/ZhgChgLi/ZMarkupParser/issues){:target="_blank"}



> [If you have the heart but lack the strength, you can also give me a ⭐ so that the Repo can be seen by more people, thus giving the GitHub gods a chance to contribute!](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"} 




### Summary


![[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}](/assets/2724f02f6e7/1*A0yXupXW9-F9ZWe4gp2ObA.jpeg)

[ZMarkupParser](https://github.com/ZhgChgLi/ZMarkupParser){:target="_blank"}

This concludes all the technical details and my journey in developing ZMarkupParser. It took me nearly three months of after-work and weekend time, countless research and practical processes, writing tests, improving Test Coverage, and establishing CI; finally, I achieved a result that looks somewhat presentable. I hope this tool helps those who have similar troubles, and I also hope everyone can work together to make this tool even better.

![[pinkoi\.com](https://www.pinkoi.com){:target="_blank"}](/assets/2724f02f6e7/0*9YdJaNSQXlAfmT21.jpg)

[pinkoi\.com](https://www.pinkoi.com){:target="_blank"}

Currently, it is applied in our company's [pinkoi\.com](https://www.pinkoi.com){:target="_blank"} iOS app, and no issues have been found. 😄
#### Further Reading
- [ZMarkupParser HTML String to NSAttributedString Tool](../a5643de271e4/)
- [String Rendering](https://www.objc.io/issues/9-strings/string-rendering/){:target="_blank"}
- [Asynchronous NSTextAttachments](https://www.cocoanetics.com/2016/09/asynchronous-nstextattachment-1/){:target="_blank"}

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0-html-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B-2724f02f6e7){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
