---
author: ZhgChgLi
categories:
- ZRealm Dev.
date: 2022-07-08T07:58:30.799+0000
description: Discover how applying the Visitor Pattern improves TableView's code readability
  and scalability, enabling developers to manage complex UI components efficiently
  and extend functionality with ease.
image:
  path: /assets/60473cb47550/1*0YcpTUOCDjuV6Ii4jgbK0g.jpeg
last_modified_at: 2025-12-14T08:01:50.221+0000
render_with_liquid: false
tags:
- ios-app-development
- design-patterns
- visitor-pattern
- uitableview
- refactoring
- english
- ai-translation
title: Visitor Pattern｜Enhance TableView Readability and Extensibility
---

### Visitor Pattern in TableView

Using Visitor Pattern to Improve TableView Readability and Extensibility

![Photo by [Alex wong](https://unsplash.com/@killerfvith?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/60473cb47550/1*0YcpTUOCDjuV6Ii4jgbK0g.jpeg)

Photo by [Alex wong](https://unsplash.com/@killerfvith?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}

#### Preface

Following the previous article "[Visitor Pattern in Swift](../ba5773a7bfea/)" which introduced the Visitor pattern and a simple practical use case, this article will present another real-world application in iOS development.

### Requirement Scenario

To develop a dynamic wall feature, multiple types of blocks need to be dynamically combined and displayed.

Taking StreetVoice's dynamic wall as an example:

![](/assets/60473cb47550/1*_Liz9H0ZUD8Kk6kLKMMWjQ.png)

As shown in the above image, the dynamic wall is composed of various types of blocks dynamically combined:

- Type A: Activity Feed

- Type B: Tracking Recommendation

- Type C: New Song Updates

- Type D: New Album Updates

- Type E: New Tracking Updates

- Type …. More

The types are expected to increase as features iterate in the future.

### Problem

Without any architectural design, the code might look like this:

```swift
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    let row = datas[indexPath.row]
    switch row.type {
    case .invitation:
        let cell = tableView.dequeueReusableCell(withIdentifier: "invitation", for: indexPath) as! InvitationCell
        // configure cell with viewObject/viewModel...
        return cell
    case .newSong:
        let cell = tableView.dequeueReusableCell(withIdentifier: "newSong", for: indexPath) as! NewSongCell
        // configure cell with viewObject/viewModel...
        return cell
    case .newEvent:
        let cell = tableView.dequeueReusableCell(withIdentifier: "newEvent", for: indexPath) as! NewEventCell
        // configure cell with viewObject/viewModel...
        return cell
    case .newText:
        let cell = tableView.dequeueReusableCell(withIdentifier: "newText", for: indexPath) as! NewTextCell
        // configure cell with viewObject/viewModel...
        return cell
    case .newPhotos:
        let cell = tableView.dequeueReusableCell(withIdentifier: "newPhotos", for: indexPath) as! NewPhotosCell
        // configure cell with viewObject/viewModel...
        return cell
    }
}

func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
    let row = datas[indexPath.row]
    switch row.type {
    case .invitation:
        if row.isEmpty {
            return 100
        } else {
            return 300
        }
    case .newSong:
        return 100
    case .newEvent:
        return 200
    case .newText:
        return UITableView.automaticDimension
    case .newPhotos:
        return UITableView.automaticDimension
    }
}
```

- Hard to test: It is difficult to verify which Type corresponds to which logic output.

- Difficult to extend and maintain: When adding a new Type, this ViewController must be modified; cellForRow, heightForRow, willDisplay… are scattered across multiple functions, making it easy to forget or make mistakes.

- Hard to read: All logic is on the View side.

### Visitor Pattern Solution

#### Why?

Here is the organized object relationship, as shown in the diagram below:

![](/assets/60473cb47550/1*f4tscbmMV9LkRCtz9G8WRQ.jpeg)

We have many types of DataSource (ViewObject) that need to interact with various types of visitors, which is a typical example of [Visitor Double Dispatch](https://refactoringguru.cn/design-patterns/visitor-double-dispatch){:target="_blank"}.

#### How?

To simplify the demo code, the following are used: `PlainTextFeedViewObject` for plain text feeds, `MemoriesFeedViewObject` for daily memories, and `MediaFeedViewObject` for image feeds to demonstrate the design.

#### **The architecture diagram applying the Visitor Pattern is as follows:**

![](/assets/60473cb47550/1*vFXx4MBtMsDO2ppIUQZgJA.jpeg)

#### **First, define the Visitor interface. This interface abstractly declares the DataSource types that the visitor can accept:**

```swift
protocol FeedVisitor {
    associatedtype T
    func visit(_ viewObject: PlainTextFeedViewObject) -> T?
    func visit(_ viewObject: MediaFeedViewObject) -> T?
    func visit(_ viewObject: MemoriesFeedViewObject) -> T?
    //...
}
```

Each operator implements the `FeedVisitor` interface:

```swift
struct FeedCellVisitor: FeedVisitor {
    typealias T = UITableViewCell.Type
    
    func visit(_ viewObject: MediaFeedViewObject) -> T? {
        return MediaFeedTableViewCell.self
    }
    
    func visit(_ viewObject: MemoriesFeedViewObject) -> T? {
        return MemoriesFeedTableViewCell.self
    }
    
    func visit(_ viewObject: PlainTextFeedViewObject) -> T? {
        return PlainTextFeedTableViewCell.self
    }
}
```

Implementing ViewObject &lt;-&gt; UITableViewCell Mapping.

```swift
struct FeedCellHeightVisitor: FeedVisitor {
    typealias T = CGFloat
    
    func visit(_ viewObject: MediaFeedViewObject) -> T? {
        return 30
    }
    
    func visit(_ viewObject: MemoriesFeedViewObject) -> T? {
        return 10
    }
    
    func visit(_ viewObject: PlainTextFeedViewObject) -> T? {
        return 10
    }
}
```

Implementing ViewObject &lt;-&gt; UITableViewCell Height Mapping.

```swift
struct FeedCellConfiguratorVisitor: FeedVisitor {
    
    private let cell: UITableViewCell
    
    init(cell: UITableViewCell) {
        self.cell = cell
    }
    
    func visit(_ viewObject: MediaFeedViewObject) -> Any? {
        guard let cell = cell as? MediaFeedTableViewCell else { return nil }
        // cell.config(viewObject)
        return nil
    }
    
    func visit(_ viewObject: MemoriesFeedViewObject) -> Any? {
        guard let cell = cell as? MediaFeedTableViewCell else { return nil }
        // cell.config(viewObject)
        return nil
    }
    
    func visit(_ viewObject: PlainTextFeedViewObject) -> Any? {
        guard let cell = cell as? MediaFeedTableViewCell else { return nil }
        // cell.config(viewObject)
        return nil
    }
}
```

How to Implement ViewObject <-> Cell Configuration Mapping.

When a new DataSource (ViewObject) needs to be supported, simply add a new method to the FeedVisitor interface and implement the corresponding logic in each visitor.

**Binding DataSource (ViewObject) and Visitor:**

```swift
protocol FeedViewObject {
    @discardableResult func accept<V: FeedVisitor>(visitor: V) -> V.T?
}
```

#### **Interface for ViewObject Implementation Binding:**

```
struct PlainTextFeedViewObject: FeedViewObject {
    func accept<V>(visitor: V) -> V.T? where V : FeedVisitor {
        return visitor.visit(self)
    }
}
struct MemoriesFeedViewObject: FeedViewObject {
    func accept<V>(visitor: V) -> V.T? where V : FeedVisitor {
        return visitor.visit(self)
    }
}
```

#### **Implementation in UITableView:**

```swift
final class ViewController: UIViewController {

    @IBOutlet weak var tableView: UITableView!
    
    private let cellVisitor = FeedCellVisitor()
    
    private var viewObjects: [FeedViewObject] = [] {
        didSet {
            viewObjects.forEach { viewObject in
                let cellName = viewObject.accept(visitor: cellVisitor)
                tableView.register(cellName, forCellReuseIdentifier: String(describing: cellName))
            }
        }
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        tableView.delegate = self
        tableView.dataSource = self
        
        viewObjects = [
            MemoriesFeedViewObject(),
            MediaFeedViewObject(),
            PlainTextFeedViewObject(),
            MediaFeedViewObject(),
            PlainTextFeedViewObject(),
            MediaFeedViewObject(),
            PlainTextFeedViewObject()
        ]
        // Do any additional setup after loading the view.
    }
}

extension ViewController: UITableViewDataSource {
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return viewObjects.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let viewObject = viewObjects[indexPath.row]
        let cellName = viewObject.accept(visitor: cellVisitor)
        
        let cell = tableView.dequeueReusableCell(withIdentifier: String(describing: cellName), for: indexPath)
        let cellConfiguratorVisitor = FeedCellConfiguratorVisitor(cell: cell)
        viewObject.accept(visitor: cellConfiguratorVisitor)
        return cell
    }
}

extension ViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        let viewObject = viewObjects[indexPath.row]
        let cellHeightVisitor = FeedCellHeightVisitor()
        let cellHeight = viewObject.accept(visitor: cellHeightVisitor) ?? UITableView.automaticDimension
        return cellHeight
    }
}
```

### Result

- Testing: Complies with the Single Responsibility Principle, allowing tests for each data point of every visitor separately

- Extension and Maintenance: When supporting a new DataSource (ViewObject), simply add a method to the Visitor protocol and implement it in the respective Visitor classes. To introduce a new operator, just create a new class that implements it.

- Reading: You only need to browse through each visitor object to understand the composition logic of each view on the page.

### Complete Project

[![](https://opengraph.githubassets.com/968c942531151fa399342c0b0edb304fd0bfb066a8519b2e2d490978c894e196/zhgchgli0718/VisitorPatternInTableView)](https://github.com/zhgchgli0718/VisitorPatternInTableView){:target="_blank"}

#### Murmur…

Article written during a creative low period in July 2022. Please kindly forgive any incomplete descriptions or errors!

### Further Reading

- [Practical Application of Design Patterns (Encapsulating Socket.io)](../78507a8de6a5/)

- [Practical Application of Design Patterns (Encapsulating WKWebView)](../f4b02ee342a4/)

- [Visitor Pattern in Swift (Share Object to XXX Example)](../ba5773a7bfea/)

If you have any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

*[Post](https://dev.zhgchg.li/visitor-pattern-in-tableview-60473cb47550){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*