---
title: "iOS WKWebView Page and File Resource Preload / Cache Research"
author: "ZhgChgLi"
date: 2024-07-28T09:53:05.535+0000
last_modified_at: 2024-08-10T09:11:41.233+0000
categories: ["ZRealm Dev."]
tags: ["ios","ios-app-development","cache","webview","http-request"]
description: "Research on pre-downloading and caching resources in iOS WKWebView to improve page loading speed."
image:
  path: /assets/5033090c18ba/1*KACJYJkLfa2u5iKYJlJb2Q.jpeg
render_with_liquid: false
---

### iOS WKWebView Page and File Resource Preload / Cache Research

Research on pre-downloading and caching resources in iOS WKWebView to improve page loading speed.



![Photo by [Antoine Gravier](https://unsplash.com/@antoine_gravphotos?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}](/assets/5033090c18ba/1*KACJYJkLfa2u5iKYJlJb2Q.jpeg)

Photo by [Antoine Gravier](https://unsplash.com/@antoine_gravphotos?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}
#### Background

For some reason, I've always had a connection with "Cache." Previously, I was responsible for researching and practicing the " [iOS HLS Cache Implementation Exploration Journey](../d796bf8e661e/) " and " [AVPlayer Local Cache Functionality Overview](../6ce488898003/) "; unlike streaming cache, which aims to reduce playback traffic, **this time the main task is to enhance the loading speed of In-app WKWebView**. This also involves research on WKWebView's preloading and caching; however, to be honest, the WKWebView scenario is more complex. Unlike AVPlayer, which streams audio and video as one or multiple continuous chunk files that only require caching for the files, WKWebView not only has its own page files but also includes resource files (e.g., .js, .css, fonts, images...) that are rendered into a page for the user by the Browser Engine. There are many aspects that the App cannot control, from the network to the performance of front-end JavaScript syntax and rendering methods, all of which take time.

**This article only studies the technical feasibility of iOS and does not necessarily represent the final solution. Overall, this issue is better addressed by front-end developers, as they can achieve a more effective outcome.** I encourage front-end partners to optimize the time to first contentful paint and improve the HTTP cache mechanism, which can speed up both Web/mWeb itself and impact the speed of Android/iOS in-app WebView, while also enhancing [Google SEO ranking](https://developers.google.com/search/blog/2018/01/using-page-speed-in-mobile-search?hl=zh-tw){:target="_blank"}.
### Technical Details
#### iOS Restrictions

According to the [Apple Review Guidelines 2.5.6](https://developer.apple.com/app-store/review/guidelines/){:target="_blank"}:


> _Apps that browse the web must use the appropriate WebKit framework and WebKit JavaScript. You may apply for an entitlement to use an alternative web browser engine in your app. [Learn more about these entitlements](https://developer.apple.com/support/alternative-browser-engines/){:target="_blank"}._

**Apps can only use the WebKit Framework (WKWebView) provided by Apple and are not allowed to use third-party or modified WebKit engines; otherwise, they will not be permitted for release. Additionally, starting from iOS 17.4, to comply with regulations, regions in the EU can [use other browser engines](https://developer.apple.com/support/alternative-browser-engines/){:target="_blank"} after obtaining special permission from Apple.**


> What Apple does not allow, we cannot do. 




\[Unverified\] According to research, even the iOS versions of Chrome and Firefox can only use Apple WebKit (WKWebView).

**Another very important point:**

> _WKWebView runs on a separate thread outside the main thread of the App, so all requests and operations do not pass through our App._ 




#### HTTP Cache Flow


![](/assets/5033090c18ba/1*ozXaaWpTfw6IJOwt54EzsQ.jpeg)


The HTTP protocol includes cache protocols, and the system has already implemented a caching mechanism for all network-related components (URLSession, WKWebView, etc.), so the Client App does not need to implement anything, and it is not recommended to create a custom caching mechanism; following the HTTP protocol is the fastest, most stable, and most effective route.

**The general operation flow of HTTP Cache is as follows:**
1. The Client initiates a request.
2. The Server responds with cache strategies in the Response Header, and the system's URLSession, WKWebView, etc., will automatically cache the Response based on the Cache Header, applying this strategy to subsequent requests.
3. When requesting the same resource again, if the cache has not expired, it will directly read from memory or disk and respond to the App with the local cache.
4. If it has expired (expiration does not mean invalid), a real network request is made to the Server. If the content has not changed (even if expired, it is still valid), the Server will respond with 304 Not Modified (Empty Body). Although a network request is made, the response is essentially in milliseconds with no Response Body, resulting in minimal traffic consumption.
5. If the content has changed, the Server will provide the data again along with the Cache Header.



> _Caching can occur not only in local caches but also in Network Proxy Servers or along the way._ 





**Common HTTP Response Cache Header parameters:**
```yaml
expires: RFC 2822 date
pragma: no-cache
# Newer parameters:
cache-control: private/public/no-store/no-cache/max-age/s-max-age/must-revalidate/proxy-revalidate...
etag: XXX
```

**Common HTTP Request Cache Header parameters:**
```yaml
If-Modified-Since: 2024-07-18 13:00:00
IF-None-Match: 1234
```


> **_In iOS, network-related components (URLSession, WKWebView, etc.) handle HTTP Request/Response Cache Headers automatically and cache them without requiring us to manage Cache Header parameters._** 





For more detailed information on how HTTP Cache works, refer to "[Huli's Step-by-Step Understanding of HTTP Cache Mechanism](https://blog.techbridge.cc/2017/06/17/cache-introduction/){:target="_blank"}."
### Overview of iOS WKWebView


![](/assets/5033090c18ba/1*j9uw_OGpR-Lrq_4Gpj5beA.jpeg)


Back to iOS, since we can only use Apple WebKit, we can only explore methods provided by Apple to achieve preloading and caching.

The above image summarizes all Apple iOS WebKit (WKWebView) related methods as introduced by ChatGPT 4o, along with brief descriptions; the green parts are methods related to data storage.

**Here are a few interesting methods to share:**
- WKProcessPool: Allows multiple WKWebViews to share resources, data, cookies, etc.
- WKHTTPCookieStore: Manages cookies for WKWebView, allowing sharing between WKWebViews or between App's URLSession cookies and WKWebView.
- WKWebsiteDataStore: Manages website cache files (can only read information and clear).
- WKURLSchemeHandler: Registers a custom handler to process URL schemes that WKWebView cannot recognize.
- WKContentWorld: Groups injected JavaScript (WKUserScript) scripts for management.
- WKFindXXX: Controls the page search functionality.
- WKContentRuleListStore: Implements content blocking features (e.g., blocking ads) within WKWebView.

### Research on Feasibility of iOS WKWebView Preload Cache Solutions
### Perfecting HTTP Cache âœ…

As introduced earlier regarding the HTTP Cache mechanism, we can ask the Web Team to improve the HTTP Cache settings for active pages. The Client iOS side only needs to check the CachePolicy settings, as the system has already handled the rest!
#### **CachePolicy Settings**

**URLSession:**
```swift
let configuration = URLSessionConfiguration.default
configuration.requestCachePolicy = .useProtocolCachePolicy
let session = URLSession(configuration: configuration)
```

**URLRequest/WKWebView:**
```swift
var request = URLRequest(url: url)
request.cachePolicy = .reloadRevalidatingCacheData
//
wkWebView.load(request)
```
- **useProtocolCachePolicy**: Default, follows the default HTTP Cache control.
- **reloadIgnoringLocalCacheData**: Does not use local cache; each request loads data from the network (but allows network, Proxy caching...).
- **reloadIgnoringLocalAndRemoteCacheData**: Always loads data from the network, regardless of local or remote cache.
- **returnCacheDataElseLoad**: Uses cached data if available; otherwise, loads data from the network.
- **returnCacheDataDontLoad**: Only uses cached data; does not make a network request if no cached data is available.
- **reloadRevalidatingCacheData**: Sends a request to check if the local cache has expired; if not expired (304 Not Modified), it uses cached data; otherwise, it reloads data from the network.

#### **Setting Cache Size**

**App Global:**
```swift
let memoryCapacity = 512 * 1024 * 1024 // 512 MB
let diskCapacity = 10 * 1024 * 1024 * 1024 // 10 GB
let urlCache = URLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: "myCache")
        
URLCache.shared = urlCache
```

**Individual URLSession:**
```csharp
let memoryCapacity = 512 * 1024 * 1024 // 512 MB
let diskCapacity = 10 * 1024 * 1024 * 1024 // 10 GB
let cache = URLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: "myCache")
        
let configuration = URLSessionConfiguration.default
configuration.urlCache = cache
```


> **_Additionally, as mentioned earlier, WKWebView runs on a separate thread outside the main thread of the App, so the cache of URLRequest and URLSession is not shared with WKWebView._** 




#### **How to Use Safari Developer Tools in** WKWebView?

Check if local cache is being used.

**Enable Developer Features in Safari:**


![](/assets/5033090c18ba/1*6j4djW1IeD2n8FGX6FbOtw.png)


**Enable isInspectable in WKWebView:**
```swift
func makeWKWebView() -> WKWebView {
 let webView = WKWebView(frame: .zero)
 webView.isInspectable = true // is only available in iOS 16.4 or newer
 return webView
}
```

WKWebView must have `webView.isInspectable = true` to use Safari Developer Tools in Debug Build.


![p\.s\. This is a separate test WKWebView project](/assets/5033090c18ba/1*6E6AfdFW3w7nvO2VlbhRCA.png)

p\.s\. This is a separate test WKWebView project.

Set a breakpoint at the `webView.load` line.

**Start Testing:**

Build & Run:


![](/assets/5033090c18ba/1*8jCKl-UzSLrfjy9IAm26pA.png)


When you hit the webView\.load breakpoint, click "Step Over."


![](/assets/5033090c18ba/1*LAX4hrwffthRAtK-_9Q42A.png)


Return to Safari, select "Develop" from the toolbar -> "Simulator" -> "Your Project" -> "about:blank."
- Since the page has not started loading yet, the URL will be about:blank.
- If about:blank does not appear, return to XCode and click the step-over button again until it does.

The developer tools corresponding to that page will appear:


![](/assets/5033090c18ba/1*kde2nIvjC8CxFBIcoVhXqg.png)


Return to XCode and click to continue execution:


![](/assets/5033090c18ba/1*PtAMLX46fNwFDfF7lidyaA.png)


Back in Safari Developer Tools, you will be able to see the resource loading status and the full functionality of the developer tools (components, storage debugging, etc.).

![](/assets/5033090c18ba/1*l0vGOvT2UupVCvf4MrLgUA.png)


**If the network resource has HTTP Cache, the size will be displayed as "Disk":**


![](/assets/5033090c18ba/1*TMIPgtC2SVYzEmBD_xPQ_A.png)



![](/assets/5033090c18ba/1*KNbus1iFkCl4HjWThyYoew.png)


You can also see cache information by clicking in.
#### Clearing WKWebView Cache
```swift
// Clean Cookies
HTTPCookieStorage.shared.removeCookies(since: Date.distantPast)

// Clean Stored Data, Cache Data
let dataTypes = WKWebsiteDataStore.allWebsiteDataTypes()
let store = WKWebsiteDataStore.default()
store.fetchDataRecords(ofTypes: dataTypes) { records in
 records.forEach { record in
  store.removeData(
   ofTypes: record.dataTypes,
   for: records,
   completionHandler: {
          print("clearWebViewCache() - \(record)")           
   }
  )
 }
}
```

You can use the above method to clear cached resources, local data, and cookie data in WKWebView.


> **_However, perfecting the HTTP Cache only addresses the caching part (making the second entry fast); preloading (the first entry) will not be affected._** _âœ…_ 




### Perfecting HTTP Cache + WKWebView Preload Full Page ðŸ˜•
```swift
class WebViewPreloader {
    static let shared = WebViewPreloader()

    private var _webview: WKWebView = WKWebView()

    private init() { }

    func preload(url: URL) {
        let request = URLRequest(url: url)
        Task { @MainActor in
            webview.load(request)
        }
    }
}

WebViewPreloader.shared.preload("https://zhgchg.li/campaign/summer")
```

Based on the perfected HTTP Cache, the second load of WKWebView will have caching. We can preload all the URLs in the list or homepage once to allow them to be cached, so that when users enter, it will be faster.


> **_After testing, the principle is feasible; however, the performance and network traffic consumption are too high_** _; users may not even enter the detailed page, but we preload all pages, which feels a bit like shooting in the dark._ 
 

> _I personally believe this is impractical in reality, and the disadvantages outweigh the benefits, leading to unnecessary complications. ðŸ˜•_ 




### Perfecting HTTP Cache + WKWebView Preload Pure Resources ðŸŽ‰

Based on the optimization of the above method, we can use the HTML Link Preload method to specifically preload only the resource files (e.g., .js, .css, fonts, images...) that will be used in the page, allowing users to use cached resources directly without making network requests for resource files.


> **_This means I am no longer preloading everything on the entire page; I am only preloading the resource files that will be used on the page, which may also be shared across pages; the page file .html is still fetched from the network and combined with the preloaded files to render the page._** 





Please note: This still follows the HTTP Cache, so these resources must also support HTTP Cache; otherwise, subsequent requests will still go through the network.

Please note: This still follows the HTTP Cache, so these resources must also support HTTP Cache; otherwise, subsequent requests will still go through the network.

Please note: This still follows the HTTP Cache, so these resources must also support HTTP Cache; otherwise, subsequent requests will still go through the network.
```xml
<!DOCTYPE html>
<html lang="zh-tw">
 <head>
    <link rel="preload" href="https://cdn.zhgchg.li/dist/main.js" as="script">
    <link rel="preload" href="https://image.zhgchg.li/v2/image/get/campaign.jpg" as="image">
    <link rel="preload" href="https://cdn.zhgchg.li/assets/fonts/glyphicons-halflings-regular.woff2" as="font">
    <link rel="preload" href="https://cdn.zhgchg.li/assets/fonts/Simple-Line-Icons.woff2?v=2.4.0" as="font">
  </head>
</html>
```

**Common Supported File Types:**
- \.js script
- \.css style
- font
- image


The Web Team will place the above HTML content in a path agreed upon with the App, and our `WebViewPreloader` will load this path, allowing WKWebView to parse the `<link>` preload resources and generate cache.
```swift
WebViewPreloader.shared.preload("https://zhgchg.li/campaign/summer/preload")
// or load all at once
WebViewPreloader.shared.preload("https://zhgchg.li/assets/preload")
```


> **_After testing, a good balance can be achieved between traffic consumption and preloading_** _. ðŸŽ‰
 

> **_The downside is that maintaining this cache resource list is necessary, and web optimization for page rendering and loading is still required; otherwise, the perceived time for the first page to appear will still be long._** 

```markdown
### URLProtocol _âŒ_

Additionally, let's think about our old friend [URLProtocol](https://developer.apple.com/documentation/foundation/urlprotocol){:target="_blank"}. All requests based on the `URL Loading System` (URLSession, openURL, etc.) can be intercepted and manipulated.
```swift
class CustomURLProtocol: URLProtocol {
    override class func canInit(with request: URLRequest) -> Bool {
        // Determine whether to handle this request
        if let url = request.url {
            return url.scheme == "custom"
        }
        return false
    }
    
    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        // Return the request
        return request
    }
    
    override func startLoading() {
        // Handle the request and load data
        // Change to caching strategy, first read the file from local
        if let url = request.url {
            let response = URLResponse(url: url, mimeType: "text/plain", expectedContentLength: -1, textEncodingName: nil)
            self.client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)
            
            let data = "This is a custom response!".data(using: .utf8)!
            self.client?.urlProtocol(self, didLoad: data)
            self.client?.urlProtocolDidFinishLoading(self)
        }
    }
    
    override func stopLoading() {
        // Stop loading data
    }
}

// AppDelegate.swift didFinishLaunchingWithOptions:
URLProtocol.registerClass(CustomURLProtocol.self)
```

The abstract idea is to stealthily send URLRequest in the background -> URLProtocol -> download all resources from it, user -> WKWebView -> Request -> URLProtocol -> respond with preloaded resources.

> **_As mentioned earlier, WKWebView runs on a separate thread outside the main app thread, so URLProtocol cannot intercept requests from WKWebView._**

> **_However, I've heard that black magic might work, but it's not recommended as it could lead to other issues (like rejection during review)._**

> **_This path is a dead end_** _âŒ._ 

### WKURLSchemeHandler _ðŸ˜•_

Apple introduced a new method in iOS 11, seemingly to compensate for WKWebView's inability to use URLProtocol; however, this method is similar to [AVPlayer's ResourceLoader](../6ce488898003/). **Only schemes that the system cannot recognize will be sent to our custom WKURLSchemeHandler for processing.**

The abstract idea is the same: stealthily send WKWebView -> Request -> WKURLSchemeHandler -> download all resources from it, user -> WKWebView -> Request -> WKURLSchemeHandler -> respond with preloaded resources.
```swift
import WebKit

class CustomSchemeHandler: NSObject, WKURLSchemeHandler {
    func webView(_ webView: WKWebView, start urlSchemeTask: WKURLSchemeTask) {
        // Handle custom scheme
        let url = urlSchemeTask.request.url!
        
        if url.scheme == "custom-scheme" {
            // Change to caching strategy, first read the file from local
            let response = URLResponse(url: url, mimeType: "text/html", expectedContentLength: -1, textEncodingName: nil)
            urlSchemeTask.didReceive(response)
            
            let html = "<html><body><h1>Hello from custom scheme!</h1></body></html>"
            let data = html.data(using: .utf8)!
            urlSchemeTask.didReceive(data)
            urlSchemeTask.didFinish()
        }
    }

    func webView(_ webView: WKWebView, stop urlSchemeTask: WKURLSchemeTask) {
        // Stop
    }
}

let webViewConfiguration = WKWebViewConfiguration()
webViewConfiguration.setURLSchemeHandler(CustomSchemeHandler(), forURLScheme: "mycacher")

let customURL = URL(string: "mycacher://zhgchg.li/campaign/summer")!
webView.load(URLRequest(url: customURL))
```
- Since http/https are schemes that the system can handle, we cannot customize the handling of http/https; we need to change the scheme to one that the system does not recognize (e.g., `mycacher://`).
- All paths within the page should use relative paths to automatically prepend `mycacher://`, allowing our handler to capture them.
- If you don't want to change http/https but still want to capture http/https requests, you can only resort to black magic, **not recommended**, as it may lead to other issues (like rejection during review).
- Self-caching page files and responding may cause requests made by Ajax, XMLHttpRequest, and Fetch to be blocked by [**CORS Same-Origin Policy**](https://developer.mozilla.org/zh-TW/docs/Web/Security/Same-origin_policy){:target="_blank"}, requiring a reduction in website security to use (since it would become mycacher:// sending requests to http://zhgchg.li/xxx, which are different origins).
- You may need to implement your own Cache Policy, such as when to update? How long is it valid? **(This is similar to what HTTP Cache does.)**

> **_In summary, while it is theoretically feasible, the implementation requires significant investment; overall, it is not cost-effective and difficult to scale and maintain stability._** _ðŸ˜•_

It seems that the WKURLSchemeHandler method is more suitable for web pages with large resource files that need to be downloaded, declaring a custom scheme for the app to handle, collaborating to render the web page.
#### Bridge WKWebView network requests to be sent by the app ðŸ«¥

Change WKWebView to call the app's predefined interface (WkUserScript) instead of Ajax, XMLHttpRequest, and Fetch, allowing the app to request resources.

> _This case is not very helpful, as the delay is due to the first screen appearing too slowly, rather than subsequent loading; furthermore, this method creates a deep and strange dependency between Web and App._ ðŸ«¥

### Start with Service Worker _âŒ_

> _Due to security issues, only Apple's own Safari app supports this; WKWebView does not support it._ âŒ

### WKWebView Performance Optimization ðŸ«¥

Optimizing the performance of WKWebView Load View.

> _WKWebView itself is like a skeleton, while the web page is the flesh and blood; research shows that optimizing the skeleton (e.g., reusing WKProcessPool) has very limited effects, possibly reducing the time from 0.0003 to 0.000015 seconds._ 

### Local HTML, Local Resource Files ðŸ«¥

Similar to the Preload method, just change to placing the active page in the App Bundle or fetching it from a remote source at startup.

> _Placing the entire HTML page may also encounter CORS same-origin issues; simply placing web resource files seems to be replaceable with a "complete HTTP Cache + WKWebView Preload pure resources" approach; placing in the App Bundle only increases App Size, while fetching from remote is just WKWebView Preload._ ðŸ«¥

### Frontend Optimization ðŸŽ‰ðŸŽ‰ðŸŽ‰

![[Source: wedevs](https://wedevs.com/blog/348939/first-contentful-paint-largest-contentful-paint/){:target="_blank"}](/assets/5033090c18ba/1*Y3nDpbc4aEd0wg7Enk4k8A.png)

[Source: wedevs](https://wedevs.com/blog/348939/first-contentful-paint-largest-contentful-paint/){:target="_blank"}

Refer to [wedevs optimization suggestions](https://wedevs.com/blog/348939/first-contentful-paint-largest-contentful-paint/){:target="_blank"}. The frontend HTML page should have four loading stages, from the initial loading of the page file (.html) First Paint (blank page) to First Contentful Paint (rendering the page skeleton), then to First Meaningful Paint (filling in the page content) to Time To Interactive (finally allowing user interaction).

![](/assets/5033090c18ba/1*UirBj7nm_spU6knKbsyzxA.png)

Testing with our page; the browser and WKWebView will first request the main page .html and then load the necessary resources, simultaneously constructing the screen for the user according to the program's guidance. Comparing with the article, it turns out that the page stages only have First Paint (blank) to Time To Interactive (First Contentful Paint only has the Navigation Bar, which probably doesn't count...), missing the intermediate staged rendering for the user, thus extending the overall waiting time for users.

> _Moreover, currently only resource files have HTTP Cache set, while the main page does not._

Additionally, you can refer to [Google PageSpeed Insights](https://pagespeed.web.dev/){:target="_blank"} for optimization suggestions, such as compression, reducing script size, etc.

![](/assets/5033090c18ba/1*ihntq14ZIPCHnJvgBKAKDQ.png)

> _Since the core of in-app WKWebView is still the web page itself, adjusting from the frontend web is a very effective way to achieve significant results with minimal effort. ðŸŽ‰ðŸŽ‰ðŸŽ‰_

### Focus on User Experience ðŸŽ‰ðŸŽ‰ðŸŽ‰

![](/assets/5033090c18ba/1*lxEvkhODfhjmEqE21zLcRw.png)

> _A simple implementation focusing on user experience is to add a Loading Progress Bar, rather than just displaying a blank page that leaves users confused; let them know that the page is loading and how far along it is. ðŸŽ‰ðŸŽ‰ðŸŽ‰_

### Conclusion

The above are some thoughts and research on feasible solutions for WKWebView preloading and caching. The technology itself is not the biggest issue; the key is the choice of which methods are most effective for users and require the least investment from the development side. Choosing these methods may only require small adjustments to achieve the goal directly; choosing the wrong methods can lead to a significant investment of resources going in circles and likely result in difficulties in maintenance and usage later on.

> _There are always more solutions than difficulties; sometimes it just requires imagination._

Perhaps there are also brilliant combinations that I haven't thought of; everyone is welcome to contribute.

### References
#### WKWebView Preload Pure Resource ðŸŽ‰ Solutions can refer to the following video

[!["Preload strategies using WKWebView" by JonatÃ¡n Urquiza](/assets/5033090c18ba/bc6c_hqdefault.jpg ""Preload strategies using WKWebView" by JonatÃ¡n Urquiza")](https://www.youtube.com/watch?v=ZQvyfFieBfs){:target="_blank"}

The author also mentioned the WKURLSchemeHandler method.

**The complete Demo Repo in the video is as follows:**

[![](https://opengraph.githubassets.com/6789eaaf4d4f56f69df9d39e4abae4a910b10da24a14ff934a367da52fbde78c/jonurq/preload-strategies-wkwebview)](https://github.com/jonurq/preload-strategies-wkwebview){:target="_blank"}

#### iOS Old Driver Weekly

[![](https://repository-images.githubusercontent.com/115476023/2a31ab00-183a-11eb-889c-b9674f419108)](https://github.com/SwiftOldDriver/iOS-Weekly/issues?q=WkWebView){:target="_blank"}

The shares about WkWebView in the Old Driver Weekly are also worth a look.
### Miscellaneous

It's been a while since I returned to writing long articles related to iOS development.

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-wkwebview-%E9%A0%81%E9%9D%A2%E8%88%87%E6%AA%94%E6%A1%88%E8%B3%87%E6%BA%90-preload-%E9%A0%90%E8%BC%89-cache-%E7%B7%A9%E5%AD%98%E7%A0%94%E7%A9%B6-5033090c18ba){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```