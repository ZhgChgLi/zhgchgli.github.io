---
title: "iOS WKWebView Page and File Resource Preload / Cache Research"
author: "ZhgChgLi"
date: 2024-07-28T09:53:05.535+0000
last_modified_at: 2024-08-10T09:11:41.233+0000
categories: ["ZRealm Dev."]
tags: ["ios","ios-app-development","cache","webview","http-request"]
description: "Research on pre-downloading and caching resources in iOS WKWebView to improve page loading speed."
image:
  path: /assets/5033090c18ba/1*KACJYJkLfa2u5iKYJlJb2Q.jpeg
render_with_liquid: false
---

### iOS WKWebView Page and File Resource Preload / Cache Research

Research on pre-downloading and caching resources in iOS WKWebView to improve page loading speed.



![Photo by [Antoine Gravier](https://unsplash.com/@antoine_gravphotos?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}](/assets/5033090c18ba/1*KACJYJkLfa2u5iKYJlJb2Q.jpeg)

Photo by [Antoine Gravier](https://unsplash.com/@antoine_gravphotos?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash){:target="_blank"}
#### Background

For some reason, I have always had a connection with "Cache." Previously, I was responsible for researching and practicing the " [iOS HLS Cache Implementation Exploration Journey](../d796bf8e661e/) " and " [AVPlayer Local Cache Functionality Overview](../6ce488898003/) "; unlike streaming cache, which aims to reduce playback traffic, **the main task this time is to improve the loading speed of In-app WKWebView**. This also involves research on WKWebView's preloading and caching; however, to be honest, the WKWebView scenario is more complex. Unlike AVPlayer streaming audio and video, which consists of one or more continuous chunk files that only need to be cached, WKWebView not only has its own page files but also includes resource files (e.g., .js, .css, font, image…) that are rendered into a page by the Browser Engine for the user. There are many aspects that the app cannot control, from the network to the performance of front-end JavaScript syntax and rendering methods, all of which take time.

**This article only studies the technical feasibility of iOS and does not necessarily represent the final solution. Overall, it is better for front-end developers to tackle this issue to achieve a more efficient outcome.** I urge front-end partners to optimize the time it takes for the first contentful paint and improve the HTTP cache mechanism, which can accelerate both Web/mWeb itself and influence the speed of Android/iOS in-app WebView, and will also enhance [Google SEO ranking](https://developers.google.com/search/blog/2018/01/using-page-speed-in-mobile-search?hl=zh-tw){:target="_blank"}.
### Technical Details
#### iOS Limitations

According to [Apple Review Guidelines 2.5.6](https://developer.apple.com/app-store/review/guidelines/){:target="_blank"}:


> _Apps that browse the web must use the appropriate WebKit framework and WebKit JavaScript. You may apply for an entitlement to use an alternative web browser engine in your app. [Learn more about these entitlements](https://developer.apple.com/support/alternative-browser-engines/){:target="_blank"}._

```markdown
**Apps can only use the WebKit Framework (WKWebView) provided by Apple, and the use of third-party or modified WebKit engines is not allowed**, otherwise, the app will not be permitted for submission; additionally, starting from iOS 17.4, in order to comply with regulations, regions in the EU can [use other Browser Engines](https://developer.apple.com/support/alternative-browser-engines/){:target="_blank"} after **obtaining special permission from Apple**.

> What Apple does not provide, we cannot do.

\[未驗證\] Research indicates that even the iOS versions of Chrome and Firefox can only use Apple WebKit (WKWebView).

**Another very important point:**

> _WKWebView runs on a separate thread outside the main thread of the app, so all requests and operations do not go through our app._

#### HTTP Cache Flow

![](/assets/5033090c18ba/1*ozXaaWpTfw6IJOwt54EzsQ.jpeg)

The HTTP protocol includes a Cache protocol, and the system has already implemented a caching mechanism in all network-related components (URLSession, WKWebView, etc.), so the Client App does not need to implement anything, and it is not recommended to create your own caching mechanism; following the HTTP protocol is the fastest, most stable, and most effective way.

**The general operation flow of HTTP Cache is as follows:**
1. The client initiates a request.
2. The server responds with a Cache strategy in the Response Header, and the system's URLSession, WKWebView, etc., will automatically cache the Response based on the Cache Header, and subsequent requests will automatically apply this strategy.
3. When requesting the same resource again, if the cache has not expired, it will directly read the local cache from memory or disk and respond to the app.
4. If it has expired (expiration does not mean invalid), a real network request will be initiated to ask the server; if the content has not changed (even if it is expired, it is still valid), the server will respond with 304 Not Modified (Empty Body). Although a network request is actually made, the response time is basically in milliseconds with no Response Body, resulting in minimal traffic consumption.
5. If the content has changed, the data and Cache Header will be provided again.

> _Caching can occur not only in local Cache but also in Network Proxy Servers or along the way._

**Common HTTP Response Cache Header parameters:**
```yaml
expires: RFC 2822 date
pragma: no-cache
# Newer parameters:
cache-control: private/public/no-store/no-cache/max-age/s-max-age/must-revalidate/proxy-revalidate...
etag: XXX
```

**Common HTTP Request Cache Header parameters:**
```yaml
If-Modified-Since: 2024-07-18 13:00:00
IF-None-Match: 1234
```

> **_In iOS, network-related components (URLSession, WKWebView, etc.) handle HTTP Request/Response Cache Headers themselves and automatically perform caching; we do not need to handle Cache Header parameters ourselves._**

More detailed information on how HTTP Cache works can be found in "[Huli's Step-by-Step Understanding of HTTP Cache Mechanism](https://blog.techbridge.cc/2017/06/17/cache-introduction/){:target="_blank"}"
### Overview of iOS WKWebView

![](/assets/5033090c18ba/1*j9uw_OGpR-Lrq_4Gpj5beA.jpeg)

Back to iOS, since we can only use Apple WebKit, we can only explore ways to achieve preloaded caching through the WebKit methods provided by Apple.

The above image summarizes all the Apple iOS WebKit (WKWebView) related methods introduced using ChatGPT 4o, along with brief descriptions; the green section includes methods related to data storage.

**Here are a few interesting methods to share:**
- WKProcessPool: Allows multiple WKWebViews to share resources, data, cookies, etc.
- WKHTTPCookieStore: Manages WKWebView cookies, as well as cookies between WKWebViews or within the app's URLSession and WKWebView.
- WKWebsiteDataStore: Manages website cache files. (Can only read information and clear)
- WKURLSchemeHandler: Allows registration of a custom handler to process URL schemes that WKWebView cannot recognize.
- WKContentWorld: Allows grouping management of injected JavaScript (WKUserScript) scripts.
- WKFindXXX: Controls the page search functionality.
- WKContentRuleListStore: Implements content blocking functionality (e.g., blocking ads) within WKWebView.
```

### iOS WKWebView Preloading Cache Feasibility Study
### Improving HTTP Cache ✅

As introduced in the previous section about the HTTP Cache mechanism, we can ask the Web Team to enhance the HTTP Cache settings for the activity page. The Client iOS side only needs to perform a simple check on the CachePolicy settings; the system will handle the rest!
#### **CachePolicy Settings**

**URLSession:**
```swift
let configuration = URLSessionConfiguration.default
configuration.requestCachePolicy = .useProtocolCachePolicy
let session = URLSession(configuration: configuration)
```

**URLRequest/WKWebView:**
```swift
var request = URLRequest(url: url)
request.cachePolicy = .reloadRevalidatingCacheData
//
wkWebView.load(request)
```
- **useProtocolCachePolicy** : Default, follows the default HTTP Cache control.
- **reloadIgnoringLocalCacheData** : Does not use local cache, loads data from the network on every request (but allows network, Proxy cache…).
- **reloadIgnoringLocalAndRemoteCacheData** : Always loads data from the network, regardless of local or remote cache.
- **returnCacheDataElseLoad** : Uses cached data if available; otherwise, loads data from the network.
- **returnCacheDataDontLoad** : Only uses cached data; does not make a network request if no cached data is available.
- **reloadRevalidatingCacheData** : Sends a request to check if the local cache is expired; if not expired (304 Not Modified), uses cached data; otherwise, reloads data from the network.

#### **Setting Cache Size**

**App Global:**
```swift
let memoryCapacity = 512 * 1024 * 1024 // 512 MB
let diskCapacity = 10 * 1024 * 1024 * 1024 // 10 GB
let urlCache = URLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: "myCache")
        
URLCache.shared = urlCache
```

**Individual URLSession:**
```csharp
let memoryCapacity = 512 * 1024 * 1024 // 512 MB
let diskCapacity = 10 * 1024 * 1024 * 1024 // 10 GB
let cache = URLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: "myCache")
        
let configuration = URLSessionConfiguration.default
configuration.urlCache = cache
```


> **_Additionally, as mentioned earlier, WKWebView runs on a separate thread outside the main App thread, so the cache for URLRequest and URLSession is not shared with WKWebView._** 




#### **How to Use Safari Developer Tools in** WKWebView **?**

Check if local Cache is being used.

**Enable Developer Features in Safari:**


![](/assets/5033090c18ba/1*6j4djW1IeD2n8FGX6FbOtw.png)


**Enable isInspectable in WKWebView:**
```swift
func makeWKWebView() -> WKWebView {
 let webView = WKWebView(frame: .zero)
 webView.isInspectable = true // is only available in ios 16.4 or newer
 return webView
}
```

WKWebView must have `webView.isInspectable = true` to use Safari Developer Tools in the Debug Build version.

![p.s. This is a test WKWebView project I opened separately](/assets/5033090c18ba/1*6E6AfdFW3w7nvO2VlbhRCA.png)

p.s. This is a test WKWebView project I opened separately

Set a breakpoint at `webView.load`.

**Start Testing:**

Build & Run:

![](/assets/5033090c18ba/1*8jCKl-UzSLrfjy9IAm26pA.png)

When you reach the webView.load breakpoint, click "Step Over".

![](/assets/5033090c18ba/1*LAX4hrwffthRAtK-_9Q42A.png)

Return to Safari, select "Develop" from the toolbar -> "Simulator" -> "Your Project" -> "about:blank".
- Since the page has not started loading yet, the URL will be about:blank.
- If about:blank does not appear, return to XCode and click the step over button again until it appears.

The developer tools corresponding to that page will appear:

![](/assets/5033090c18ba/1*kde2nIvjC8CxFBIcoVhXqg.png)

Back in XCode, click continue:

![](/assets/5033090c18ba/1*PtAMLX46fNwFDfF7lidyaA.png)

Returning to the Safari developer tools will allow you to see the resource loading status and the full functionality of the developer tools (components, storage debugging, etc.).

![](/assets/5033090c18ba/1*l0vGOvT2UupVCvf4MrLgUA.png)

**If the network resource has HTTP Cache, the size will be displayed as "Disk":**

![](/assets/5033090c18ba/1*TMIPgtC2SVYzEmBD_xPQ_A.png)

![](/assets/5033090c18ba/1*KNbus1iFkCl4HjWThyYoew.png)

Clicking in will also show cache information.
#### Clear WKWebView Cache
```swift
// Clean Cookies
HTTPCookieStorage.shared.removeCookies(since: Date.distantPast)

// Clean Stored Data, Cache Data
let dataTypes = WKWebsiteDataStore.allWebsiteDataTypes()
let store = WKWebsiteDataStore.default()
store.fetchDataRecords(ofTypes: dataTypes) { records in
 records.forEach { record in
  store.removeData(
   ofTypes: record.dataTypes,
   for: records,
   completionHandler: {
          print("clearWebViewCache() - \(record)")           
   }
  )
 }
}
```

You can use the above method to clear cached resources, local data, and cookie data from WKWebView.

> **_However, improving HTTP Cache only addresses the caching part (it will be fast on the second entry), preloading (the first entry) will not be affected._** _✅_

### Improving HTTP Cache + WKWebView Preload Full Page 😕
```swift
class WebViewPreloader {
    static let shared = WebViewPreloader()

    private var _webview: WKWebView = WKWebView()

    private init() { }

    func preload(url: URL) {
        let request = URLRequest(url: url)
        Task { @MainActor in
            webview.load(request)
        }
    }
}

WebViewPreloader.shared.preload("https://zhgchg.li/campaign/summer")
```

Based on the improved HTTP Cache, the second Load of WKWebView will have caching. We can preload all the URLs in the list or homepage once to ensure they are cached, allowing users to access them more quickly.

> **_Through testing, the principle is feasible; however, it consumes too much performance and network traffic_** _; users may not even enter the detailed page, but we preload all pages, which feels a bit like shooting in the dark._

> _Personally, I believe it is impractical in reality, and the benefits outweigh the drawbacks, akin to throwing the baby out with the bathwater.😕_

### Perfecting HTTP Cache + WKWebView Preload Pure Resources 🎉

Based on the optimization of the above method, we can combine it with the HTML Link Preload method, specifically preloading only the resource files that will be used in the page (e.g., .js, .css, font, image…) so that users can directly use the cached resources without making additional network requests for resource files.

> **_This means I am no longer preloading everything on the entire page; I am only preloading the resource files that will be used on the page, which may also be shared across pages; the page file .html is still fetched from the network and combined with the preloaded files to render the page._**

Please note: This still relies on HTTP Cache, so these resources must also support HTTP Cache; otherwise, subsequent requests will still go over the network.

Please note: This still relies on HTTP Cache, so these resources must also support HTTP Cache; otherwise, subsequent requests will still go over the network.

Please note: This still relies on HTTP Cache, so these resources must also support HTTP Cache; otherwise, subsequent requests will still go over the network.
```xml
<!DOCTYPE html>
<html lang="zh-tw">
 <head>
    <link rel="preload" href="https://cdn.zhgchg.li/dist/main.js" as="script">
    <link rel="preload" href="https://image.zhgchg.li/v2/image/get/campaign.jpg" as="image">
    <link rel="preload" href="https://cdn.zhgchg.li/assets/fonts/glyphicons-halflings-regular.woff2" as="font">
    <link rel="preload" href="https://cdn.zhgchg.li/assets/fonts/Simple-Line-Icons.woff2?v=2.4.0" as="font">
  </head>
</html>
```

**Common Supported File Types:**
- .js script
- .css style
- font
- image

The Web Team will place the above HTML content in the path agreed upon with the App, and our `WebViewPreloader` will change to load this path, allowing WKWebView to parse the `<link>` preload resources and generate the cache.
```swift
WebViewPreloader.shared.preload("https://zhgchg.li/campaign/summer/preload")
// or uniformly at
WebViewPreloader.shared.preload("https://zhgchg.li/assets/preload")
```

> **_Through testing, a good balance can be achieved between data consumption and preloading._** 🎉

> **_The downside is that this cache resource list needs to be maintained, and web optimization for page rendering and loading is still required; otherwise, the perceived loading time for the first page will still be long._**

### URLProtocol _❌_

Additionally, let's think about our old friend [URLProtocol](https://developer.apple.com/documentation/foundation/urlprotocol){:target="_blank"}, which can intercept and manipulate all requests based on the `URL Loading System` (URLSession, openURL…).
```swift
class CustomURLProtocol: URLProtocol {
    override class func canInit(with request: URLRequest) -> Bool {
        // Determine whether to handle this request
        if let url = request.url {
            return url.scheme == "custom"
        }
        return false
    }
    
    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        // Return the request
        return request
    }
    
    override func startLoading() {
        // Handle the request and load data
        // Change to cache strategy, first read the file from local
        if let url = request.url {
            let response = URLResponse(url: url, mimeType: "text/plain", expectedContentLength: -1, textEncodingName: nil)
            self.client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)
            
            let data = "This is a custom response!".data(using: .utf8)!
            self.client?.urlProtocol(self, didLoad: data)
            self.client?.urlProtocolDidFinishLoading(self)
        }
    }
    
    override func stopLoading() {
        // Stop loading data
    }
}

// AppDelegate.swift didFinishLaunchingWithOptions:
URLProtocol.registerClass(CustomURLProtocol.self)
```


The abstract idea is to stealthily send a URLRequest in the background -> URLProtocol -> download all resources from it, user -> WKWebView -> Request -> URLProtocol -> respond with preloaded resources.


> **_As mentioned before, WKWebView runs on a separate thread outside the main thread of the app, so URLProtocol cannot intercept requests from WKWebView._** 


> **_However, I've heard that some black magic might work, but it's not recommended as it could lead to other issues (like rejection during review)._** 


> **_This path is blocked_** _❌._ 




### WKURLSchemeHandler _😕_

Apple introduced this new method in iOS 11, seemingly to compensate for the inability of WKWebView to use URLProtocol; however, this method is similar to [AVPlayer's ResourceLoader](../6ce488898003/), **only schemes that the system cannot recognize will be handed over to our custom WKURLSchemeHandler for processing**.

The abstract idea is still to stealthily send a WKWebView -> Request -> WKURLSchemeHandler in the background -> download all resources from it, user -> WKWebView -> Request -> WKURLSchemeHandler -> respond with preloaded resources.
```swift
import WebKit

class CustomSchemeHandler: NSObject, WKURLSchemeHandler {
    func webView(_ webView: WKWebView, start urlSchemeTask: WKURLSchemeTask) {
        // Handle custom
        let url = urlSchemeTask.request.url!
        
        if url.scheme == "custom-scheme" {
            // Change to cache strategy, read file from local first
            let response = URLResponse(url: url, mimeType: "text/html", expectedContentLength: -1, textEncodingName: nil)
            urlSchemeTask.didReceive(response)
            
            let html = "<html><body><h1>Hello from custom scheme!</h1></body></html>"
            let data = html.data(using: .utf8)!
            urlSchemeTask.didReceive(data)
            urlSchemeTask.didFinish()
        }
    }

    func webView(_ webView: WKWebView, stop urlSchemeTask: WKURLSchemeTask) {
        // Stop
    }
}

let webViewConfiguration = WKWebViewConfiguration()
webViewConfiguration.setURLSchemeHandler(CustomSchemeHandler(), forURLScheme: "mycacher")

let customURL = URL(string: "mycacher://zhgchg.li/campaign/summer")!
webView.load(URLRequest(url: customURL))
```
- Since http/https are schemes that the system can handle, we cannot define custom handling for http/https; we need to change the scheme to one that the system does not recognize (e.g., `mycacher://`).
- All paths in the page must use relative paths to automatically prepend `mycacher://` so that our handler can capture them.
- If you don't want to change http/https but still want to capture http/https requests, you can only resort to black magic, **not recommended,** as it could lead to other issues (like rejection during review).
- Self-caching page files and responding may cause Ajax, XMLHttpRequest, and Fetch requests used in the page to be blocked by [**CORS Same-Origin Policy**](https://developer.mozilla.org/zh-TW/docs/Web/Security/Same-origin_policy){:target="_blank"}, which requires lowering the website's security to use (because it will turn into mycacher:// sending requests to http://zhgchg.li/xxx, which are different origins).
- You may need to implement your own Cache Policy, such as when to update? How long is it valid? **\(This is similar to what HTTP Cache does\)**

```markdown
> **_In summary, while it is theoretically feasible, the implementation requires significant investment; overall, it does not align with cost-effectiveness and is difficult to scale and maintain stability._** _😕_ 

It seems that the WKURLSchemeHandler method is more suitable for scenarios where there are large resource files to download within a webpage, declaring a custom scheme for the app to handle, collaborating to render the webpage.
#### Bridging WKWebView network requests to be sent by the app 🫥

WKWebView is changed to call the app's predefined interface (WkUserScript) instead of Ajax, XMLHttpRequest, or Fetch, allowing the app to request resources.

> _This case is not very helpful because the delay is in the appearance of the first screen, rather than in subsequent loading; moreover, this method creates a strange dependency relationship between Web and App 🫥_ 

### Starting from Service Worker _❌_

> _Due to security issues, only Apple's own Safari app supports it; WKWebView does not support it ❌._ 

### WKWebView Performance Optimization 🫥

Optimizing the performance of WKWebView Load View.

> _WKWebView itself is like a skeleton, while the web page is the flesh and blood. Research shows that optimizing the skeleton (e.g., reusing WKProcessPool) has very limited effects, possibly a difference of 0.0003 -> 0.000015 seconds._ 

### Local HTML, Local Resource Files 🫥

Similar to the Preload method, but instead, the active page is placed in the App Bundle or fetched from a remote source at startup.

> _Placing the entire HTML page may also encounter CORS same-origin issues; simply placing web resource files seems to be replaceable with the "Complete HTTP Cache + WKWebView Preload pure resources" method; placing in the App Bundle unnecessarily increases App Size, while fetching from remote is just WKWebView Preload 🫥_ 

### Frontend Optimization 🎉🎉🎉

![[Source: wedevs](https://wedevs.com/blog/348939/first-contentful-paint-largest-contentful-paint/){:target="_blank"}](/assets/5033090c18ba/1*Y3nDpbc4aEd0wg7Enk4k8A.png)

[Source: wedevs](https://wedevs.com/blog/348939/first-contentful-paint-largest-contentful-paint/){:target="_blank"}

Referencing [wedevs optimization suggestions](https://wedevs.com/blog/348939/first-contentful-paint-largest-contentful-paint/){:target="_blank"}, the frontend HTML page should have four loading stages, from the initial loading of the page file (.html) First Paint (blank page) to First Contentful Paint (rendering the page skeleton), then to First Meaningful Paint (filling in the page content) to Time To Interactive (finally allowing user interaction).

![](/assets/5033090c18ba/1*UirBj7nm_spU6knKbsyzxA.png)

Testing with our page; the browser and WKWebView first request the main page .html and then load the necessary resources, simultaneously constructing the screen for the user according to program instructions. Comparing with the article, it turns out that the page stages only go from First Paint (blank) to Time To Interactive (First Contentful Paint only has the Navigation Bar, which probably doesn't count...), missing the intermediate phased rendering for the user, thus extending the overall waiting time for the user.

> _Moreover, currently only resource-type files have HTTP Cache set, while the main page does not._ 

Additionally, you can refer to [Google PageSpeed Insights](https://pagespeed.web.dev/){:target="_blank"} for optimization suggestions, such as compression, reducing script size, etc.

![](/assets/5033090c18ba/1*ihntq14ZIPCHnJvgBKAKDQ.png)

> _Since the core of in-app WKWebView is still the web page itself; thus, adjusting from the frontend web is a very effective way to achieve significant results with minimal effort. 🎉🎉🎉_ 

### Focusing on User Experience 🎉🎉🎉

![](/assets/5033090c18ba/1*lxEvkhODfhjmEqE21zLcRw.png)
```

```markdown
> _A simple implementation that focuses on user experience by adding a Loading Progress Bar, so users are not left staring at a blank page without knowing what's happening. It lets them know that the page is loading and shows the progress. 🎉🎉🎉_

### Conclusion

The above is a summary of some thoughts and research on feasible solutions for preloading and caching with WKWebView. The technology itself is not the biggest issue; the key is the choice of methods that are most effective for users while minimizing costs for developers. Choosing the right methods may only require small adjustments to achieve the goal directly; choosing the wrong methods can lead to significant resource investment with little progress and may make future maintenance and usage difficult.

> _There are always more solutions than difficulties; sometimes it's just a lack of imagination._

Perhaps there are also brilliant combinations that I haven't thought of, and everyone is welcome to contribute.

### References
#### WKWebView Preload Pure Resource 🎉 Solutions can refer to the following video

[!["Preload strategies using WKWebView" by Jonatán Urquiza](/assets/5033090c18ba/bc6c_hqdefault.jpg ""Preload strategies using WKWebView" by Jonatán Urquiza")](https://www.youtube.com/watch?v=ZQvyfFieBfs){:target="_blank"}

Additionally, the author also mentioned the WKURLSchemeHandler method.

**The complete Demo Repo in the video is as follows:**

[![](https://opengraph.githubassets.com/6789eaaf4d4f56f69df9d39e4abae4a910b10da24a14ff934a367da52fbde78c/jonurq/preload-strategies-wkwebview)](https://github.com/jonurq/preload-strategies-wkwebview){:target="_blank"}

#### iOS Old Driver Weekly

[![](https://repository-images.githubusercontent.com/115476023/2a31ab00-183a-11eb-889c-b9674f419108)](https://github.com/SwiftOldDriver/iOS-Weekly/issues?q=WkWebView){:target="_blank"}

The shares about WkWebView in the Old Driver Weekly are also worth a look.

### Miscellaneous

A long-awaited return to writing in-depth articles related to iOS development.

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-wkwebview-%E9%A0%81%E9%9D%A2%E8%88%87%E6%AA%94%E6%A1%88%E8%B3%87%E6%BA%90-preload-%E9%A0%90%E8%BC%89-cache-%E7%B7%A9%E5%AD%98%E7%A0%94%E7%A9%B6-5033090c18ba){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```
