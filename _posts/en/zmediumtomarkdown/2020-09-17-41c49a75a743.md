---
title: "Using Swift to Write Run Scripts Directly in Xcode!"
author: "ZhgChgLi"
date: 2020-09-17T15:53:20.026+0000
last_modified_at: 2024-04-13T08:35:25.885+0000
categories: ["ZRealm Dev."]
tags: ["ios","shell-script","xcode","ios-app-development","toolkit"]
description: "Introducing Localization multilingual support and checking for missing Image Assets, using Swift to create Run Script."
image:
  path: /assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg
render_with_liquid: false
---

### Using Swift to Write Shell Scripts Directly in Xcode!

Introducing Localization multilingual support and checking for missing Image Assets, using Swift to create Shell Script.

![Photo by [Glenn Carstens\-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg)

Photo by [Glenn Carstens\-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Background

Due to my clumsiness, I often miss the ";" when editing multilingual files, causing the app to build with incorrect language displays. As development progresses, the localization files become increasingly large, with repeated and unused phrases mixed together, creating a very chaotic situation (the same applies to Image Assets).

I have always wanted to find a tool to help address these issues. Previously, I used [iOSLocalizationEditor](https://github.com/igorkulman/iOSLocalizationEditor){:target="_blank"}, a Mac app that functions more like a localization file editor, allowing for reading and editing localization file contents, but it lacks an automatic checking feature.
### Desired Features

Automatically check for errors, omissions, duplicates in multilingual files, and missing Image Assets during project builds.
### Solution

To achieve our desired functionality, we need to add a Run Script check script in the Build Phases.

However, the check script needs to be written in shell script, and since my grasp of shell script is not very strong, I thought about searching for existing scripts online but couldn't find one that fully meets the desired functionality. Just when I was about to give up, I suddenly thought:

> **Shell scripts can be written in Swift!**

I am much more familiar with and have a better grasp of Swift compared to shell scripts! Following this direction, I indeed found two existing tool scripts!

Two checking tools written by the team at [freshOS](https://freshos.github.io/){:target="_blank"}:
- [**Localize 🏁**](https://github.com/freshOS/Localize){:target="_blank"}
- [**Asset Checker 👮**](https://github.com/s4cha/AssetChecker){:target="_blank"}

They completely meet our desired functionality requirements! Moreover, they are written in Swift, making customization and modifications very easy.
#### [Localize 🏁](https://github.com/freshOS/Localize){:target="_blank"} Multilingual File Checking Tool

**Features:**
- Automatically checks during build
- Automatically formats and organizes localization files
- Checks for omissions and extras in multilingual files compared to the primary language
- Checks for duplicate phrases in multilingual files
- Checks for untranslated phrases in multilingual files
- Checks for unused phrases in multilingual files

**Installation Method:**
1. [Download the Swift Script file of the tool](https://github.com/freshOS/Localize/blob/master/Localize.swift){:target="_blank"}
2. Place it in the project directory, e.g., `${SRCROOT}/Localize.swift`
3. Open project settings → iOS Target → Build Phases → click the "+" in the top left → New Run Script Phase → paste the path in the Script content, e.g., `${SRCROOT}/Localize.swift`

```markdown
![](/assets/41c49a75a743/1*k2OHjrcQaQIWLqV7G57TgA.png)

4. Open the `Localize.swift` file in Xcode for configuration. You can see the adjustable settings in the upper half of the file:
```swift
// Enable check script
let enabled = true

// Localization file directory
let relativeLocalizableFolders = "/Resources/Languages"

// Project directory (used to search if phrases are used in the code)
let relativeSourceFolder = "/Sources"

// Regular expression for NSLocalized localization file usage in code
// You can add more without modification
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\"", // Swift and Objc Native
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine Calls
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen generation
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized pattern
]

// Phrases to ignore for "unused key warnings"
let ignoredFromUnusedKeys: [String] = []
/* example
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

// Primary language
let masterLanguage = "en"

// Enable sorting and organizing files a-z
let sanitizeFiles = false

// Is the project single or multilingual
let singleLanguage = false

// Enable check for untranslated phrases
let checkForUntranslated = true
```

5. Build! Success!

![](/assets/41c49a75a743/1*74osParg9RRi2gcRx9ELuw.png)

**Check result prompt types:**
- **Build Error** ❌ **:**
  - \[Duplication\] The item exists multiple times in the localization file
  - \[Unused Key\] The item is defined in the localization file but not used in the actual program
  - \[Missing\] The item is not defined in the localization file but is used in the actual program
  - \[Redundant\] The item is redundant compared to the primary localization file
  - \[Missing Translation\] The item exists in the primary localization file but is missing in this localization file
- **Build Warning** ⚠️ **:**
  - \[Potentially Untranslated\] This item is untranslated (content is the same as the main localization file item)

> **_Not done yet, we now have automatic check prompts, but we still need to manually tweak a bit._**

**Custom Regex Matching:**

Looking back at the check script `Localize.swift`, the first item in the settings section for patterns:

`"NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\""`

Matches the `NSLocalizedString()` method in Swift/ObjC. This regular expression can only match phrases in the format of `"Home.Title"`; if we have complete sentences or those with format parameters, they will be mistakenly treated as \[Unused Key\].

EX: `"Hi, %@ welcome to my app", "Hello World!"` **&lt;\- These phrases cannot be matched**

We can add a new patterns setting or change the original patterns to:

`"NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\""`

This mainly adjusts the matching phrase after the `NSLocalizedString` method to capture any string until `"` appears, and you can also [click here](https://rubular.com/r/5eXvGy3svsAHyT){:target="_blank"} to customize it according to your needs.
```

```markdown
**Add Language File Format Check Functionality:**

This script only checks the content correspondence of language files and does not check whether the file format is correct (e.g., whether a **;** is missing). If you need this functionality, you will have to add it yourself!
```swift
//....
let formatResult = shell("plutil -lint \(location)")
guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
  let str = "\(path)/\(name).lproj"
            + "/Localizable.strings:1: "
            + "error: [File Invalid] "
            + "This Localizable.strings file format is invalid."
  print(str)
  numberOfErrors += 1
  return
}
//....

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```

Add `shell()` to execute shell scripts, using `plutil -lint` to check the correctness of plist language file formats. Errors or missing **;** will return an error, while no errors will return `OK` for judgment!

The check can be added after `let location = singleLanguage…` in LocalizationFiles->process(), around line 135, or refer to the complete modified version I provided at the end.

**Other Customizations:**

We can customize according to our needs, such as changing error to warning or removing a certain check function (EX: Potentially Untranslated, Unused Key); the script is in Swift, which we are all familiar with! Don't worry about breaking or making mistakes!

To show an Error ❌ during build:
```
print("Project file.lproj" + "/file:line: " + "error: Error message")
```

To show a Warning ⚠️ during build:
```
print("Project file.lproj" + "/file:line: " + "warning: Warning message")
```

**Final Modified Version:**
```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// WHAT
// 1. Find Missing keys in other Localization files
// 2. Find potentially untranslated keys
// 3. Find Duplicate keys
// 4. Find Unused keys and generate script to delete them all at once

// MARK: Start Of Configurable Section

/*
 You can enable or disable the script whenever you want
 */
let enabled = true

/*
 Put your path here, example ->  Resources/Localizations/Languages
 */
let relativeLocalizableFolders = "/streetvoice/SupportingFiles"

/*
 This is the path of your source folder which will be used in searching
 for the localization keys you actually use in your project
 */
let relativeSourceFolder = "/streetvoice"

/*
 Those are the regex patterns to recognize localizations.
 */
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\"", // Swift and Objc Native
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine Calls
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen generation
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized pattern
]

/*
 Those are the keys you don't want to be recognized as "unused"
 For instance, Keys that you concatenate will not be detected by the parsing
 so you want to add them here in order not to create false positives :)
 */
let ignoredFromUnusedKeys: [String] = []
/* example
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

let masterLanguage = "base"

/*
 Sanitizing files will remove comments, empty lines and order your keys alphabetically.
 */
let sanitizeFiles = false

/*
 Determines if there are multiple localizations or not.
 */
let singleLanguage = false

/*
 Determines if we should show errors if there's a key within the app
 that does not appear in master translations.
*/
let checkForUntranslated = false

// MARK: End Of Configurable Section

if enabled == false {
    print("Localization check cancelled")
    exit(000)
}

// Detect list of supported languages automatically
func listSupportedLanguages() -> [String] {
    var sl: [String] = []
    let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
    if !FileManager.default.fileExists(atPath: path) {
        print("Invalid configuration: \(path) does not exist.")
        exit(1)
    }
    let enumerator = FileManager.default.enumerator(atPath: path)
    let extensionName = "lproj"
    print("Found these languages:")
    while let element = enumerator?.nextObject() as? String {
        if element.hasSuffix(extensionName) {
            print(element)
            let name = element.replacingOccurrences(of: ".\(extensionName)", with: "")
            sl.append(name)
        }
    }
    return sl
}

let supportedLanguages = listSupportedLanguages()
var ignoredFromSameTranslation: [String: [String]] = [:]
let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
var numberOfWarnings = 0
var numberOfErrors = 0

struct LocalizationFiles {
    var name = ""
    var keyValue: [String: String] = [:]
    var linesNumbers: [String: Int] = [:]

    init(name: String) {
        self.name = name
        process()
    }

    mutating func process() {
        if sanitizeFiles {
            removeCommentsFromFile()
            removeEmptyLinesFromFile()
            sortLinesAlphabetically()
        }
        let location = singleLanguage ? "\(path)/Localizable.strings" : "\(path)/\(name).lproj/Localizable.strings"
        
        let formatResult = shell("plutil -lint \(location)")
        guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
            let str = "\(path)/\(name).lproj"
                + "/Localizable.strings:1: "
                + "error: [File Invalid] "
                + "This Localizable.strings file format is invalid."
            print(str)
            numberOfErrors += 1
            return
        }
        
        guard let string = try? String(contentsOfFile: location, encoding: .utf8) else {
            return
        }

        let lines = string.components(separatedBy: .newlines)
        keyValue = [:]

        let pattern = "\"(.*)\" = \"(.+)\";"
        let regex = try? NSRegularExpression(pattern: pattern, options: [])
        var ignoredTranslation: [String] = []

        for (lineNumber, line) in lines.enumerated() {
            let range = NSRange(location: 0, length: (line as NSString).length)

            // Ignored pattern
            let ignoredPattern = "\"(.*)\" = \"(.+)\"; *\\/\\/ *ignore-same-translation-warning"
            let ignoredRegex = try? NSRegularExpression(pattern: ignoredPattern, options: [])
            if let ignoredMatch = ignoredRegex?.firstMatch(in: line,
                                                           options: [],
                                                           range: range) {
                let key = (line as NSString).substring(with: ignoredMatch.range(at: 1))
                ignoredTranslation.append(key)
            }

            if let firstMatch = regex?.firstMatch(in: line, options: [], range: range) {
                let key = (line as NSString).substring(with: firstMatch.range(at: 1))
                let value = (line as NSString).substring(with: firstMatch.range(at: 2))

                if keyValue[key] != nil {
                    let str = "\(path)/\(name).lproj"
                        + "/Localizable.strings:\(linesNumbers[key]!): "
                        + "error: [Duplication] \"\(key)\" "
                        + "is duplicated in \(name.uppercased()) file"
                    print(str)
                    numberOfErrors += 1
                } else {
                    keyValue[key] = value
                    linesNumbers[key] = lineNumber + 1
                }
            }
        }
        print(ignoredFromSameTranslation)
        ignoredFromSameTranslation[name] = ignoredTranslation
    }

    func rebuildFileString(from lines: [String]) -> String {
        return lines.reduce("") { (r: String, s: String) -> String in
            (r == "") ? (r + s) : (r + "\n" + s)
        }
    }

    func removeEmptyLinesFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeCommentsFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { !$0.hasPrefix("//") }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func sortLinesAlphabetically() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            let lines = string.components(separatedBy: .newlines)

            var s = ""
            for (i, l) in sortAlphabetically(lines).enumerated() {
                s += l
                if i != lines.count - 1 {
                    s += "\n"
                }
            }
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeEmptyLinesFromLines(_ lines: [String]) -> [String] {
        return lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
    }

    func sortAlphabetically(_ lines: [String]) -> [String] {
        return lines.sorted()
    }
}

// MARK: - Load Localization Files in memory

let masterLocalizationFile = LocalizationFiles(name: masterLanguage)
let localizationFiles = supportedLanguages
    .filter { $0 != masterLanguage }
    .map { LocalizationFiles(name: $0) }

// MARK: - Detect Unused Keys

let sourcesPath = FileManager.default.currentDirectoryPath + relativeSourceFolder
let fileManager = FileManager.default
let enumerator = fileManager.enumerator(atPath: sourcesPath)
var localizedStrings: [String] = []
while let swiftFileLocation = enumerator?.nextObject() as? String {
    // checks the extension
    if swiftFileLocation.hasSuffix(".swift") || swiftFileLocation.hasSuffix(".m") || swiftFileLocation.hasSuffix(".mm") {
        let location = "\(sourcesPath)/\(swiftFileLocation)"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            for p in patterns {
                let regex = try? NSRegularExpression(pattern: p, options: [])
                let range = NSRange(location: 0, length: (string as NSString).length) // Obj c wa
                regex?.enumerateMatches(in: string,
                                        options: [],
                                        range: range,
                                        using: { result, _, _ in
                                            if let r = result {
                                                let value = (string as NSString).substring(with: r.range(at: r.numberOfRanges - 1))
                                                localizedStrings.append(value)
                                            }
                })
            }
        }
    }
}

var masterKeys = Set(masterLocalizationFile.keyValue.keys)
let usedKeys = Set(localizedStrings)
let ignored = Set(ignoredFromUnusedKeys)
let unused = masterKeys.subtracting(usedKeys).subtracting(ignored)
let untranslated = usedKeys.subtracting(masterKeys)

// Here generate Xcode regex Find and replace script to remove dead keys all at once!
var replaceCommand = "\"("
var counter = 0
for v in unused {
    var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[v]!): "
    str += "error: [Unused Key] \"\(v)\" is never used"
    print(str)
    numberOfErrors += 1
    if counter != 0 {
        replaceCommand += "|"
    }
    replaceCommand += v
    if counter == unused.count - 1 {
        replaceCommand += ")\" = \".*\";"
    }
    counter += 1
}

print(replaceCommand)

// MARK: - Compare each translation file against master (en)

for file in localizationFiles {
    for k in masterLocalizationFile.keyValue.keys {
        if file.keyValue[k] == nil {
            var str = "\(path)/\(file.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[k]!): "
            str += "error: [Missing] \"\(k)\" missing from \(file.name.uppercased()) file"
            print(str)
            numberOfErrors += 1
        }
    }

    let redundantKeys = file.keyValue.keys.filter { !masterLocalizationFile.keyValue.keys.contains($0) }

    for k in redundantKeys {
        let str = "\(path)/\(file.name).lproj/Localizable.strings:\(file.linesNumbers[k]!): "
            + "error: [Redundant key] \"\(k)\" redundant in \(file.name.uppercased()) file"

        print(str)
    }
}

if checkForUntranslated {
    for key in untranslated {
        var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:1: "
        str += "error: [Missing Translation] \(key) is not translated"

        print(str)
        numberOfErrors += 1
    }
}

print("Number of warnings : \(numberOfWarnings)")
print("Number of errors : \(numberOfErrors)")

if numberOfErrors > 0 {
    exit(1)
}

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```

> **_Finally, it's not over yet!_** 

Once our Swift checking tool scripts are debugged, we need to **compile them into executables to reduce build time**; otherwise, we would have to recompile each time we build (which can reduce time by about 90%).

Open the terminal and navigate to the directory where the checking tool script is located in the project, then execute:
```bash
swiftc -o Localize Localize.swift
```

![](/assets/41c49a75a743/1*rwq_KZIDW-Lvtpd2xmgjDw.png)

![](/assets/41c49a75a743/1*BCKtqshZxHH17j3nBGtNlg.png)

Then go back to Build Phases and change the Script content path to the executable.

EX: `${SRCROOT}/Localize`

![](/assets/41c49a75a743/1*ewhCXzXNuS0MCTMCuINWng.png)

**Done!**
#### Tool 2. [**Asset Checker 👮**](https://github.com/s4cha/AssetChecker){:target="_blank"} **Image Resource Checking Tool**

**Features:**
- Automatically checks during build
- Checks for missing images: names are called, but the image resource directory does not contain them
- Checks for extra images: names are not used, but exist in the image resource directory

**Installation Method:**
1. [Download the Swift Script file for the tool](https://github.com/freshOS/AssetChecker/blob/master/Classes/main.swift){:target="_blank"}
2. Place it in the project directory EX: `${SRCROOT}/AssetChecker.swift`
3. Open project settings → iOS Target → Build Phases → top left “+” → New Run Script Phase → paste the path in the Script content

```bash
${SRCROOT}/AssetChecker.swift ${SRCROOT}/project_directory ${SRCROOT}/Resources/Images.xcassets
//${SRCROOT}/Resources/Images.xcassets = the location of your .xcassets
```

![](/assets/41c49a75a743/1*TPLS60W1iQiGFzU-inf3aA.png)

You can directly include the parameters in the path, parameter 1: project directory location, parameter 2: image resource directory location; or edit the `AssetChecker.swift` top parameter configuration section like the localization checking tool:
```swift
// Configure me \o/

// Project directory location (used to search if images are used in the code)
var sourcePathOption:String? = nil

// .xcassets directory location
var assetCatalogPathOption:String? = nil

// Unused warning ignore items
let ignoredUnusedNames = [String]()
```

4. Build! Success!

**Check Result Prompt Types:**
- **Build Error** ❌ **:**
\- \[Asset Missing\] Items are called in the program, but do not appear in the image resource directory
- **Build Warning** ⚠️ **:**
\- \[Asset Unused\] Items are not used in the program, but appear in the image resource directory
_p.s. If the images are provided by dynamic variables, the checking tool will not be able to identify them; you can add them to `ignoredUnusedNames` as exceptions._

Other operations are the same as the localization checking tool, so I won't elaborate here; the most important thing is to **remember to compile into an executable after debugging and change the run script content to the executable!**
#### Develop Your Own Tool!

> **_We can refer to the image resource checking tool script:_** 

```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// Configure me \o/
var sourcePathOption:String? = nil
var assetCatalogPathOption:String? = nil
let ignoredUnusedNames = [String]()

for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        sourcePathOption = arg
    case 2:
        assetCatalogPathOption = arg
    default:
        break
    }
}

guard let sourcePath = sourcePathOption else {
    print("AssetChecker:: error: Source path was missing!")
    exit(0)
}

guard let assetCatalogAbsolutePath = assetCatalogPathOption else {
    print("AssetChecker:: error: Asset Catalog path was missing!")
    exit(0)
}

print("Searching sources in \(sourcePath) for assets in \(assetCatalogAbsolutePath)")

/* Put here the asset generating false positives, 
 For instance when you build asset names at runtime
let ignoredUnusedNames = [
    "IconArticle",
    "IconMedia",
    "voteEN",
    "voteES",
    "voteFR"
] 
*/

// MARK : - End Of Configurable Section
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}

// MARK: - List Assets
func listAssets() -> [String] {
    let extensionName = "imageset"
    let enumerator = FileManager.default.enumerator(atPath: assetCatalogAbsolutePath)
    return elementsInEnumerator(enumerator)
        .filter { $0.hasSuffix(extensionName) }                             // Is Asset
        .map { $0.replacingOccurrences(of: ".\(extensionName)", with: "") } // Remove extension
        .map { $0.components(separatedBy: "/").last ?? $0 }                 // Remove folder path
}

// MARK: - List Used Assets in the codebase
func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // Image Literal
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // Default UIImage call (Swift)
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // Default UIImage call 
        "\\<image name=\"\(namePattern)\".*", // Storyboard resources
        "R.image.\(namePattern)\\(\\)" //R.swift support
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") || $0.hasSuffix(".swift") || $0.hasSuffix(".xib") || $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .compactMap{$0}
            .compactMap{$0}                                             // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings occurrences
            .flatMap{$0}                                                // Flatten
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") || $0.hasSuffix(".swift") || $0.hasSuffix(".xib") || $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .flatMap{$0}
            .flatMap{$0}                                                // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings occurrences
            .flatMap{$0}                                                // Flatten
    #endif
}

// MARK: - Beginning of script
let assets = Set(listAssets())
let used = Set(listUsedAssetLiterals() + ignoredUnusedNames)

// Generate Warnings for Unused Assets
let unused = assets.subtracting(used)
unused.forEach { print("\(assetCatalogAbsolutePath):: warning: [Asset Unused] \($0)") }

// Generate Error for broken Assets
let broken = used.subtracting(assets)
broken.forEach { print("\(assetCatalogAbsolutePath):: error: [Asset Missing] \($0)") }

if broken.count > 0 {
    exit(1)
}
```


Compared to the localization check script, this script is concise and includes all the important functions, making it very valuable for reference!

_P.S. You can see the code has the `localizedStrings()` naming, which makes me suspect that the author copied the logic from the localization check tool and forgot to change the method name XD_

**For example:**
```swift
for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        // Parameter 1
    case 2:
        // Parameter 2
    default:
        break
    }
}
```

^Method for receiving external parameters
```swift
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}

func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // Image Literal
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // Default UIImage call (Swift)
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // Default UIImage call 
        "\\<image name=\"\(namePattern)\".*", // Storyboard resources
        "R.image.\(namePattern)\\(\\)" //R.swift support
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") || $0.hasSuffix(".swift") || $0.hasSuffix(".xib") || $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .compactMap{$0}
            .compactMap{$0}                                             // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings occurrences
            .flatMap{$0}                                                // Flatten
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") || $0.hasSuffix(".swift") || $0.hasSuffix(".xib") || $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .flatMap{$0}
            .flatMap{$0}                                                // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings occurrences
            .flatMap{$0}                                                // Flatten
    #endif
}
```

```markdown
^Method to traverse all project files and perform regex matching
```swift
//To trigger an Error during build ❌：
print("Project files.lproj" + "/file:line: " + "error: Error message")
//To trigger a Warning during build ⚠️：
print("Project files.lproj" + "/file:line: " + "warning: Warning message")
```

^print error or warning

You can refer to the above programming methods to create the tools you desire.
### Summary

With the introduction of these two checking tools, we can develop with greater peace of mind, efficiency, and reduced redundancy; also, this experience has broadened our horizons, and in the future, if there are any new build run script requirements, we can directly use the most familiar language, Swift, to create them!


If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.



_[Post](https://medium.com/zrealm-ios-dev/xcode-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-swift-%E6%92%B0%E5%AF%AB-run-script-41c49a75a743){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```
