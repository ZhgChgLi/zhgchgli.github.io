---
author: ZhgChgLi
categories:
- ZRealm Dev.
date: 2020-09-17T15:53:20.026+0000
description: Developers facing localization and image asset omissions can automate
  detection using Swift-based Run Scripts in Xcode, streamlining project integrity
  and reducing manual errors effectively.
image:
  path: /assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg
last_modified_at: 2024-04-13T08:35:25.885+0000
render_with_liquid: false
tags:
- english
- ai-translation
- ios
- shell-script
- xcode
- ios-app-development
- toolkit
title: Swift Run Script in XcodeÔΩúLocalization & Image Asset Checks Automated
---

### Write Shell Scripts Directly in Swift with Xcode!

Implementing Localization for Multiple Languages and Image Assets Missing Check, Using Swift to Build Shell Script

![Photo by [Glenn Carstens-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/41c49a75a743/1*RU89TcfRAR5mmclMX9x57w.jpeg)

Photo by [Glenn Carstens-Peters](https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}

### Reason

Because of my clumsiness, I often miss semicolons when editing multilingual files, causing language display errors in the app build. Additionally, as development progresses, the language files have become larger, with repeated and unused phrases mixed together, making it very messy (the same issue applies to Image Assets).

I have always wanted a tool to help with this issue. Previously, I used the Mac app [iOSLocalizationEditor](https://github.com/igorkulman/iOSLocalizationEditor){:target="_blank"}, but it mainly functions as a localization file editor, allowing you to read and edit the file contents without any automatic checking features.

### Expected Features

Automatically check for errors, missing entries, duplicates in multiple languages, and missing Image Assets during project build.

### Solution

To achieve our desired functionality, we need to add a Run Script check in Build Phases.

However, the check script needs to be written in shell script. Since I am not very proficient in shell scripting, I tried searching online for existing scripts that fully meet the desired functionality but couldn't find any. Just when I was about to give up, I suddenly thought:

> **You can write Shell Scripts using Swift**!

More familiar and proficient compared to shell script! Following this direction, I indeed found two existing tool scripts!

Two inspection tools developed by the [freshOS](https://freshos.github.io/){:target="_blank"} team:

- [**Localize üèÅ**](https://github.com/freshOS/Localize){:target="_blank"}

- [**Asset Checker üëÆ**](https://github.com/s4cha/AssetChecker){:target="_blank"}

Fully meets our expected functional requirements! And since they use Swift, customization and modifications are very easy.

#### [Localize üèÅ](https://github.com/freshOS/Localize){:target="_blank"} Multilingual File Checking Tool

**Function:**

- Automatic Check During Build

- Automatic Layout and Organization of Language Files

- Check for missing or extra content in multilingual and primary languages

- Check for duplicate sentences in multiple languages

- Check untranslated sentences in multilingual content

- Check for unused multilingual phrases

**Installation Method:**

1. [Download the Swift Script file for the tool](https://github.com/freshOS/Localize/blob/master/Localize.swift){:target="_blank"}

2. Place it in the project directory, e.g., `${SRCROOT}/Localize.swift`

3. Open Project Settings ‚Üí iOS Target ‚Üí Build Phases ‚Üí Top left corner "+" ‚Üí New Run Script Phase ‚Üí Paste the script path in the Script content, e.g., `${SRCROOT}/Localize.swift`

![](/assets/41c49a75a743/1*k2OHjrcQaQIWLqV7G57TgA.png)

4. Open and edit the `Localize.swift` file using Xcode. You can find configurable settings in the upper part of the file:

```swift
// Enable script check
let enabled = true

// Language files directory
let relativeLocalizableFolders = "/Resources/Languages"

// Project directory (used to search if strings are used in the code)
let relativeSourceFolder = "/Sources"

// Regular expressions for NSLocalized language file usage in code
// Can add more, no need to change
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\"", // Swift and Objc Native
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine Calls
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen generation
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized pattern
]

// Strings to ignore from "unused string" warnings
let ignoredFromUnusedKeys: [String] = []
/* example
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

// Main language
let masterLanguage = "en"

// Enable sorting and organizing language files a-z
let sanitizeFiles = false

// Is the project single or multi-language
let singleLanguage = false

// Enable check for untranslated strings
let checkForUntranslated = true
```

5. Build! Success!

![](/assets/41c49a75a743/1*74osParg9RRi2gcRx9ELuw.png)

**Check Result Prompt Types:**

- **Build Error** ‚ùå **:**
  - [Duplication] The item is duplicated in the localization file
  - [Unused Key] The item is defined in the localization file but not used in the code
  - [Missing] The item is used in the code but not defined in the localization file
  - [Redundant] The item is redundant in this localization file compared to the main localization file
  - [Missing Translation] The item exists in the main localization file but is missing in this localization file

- **Build Warning** ‚ö†Ô∏è **:**
  - [Potentially Untranslated] This item is untranslated (same as the main language file content)

> ***Not finished yet. Now the automatic check prompt is available, but we still need to customize it ourselves.***

**Custom Regex Matching:**

Looking back at the first item in the patterns section of the top settings block in the `Localize.swift` script:

`"NSLocalized(Format)?String\\(\\s*@?\"([\\w\\.]+)\""`

Matching Swift/ObjC's `NSLocalizedString()` method, this regular expression can only match statements in the format `"Home.Title"`; if it is a complete sentence or includes format parameters, it will be mistakenly treated as [Unused Key].

EX: `"Hi, %@ welcome to my app"„ÄÅ"Hello World!"` **<- These phrases cannot be matched**

We can add a new patterns setting or change the original patterns to:

`"NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\""`

The main adjustment is to the matching pattern after the `NSLocalizedString` method, capturing any string until a `"` appears to stop. You can also [click here](https://rubular.com/r/5eXvGy3svsAHyT){:target="_blank"} to customize it according to your needs.

**Add Language File Format Validation Feature:**

This script only checks content correspondence for localization files and does not verify file format correctness (such as missing "**;**"). You need to add this feature yourself if required!

```swift
//....
let formatResult = shell("plutil -lint \(location)")
guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
  let str = "\(path)/\(name).lproj"
            + "/Localizable.strings:1: "
            + "error: [File Invalid] "
            + "This Localizable.strings file format is invalid."
  print(str)
  numberOfErrors += 1
  return
}
//....

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```

Add `shell()` to execute shell scripts, using `plutil -lint` to check the plist localization file format. If there are errors or missing semicolons, it returns an error; if correct, it returns `OK` to indicate validation!

The check can be added after `let location = singleLanguage‚Ä¶` in LocalizationFiles->process() at around line 135, or refer to the complete modified version I provided at the end.

**Other Customizations:**

We can customize according to our needs, such as changing errors to warnings or disabling certain checks (e.g., Potentially Untranslated, Unused Key). The script is written in Swift, which we are all familiar with! No worries about breaking or messing it up!

To make an Error ‚ùå appear during build:

```
print("ProjectFiles.lproj" + "/file:line: " + "error: error message")
```

To make a Warning ‚ö†Ô∏è appear during build:

```
print("ProjectFolder.lproj" + "/file:line: " + "warning: Warning message")
```

**Final Ultimate Modified Version:**

```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// WHAT
// 1. Find Missing keys in other Localization files
// 2. Find potentially untranslated keys
// 3. Find Duplicate keys
// 4. Find Unused keys and generate script to delete them all at once

// MARK: Start Of Configurable Section

/*
 You can enable or disable the script whenever you want
 */
let enabled = true

/*
 Put your path here, example ->  Resources/Localizations/Languages
 */
let relativeLocalizableFolders = "/streetvoice/SupportingFiles"

/*
 This is the path of your source folder which will be used in searching
 for the localization keys you actually use in your project
 */
let relativeSourceFolder = "/streetvoice"

/*
 Those are the regex patterns to recognize localizations.
 */
let patterns = [
    "NSLocalized(Format)?String\\(\\s*@?\"([^(\")]+)\"", // Swift and Objc Native
    "Localizations\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\.[A-Z]{1}[a-z]*[A-z]*)*)", // Laurine Calls
    "L10n.tr\\(key: \"(\\w+)\"", // SwiftGen generation
    "ypLocalized\\(\"(.*)\"\\)",
    "\"(.*)\".localized" // "key".localized pattern
]

/*
 Those are the keys you don't want to be recognized as "unused"
 For instance, Keys that you concatenate will not be detected by the parsing
 so you want to add them here in order not to create false positives :)
 */
let ignoredFromUnusedKeys: [String] = []
/* example
let ignoredFromUnusedKeys = [
    "NotificationNoOne",
    "NotificationCommentPhoto",
    "NotificationCommentHisPhoto",
    "NotificationCommentHerPhoto"
]
*/

let masterLanguage = "base"

/*
 Sanitizing files will remove comments, empty lines and order your keys alphabetically.
 */
let sanitizeFiles = false

/*
 Determines if there are multiple localizations or not.
 */
let singleLanguage = false

/*
 Determines if we should show errors if there's a key within the app
 that does not appear in master translations.
*/
let checkForUntranslated = false

// MARK: End Of Configurable Section

if enabled == false {
    print("Localization check cancelled")
    exit(000)
}

// Detect list of supported languages automatically
func listSupportedLanguages() -> [String] {
    var sl: [String] = []
    let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
    if !FileManager.default.fileExists(atPath: path) {
        print("Invalid configuration: \(path) does not exist.")
        exit(1)
    }
    let enumerator = FileManager.default.enumerator(atPath: path)
    let extensionName = "lproj"
    print("Found these languages:")
    while let element = enumerator?.nextObject() as? String {
        if element.hasSuffix(extensionName) {
            print(element)
            let name = element.replacingOccurrences(of: ".\(extensionName)", with: "")
            sl.append(name)
        }
    }
    return sl
}

let supportedLanguages = listSupportedLanguages()
var ignoredFromSameTranslation: [String: [String]] = [:]
let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders
var numberOfWarnings = 0
var numberOfErrors = 0

struct LocalizationFiles {
    var name = ""
    var keyValue: [String: String] = [:]
    var linesNumbers: [String: Int] = [:]

    init(name: String) {
        self.name = name
        process()
    }

    mutating func process() {
        if sanitizeFiles {
            removeCommentsFromFile()
            removeEmptyLinesFromFile()
            sortLinesAlphabetically()
        }
        let location = singleLanguage ? "\(path)/Localizable.strings" : "\(path)/\(name).lproj/Localizable.strings"
        
        let formatResult = shell("plutil -lint \(location)")
        guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == "OK" else {
            let str = "\(path)/\(name).lproj"
                + "/Localizable.strings:1: "
                + "error: [File Invalid] "
                + "This Localizable.strings file format is invalid."
            print(str)
            numberOfErrors += 1
            return
        }
        
        guard let string = try? String(contentsOfFile: location, encoding: .utf8) else {
            return
        }

        let lines = string.components(separatedBy: .newlines)
        keyValue = [:]

        let pattern = "\"(.*)\" = \"(.+)\";"
        let regex = try? NSRegularExpression(pattern: pattern, options: [])
        var ignoredTranslation: [String] = []

        for (lineNumber, line) in lines.enumerated() {
            let range = NSRange(location: 0, length: (line as NSString).length)

            // Ignored pattern
            let ignoredPattern = "\"(.*)\" = \"(.+)\"; *\\/\\/ *ignore-same-translation-warning"
            let ignoredRegex = try? NSRegularExpression(pattern: ignoredPattern, options: [])
            if let ignoredMatch = ignoredRegex?.firstMatch(in: line,
                                                           options: [],
                                                           range: range) {
                let key = (line as NSString).substring(with: ignoredMatch.range(at: 1))
                ignoredTranslation.append(key)
            }

            if let firstMatch = regex?.firstMatch(in: line, options: [], range: range) {
                let key = (line as NSString).substring(with: firstMatch.range(at: 1))
                let value = (line as NSString).substring(with: firstMatch.range(at: 2))

                if keyValue[key] != nil {
                    let str = "\(path)/\(name).lproj"
                        + "/Localizable.strings:\(linesNumbers[key]!): "
                        + "error: [Duplication] \"\(key)\" "
                        + "is duplicated in \(name.uppercased()) file"
                    print(str)
                    numberOfErrors += 1
                } else {
                    keyValue[key] = value
                    linesNumbers[key] = lineNumber + 1
                }
            }
        }
        print(ignoredFromSameTranslation)
        ignoredFromSameTranslation[name] = ignoredTranslation
    }

    func rebuildFileString(from lines: [String]) -> String {
        return lines.reduce("") { (r: String, s: String) -> String in
            (r == "") ? (r + s) : (r + "\n" + s)
        }
    }

    func removeEmptyLinesFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeCommentsFromFile() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            var lines = string.components(separatedBy: .newlines)
            lines = lines.filter { !$0.hasPrefix("//") }
            let s = rebuildFileString(from: lines)
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func sortLinesAlphabetically() {
        let location = "\(path)/\(name).lproj/Localizable.strings"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            let lines = string.components(separatedBy: .newlines)

            var s = ""
            for (i, l) in sortAlphabetically(lines).enumerated() {
                s += l
                if i != lines.count - 1 {
                    s += "\n"
                }
            }
            try? s.write(toFile: location, atomically: false, encoding: .utf8)
        }
    }

    func removeEmptyLinesFromLines(_ lines: [String]) -> [String] {
        return lines.filter { $0.trimmingCharacters(in: .whitespaces) != "" }
    }

    func sortAlphabetically(_ lines: [String]) -> [String] {
        return lines.sorted()
    }
}

// MARK: - Load Localization Files in memory

let masterLocalizationFile = LocalizationFiles(name: masterLanguage)
let localizationFiles = supportedLanguages
    .filter { $0 != masterLanguage }
    .map { LocalizationFiles(name: $0) }

// MARK: - Detect Unused Keys

let sourcesPath = FileManager.default.currentDirectoryPath + relativeSourceFolder
let fileManager = FileManager.default
let enumerator = fileManager.enumerator(atPath: sourcesPath)
var localizedStrings: [String] = []
while let swiftFileLocation = enumerator?.nextObject() as? String {
    // checks the extension
    if swiftFileLocation.hasSuffix(".swift") \\|\\| swiftFileLocation.hasSuffix(".m") \\|\\| swiftFileLocation.hasSuffix(".mm") {
        let location = "\(sourcesPath)/\(swiftFileLocation)"
        if let string = try? String(contentsOfFile: location, encoding: .utf8) {
            for p in patterns {
                let regex = try? NSRegularExpression(pattern: p, options: [])
                let range = NSRange(location: 0, length: (string as NSString).length) // Obj c workaround
                regex?.enumerateMatches(in: string,
                                        options: [],
                                        range: range,
                                        using: { result, _, _ in
                                            if let r = result {
                                                let value = (string as NSString).substring(with: r.range(at: r.numberOfRanges - 1))
                                                localizedStrings.append(value)
                                            }
                })
            }
        }
    }
}

var masterKeys = Set(masterLocalizationFile.keyValue.keys)
let usedKeys = Set(localizedStrings)
let ignored = Set(ignoredFromUnusedKeys)
let unused = masterKeys.subtracting(usedKeys).subtracting(ignored)
let untranslated = usedKeys.subtracting(masterKeys)

// Here generate Xcode regex Find and replace script to remove dead keys all at once!
var replaceCommand = "\"("
var counter = 0
for v in unused {
    var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[v]!): "
    str += "error: [Unused Key] \"\(v)\" is never used"
    print(str)
    numberOfErrors += 1
    if counter != 0 {
        replaceCommand += "\\|"
    }
    replaceCommand += v
    if counter == unused.count - 1 {
        replaceCommand += ")\" = \".*\";"
    }
    counter += 1
}

print(replaceCommand)

// MARK: - Compare each translation file against master (en)

for file in localizationFiles {
    for k in masterLocalizationFile.keyValue.keys {
        if file.keyValue[k] == nil {
            var str = "\(path)/\(file.name).lproj/Localizable.strings:\(masterLocalizationFile.linesNumbers[k]!): "
            str += "error: [Missing] \"\(k)\" missing from \(file.name.uppercased()) file"
            print(str)
            numberOfErrors += 1
        }
    }

    let redundantKeys = file.keyValue.keys.filter { !masterLocalizationFile.keyValue.keys.contains($0) }

    for k in redundantKeys {
        let str = "\(path)/\(file.name).lproj/Localizable.strings:\(file.linesNumbers[k]!): "
            + "error: [Redundant key] \"\(k)\" redundant in \(file.name.uppercased()) file"

        print(str)
    }
}

if checkForUntranslated {
    for key in untranslated {
        var str = "\(path)/\(masterLocalizationFile.name).lproj/Localizable.strings:1: "
        str += "error: [Missing Translation] \(key) is not translated"

        print(str)
        numberOfErrors += 1
    }
}

print("Number of warnings : \(numberOfWarnings)")
print("Number of errors : \(numberOfErrors)")

if numberOfErrors > 0 {
    exit(1)
}

func shell(_ command: String) -> String {
    let task = Process()
    let pipe = Pipe()

    task.standardOutput = pipe
    task.arguments = ["-c", command]
    task.launchPath = "/bin/bash"
    task.launch()

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: .utf8)!

    return output
}
```

> ***Finally, finally, it's not over yet!***

After we finish debugging our Swift inspection tool scripts, we need to **compile them into executables to reduce build time**; otherwise, each build will recompile them (which can save about 90% of the time).

Open the terminal, navigate to the directory containing the tool script in the project, and run:

```bash
swiftc -o Localize Localize.swift
```

![](/assets/41c49a75a743/1*rwq_KZIDW-Lvtpd2xmgjDw.png)

![](/assets/41c49a75a743/1*BCKtqshZxHH17j3nBGtNlg.png)

Then go back to Build Phases and change the Script content path to the executable file.

EX: `${SRCROOT}/Localize`

![](/assets/41c49a75a743/1*ewhCXzXNuS0MCTMCuINWng.png)

**Completed!**

#### Tool 2. [**Asset Checker üëÆ**](https://github.com/s4cha/AssetChecker){:target="_blank"} **Image Asset Checker Tool**

**Function:**

- Automatic Check During Build

- Check missing images: The name is referenced, but the image resource folder does not contain it.

- Check for redundant images: names not used, but present in the image resource directory

**Installation Method:**

1. [Download the Swift Script file for the tool](https://github.com/freshOS/AssetChecker/blob/master/Classes/main.swift){:target="_blank"}

2. Place it in the project directory, e.g., `${SRCROOT}/AssetChecker.swift`

3. Open Project Settings ‚Üí iOS Target ‚Üí Build Phases ‚Üí Top left "+" ‚Üí New Run Script Phase ‚Üí Paste the path in the Script content

```bash
${SRCROOT}/AssetChecker.swift ${SRCROOT}/ProjectDirectory ${SRCROOT}/Resources/Images.xcassets
//${SRCROOT}/Resources/Images.xcassets = The location of your .xcassets
```

![](/assets/41c49a75a743/1*TPLS60W1iQiGFzU-inf3aA.png)

You can directly include the setting parameters in the path: Parameter 1 is the project directory location, Parameter 2 is the image resource directory location; or edit the parameter setting block at the top of `AssetChecker.swift` like the localization checking tool:

```swift
// Configure me \o/

// Project directory location (used to check if images are referenced in the code)
var sourcePathOption:String? = nil

// .xcassets directory location
var assetCatalogPathOption:String? = nil

// Unused warning ignore list
let ignoredUnusedNames = [String]()
```

4. Build! Success!

**Check Result Prompt Type:**

- **Build Error** ‚ùå **:**
  - [Asset Missing] The item is referenced in the code but missing from the image asset directory

- **Build Warning** ‚ö†Ô∏è **:**
  - [Asset Unused] The item is not used in the code but exists in the image resource directory  
  *p.s If the image is provided by a dynamic variable, the inspection tool cannot detect it. You can add it to `ignoredUnusedNames` as an exception.*

Other operations are the same as language checking tools, so they won't be repeated here; the most important thing is to **remember to compile into an executable after debugging, and change the run script to use the executable!**

#### Develop Your Own Tools!

> ***We can refer to the image resource inspection tool script:***

```swift
#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

// Configure me \o/
var sourcePathOption:String? = nil
var assetCatalogPathOption:String? = nil
let ignoredUnusedNames = [String]()

for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        sourcePathOption = arg
    case 2:
        assetCatalogPathOption = arg
    default:
        break
    }
}

guard let sourcePath = sourcePathOption else {
    print("AssetChecker:: error: Source path was missing!")
    exit(0)
}

guard let assetCatalogAbsolutePath = assetCatalogPathOption else {
    print("AssetChecker:: error: Asset Catalog path was missing!")
    exit(0)
}

print("Searching sources in \(sourcePath) for assets in \(assetCatalogAbsolutePath)")

/* Put here the asset generating false positives, 
 For instance when you build asset names at runtime
let ignoredUnusedNames = [
    "IconArticle",
    "IconMedia",
    "voteEN",
    "voteES",
    "voteFR"
] 
*/


// MARK : - End Of Configurable Section
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}


// MARK: - List Assets
func listAssets() -> [String] {
    let extensionName = "imageset"
    let enumerator = FileManager.default.enumerator(atPath: assetCatalogAbsolutePath)
    return elementsInEnumerator(enumerator)
        .filter { $0.hasSuffix(extensionName) }                             // Is Asset
        .map { $0.replacingOccurrences(of: ".\(extensionName)", with: "") } // Remove extension
        .map { $0.components(separatedBy: "/").last ?? $0 }                 // Remove folder path
}


// MARK: - List Used Assets in the codebase
func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // Image Literal
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // Default UIImage call (Swift)
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // Default UIImage call 
        "\\<image name=\"\(namePattern)\".*", // Storyboard resources
        "R.image.\(namePattern)\\(\\)" //R.swift support
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .compactMap{$0}
            .compactMap{$0}                                             // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings occurrences
            .flatMap{$0}                                                // Flatten
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .flatMap{$0}
            .flatMap{$0}                                                // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings occurrences
            .flatMap{$0}                                                // Flatten
    #endif
}


// MARK: - Beginning of script
let assets = Set(listAssets())
let used = Set(listUsedAssetLiterals() + ignoredUnusedNames)


// Generate Warnings for Unused Assets
let unused = assets.subtracting(used)
unused.forEach { print("\(assetCatalogAbsolutePath):: warning: [Asset Unused] \($0)") }


// Generate Error for broken Assets
let broken = used.subtracting(assets)
broken.forEach { print("\(assetCatalogAbsolutePath):: error: [Asset Missing] \($0)") }

if broken.count > 0 {
    exit(1)
}
```

Compared to language check scripts, this script is concise and includes all essential functions, making it very valuable as a reference!

*P.S You can see the code uses the name `localizedStrings()`. I suspect the author copied the logic from a localization checking tool and forgot to rename the method XD*

**For example:**

```swift
for (index, arg) in CommandLine.arguments.enumerated() {
    switch index {
    case 1:
        // Argument 1
    case 2:
        // Argument 2
    default:
        break
    }
}
```

^Method to receive external parameters

```swift
func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -> [String] {
    var elements = [String]()
    while let e = enumerator?.nextObject() as? String {
        elements.append(e)
    }
    return elements
}

func localizedStrings(inStringFile: String) -> [String] {
    var localizedStrings = [String]()
    let namePattern = "([\\w-]+)"
    let patterns = [
        "#imageLiteral\\(resourceName: \"\(namePattern)\"\\)", // Image Literal
        "UIImage\\(named:\\s*\"\(namePattern)\"\\)", // Default UIImage call (Swift)
        "UIImage imageNamed:\\s*\\@\"\(namePattern)\"", // Default UIImage call 
        "\\<image name=\"\(namePattern)\".*", // Storyboard resources
        "R.image.\(namePattern)\\(\\)" //R.swift support
    ]
    for p in patterns {
        let regex = try? NSRegularExpression(pattern: p, options: [])
        let range = NSRange(location:0, length:(inStringFile as NSString).length)
        regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in
            if let r = result {
                let value = (inStringFile as NSString).substring(with:r.range(at: 1))
                localizedStrings.append(value)
            }
        }
    }
    return localizedStrings
}

func listUsedAssetLiterals() -> [String] {
    let enumerator = FileManager.default.enumerator(atPath:sourcePath)
    print(sourcePath)
    
    #if swift(>=4.1)
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .compactMap{$0}
            .compactMap{$0}                                             // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings occurrences
            .flatMap{$0}                                                // Flatten
    #else
        return elementsInEnumerator(enumerator)
            .filter { $0.hasSuffix(".m") \\|\\| $0.hasSuffix(".swift") \\|\\| $0.hasSuffix(".xib") \\|\\| $0.hasSuffix(".storyboard") }    // Only Swift and Obj-C files
            .map { "\(sourcePath)/\($0)" }                              // Build file paths
            .map { try? String(contentsOfFile: $0, encoding: .utf8)}    // Get file contents
            .flatMap{$0}
            .flatMap{$0}                                                // Remove nil entries
            .map(localizedStrings)                                      // Find localizedStrings occurrences
            .flatMap{$0}                                                // Flatten
    #endif
}
```

^Method to Traverse All Project Files and Perform Regex Matching

```swift
// To make an Error ‚ùå appear during build:
print("ProjectFile.lproj" + "/file:line: " + "error: error message")
// To make a Warning ‚ö†Ô∏è appear during build:
print("ProjectFile.lproj" + "/file:line: " + "warning: warning message")
```

^print error or warning

You can combine the above programming methods to create the tool you want.

### Summary

After introducing these two inspection tools, we can develop with more confidence, greater efficiency, and less redundancy. This experience has been eye-opening, and in the future, any new build run script requirements can be created directly using the most familiar language, Swift!

If you have any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

*[Post](https://medium.com/zrealm-ios-dev/xcode-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-swift-%E6%92%B0%E5%AF%AB-run-script-41c49a75a743){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}.*