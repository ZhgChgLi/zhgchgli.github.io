---
title: "Visitor Pattern in iOS (Swift)"
author: "ZhgChgLi"
date: 2021-06-15T15:58:36.329+0000
last_modified_at: 2024-09-06T05:58:52.296+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","swift","design-patterns","visitor-pattern","double-dispatch"]
description: "Analysis of the practical application scenarios of the Visitor Design Pattern in iOS development"
image:
  path: /assets/ba5773a7bfea/1*Q1BLU8QHVBLEMx6KlMSHWQ.jpeg
render_with_liquid: false
---

### Visitor Pattern in Swift \(Share Object to XXX Example\)

Analysis of the practical application scenarios of the Visitor Pattern \(for sharing products, songs, articles… to Facebook, Line, LinkedIn\. \. scenarios\)

![Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/ba5773a7bfea/1*Q1BLU8QHVBLEMx6KlMSHWQ.jpeg)

Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
#### Introduction

It has been over 10 years since I first learned about "Design Patterns," and I still cannot confidently say that I have fully mastered them. I have always had a vague understanding, and I have gone through all the patterns several times, but without internalizing or applying them in practice, I quickly forget.

> _I really feel useless._ 

#### Skills and Techniques

I once saw a great analogy: the techniques, such as PHP, Laravel, iOS, Swift, SwiftUI, etc., have a relatively low learning threshold for switching between them; however, the foundational skills, such as algorithms, data structures, design patterns, etc., are considered internal skills. There is a complementary effect between foundational skills and techniques; techniques are easy to learn, but foundational skills are hard to master. Having strong techniques does not necessarily mean having strong foundational skills, but those with strong foundational skills can quickly learn techniques. Therefore, rather than saying they complement each other, it is more accurate to say that foundational skills are the basis, and when paired with techniques, they can be unstoppable.

#### Finding a Suitable Learning Method

Based on my previous learning experiences, I believe the best way for me to learn Design Patterns is to focus on mastering a few patterns first, internalizing and flexibly applying them, and developing an intuition to judge which scenarios are suitable or not. Then, I will gradually accumulate new patterns until I have mastered them all. I think the best approach is to seek practical scenarios and learn from applications.

#### Learning Resources

I recommend two free learning resources:
- [https://refactoringguru\.cn/](https://refactoringguru.cn/){:target="_blank"}: A complete introduction to all pattern structures, scenarios, and interrelationships.
- [https://shirazian\.wordpress\.com/2016/04/11/design\-patterns\-in\-swift/](https://shirazian.wordpress.com/2016/04/11/design-patterns-in-swift/){:target="_blank"}: The author introduces the application of various patterns in the context of actual iOS development, and this article will also be written in that direction.

### Visitor — Behavioral Patterns

The first chapter documents the Visitor Pattern, which is one of the gold mines I discovered during my year at StreetVoice. There are many places in the StreetVoice App that effectively use the Visitor Pattern to solve architectural problems; I also grasped the essence of the Visitor's principles during this experience. So, let's write about it in the first chapter!

#### What is Visitor?

First, please understand what the Visitor is. What problem does it aim to solve? What is its structural composition?

![Image from [refactoringguru](https://refactoringguru.cn/design-patterns/visitor){:target="_blank"}](/assets/ba5773a7bfea/1*rbswlsges8_oS3pNI1-WKA.png)


The image is sourced from [refactoringguru](https://refactoringguru.cn/design-patterns/visitor){:target="_blank"}

The detailed content will not be repeated here; please refer directly to [refactoringguru's explanation of the Visitor](https://refactoringguru.cn/design-patterns/visitor){:target="_blank"}.
### iOS Practical Scenario — Sharing Functionality

Assuming we have the following three Models: UserModel, SongModel, and PlaylistModel. Now we want to implement a sharing feature that can share to: Facebook, Line, and Instagram; each Model needs to present different sharing messages, and the data required for each platform varies:

![](/assets/ba5773a7bfea/1*ad2ijo5Bvm9_wnM1g2LNog.png)

The combined scenario is shown in the image above. The first table displays the customized content for each Model, while the second table shows the data required by each sharing platform.

> **_Especially Instagram requires multiple images when sharing a Playlist, which is different from the source needed for other shares._** 

#### Defining the Models

First, let's define the properties for each Model:
```swift
// Model
struct UserModel {
    let id: String
    let name: String
    let profileImageURLString: String
}

struct SongModel {
    let id: String
    let name: String
    let user: UserModel
    let coverImageURLString: String
}

struct PlaylistModel {
    let id: String
    let name: String
    let user: UserModel
    let songs: [SongModel]
    let coverImageURLString: String
}

// Data

let user = UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png")

let song = SongModel(id: "1",
                     name: "Wake me up",
                     user: user,
                     coverImageURLString: "https://zhgchg.li/cover/1.png")

let playlist = PlaylistModel(id: "1",
                            name: "Avicii Tribute Concert",
                            user: user,
                            songs: [
                                song,
                                SongModel(id: "2", name: "Waiting for love", user: UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png"), coverImageURLString: "https://zhgchg.li/cover/3.png"),
                                SongModel(id: "3", name: "Lonely Together", user: UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png"), coverImageURLString: "https://zhgchg.li/cover/1.png"),
                                SongModel(id: "4", name: "Heaven", user: UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png"), coverImageURLString: "https://zhgchg.li/cover/4.png"),
                                SongModel(id: "5", name: "S.O.S", user: UserModel(id: "1", name: "Avicii", profileImageURLString: "https://zhgchg.li/profile/1.png"), coverImageURLString: "https://zhgchg.li/cover/5.png")],
                            coverImageURLString: "https://zhgchg.li/playlist/1.png")
```
#### A Thoughtless Approach


Without considering the structure at all, here’s a dirty approach without any thought.

![Stephen Chow — God of Cookery](/assets/ba5773a7bfea/1*5kBPDRNpaHNyW4u4YEsOGA.png)

Stephen Chow — God of Cookery
```swift
class ShareManager {
    private let title: String
    private let urlString: String
    private let imageURLStrings: [String]

    init(user: UserModel) {
        self.title = "Hi, I want to share an amazing artist with you, \(user.name)."
        self.urlString = "https://zhgchg.li/user/\(user.id)"
        self.imageURLStrings = [user.profileImageURLString]
    }

    init(song: SongModel) {
        self.title = "Hi, I want to share a great song I just heard, \(song.user.name)'s \(song.name)."
        self.urlString = "https://zhgchg.li/user/\(song.user.id)/song/\(song.id)"
        self.imageURLStrings = [song.coverImageURLString]
    }

    init(playlist: PlaylistModel) {
        self.title = "Hi, I can't stop listening to this playlist, \(playlist.name)."
        self.urlString = "https://zhgchg.li/user/\(playlist.user.id)/playlist/\(playlist.id)"
        self.imageURLStrings = playlist.songs.map({ $0.coverImageURLString })
    }

    func shareToFacebook() {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![\(self.title)](\(String(describing: self.imageURLStrings.first))](\(self.urlString))")
    }

    func shareToInstagram() {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(self.imageURLStrings.joined(separator: ","))
    }

    func shareToLine() {
        // call Line share sdk...
        print("Share to Line...")
        print("[\(self.title)](\(self.urlString))")
    }
}
```

There’s nothing much to say, it’s just a 0 structure all mixed together. If today we want to add a new sharing platform, change the sharing information for a certain platform, or add a new shareable model, we have to modify ShareManager; additionally, the design of imageURLStrings is based on the consideration that Instagram requires an array of images when sharing playlists, which is somewhat backward because it leads to designing the structure based on needs, polluting other types that do not require an image set.
#### Optimize a bit

Slightly separate the logic.
```swift
protocol Shareable {
    func getShareText() -> String
    func getShareURLString() -> String
    func getShareImageURLStrings() -> [String]
}

extension UserModel: Shareable {
    func getShareText() -> String {
        return "Hi, I want to share an amazing artist with you, \(self.name)."
    }

    func getShareURLString() -> String {
        return "https://zhgchg.li/user/\(self.id)"
    }

    func getShareImageURLStrings() -> [String] {
        return [self.profileImageURLString]
    }
}

extension SongModel: Shareable {
    func getShareText() -> String {
        return "Hi, I want to share a great song I just heard, \(self.user.name)'s \(self.name)."
    }

    func getShareURLString() -> String {
        return "https://zhgchg.li/user/\(self.user.id)/song/\(self.id)"
    }

    func getShareImageURLStrings() -> [String] {
        return [self.coverImageURLString]
    }
}

extension PlaylistModel: Shareable {
    func getShareText() -> String {
        return "Hi, I can't stop listening to this playlist, \(self.name)."
    }

    func getShareURLString() -> String {
        return "https://zhgchg.li/user/\(self.user.id)/playlist/\(self.id)"
    }

    func getShareImageURLStrings() -> [String] {
        return [self.coverImageURLString]
    }
}

protocol ShareManagerProtocol {
    var model: Shareable { get }
    init(model: Shareable)
    func share()
}

class FacebookShare: ShareManagerProtocol {
    let model: Shareable

    required init(model: Shareable) {
        self.model = model
    }

    func share() {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![\(model.getShareText())](\(String(describing: model.getShareImageURLStrings().first))](\(model.getShareURLString())")
    }
}

class InstagramShare: ShareManagerProtocol {
    let model: Shareable

    required init(model: Shareable) {
        self.model = model
    }

    func share() {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(model.getShareImageURLStrings().joined(separator: ","))
    }
}

class LineShare: ShareManagerProtocol {
    let model: Shareable

    required init(model: Shareable) {
        self.model = model
    }

    func share() {
        // call Line share sdk...
        print("Share to Line...")
        print("[\(model.getShareText())](\(model.getShareURLString())")
    }
}
```


We have extracted a CanShare Protocol, and any Model that adheres to this protocol can support sharing; the sharing part has also been separated into ShareManagerProtocol. For new sharing, as long as the protocol content is implemented, modifications or deletions will not affect other ShareManagers.

However, getShareImageURLStrings remains peculiar. Additionally, suppose today a new sharing platform requires Model data that is vastly different, for example, WeChat sharing also needs play counts, creation dates, etc., which only it requires. This is when things start to get chaotic.
#### Visitor

Using the Visitor Pattern solution.
```swift
// Visitor Version
protocol Shareable {
    func accept(visitor: SharePolicy)
}

extension UserModel: Shareable {
    func accept(visitor: SharePolicy) {
        visitor.visit(model: self)
    }
}

extension SongModel: Shareable {
    func accept(visitor: SharePolicy) {
        visitor.visit(model: self)
    }
}

extension PlaylistModel: Shareable {
    func accept(visitor: SharePolicy) {
        visitor.visit(model: self)
    }
}

protocol SharePolicy {
    func visit(model: UserModel)
    func visit(model: SongModel)
    func visit(model: PlaylistModel)
}

class ShareToFacebookVisitor: SharePolicy {
    func visit(model: UserModel) {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![Hi, I want to share a great artist with you \(model.name).](\(model.profileImageURLString)](https://zhgchg.li/user/\(model.id)")
    }
    
    func visit(model: SongModel) {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![Hi, I want to share a great song I just heard, \(model.user.name)'s \(model.name), it was played in this way.](\(model.coverImageURLString))](https://zhgchg.li/user/\(model.user.id)/song/\(model.id)")
    }
    
    func visit(model: PlaylistModel) {
        // call Facebook share sdk...
        print("Share to Facebook...")
        print("[![Hi, I can't stop listening to this playlist \(model.name).](\(model.coverImageURLString))](https://zhgchg.li/user/\(model.user.id)/playlist/\(model.id)")
    }
}

class ShareToLineVisitor: SharePolicy {
    func visit(model: UserModel) {
        // call Line share sdk...
        print("Share to Line...")
        print("[Hi, I want to share a great artist with you \(model.name).](https://zhgchg.li/user/\(model.id)")
    }
    
    func visit(model: SongModel) {
        // call Line share sdk...
        print("Share to Line...")
        print("[Hi, I want to share a great song I just heard, \(model.user.name)'s \(model.name), it was played in this way.]](https://zhgchg.li/user/\(model.user.id)/song/\(model.id)")
    }
    
    func visit(model: PlaylistModel) {
        // call Line share sdk...
        print("Share to Line...")
        print("[Hi, I can't stop listening to this playlist \(model.name).](https://zhgchg.li/user/\(model.user.id)/playlist/\(model.id)")
    }
}

class ShareToInstagramVisitor: SharePolicy {
    func visit(model: UserModel) {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(model.profileImageURLString)
    }
    
    func visit(model: SongModel) {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(model.coverImageURLString)
    }
    
    func visit(model: PlaylistModel) {
        // call Instagram share sdk...
        print("Share to Instagram...")
        print(model.songs.map({ $0.coverImageURLString }).joined(separator: ","))
    }
}

// Use case
let shareToInstagramVisitor = ShareToInstagramVisitor()
user.accept(visitor: shareToInstagramVisitor)
playlist.accept(visitor: shareToInstagramVisitor)
```

Here’s the translated text while preserving the original Markdown format:

---

Let's take a look at what we did line by line:
- First, we created a Shareable Protocol, which is intended to facilitate the management of Models that support sharing Visitors with a unified interface (it can also be undefined).
- UserModel/SongModel/PlaylistModel implement Shareable `func accept(visitor: SharePolicy)`, and if there are new Models that support sharing, they only need to implement the protocol.
- We define SharePolicy to list the supported Models `(must be concrete type)`. You might wonder why not define it as `visit(model: Shareable)`. If that were the case, it would repeat the issues from the previous version.
- Each Share method implements SharePolicy, combining the necessary resources according to the source.
- Suppose today we have a WeChat sharing feature, which requires special data (play count, creation date); it will not affect the existing code because it can obtain the information it needs from the concrete model.

Achieving low coupling and high cohesion in software development.

The above is a classic implementation of [Visitor Double Dispatch](https://refactoringguru.cn/design-patterns/visitor-double-dispatch){:target="_blank"}, but we rarely encounter such situations in daily development. Generally, there may only be one Visitor, but I think this pattern is also suitable for combinations. For example, if there is a requirement to SaveToCoreData, we can directly define `accept(visitor: SaveToCoreDataVisitor)` without declaring a Policy Protocol, which is also a good architectural usage.
```swift
protocol Saveable {
  func accept(visitor: SaveToCoreDataVisitor)
}

class SaveToCoreDataVisitor {
    func visit(model: UserModel) {
        // map UserModel to coredata
    }
    
    func visit(model: SongModel) {
        // map SongModel to coredata
    }
    
    func visit(model: PlaylistModel) {
        // map PlaylistModel to coredata
    }
}
```

Other applications: Save, Like, tableview/collectionview cellforrow…\.
### Principles

Finally, let's discuss some common principles:
- Code is meant to be read by people; do not over-design.
- Consistency is important; the same codebase should use the same architectural methods in similar situations.
- If the scope is controllable or other situations are unlikely to occur, continuing to break it down further can be considered over-designed.
- Apply more, invent less; Design Patterns have been around in software design for decades, and they consider scenarios that are likely more comprehensive than creating a new architecture.
- If you don't understand a Design Pattern, you can learn it, but if it's a self-created architecture, it’s harder to convince others to learn it, as it may only be applicable to this specific case and not common sense.
- Code duplication does not necessarily mean bad; an excessive pursuit of encapsulation may lead to over-design. Again, referring back to the previous points, code is meant to be read, so as long as it is readable with low coupling and high cohesion, it is good code.
- Do not modify patterns arbitrarily; there is a reason for their design, and random modifications may cause issues in certain scenarios.
- Once you start taking detours, you will stray further and further, and the code will become messier.

> _inspired by [＠saiday](https://twitter.com/saiday){:target="_blank"}_

#### References
- [Design Patterns in Swift: Visitor](https://shirazian.wordpress.com/2016/04/22/design-patterns-in-swift-visitor/){:target="_blank"} 
(Another application scenario using Visitor)
- [https://github\.com/kingreza/Swift\-Visitor](https://github.com/kingreza/Swift-Visitor){:target="_blank"}
- [Deep Linking at Scale on iOS](https://medium.com/@albertodebo/deep-linking-at-scale-on-ios-1dd8789c389f){:target="_blank"} (State Pattern)

### Further Reading
- Practical Applications of Design Patterns — In WKWebView with Builder, Strategy & Chain of Responsibility Pattern
- [Practical Applications of Design Patterns](../78507a8de6a5/)
- [Visitor Pattern in TableView](../60473cb47550/)

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/visitor-pattern-in-ios-swift-ba5773a7bfea){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
