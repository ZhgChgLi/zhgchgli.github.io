---
title: "Implementing iOS NSAttributedString HTML Render on Your Own"
author: "ZhgChgLi"
date: 2022-06-09T16:11:59.122+0000
last_modified_at: 2024-04-14T02:07:40.904+0000
categories: ["ZRealm Dev."]
tags: ["ios-app-development","nsattributedstring","html-parsing","html","markdown"]
description: "An alternative to iOS NSAttributedString DocumentType.html"
image:
  path: /assets/a8c2d26cc734/1*l93Ay_tGXTRvwS7ofgt5og.jpeg
render_with_liquid: false
---

### Implementing iOS NSAttributedString HTML Render on Your Own

An alternative to iOS NSAttributedString DocumentType.html



![Photo by [Florian Olivo](https://unsplash.com/@florianolv?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/a8c2d26cc734/1*l93Ay_tGXTRvwS7ofgt5og.jpeg)

Photo by [Florian Olivo](https://unsplash.com/@florianolv?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### \[TL;DR\] 2023/03/12

Re-developed using another method _“ [**ZMarkupParser HTML String to NSAttributedString Tool**](../a5643de271e4/) ”_ , for technical details and development stories, please visit “ [The Things About Manually Creating an HTML Parser](../2724f02f6e7/) ”
### Origin

Since the release of iOS 15 last year, the app has consistently been plagued by a crash issue, which has ranked high for a long time. According to data, there were over 2.4K crashes affecting more than 1.4K users in the last 90 days (2022/03/11~2022/06/08).


![](/assets/a8c2d26cc734/1*r--z0J1P6t5ECfVyb5_OxQ.png)



> From the data, it appears that the official team has likely fixed (or reduced the occurrence rate of) this significant crash issue in versions of iOS ≥ 15.2, as the data shows a downward trend. 





**Most affected versions:** iOS 15.0.X ~ iOS 15.X.X

Additionally, sporadic crashes were also observed in iOS 12 and iOS 13, indicating that this issue has likely existed for a long time, but the probability of occurrence in the earlier versions of iOS 15 was nearly 100%.
#### Cause of the Crash:


![](/assets/a8c2d26cc734/1*vKmvralAmDrhWrXYLHpspw.png)

```
<compiler-generated> line 2147483647 specialized @nonobjc NSAttributedString.init(data:options:documentAttributes:)
```

The crash issue occurs with `Crashed: com.apple.main-thread EXC_BREAKPOINT 0x00000001de9d4e44` when initializing NSAttributedString.


> It is also possible that the operation is not on the Main Thread. 




#### Reproduction Method:

When this issue suddenly emerged, the development team was puzzled; rechecking the crash logs showed no problems, and it was unclear under what circumstances users experienced it; until one time, by coincidence, I switched to “Low Power Mode” and triggered the issue! **WTF!**


![](/assets/a8c2d26cc734/1*gVfmnCN7QcHO90Y7HyntbA.gif)

### Solution

After some searching, I found many similar cases online and discovered the earliest related [crash issue inquiry](https://developer.apple.com/forums/thread/115405){:target="_blank"} from the App Developer Forums, receiving a response from **official** sources:

![](/assets/a8c2d26cc734/1*XmZuJf4Rtk4chiBx8_yMXw.png)

- This is a known iOS Foundation bug: it has existed since iOS 12.
- To render complex, unconstrained HTML: please use WKWebView.
- **Rendering constraints: you can write your own HTML parser & renderer.**
- Directly using Markdown as a rendering constraint: iOS ≥ 15 NSAttributedString can [render text using Markdown format directly](https://developer.apple.com/documentation/foundation/nsattributedstring/3796598-init){:target="_blank"}

> **Rendering constraints** refer to the limited rendering formats supported by the app, such as only supporting **bold**, italic, and [hyperlinks](https://zhgchg.li){:target="_blank"}.

#### Supplement. Rendering complex HTML — Creating a text-wrapping effect

You can coordinate with the backend to create an interface:
```json
{
  "content":[
    {"type":"text","value":"Paragraph 1 plain text"},
    {"type":"text","value":"Paragraph 2 plain text"},
    {"type":"text","value":"Paragraph 3 plain text"},
    {"type":"text","value":"Paragraph 4 plain text"},
    {"type":"image","src":"https://zhgchg.li/logo.png","title":"ZhgChgLi"},
    {"type":"text","value":"Paragraph 5 plain text"}
  ]
}
```

You can combine this with Markdown to support text rendering, or refer to Medium's approach:
```json
"Paragraph": {
    "text": "code in text, and link in text, and ZhgChgLi, and bold, and I, only i",
    "markups": [
      {
        "type": "CODE",
        "start": 5,
        "end": 7
      },
      {
        "start": 18,
        "end": 22,
        "href": "http://zhgchg.li",
        "type": "LINK"
      },
      {
        "type": "STRONG",
        "start": 50,
        "end": 63
      },
      {
        "type": "EM",
        "start": 55,
        "end": 69
      }
    ]
}
```

This means that in the text `code in text, and link in text, and ZhgChgLi, and bold, and I, only i`:
```
- Characters 5 to 7 should be marked as code (wrapped in `Text` format).
- Characters 18 to 22 should be marked as a link (wrapped in [Text](URL) format).
- Characters 50 to 63 should be marked as bold (wrapped in *Text* format).
- Characters 55 to 69 should be marked as italic (wrapped in _Text_ format).
```

With a defined and describable structure, the app can render natively, achieving optimal performance and user experience.

> For pitfalls of using UITextView for text wrapping, you can refer to my previous article: [iOS UITextView Text Wrapping Editor (Swift)](../e37d66ea1146/)

### Why?

Before we delve into the practical solutions, let's return to the core of the problem. I believe the main issue does not stem from Apple; the official bug is merely the trigger for this problem.

The issue primarily arises from **the app being treated as a web interface for rendering**. The advantage is that web development is fast, and the same API endpoint can provide HTML without distinguishing between clients, allowing flexible rendering of any desired content. The downside is that HTML is not a common interface for apps, one cannot expect app engineers to understand HTML, **performance is extremely poor**, it can only run on the main thread, results cannot be anticipated during development, and support specifications cannot be confirmed.

Digging deeper into the problem, it often stems from the inability to define the original requirements, uncertainty about which specifications the app needs to support, and the rush to use HTML as the interface between the app and the web.
#### **Performance is extremely poor**

```markdown
To supplement the performance section, the actual test shows that directly using `NSAttributedString DocumentType.html` has a speed difference of 5 to 20 times compared to a self-implemented rendering method.
#### Better

Since this is for an app, a better approach should start from the perspective of app development. The cost of adjusting requirements for an app is much higher than for the web; effective app development should be based on iterative adjustments with specifications. It is essential to confirm the specifications that can be supported at the moment, and if changes are needed later, we can schedule time to expand the specifications. This reduces communication costs and increases work efficiency.
- Confirm the scope of requirements
- Confirm the supported specifications
- Confirm the interface specifications (Markdown/BBCode/... It is also acceptable to continue using HTML, but it should be constrained, for example, only using `<b>/<i>/<a>/<u>`, and the program must **clearly inform** developers)
- Self-implement the rendering mechanism
- Maintain and iterate support specifications

### \[2023/02/27 Updated\] \[TL;DR\]:

The approach has been updated to not use XMLParser, as the fault tolerance rate is 0:

`<br>` / `<Congratulation!>` / `<b>Bold<i>Bold+Italic</b>Italic</i>` 
The above three possible scenarios will cause XMLParser to throw an error and display a blank screen. When using XMLParser, the HTML string must fully comply with XML rules and cannot display correctly like a browser or NSAttributedString.DocumentType.html.

[![](https://miro.medium.com/v2/resize:fit:1200/1*A0yXupXW9-F9ZWe4gp2ObA.jpeg)](https://medium.com/zrealm-ios-dev/zmarkupparser-html-string-%E8%BD%89%E6%8F%9B-nsattributedstring-%E5%B7%A5%E5%85%B7-a5643de271e4){:target="_blank"}

The development is now done purely in Swift, parsing HTML tags through Regex and performing tokenization to analyze and correct tag accuracy (fixing unclosed tags & misaligned tags), then converting them into an abstract syntax tree. Finally, using the Visitor Pattern, the HTML tags are matched with abstract styles to obtain the final NSAttributedString result, without relying on any parser library.

— —
### How?

The die is cast. Returning to the main topic, we are currently rendering `NSAttributedString` with HTML. How can we solve the aforementioned crashing and performance issues?
#### Inspired by

[![](https://opengraph.githubassets.com/7e71c0eb7d2a88f00a77cb8e0181081b88683ab2d359221336aa9776a4cd097d/malcommac/SwiftRichString)](https://github.com/malcommac/SwiftRichString){:target="_blank"}

### Strip HTML Remove HTML

Before discussing HTML rendering, let's talk about stripping HTML. As mentioned in the previous section "Why?", it should be specified where the app will obtain HTML and what HTML it will receive; it should not be the case that the app " **might** " receive HTML that needs to be stripped.

> To quote a former supervisor: Isn't this too crazy?

#### Option 1. NSAttributedString
```swift
let data = "<div>Text</div>".data(using: .unicode)!
let attributed = try NSAttributedString(data: data, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue], documentAttributes: nil)
let string = attributed.string
```
- Using NSAttributedString to render HTML and then extracting the string will yield a clean String.
- The same issues as mentioned in this chapter arise: iOS 15 is prone to crashes, has poor performance, and can only operate on the Main Thread.

#### Option 2. Regex
```swift
htmlString = "<div>Test</div>"
htmlString.replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression, range: nil)
```
- The simplest and most effective method.
- Regex cannot guarantee complete accuracy, e.g., `<p foo=">now what?">Paragraph</p>` is valid HTML but will be stripped incorrectly.
```

#### Option 3\. XMLParser

Referring to [SwiftRichString](https://github.com/malcommac/SwiftRichString){:target="_blank"}, use **[XMLParser](https://developer.apple.com/documentation/foundation/xmlparser){:target="_blank"}** from Foundation to implement HTML parsing and stripping functionality as XML.

```swift
import UIKit
// Ref: https://github.com/malcommac/SwiftRichString
final class HTMLStripper: NSObject, XMLParserDelegate {

    private static let topTag = "source"
    private var xmlParser: XMLParser
    
    private(set) var storedString: String
    
    // The XML parser sometimes splits strings, which can break localization-sensitive
    // string transforms. Work around this by using the currentString variable to
    // accumulate partial strings, and then reading them back out as a single string
    // when the current element ends, or when a new one is started.
    private var currentString: String?
    
    // MARK: - Initialization

    init(string: String) throws {
        let xmlString = HTMLStripper.escapeWithUnicodeEntities(string)
        let xml = "<\(HTMLStripper.topTag)>\(xmlString)</\(HTMLStripper.topTag)>"
        guard let data = xml.data(using: String.Encoding.utf8) else {
            throw XMLParserInitError("Unable to convert to UTF8")
        }
        
        self.xmlParser = XMLParser(data: data)
        self.storedString = ""
        
        super.init()
        
        xmlParser.shouldProcessNamespaces = false
        xmlParser.shouldReportNamespacePrefixes = false
        xmlParser.shouldResolveExternalEntities = false
        xmlParser.delegate = self
    }
    
    /// Parse and generate attributed string.
    func parse() throws -> String {
        guard xmlParser.parse() else {
            let line = xmlParser.lineNumber
            let shiftColumn = (line == 1)
            let shiftSize = HTMLStripper.topTag.lengthOfBytes(using: String.Encoding.utf8) + 2
            let column = xmlParser.columnNumber - (shiftColumn ? shiftSize : 0)
            
            throw XMLParserError(parserError: xmlParser.parserError, line: line, column: column)
        }
        
        return storedString
    }
    
    // MARK: XMLParserDelegate
    
    @objc func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String: String]) {
        foundNewString()
    }
    
    @objc func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) {
        foundNewString()
    }
    
    @objc func parser(_ parser: XMLParser, foundCharacters string: String) {
        currentString = (currentString ?? "").appending(string)
    }
    
    // MARK: Support Private Methods
    
    func foundNewString() {
        if let currentString = currentString {
            storedString.append(currentString)
            self.currentString = nil
        }
    }
    
    // handle html entity / html hex
    // Perform string escaping to replace all characters which is not supported by NSXMLParser
    // into the specified encoding with decimal entity.
    // For example if your string contains '&' character parser will break the style.
    // This option is active by default.
    // ref: https://github.com/malcommac/SwiftRichString/blob/e0b72d5c96968d7802856d2be096202c9798e8d1/Sources/SwiftRichString/Support/XMLStringBuilder.swift
    static func escapeWithUnicodeEntities(_ string: String) -> String {
        guard let escapeAmpRegExp = try? NSRegularExpression(pattern: "&(?!(#[0-9]{2,4}|[A-z]{2,6});)", options: NSRegularExpression.Options(rawValue: 0)) else {
            return string
        }
        
        let range = NSRange(location: 0, length: string.count)
        return escapeAmpRegExp.stringByReplacingMatches(in: string,
                                                        options: NSRegularExpression.MatchingOptions(rawValue: 0),
                                                        range: range,
                                                        withTemplate: "&amp;")
    }
}


let test = "I agree to provide my personal ID number/passport/residence permit number for cross-border logistics use, and I have understood the logistics requirements for cross-border goods."

let stripper = try HTMLStripper(string: test)
print(try! stripper.parse())

// I agree to provide my personal ID number/passport/residence permit number for cross-border logistics use, and I have understood the logistics requirements for cross-border goods.
```

```markdown
Using the Foundation XML Parser to handle Strings, implement `XMLParserDelegate` to store the String in `currentString`. Since the String may sometimes be split into multiple Strings, `foundCharacters` can be called multiple times. When `didStartElement` and `didEndElement` are triggered, the current result is saved and `currentString` is cleared.
- The advantage is that it will also convert HTML Entities to actual characters e.g. `&#103; -> g`
- The advantage is that it is complex to implement, and if it encounters non-compliant HTML, the XMLParser will fail e.g. `<br>` forgetting to write as `<br/>`

> Personally, I believe that simply stripping HTML **Option 2. is a better method**. I introduce this method because rendering HTML uses the same principle, using this as a simple example :)


### HTML Render w/XMLParser

Using XMLParser to implement it yourself, similar to the Strip principle, we can add parsing for what Tag to render correspondingly.

Requirements:
- Support extending the Tags to be parsed
- Support setting Tag Default Style e.g. &lt;a&gt; Tag applying link styles
- Support parsing `style` attributes, as HTML explicitly indicates the styles to be displayed with `style="color:red"`
- Styles support changing font weight, size, underline, line spacing, letter spacing, background color, and font color
- Does not support Image Tag, Table Tag, and other more complex TAGs

> Everyone can reduce functionality according to their own specification needs. For example, if background color adjustment is not needed, then there is no need to open up a setting for background color.

> This article is just a conceptual implementation, **not a Best Practice in architecture**; if there are clear specifications and usage methods, consider applying some Design Patterns to achieve good maintainability and extensibility.

### ⚠️⚠️⚠️ Attention ⚠️⚠️⚠️

Once again, I remind you, **if your App is brand new or has the opportunity to be completely changed to Markdown format, it is still recommended to adopt the above method. Writing your own Render is too complex and the performance will not be better than Markdown**.

> Even if you are on iOS &lt; 15 and do not support native Markdown, you can still find [a well-made Markdown Parser solution by a great developer on Github](https://github.com/chockenberry/MarkdownAttributedString){:target="_blank"}.

#### HTMLTagParser
```swift
protocol HTMLTagParser {
    static var tag: String { get } // Declare the Tag Name to be parsed, e.g. a
    var storedHTMLAttributes: [String: String]? { get set } // The parsed results will be stored here, e.g. href, style
    var style: AttributedStringStyle? { get } // The style to be applied to this Tag
    
    func render(attributedString: inout NSMutableAttributedString) // Implement the logic to render HTML to attributedString
}
```

Declare the HTML Tag entities that can be parsed for easier management and extension.
#### AttributedStringStyle
```swift
protocol AttributedStringStyle {
    var font: UIFont? { get set }
    var color: UIColor? { get set }
    var backgroundColor: UIColor? { get set }
    var wordSpacing: CGFloat? { get set }
    var paragraphStyle: NSParagraphStyle? { get set }
    var customs: [NSAttributedString.Key: Any]? { get set } // Universal setting, it is recommended to abstract this out after confirming the supported specifications and close this opening
    func render(attributedString: inout NSMutableAttributedString)
}

// abstract implement
extension AttributedStringStyle {
    func render(attributedString: inout NSMutableAttributedString) {
        let range = NSMakeRange(0, attributedString.length)
        if let font = font {
            attributedString.addAttribute(NSAttributedString.Key.font, value: font, range: range)
        }
        if let color = color {
            attributedString.addAttribute(NSAttributedString.Key.foregroundColor, value: color, range: range)
        }
        if let backgroundColor = backgroundColor {
            attributedString.addAttribute(NSAttributedString.Key.backgroundColor, value: backgroundColor, range: range)
        }
        if let wordSpacing = wordSpacing {
            attributedString.addAttribute(NSAttributedString.Key.kern, value: wordSpacing as Any, range: range)
        }
        if let paragraphStyle = paragraphStyle {
            attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: range)
        }
        if let customAttributes = customs {
            attributedString.addAttributes(customAttributes, range: range)
        }
    }
}
```


Declare the styles that can be set for the Tag.
#### HTMLStyleAttributedParser
```swift
// only support tag attributed down below
// can set color,font size,line height,word spacing,background color

enum HTMLStyleAttributedParser: String {
    case color = "color"
    case fontSize = "font-size"
    case lineHeight = "line-height"
    case wordSpacing = "word-spacing"
    case backgroundColor = "background-color"
    
    func render(attributedString: inout NSMutableAttributedString, value: String) -> Bool {
        let range = NSMakeRange(0, attributedString.length)
        switch self {
        case .color:
            if let color = convertToiOSColor(value) {
                attributedString.addAttribute(NSAttributedString.Key.foregroundColor, value: color, range: range)
                return true
            }
        case .backgroundColor:
            if let color = convertToiOSColor(value) {
                attributedString.addAttribute(NSAttributedString.Key.backgroundColor, value: color, range: range)
                return true
            }
        case .fontSize:
            if let size = convertToiOSSize(value) {
                attributedString.addAttribute(NSAttributedString.Key.font, value: UIFont.systemFont(ofSize: CGFloat(size)), range: range)
                return true
            }
        case .lineHeight:
            if let size = convertToiOSSize(value) {
                let paragraphStyle = NSMutableParagraphStyle()
                paragraphStyle.lineSpacing = size
                attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: range)
                return true
            }
        case .wordSpacing:
            if let size = convertToiOSSize(value) {
                attributedString.addAttribute(NSAttributedString.Key.kern, value: size, range: range)
                return true
            }
        }
        
        return false
    }
    
    // convert 36px -> 36
    private func convertToiOSSize(_ string: String) -> CGFloat? {
        guard let regex = try? NSRegularExpression(pattern: "^([0-9]+)"),
              let firstMatch = regex.firstMatch(in: string, options: [], range: NSRange(location: 0, length: string.utf16.count)),
              let range = Range(firstMatch.range, in: string),
              let size = Float(String(string[range])) else {
            return nil
        }
        return CGFloat(size)
    }
    
    // convert html hex color #ffffff to UIKit Color
    private func convertToiOSColor(_ hexString: String) -> UIColor? {
        var cString: String = hexString.trimmingCharacters(in: .whitespacesAndNewlines).uppercased()

        if cString.hasPrefix("#") {
            cString.remove(at: cString.startIndex)
        }

        if (cString.count) != 6 {
            return nil
        }

        var rgbValue: UInt64 = 0
        Scanner(string: cString).scanHexInt64(&rgbValue)

        return UIColor(
            red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0,
            green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0,
            blue: CGFloat(rgbValue & 0x0000FF) / 255.0,
            alpha: CGFloat(1.0)
        )
    }
}
```


Implement a Style Attributed Parser to parse `style="color:red;font-size:16px"` but since there are many CSS styles that can be set, it is necessary to enumerate the supported range.
```swift
extension HTMLTagParser {

    func render(attributedString: inout NSMutableAttributedString) {
        defaultStyleRender(attributedString: &attributedString)
    }
    
    func defaultStyleRender(attributedString: inout NSMutableAttributedString) {
        // setup default style to NSMutableAttributedString
        style?.render(attributedString: &attributedString)
        
        // setup & override HTML style (style="color:red;background-color:black") to NSMutableAttributedString if it exists
        // any html tag can have style attribute
        if let style = storedHTMLAttributes?["style"] {
            let styles = style.split(separator: ";").map { $0.split(separator: ":") }.filter { $0.count == 2 }
            for style in styles {
                let key = String(style[0])
                let value = String(style[1])
                
                if let styleAttributed = HTMLStyleAttributedParser(rawValue: key), styleAttributed.render(attributedString: &attributedString, value: value) {
                    print("Unsupported style attributed or value[\(key):\(value)]")
                }
            }
        }
    }
}
```

Apply HTMLStyleAttributedParser & abstract implementation of HTMLStyleAttributedParser.
#### Some examples of Tag Parser & AttributedStringStyle implementations
```
struct LinkStyle: AttributedStringStyle {
   var font: UIFont? = UIFont.systemFont(ofSize: 14)
   var color: UIColor? = UIColor.blue
   var backgroundColor: UIColor? = nil
   var wordSpacing: CGFloat? = nil
   var paragraphStyle: NSParagraphStyle?
   var customs: [NSAttributedString.Key: Any]? = [.underlineStyle: NSUnderlineStyle.single.rawValue]
}

struct ATagParser: HTMLTagParser {
    // <a></a>
    static let tag: String = "a"
    var storedHTMLAttributes: [String: String]? = nil
    let style: AttributedStringStyle? = LinkStyle()
    
    func render(attributedString: inout NSMutableAttributedString) {
        defaultStyleRender(attributedString: &attributedString)
        if let href = storedHTMLAttributes?["href"], let url = URL(string: href) {
            let range = NSMakeRange(0, attributedString.length)
            attributedString.addAttribute(NSAttributedString.Key.link, value: url, range: range)
        }
    }
}
struct BoldStyle: AttributedStringStyle {
   var font: UIFont? = UIFont.systemFont(ofSize: 14, weight: .bold)
   var color: UIColor? = UIColor.black
   var backgroundColor: UIColor? = nil
   var wordSpacing: CGFloat? = nil
   var paragraphStyle: NSParagraphStyle?
   var customs: [NSAttributedString.Key: Any]? = [.underlineStyle: NSUnderlineStyle.single.rawValue]
}

struct BoldTagParser: HTMLTagParser {
    // <b></b>
    static let tag: String = "b"
    var storedHTMLAttributes: [String: String]? = nil
    let style: AttributedStringStyle? = BoldStyle()
}
```
#### HTMLToAttributedStringParser: Core implementation of XMLParserDelegate
```swift
// Ref: https://github.com/malcommac/SwiftRichString
final class HTMLToAttributedStringParser: NSObject {
    
    private static let topTag = "source"
    private var xmlParser: XMLParser?
    
    private(set) var attributedString: NSMutableAttributedString = NSMutableAttributedString()
    private(set) var supportedTagRenders: [HTMLTagParser] = []
    private let defaultStyle: AttributedStringStyle
    
    /// Styles applied at each fragment.
    private var renderingTagRenders: [HTMLTagParser] = []

    // The XML parser sometimes splits strings, which can break localization-sensitive
    // string transforms. Work around this by using the currentString variable to
    // accumulate partial strings, and then reading them back out as a single string
    // when the current element ends, or when a new one is started.
    private var currentString: String?
    
    // MARK: - Initialization

    init(defaultStyle: AttributedStringStyle) {
        self.defaultStyle = defaultStyle
        super.init()
    }
    
    func register(_ tagRender: HTMLTagParser) {
        if let index = supportedTagRenders.firstIndex(where: { type(of: $0).tag == type(of: tagRender).tag }) {
            supportedTagRenders.remove(at: index)
        }
        supportedTagRenders.append(tagRender)
    }
    
    /// Parse and generate attributed string.
    func parse(string: String) throws -> NSAttributedString {
        var xmlString = HTMLToAttributedStringParser.escapeWithUnicodeEntities(string)
        
        // make sure <br/> format is correct XML
        // because Web may use <br> to present <br/>, but <br> is not a valid XML
        xmlString = xmlString.replacingOccurrences(of: "<br>", with: "<br/>")
        
        let xml = "<\(HTMLToAttributedStringParser.topTag)>\(xmlString)</\(HTMLToAttributedStringParser.topTag)>"
        guard let data = xml.data(using: String.Encoding.utf8) else {
            throw XMLParserInitError("Unable to convert to UTF8")
        }
        
        let xmlParser = XMLParser(data: data)
        xmlParser.shouldProcessNamespaces = false
        xmlParser.shouldReportNamespacePrefixes = false
        xmlParser.shouldResolveExternalEntities = false
        xmlParser.delegate = self
        self.xmlParser = xmlParser
        
        attributedString = NSMutableAttributedString()
        
        guard xmlParser.parse() else {
            let line = xmlParser.lineNumber
            let shiftColumn = (line == 1)
            let shiftSize = HTMLToAttributedStringParser.topTag.lengthOfBytes(using: String.Encoding.utf8) + 2
            let column = xmlParser.columnNumber - (shiftColumn ? shiftSize : 0)
            
            throw XMLParserError(parserError: xmlParser.parserError, line: line, column: column)
        }
        
        return attributedString
    }
}

// MARK: Private Method

private extension HTMLToAttributedStringParser {
    func enter(element elementName: String, attributes: [String: String]) {
        // elementName = tagName, EX: a,span,div...
        guard elementName != HTMLToAttributedStringParser.topTag else {
            return
        }
        
        if let index = supportedTagRenders.firstIndex(where: { type(of: $0).tag == elementName }) {
            var tagRender = supportedTagRenders[index]
            tagRender.storedHTMLAttributes = attributes
            renderingTagRenders.append(tagRender)
        }
    }
    
    func exit(element elementName: String) {
        if !renderingTagRenders.isEmpty {
            renderingTagRenders.removeLast()
        }
    }
    
    func foundNewString() {
        if let currentString = currentString {
            // currentString != nil ,ex: <i>currentString</i>
            var newAttributedString = NSMutableAttributedString(string: currentString)
            if !renderingTagRenders.isEmpty {
                for (key, tagRender) in renderingTagRenders.enumerated() {
                    // Render Style
                    tagRender.render(attributedString: &newAttributedString)
                    renderingTagRenders[key].storedHTMLAttributes = nil
                }
            } else {
                defaultStyle.render(attributedString: &newAttributedString)
            }
            attributedString.append(newAttributedString)
            self.currentString = nil
        } else {
            // currentString == nil ,ex: <br/>
            var newAttributedString = NSMutableAttributedString()
            for (key, tagRender) in renderingTagRenders.enumerated() {
                // Render Style
                tagRender.render(attributedString: &newAttributedString)
                renderingTagRenders[key].storedHTMLAttributes = nil
            }
            attributedString.append(newAttributedString)
        }
    }
}

// MARK: Helper

extension HTMLToAttributedStringParser {
    // handle html entity / html hex
    // Perform string escaping to replace all characters which are not supported by NSXMLParser
    // into the specified encoding with decimal entity.
    // For example, if your string contains '&' character, the parser will break the style.
    // This option is active by default.
    // ref: https://github.com/malcommac/SwiftRichString/blob/e0b72d5c96968d7802856d2be096202c9798e8d1/Sources/SwiftRichString/Support/XMLStringBuilder.swift
    static func escapeWithUnicodeEntities(_ string: String) -> String {
        guard let escapeAmpRegExp = try? NSRegularExpression(pattern: "&(?!(#[0-9]{2,4}|[A-z]{2,6});)", options: NSRegularExpression.Options(rawValue: 0)) else {
            return string
        }
        
        let range = NSRange(location: 0, length: string.count)
        return escapeAmpRegExp.stringByReplacingMatches(in: string,
                                                        options: NSRegularExpression.MatchingOptions(rawValue: 0),
                                                        range: range,
                                                        withTemplate: "&amp;")
    }
}

// MARK: XMLParserDelegate

extension HTMLToAttributedStringParser: XMLParserDelegate {
    func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String: String]) {
        foundNewString()
        enter(element: elementName, attributes: attributeDict)
    }
    
    func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) {
        foundNewString()
        guard elementName != HTMLToAttributedStringParser.topTag else {
            return
        }
        
        exit(element: elementName)
    }
    
    func parser(_ parser: XMLParser, foundCharacters string: String) {
        currentString = (currentString ?? "").appending(string)
    }
}
```


Applying the logic of Strip, we can combine the disassembled structure within it. From `elementName`, we can determine the current Tag and apply the corresponding Tag Parser along with the defined Style.
#### Test Result
```swift
let test = "I agree to provide my <b><i>personal</i></b> ID number/passport/residence <span style=\"color:#FF0000;font-size:20px;word-spacing:10px;line-height:10px\">number</span> for <i>cross-border logistics</i> use, and I have understood the logistics requirements for cross-border<br/>goods<p>flow</p>."
let render = HTMLToAttributedStringParser(defaultStyle: DefaultTextStyle())
render.register(ATagParser())
render.register(BoldTagParser())
render.register(SpanTagParser())
//...
print(try! render.parse(string: test))

// Result:
// I agree {
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// } to provide {
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// } my {
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Bold 14.00 pt. P [] (0x13a013870) fobj=0x13a013870, spc=3.46\"";
//     NSUnderline = 1;
// } ID number/passport/residence {
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// } number {
//     NSColor = "UIExtendedSRGBColorSpace 1 0 0 1";
//     NSFont = "\".SFNS-Regular 20.00 pt. P [] (0x13a015fa0) fobj=0x13a015fa0, spc=4.82\"";
//     NSKern = 10;
//     NSParagraphStyle = "Alignment 4, LineSpacing 10, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// } for cross-border logistics use {
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// } and I have understood the logistics requirements for cross-border {
//     NSColor = "UIExtendedGrayColorSpace 0 1";
//     NSFont = "\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\"";
//     NSParagraphStyle = "Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\n    28L,\n    56L,\n    84L,\n    112L,\n    140L,\n    168L,\n    196L,\n    224L,\n    252L,\n    280L,\n    308L,\n    336L\n), DefaultTabInterval 0, Blocks (\n), Lists (\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''";
// } goods flow.
// }
```

**Results:**


![](/assets/a8c2d26cc734/1*LaKhRLhHm2jfptG4h_jB5Q.png)

### Done!

With this, we have completed the implementation of HTML rendering functionality through XMLParser, while maintaining extensibility and specifications, allowing us to manage and understand the types of string rendering currently supported by the app from the code.

### Complete GitHub Repo as follows


[![](https://opengraph.githubassets.com/c021159c3da82c37ff65d210c7a64aa4e56e398964b824baf4f248bb25bdb805/zhgchgli0718/HTMLToAttributedStringRednerExample)](https://github.com/zhgchgli0718/HTMLToAttributedStringRednerExample){:target="_blank"}




> _This article is also published on my personal blog: [**\[Click here\]**](../a8c2d26cc734/) ._ 





> _If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"} ._ 






_[Post](https://medium.com/zrealm-ios-dev/%E8%87%AA%E8%A1%8C%E5%AF%A6%E7%8F%BE-ios-nsattributedstring-html-render-a8c2d26cc734){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
