---
title: "Exploring Methods for iOS HLS Caching"
author: "ZhgChgLi"
date: 2020-04-08T17:12:17.716+0000
last_modified_at: 2024-04-13T08:09:26.884+0000
categories: ["ZRealm Dev."]
tags: ["hls","ios","ios-app-development","cache","reverse-proxy"]
description: "How to achieve caching functionality while playing m3u8 streaming media files using AVPlayer"
image:
  path: /assets/d796bf8e661e/1*x_Js63o52qJMmYHKIuKF7A.jpeg
render_with_liquid: false
---

### Exploring Methods for iOS HLS Caching

How to achieve caching functionality while playing m3u8 streaming media files using AVPlayer



![photo by [Mihis Alex](https://www.pexels.com/zh-tw/@mcraftpix?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels){:target="_blank"}](/assets/d796bf8e661e/1*x_Js63o52qJMmYHKIuKF7A.jpeg)

photo by [Mihis Alex](https://www.pexels.com/zh-tw/@mcraftpix?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels){:target="_blank"}
#### \[2023/03/12\] Update
- The next article, "[AVPlayer Implementation of Local Caching Features](../6ce488898003/)," will teach you how to implement AVPlayer caching.



[![](https://repository-images.githubusercontent.com/612890185/346ae563-7278-4518-a19b-f5d367e60adc)](https://github.com/ZhgChgLi/ZPlayerCacher){:target="_blank"}


I have open-sourced my previous implementation, which can be directly used by those in need.
- Customizable caching strategies, can use PINCache or others…
- Externally, just call the make AVAsset factory with the URL, and the AVAsset will support caching
- Implemented data flow strategies using Combine
- Wrote some tests

### About

HTTP Live Streaming (HLS) is a streaming media network transmission protocol based on HTTP proposed by Apple.

For music playback, in non-streaming situations, we use mp3 as the music file, and the time it takes to download the entire file depends on its size; HLS splits a file into multiple smaller files, allowing playback to start as soon as the first segment is received without needing to download the entire file!

The `.m3u8` file records the bitrate, playback order, duration, and overall audio information of these segmented `.ts` files. It can also provide encryption protection, low-latency live streaming, etc.

Example of an `.m3u8` file (aviciiwakemeup\.m3u8):
```plaintext
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-ALLOW-CACHE:YES
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:9.900411,
aviciiwakemeup–00001.ts
#EXTINF:9.900400,
aviciiwakemeup–00002.ts
#EXTINF:9.900411,
aviciiwakemeup–00003.ts
#EXTINF:9.900411,
.
.
.
#EXTINF:6.269389,
aviciiwakemeup-00028.ts
#EXT-X-ENDLIST
```

_\*EXT\-X\-ALLOW\-CACHE has been deprecated in [iOS≥ 8/Protocol Ver\.7](https://developer.apple.com/documentation/http_live_streaming/about_the_ext-x-version_tag?language=objc){:target="_blank"} and is no longer meaningful whether this line is present or not._
### Goals


For a streaming media service, **Cache is extremely important**; because each audio file can range from a few MB to several GB. If we have to pull the file from the server every time we replay, it puts a significant load on the server, and the data costs are $$$$. If there is a cache layer, it can save a lot of money for the service, and users won't waste bandwidth or time re-downloading; it's a win-win mechanism (but remember to set limits/timely clear to avoid filling up users' devices).

### Problem

In the past, when not streaming, handling mp3/mp4 files was straightforward: just download them to the device before playback, and only start playing once the download is complete. After all, no matter what, the file has to be fully downloaded before playback, so why not use URLSession to download the file and then provide the local file path using file:// to AVPlayer for playback? Alternatively, the proper way is to use AVAssetResourceLoaderDelegate to cache the downloaded data in the delegate methods.

When it comes to streaming, the idea is quite simple: first read the `.m3u8` file, then parse the information inside, and cache each `.ts` file. However, in practice, I found that it was not that simple, and the complexity exceeded my expectations, which is why I wrote this article!

For playback, we still directly use iOS AVFoundation's AVPlayer; there is no difference in operation between streaming and non-streaming files.

**Example:**
```swift
let url:URL = URL(string:"https://zhgchg.li/aviciiwakemeup.m3u8")
var player: AVPlayer = AVPlayer(url: url)
player.play()
```
### **2021–01–05 Update:**

We have reverted to using mp3 files, which allows us to directly implement using `AVAssetResourceLoaderDelegate`. For detailed implementation, please refer to "[AVPlayer Streaming and Caching Practical Implementation](../ee47f8f1e2d2/)".

### Practical Solutions

Here are several solutions we can achieve for our goals and the problems encountered during implementation.
#### Solution 1. AVAssetResourceLoaderDelegate ❌

The first idea is to just do it the same way as with mp3/mp4! Use AVAssetResourceLoaderDelegate to cache the `.ts` files in the delegate methods.

However, I’m sorry, this path is blocked because we cannot intercept the download request information for `.ts` files in the delegate. You can find more details in this [Q&A](https://stackoverflow.com/questions/29752028/unknown-error-12881-when-using-avassetresourceloader/30239876#30239876){:target="_blank"} and the [official documentation](https://developer.apple.com/library/archive/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECHTTPLIVESTREAMING){:target="_blank"}.

For the implementation of AVAssetResourceLoaderDelegate, please refer to "[AVPlayer Streaming and Caching Practical Implementation](../ee47f8f1e2d2/)".
#### Solution 2.1 Intercept Requests with URLProtocol ❌

URLProtocol is a method I recently learned, which allows us to intercept all requests based on the `URL Loading System` (URLSession, Call API, download images, etc.) to modify the Request, Response, and then return them as if nothing happened, stealthily. For more about URLProtocol, you can refer to [this article](https://www.jianshu.com/p/fbe57730d3e1){:target="_blank"}.

Using this method, we plan to intercept AVFoundation AVPlayer's requests for `.m3u8` and `.ts`, intercept them, and if there is a local cache, return the cached data directly; if not, then actually send the request out. This way, we can achieve our goal.

Again, I’m sorry, this path is also blocked; because AVFoundation AVPlayer's requests are not on the `URL Loading System`, we cannot intercept them.
_*There is a saying that it works on the simulator but not on the actual device._
#### Solution 2.2 Force it into URLProtocol ❌

Based on Solution 2.1, a brute-force idea is to change the request URL to a custom scheme (e.g., streetVoiceCache://). Since AVFoundation cannot handle this request, it will be thrown out, allowing our URLProtocol to intercept it and do what we want.
```swift
let url:URL = URL(string:"streetVoiceCache://zhgchg.li/aviciiwakemeup.m3u8?originSchme=https")
var player: AVPlayer = AVPlayer(url: url)
player.play()
```

```markdown
URLProtocol will intercept `streetVoiceCache://zhgchg.li/aviciiwakemeup.m3u8?originSchme=https`, and at this point, we just need to restore it to the original URL, then send a URLSession to request the data so we can cache it ourselves; the `.ts` files in the m3u8 will also be intercepted by URLProtocol, and we can cache them here as well.

Everything seems so perfect, but when I excitedly Build-Run the APP, Apple slapped me in the face:

`Error: 12881 “CoreMediaErrorDomain custom url not redirect”`

It does not accept the Response Data for the `.ts` file Request; I can only use the `urlProtocol:wasRedirectedTo` method to redirect to the original Https request for it to play normally. Even if I download the `.ts` file locally and then redirect to that file:// file, it still does not accept it. Checking the [official forum](https://forums.developer.apple.com/thread/30833){:target="_blank"} gives the answer that this cannot be done; the `.m3u8` can only originate from Http/Https (so even if you put the entire `.m3u8` and all the segmented `.ts` files locally, you cannot use file:// to play with AVPlayer), and also, `.ts` cannot be provided with Data by URLProtocol.

`fxxk…`
#### Solution 2.2–2 Same as Solution 2.2 but with Solution 1 AVAssetResourceLoaderDelegate ❌

The implementation is like Solution 2.2, feeding AVPlayer a custom Scheme to enter AVAssetResourceLoaderDelegate; then we handle it ourselves.

Same result as 2.2:

`Error: 12881 “CoreMediaErrorDomain custom url not redirect”`

The same answer on the [official forum](https://forums.developer.apple.com/thread/113063){:target="_blank"}.

It can be used for decryption processing (refer to [this article](https://medium.com/@marslin_dev/how-to-play-aes-encrypted-video-with-airplay-2-82a353044f40){:target="_blank"} or [this example](https://www.jianshu.com/p/2c2cbe173e99){:target="_blank"}), but still cannot achieve caching functionality.
#### Solution 3. Reverse Proxy Server ⍻ (feasible, but not perfect)

This method is the most commonly suggested answer when looking for how to handle HLS Cache; it involves starting an HTTP Server on the APP to serve as a Reverse Proxy Server.

The principle is quite simple: the APP runs an HTTP Server, assuming it is on Port 8080, the URL will be `http://127.0.0.1:8080/`; then we can process incoming Requests and provide Responses.

Applied to our case, we change the request URL to:
 `http://127.0.0.1:8080/aviciiwakemeup.m3u8?origin=http://zhgchg.li/`

In the HTTP Server's Handler, we intercept and process `*.m3u8`, so when a Request comes in, it will enter our Handler, and we can do whatever we want, controlling what Data to respond with; the `.ts` files will also come in; here we can implement our desired caching mechanism.

For AVPlayer, it is just a standard streaming audio file of http://\.m3u8, so there will be no issues.

**For a complete implementation example, refer to:**

[![](https://opengraph.githubassets.com/f82feda77c302ecf87673688fe78a46bccc4669783dda9b10093ecb5382f9895/StyleShare/HLSCachingReverseProxyServer)](https://github.com/StyleShare/HLSCachingReverseProxyServer/blob/master/Sources/HLSCachingReverseProxyServer/HLSCachingReverseProxyServer.swift){:target="_blank"}
```

```markdown
Since I also referred to this example, I used [GCDWebServer](https://github.com/swisspol/GCDWebServer){:target="_blank"} for the Local HTTP Server part. Additionally, there is an updated [Telegraph](https://github.com/Building42/Telegraph){:target="_blank"} that can be used. \( [CocoaHttpServer](https://github.com/robbiehanson/CocoaHTTPServer){:target="_blank"} hasn't been updated for a long time, so I don't recommend using it \)

**Looks good! But there's a problem:**

Our service is music streaming rather than a video playback platform. Many times, users are switching music in the background; will the Local HTTP Server still be active during this time??

The documentation for GCDWebServer states that it will automatically disconnect when entering the background and reconnect when returning to the foreground, but you can set the parameter `GCDWebServerOption_AutomaticallySuspendInBackground:false` to disable this mechanism.

However, in practice, if no requests are sent for a period of time, the Server will still disconnect \(and the status will be incorrect, still showing isRunning\). It feels like it gets cut off by the system; after delving into [the implementation of HTTP Server](https://izeeshan.wordpress.com/2014/08/25/local-http-server-for-ios/){:target="_blank"}, I found that the underlying mechanism is based on sockets. After checking the [official documentation on socket services](https://developer.apple.com/library/archive/technotes/tn2277/_index.html){:target="_blank"}, this flaw cannot be resolved. The system will suspend it when there are no new connections in the background.

_\*I found a rather convoluted method online… which is to send a long request or continuously send empty requests to ensure the Server is not suspended by the system in the background._

The above is all regarding the app's status in the background. When in the foreground, the Server is very stable and will not be suspended due to idleness, so there is no issue!

**That said, since it relies on other services, testing in the development environment is fine, but in actual applications, it's recommended to implement rollback handling \(AVPlayer\.AVPlayerItemFailedToPlayToEndTimeErrorKey notification\); otherwise, if the service goes down, users will be stuck.**

`So it's not perfect...`
#### Option 4. Use the HTTP Client's caching mechanism ❌

Our `.m3u8/.ts` files' Response Headers provide `Cache-Control`, `Age`, `eTag`, and other HTTP Client Cache information; our website's caching mechanism works perfectly in Chrome, and I also saw in the official new preliminary specification document for [Protocol Extension for Low-Latency HLS](https://developer.apple.com/documentation/http_live_streaming/protocol_extension_for_low-latency_hls_preliminary_specification){:target="_blank"} that cache-control headers can be set for caching.


![](/assets/d796bf8e661e/1*vyvVp1sf9Hbtb_nWiLXYEg.png)


However, AVFoundation AVPlayer does not exhibit any HTTP Client Caching effects, so this route is also blocked! It's just wishful thinking.
#### Option 5. Do not use AVFoundation AVPlayer to play audio files ✔

Implement audio file parsing, caching, encoding, and playback functionality yourself.

**This is too hardcore and requires deep technical skills and a lot of time; I haven't researched it.**

Here’s a reference to an open-source player: [FreeStreamer](https://github.com/muhku/FreeStreamer){:target="_blank"}. If you really want to choose this option, it would be better to stand on the shoulders of giants and directly use a third-party library.
#### Option 5–1. Do not use HLS

Same as option 5, **this is too hardcore and requires deep technical skills and a lot of time; I haven't researched it.**
#### Option 6. Convert .ts segmented files to .mp3/.mp4 files ✔

I haven't researched this, but it is indeed feasible; however, it seems complicated to handle the already downloaded `.ts` files, converting each to .mp3 or .mp4 files and then playing them in order, or compressing them into a single file, seems quite challenging.
```


If you're interested, you can refer to [this article](https://github.com/xyqjay/m3u8ToMP4){:target="_blank"}.
#### Solution 7. Download the complete file before playback ⍻

This method cannot be accurately called streaming while caching; it actually downloads the entire audio file content before starting playback. If it is a `.m3u8`, as mentioned in Solution 2.2, it cannot be directly downloaded for local playback.

To implement this, you need to use the iOS ≥ 10 API `AVAssetDownloadTask.makeAssetDownloadTask`, which will package the `.m3u8` into a **`.movpkg`** stored locally for user playback.

**This is more like offline playback rather than a caching function.**

Additionally, users can view and manage the downloaded packaged audio files from "Settings" -> "General" -> "iPhone Storage" -> APP.

![Downloaded Videos Section Below](/assets/d796bf8e661e/1*_YNIdy8NRkhVdeDTNvXzxA.jpeg)

Downloaded Videos Section Below

**For detailed implementation, you can refer to this example:**

[![](https://opengraph.githubassets.com/a2ceae202336428494e5cd51b78cfbba3d139c135eaf232b4d2dffd2a7673eba/zhonglaoban/HLS-Stream)](https://github.com/zhonglaoban/HLS-Stream){:target="_blank"}

### Conclusion

The exploration process above took almost a whole week, going around in circles and nearly driving me crazy; currently, there is no reliable and easy-to-deploy method.

I will update if there are new ideas!
#### References
- [iOS Audio Playback (9): Streaming while Caching](http://msching.github.io/blog/2016/05/24/audio-in-ios-9/){:target="_blank"}
- [StyleShare/HLSCachingReverseProxyServer](https://github.com/StyleShare/HLSCachingReverseProxyServer){:target="_blank"}

If you have any questions or suggestions, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/ios-hls-cache-%E5%AF%A6%E8%B8%90%E6%96%B9%E6%B3%95%E6%8E%A2%E7%A9%B6%E4%B9%8B%E6%97%85-d796bf8e661e){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
