---
title: "Slack & ChatGPT Integration"
author: "ZhgChgLi"
date: 2024-02-16T13:17:01.111+0000
last_modified_at: 2024-02-18T04:09:17.926+0000
categories: ["ZRealm Dev."]
tags: ["cloud-functions","ios-app-development","python","chatgpt","slack"]
description: "Build your own ChatGPT OpenAI API for Slack App (Google Cloud Functions & Python)"
image:
  path: /assets/bd94cc88f9c9/1*HHE0Nbgr95O6BwhiRe8lHg.png
render_with_liquid: false
---

### Slack & ChatGPT Integration

Build your own ChatGPT OpenAI API for Slack App \(Google Cloud Functions & Python\)

#### Background

Recently, we have been promoting the use of Generative AI within the team to enhance work efficiency. Initially, we aimed to achieve an AI Assistant \(ChatGPT functionality\) to reduce the time spent on daily data inquiries, organizing cumbersome data, and manual data processing, thereby improving work efficiency. We hope that engineers, designers, PMs, marketers, and others can freely use it.

The simplest method would be to purchase the ChatGPT Team plan, which costs $25 per seat per year; however, since we are unsure about everyone's usage frequency \(volume\) and wish to integrate with external collaboration and development processes, we opted for the OpenAI API approach, wrapping it through other services for team members to use.

You can generate an OpenAI API Key from [this page](https://platform.openai.com/api-keys){:target="_blank"}. The Key does not correspond to a specific Model version; you need to specify the Model version you want to use when making requests, which will incur the corresponding Token costs.

> We need a service that allows us to set our own OpenAI API Key and use that Key for ChatGPT-like functionality.

> Whether it's a Chrome Extension or a Slack App, it's quite difficult to find services that allow you to set your own OpenAI API Key. Most services are designed to sell their own subscription plans, and allowing users to customize their API Key means they can't make money and are essentially doing charity.

#### \[Chrome Extension\] [SidebarGPT](https://chromewebstore.google.com/detail/chatgpt-assistant-for-chr/mejjgaogggabifjfjdbnobinfibaamla){:target="_blank"}

After installation, you can go to Settings \-&gt; General \-&gt; and enter your OpenAI API Key.

![](/assets/bd94cc88f9c9/1*E9SO72c7ZEBfhBMBNT-Erw.png)

You can directly call up the chat interface from the browser toolbar or side icon and use it immediately:

![](/assets/bd94cc88f9c9/1*Et1rGixc8pihUiSn8kqSqA.png)

#### \[Chrome Extension\] [OpenAI Translator](https://chrome.google.com/webstore/detail/ogjibjphoadhljaoicdnjnmgokohngcc){:target="_blank"}

If you only need translation, you can use this one, which allows you to customize the OpenAI API Key for translation.

![](/assets/bd94cc88f9c9/1*cMB9uuyBRPKtdE_7g6Yqiw.png)

![](/assets/bd94cc88f9c9/1*wKfD9BQYJuNXrUl1mr_GvA.png)

Additionally, it is an [open-source project](https://github.com/openai-translator/openai-translator){:target="_blank"} and also provides a desktop version for macOS/Windows:

[![](https://repository-images.githubusercontent.com/609416865/2fee2046-51a5-407c-9641-851e5032ec63)](https://github.com/openai-translator/openai-translator){:target="_blank"}

The advantage of a Chrome Extension is that it is quick, simple, and convenient—just install and use it directly. The downside is that you need to provide the API Key to all members, making it difficult to control leakage issues, and using third-party services also makes it hard to guarantee everyone's data security.

#### \[Self-hosted\] [LibreChat](https://github.com/danny-avila/LibreChat){:target="_blank"}

[![](https://opengraph.githubassets.com/102ca4ff10ae06f9a1fa9f7126e73ef92a641310dd20377ac942cdc7132b79f9/danny-avila/LibreChat)](https://github.com/danny-avila/LibreChat){:target="_blank"}

This is an OpenAI API Chat wrapper service recommended by colleagues in the R&D department, providing authentication and almost replicating the ChatGPT interface, with features that are more powerful than ChatGPT in this open-source project.

![](/assets/bd94cc88f9c9/1*8Y_GtNjjuz_FS-CDEwIQzA.png)

You only need to set up the project, install Docker, configure the \.env file, and start the Docker service to use it directly through the website.

> **I tried it, and it was flawless—it's like a local version of the ChatGPT service. The only downside is that it requires server deployment; if there are no other considerations, you can directly use this open-source project.**

### Slack App

In fact, deploying the [LibreChat](https://github.com/danny-avila/LibreChat){:target="_blank"} service on a server already achieves the desired effect, but I had a sudden idea that integrating it into daily tools might be more convenient. Additionally, the company's server has strict permission settings, making it difficult to start services at will.

At that time, I didn't think too much and assumed that there would be many OpenAI API integration services for Slack Apps, so I just needed to find one and set it up; however, things turned out to be more complicated than expected.

A Google search only yielded one official press release from March 2023 titled "[Why we built the ChatGPT app for Slack](https://slack.com/intl/zh-tw/blog/news/why-we-built-the-chatgpt-app-for-slack){:target="_blank"}" and some Beta images:

![[https://www\.salesforce\.com/news/stories/chatgpt\-app\-for\-slack/](https://www.salesforce.com/news/stories/chatgpt-app-for-slack/){:target="_blank"}](/assets/bd94cc88f9c9/1*M4fXzn1PIEBamjLMDckcSA.gif)

[https://www\.salesforce\.com/news/stories/chatgpt\-app\-for\-slack/](https://www.salesforce.com/news/stories/chatgpt-app-for-slack/){:target="_blank"}

It looks like the functionality is very comprehensive and can greatly enhance work efficiency; however, as of January 2024, there has been no news released, and the [Beta registration link](http://openai.com/waitlist/slack){:target="_blank"} provided at the end of the article has also expired, leaving no further updates. \(Is Microsoft trying to let Teams support it first?\)

**\[2024/02/14 Update\]:**
- According to [Slack's official news](https://slack.com/intl/zh-tw/blog/news/slack-ai-has-arrived){:target="_blank"}, it seems that the integration with ChatGPT \(OpenAI\) has likely been abandoned or restructured into [Slack AI](https://slack.com/intl/zh-tw/blog/news/slack-ai-has-arrived){:target="_blank"}.

#### Slack Apps

![](/assets/bd94cc88f9c9/1*gjkHBFeFVkCQ77lhTHM_Qg.png)

Due to the lack of an official App, I turned to search for third-party developer Apps. After searching and trying several, I hit a wall; there weren't many Apps that met the criteria, and none offered the ability to customize the Key. Each was designed to sell services and make money.

### Implementing ChatGPT OpenAI API for Slack App

Having some prior experience in developing Slack Apps, I decided to create one myself.

> **⚠️Disclaimer⚠️** 

> This article demonstrates how to create a Slack App and quickly use Google Cloud Functions to meet the requirements by connecting to the OpenAI API. There are many applications for Slack Apps, and everyone is free to explore.

> ⚠️⚠️ Google Cloud Functions, as a Function as a Service \(FaaS\), has the advantages of being convenient, quick, and having a free tier. Once the program is written, it can be deployed and executed directly, automatically scaling. The downside is that the service environment is controlled by GCP, and if the service is not called for a long time, it will enter a sleep mode. When called again, it will enter a [Cold Start](https://cloud.google.com/functions/docs/configuring/recommender?hl=en){:target="_blank"} state, which requires a longer response time. Additionally, it is also more challenging to run multiple services that interact with each other.

> For more comprehensive or high-demand usage, it is still recommended to set up a VM \(App Engine\) to run the service.

#### Final Result Image

![](/assets/bd94cc88f9c9/1*af90HtXO_f9qLReKZ85iDg.gif)

> The complete Cloud Functions Python code and Slack App settings are attached at the end of the article, so those who don't want to go through it step by step can quickly refer to it.

### Step 1\. Create a Slack App

Go to [Slack App](https://api.slack.com/apps){:target="_blank"}:

![](/assets/bd94cc88f9c9/1*m4gmfX6XuNczSRAVwzvo_g.png)

Click "Create New App"

![](/assets/bd94cc88f9c9/1*bORUew6Y7DEN9QMFqqqOQw.png)

Choose "From scratch"

![](/assets/bd94cc88f9c9/1*U_kB4YxWf0X0RnSyD9ZIYw.png)

Enter the "App Name" and select the Workspace to add it to.

![](/assets/bd94cc88f9c9/1*RNjigMtA1XJHxq4NAv3pKg.png)

Once created, go to "OAuth & Permissions" to add the necessary permissions for the Bot.

![](/assets/bd94cc88f9c9/1*rLHaXjMXifaCvHSKGeWaOg.png)

Scroll down to find the "Scopes" section, click "Add an OAuth Scope," and search to add the following permissions:
- chat:write
- im:history
- im:read
- im:write

After adding the Bot permissions, click on the left "Install App" \-&gt; "Install to Workspace"

![](/assets/bd94cc88f9c9/1*PlvdPG-pcNPtP48pGSP1Tg.png)

If the Slack App adds any other permissions later, you will need to click "Reinstall" again for them to take effect.

![](/assets/bd94cc88f9c9/1*EZTaUMwyTsWA7WmUab8rbQ.png)

> **But rest assured, the Bot Token will not change due to reinstallation.**

After setting the Slack Bot Token permissions, go to "App Home":

![](/assets/bd94cc88f9c9/1*7mBKY188fkfTpGNOLtfByQ.png)

Scroll down to find the "Show Tabs" section, enable "Messages Tab" and "Allow users to send Slash commands and messages from the messages tab" \(if this is not checked, messages cannot be sent, and it will display "Sending messages to this app has been turned off\. "\)

![](/assets/bd94cc88f9c9/1*dEOSGTBN4v5AuWncYNqBEA.png)

Return to the Slack Workspace, press "Command\+R" to refresh the page, and you will see the newly created Slack App and the message input box:

![](/assets/bd94cc88f9c9/1*7tjv1snWJ1IOsEvSTt4KeQ.png)

At this point, sending messages to the App does not have any functionality yet.

#### Enable Event Subscriptions

![](/assets/bd94cc88f9c9/1*-DpIEDSaTT2yP4LXw3ZBbQ.png)

Next, we need to enable the event subscription feature for the Slack App, which will call the API to the specified URL when designated events occur.

#### Add Google Cloud Functions

For the Request URL, [Google Cloud Functions](https://console.cloud.google.com/functions/list){:target="_blank"} will come into play.

After setting up the project and billing information, click "Create Function"

![](/assets/bd94cc88f9c9/1*dBYo5ylUh9dhJF_1YG9RBg.png)

![](/assets/bd94cc88f9c9/1*p4AmWUsLvovFVjEd7JlxuA.png)

Enter the project name for the Function name, and select "Allow unauthenticated invocations" for Authentication, meaning that anyone with the URL can access it.

> If you cannot create a Function or change the Authentication, it means your GCP account does not have full permissions for Google Cloud Functions. You will need to ask your organization administrator to add Cloud Functions Admin permissions in addition to your original role to use it.

![](/assets/bd94cc88f9c9/1*LOrzMQqDFhLE3s64sS2gKQ.png)

Runtime: Python 3\.8 or higher

`main.py`:
```python
import functions_framework

@functions_framework.http
def hello_http(request):
    request_json = request.get_json(silent=True)
    request_args = request.args
    request_headers = request.headers

    # You can use print to log runtime logs, which can be viewed in Logs
    # For advanced Logging Level usage, refer to: https://cloud.google.com/logging/docs/reference/libraries
    print(request_json)

    # Due to the limitations of FAAS (Cloud Functions), if the service is not called for too long, it will enter a cold start state, which may not respond within Slack's required 3 seconds.
    # Additionally, the OpenAI API request takes a certain amount of time to respond (depending on the response length, it may take nearly a minute to complete).
    # If Slack does not receive a response within the time limit, it considers the request lost and will call again.
    # This can cause duplicate requests and responses, so we can set the Response Headers to X-Slack-No-Retry: 1 to inform Slack that even if it does not receive a response within the time limit, it does not need to retry.
    headers = {'X-Slack-No-Retry':1}

    # If this is a Slack Retry request... ignore it
    if request_headers and 'X-Slack-Retry-Num' in request_headers:
        return ('OK!', 200, headers)

    # Slack App Event Subscriptions Verify
    # https://api.slack.com/events/url_verification
    if request_json and 'type' in request_json and request_json['type'] == 'url_verification':
        challenge = ""
        if 'challenge' in request_json:
            challenge = request_json['challenge']
        return (challenge, 200, headers)

    return ("Access Denied!", 400, headers)
```

`requirements.txt` should include the following dependencies:
```
functions-framework==3.*
requests==2.31.0
openai==1.9.0
```

Currently, it doesn't have much functionality; it only allows the Slack App to pass the Event Subscriptions verification. You can click "Deploy" to complete the initial deployment.

> ⚠️If you are not familiar with the Cloud Functions editor, you can scroll down to the bottom of the article to see supplementary content.

**After waiting for the deployment to complete (green checkmark)**, copy the Cloud Functions URL:

![](/assets/bd94cc88f9c9/1*qZCQYGuzzL0Skz6K7RV1Ow.png)

Paste the Request URL back into the Slack App Enable Events.

![](/assets/bd94cc88f9c9/1*NyL0Ja9yxzisMZg0QyHfoA.png)

If there are no issues, "Verified" will appear, completing the verification.

What we are doing here is responding to the verification request sent by Slack:
```json
{
    "token": "Jhj5dZrVaK7ZwHHjRyZWjbDl",
    "challenge": "3eZbrw1aBm2rZgRNFdxV2595E9CY3gmdALWMmHkvFXO7tYXAYM8P",
    "type": "url_verification"
}
```

By responding with the content of the `challenge` field, we can pass the verification.

![](/assets/bd94cc88f9c9/1*qgUQe3wIjCxDw8JAYR1dkg.png)

After successfully enabling it, scroll down to find the "Subscribe to bot events" section, click "Add Bot User Event," and add the "message\.im" permission.

![](/assets/bd94cc88f9c9/1*T-9-xrfQvWTEJArALV3QlA.png)

After adding all the necessary permissions, click the "reinstall your app" link at the top to reinstall the Slack App to the Workspace, and the Slack App setup will be complete.

You can also go to "App Home" or "Basic Information" to customize the Slack App's name and profile picture.

![Basic Information](/assets/bd94cc88f9c9/1*9qsVF__3nSjxLJww6PN44g.png)

Basic Information
### Step 2\. Complete the OpenAI API and Slack App Integration \(Direct Messages\)

First, we need to obtain the essential `OPENAI API KEY` and `Bot User OAuth Token`.

- `OPENAI API KEY`: [OpenAI API key page](https://platform.openai.com/account/api-keys){:target="_blank"}.

![](/assets/bd94cc88f9c9/1*DKOm3yZVA1K_EJ3AUeCDsA.png)

- `Bot User OAuth Token`: [OAuth Tokens for Your Workspace](https://api.slack.com/apps/){:target="_blank"}

![](/assets/bd94cc88f9c9/1*mLoxaBPpa_IUP_qOaFZhQg.png)

#### Handling Direct Message \(IM\) Events & Integrating OpenAI API Responses

When a user sends a message to the Slack App, the following Event JSON Payload will be received:
```json
{
  "token": "XXX",
  "team_id": "XXX",
  "context_team_id": "XXX",
  "context_enterprise_id": null,
  "api_app_id": "XXX",
  "event": {
    "client_msg_id": "XXX",
    "type": "message",
    "text": "Hello",
    "user": "XXX",
    "ts": "1707920753.115429",
    "blocks": [
      {
        "type": "rich_text",
        "block_id": "orfng",
        "elements": [
          {
            "type": "rich_text_section",
            "elements": [
              {
                "type": "text",
                "text": "Hello"
              }
            ]
          }
        ]
      }
    ],
    "team": "XXX",
    "channel": "XXX",
    "event_ts": "1707920753.115429",
    "channel_type": "im"
  },
  "type": "event_callback",
  "event_id": "XXX",
  "event_time": 1707920753,
  "authorizations": [
    {
      "enterprise_id": null,
      "team_id": "XXX",
      "user_id": "XXX",
      "is_bot": true,
      "is_enterprise_install": false
    }
  ],
  "is_ext_shared_channel": false,
  "event_context": "4-XXX"
}
```

Based on the above JSON Payload, we can enhance the Slack message to integrate with the OpenAI API and respond back to the Slack message.

```markdown
**Cloud Functions `main.py`:**
```python
import functions_framework
import requests
import asyncio
import json
import time
from openai import AsyncOpenAI

OPENAI_API_KEY = "OPENAI API KEY"
SLACK_BOT_TOKEN = "Bot User OAuth Token"

# The OPENAI API Model being used
# https://platform.openai.com/docs/models
OPENAI_MODEL = "gpt-4-1106-preview"

@functions_framework.http
def hello_http(request):
    request_json = request.get_json(silent=True)
    request_args = request.args
    request_headers = request.headers

    # You can simply use print to log runtime logs, which can be viewed in Logs
    # For advanced Logging Level usage, refer to: https://cloud.google.com/logging/docs/reference/libraries
    print(request_json)

    # Due to the limitations of FAAS (Cloud Functions), if the service is not called for a long time, 
    # the next call will enter a cold start state, which may not respond within the 3 seconds required by Slack.
    # Additionally, the OpenAI API request to response takes a certain amount of time (depending on the response length, 
    # it may take nearly a minute to finish).
    # If Slack does not receive a response within the time limit, it considers the request lost and will repeat the call.
    # This can cause issues with duplicate requests and responses, so we can set the Response Headers to 
    # X-Slack-No-Retry: 1 to inform Slack that even if a response is not received within the time limit, 
    # it does not need to retry.
    headers = {'X-Slack-No-Retry': 1}

    # If this is a Slack Retry request... ignore it
    if request_headers and 'X-Slack-Retry-Num' in request_headers:
        return ('OK!', 200, headers)

    # Slack App Event Subscriptions Verification
    # https://api.slack.com/events/url_verification
    if request_json and 'type' in request_json and request_json['type'] == 'url_verification':
        challenge = ""
        if 'challenge' in request_json:
            challenge = request_json['challenge']
        return (challenge, 200, headers)

    # Handle Event Subscriptions Events...
    if request_json and 'event' in request_json and 'type' in request_json['event']:
        # If the event source is the App and the App ID == Slack App ID, it means it's an event triggered by its own Slack App
        # Ignore it to prevent getting stuck in an infinite loop Slack App -> Cloud Functions -> Slack App -> Cloud Functions...
        if 'api_app_id' in request_json and 'app_id' in request_json['event'] and request_json['api_app_id'] == request_json['event']['app_id']:
            return ('OK!', 200, headers)

        # Event name, e.g., message (related to messages), app_mention (being mentioned)....
        eventType = request_json['event']['type']

        # SubType, e.g., message_changed (edited message), message_deleted (deleted message)...
        # New messages have no Sub Type
        eventSubType = None
        if 'subtype' in request_json['event']:
            eventSubType = request_json['event']['subtype']
        
        if eventType == 'message':
            # Messages with Sub Type are all about message edits, deletions, responses...
            # Ignore them
            if eventSubType is not None:
                return ("OK!", 200, headers)
               
            # Sender of the event message
            eventUser = request_json['event']['user']
            # Channel of the event message
            eventChannel = request_json['event']['channel']
            # Content of the event message
            eventText = request_json['event']['text']
            # Event message TS (message ID)
            eventTS = request_json['event']['event_ts']
                
            # Thread parent message TS (message ID) of the event message
            # Only new messages in a thread will have this data
            eventThreadTS = None
            if 'thread_ts' in request_json['event']:
                eventThreadTS = request_json['event']['thread_ts']
                
            openAIRequest(eventChannel, eventTS, eventThreadTS, eventText)
            return ("OK!", 200, headers)

    return ("Access Denied!", 400, headers)

def openAIRequest(eventChannel, eventTS, eventThreadTS, eventText):
    
    # Set Custom instructions
    # Thanks to my colleague (https://twitter.com/je_suis_marku) for the support
    messages = [
        {"role": "system", "content": "I only understand Traditional Chinese and English."},
        {"role": "system", "content": "I do not understand Simplified Chinese."},
        {"role": "system", "content": "When I respond in Chinese, I will use Traditional Chinese and must conform to commonly used phrases in Taiwan."},
        {"role": "system", "content": "When I respond in English, I will answer in English."},
        {"role": "system", "content": "Do not respond with pleasantries."},
        {"role": "system", "content": "There must be a space between Chinese and English. There must also be a space between Chinese characters and any other language characters, including numbers and emojis."},
        {"role": "system", "content": "If you do not know the answer, or your knowledge is too outdated, please search online and then respond."},
        {"role": "system", "content": "I will tip you 200 USD if you answer well."}
    ]

    messages.append({
        "role": "user", "content": eventText
    })

    replyMessageTS = slackRequestPostMessage(eventChannel, eventTS, "Generating response...")
    asyncio.run(openAIRequestAsync(eventChannel, replyMessageTS, messages))

async def openAIRequestAsync(eventChannel, eventTS, messages):
    client = AsyncOpenAI(
      api_key=OPENAI_API_KEY,
    )

    # Stream Response (chunked response)
    stream = await client.chat.completions.create(
      model=OPENAI_MODEL,
      messages=messages,
      stream=True,
    )
    
    result = ""

    try:
        debounceSlackUpdateTime = None
        async for chunk in stream:
            result += chunk.choices[0].delta.content or ""
            
            # Update the message every 0.8 seconds to avoid frequent calls to the Slack Update message API, 
            # which can lead to failures or waste Cloud Functions request counts
            if debounceSlackUpdateTime is None or time.time() - debounceSlackUpdateTime >= 0.8:
                response = slackUpdateMessage(eventChannel, eventTS, None, result + "...")
                debounceSlackUpdateTime = time.time()
    except Exception as e:
        print(e)
        result += "...*[An error occurred]*"

    slackUpdateMessage(eventChannel, eventTS, None, result)


### Slack ###
def slackUpdateMessage(channel, ts, metadata, text):
    endpoint = "/chat.update"
    payload = {
        "channel": channel,
        "ts": ts
    }
    if metadata is not None:
        payload['metadata'] = metadata
    
    payload['text'] = text
    
    response = slackRequest(endpoint, "POST", payload)
    return response

def slackRequestPostMessage(channel, target_ts, text):
    endpoint = "/chat.postMessage"
    payload = {
        "channel": channel,
        "text": text,
    }
    if target_ts is not None:
        payload['thread_ts'] = target_ts

    response = slackRequest(endpoint, "POST", payload)

    if response is not None and 'ts' in response:
        return response['ts']
    return None

def slackRequest(endpoint, method, payload):
    url = "https://slack.com/api" + endpoint

    headers = {
        "Authorization": f"Bearer {SLACK_BOT_TOKEN}",
        "Content-Type": "application/json",
    }

    response = None
    if method == "POST":
        response = requests.post(url, headers=headers, data=json.dumps(payload))
    elif method == "GET":
        response = requests.post(url, headers=headers)

    if response and response.status_code == 200:
        result = response.json()
        return result
    else:
        return None
```

**Return to Slack for testing:**

![](/assets/bd94cc88f9c9/1*xENCHCINYpPIQKvJeycdaA.png)

Now you can conduct Q&A with ChatGPT and the OpenAI API.
#### Adding Stream Response Interruption Feature to Save Tokens

There are many ways to implement this. If a user inputs a new message while a response is still being generated in the same thread, the previous response can be interrupted, or a shortcut can be clicked to interrupt the response.

![](/assets/bd94cc88f9c9/1*IT671oCwfUP3yqVbNtedSg.png)

This article uses the addition of a "Message Interruption" shortcut as an example.

Regardless of the interruption method, the core principle is the same. Since we do not have a database to store the generated messages and their statuses, the implementation relies on the [**metadata field**](https://api.slack.com/metadata/using){:target="_blank"} (which can store custom information within a specified message) of Slack messages.

When we use the [chat.update](https://api.slack.com/methods/chat.update){:target="_blank"} API Endpoint, if the call is successful, it will return the current message's text content and metadata. Therefore, we add a check in the OpenAI API Stream -> Slack Update Message code to see if the metadata in the response of the modification request has a "interrupt" tag. If it does, we interrupt the OpenAI Stream Response.

**First, we need to add a Slack App message Shortcut**

Go to the [Slack App](https://api.slack.com/apps){:target="_blank"} management interface, find the "Interactivity & Shortcuts" section, click to enable it, and use the same Cloud Functions URL.

![](/assets/bd94cc88f9c9/1*DCUyec3HYlrcIrZoSDCoMw.png)

Click "Create New Shortcut" to add a new message shortcut.

![](/assets/bd94cc88f9c9/1*ybhq_ceaXLFEUsLFyW7sJg.png)

Select "On messages".

![](/assets/bd94cc88f9c9/1*HDkOjV2GcJw_ETTVqV0ErQ.png)

- Name the action title: `Stop OpenAI API Response Generation`
- Short Description: `Stop OpenAI API Response Generation`
- Callback ID: `abort_openai_api` (this is for program identification and can be customized)

After clicking "Create" to complete the setup, remember to click "Save Changes" in the bottom right to save the settings.

![](/assets/bd94cc88f9c9/1*7ti_5hZOoyY6uVp5kWDl3A.png)

Click "reinstall your app" at the top again for it to take effect.

![](/assets/bd94cc88f9c9/1*dUE54HgASm30xq2ILW3ioQ.png)

Back in Slack, clicking the "…" in the upper right corner of the message will show the "Stop OpenAI API Response Generation" shortcut (clicking it at this time will have no effect).

![](/assets/bd94cc88f9c9/1*HjqrkPP1op1Kz-BQuO920Q.png)

**When a user presses the Shortcut on the message, it will send an Event JSON Payload:**
```swift
{
  "type": "message_action",
  "token": "XXXXXX",
  "action_ts": "1706188005.387646",
  "team": {
    "id": "XXXXXX",
    "domain": "XXXXXX-XXXXXX"
  },
  "user": {
    "id": "XXXXXX",
    "username": "zhgchgli",
    "team_id": "XXXXXX",
    "name": "zhgchgli"
  },
  "channel": {
    "id": "XXXXXX",
    "name": "directmessage"
  },
  "is_enterprise_install": false,
  "enterprise": null,
  "callback_id": "abort_openai_api",
  "trigger_id": "XXXXXX",
  "response_url": "https://hooks.slack.com/app/XXXXXX/XXXXXX/XXXXXX",
  "message_ts": "1706178957.161109",
  "message": {
    "bot_id": "XXXXXX",
    "type": "message",
    "text": "The English translation of 高麗菜包 is \"cabbage wrap\". If you are using it as a dish name, it may sometimes be specifically named based on the contents of the dish, such as \"pork cabbage wrap\" or \"vegetable cabbage wrap\".",
    "user": "XXXXXX",
    "ts": "1706178957.161109",
    "app_id": "XXXXXX",
    "blocks": [
      {
        "type": "rich_text",
        "block_id": "eKgaG",
        "elements": [
          {
            "type": "rich_text_section",
            "elements": [
              {
                "type": "text",
                "text": "The English translation of 高麗菜包 is \"cabbage wrap\". If you are using it as a dish name, it may sometimes be specifically named based on the contents of the dish, such as \"pork cabbage wrap\" or \"vegetable cabbage wrap\"."
              }
            ]
          }
        ]
      }
    ],
    "team": "XXXXXX",
    "bot_profile": {
      "id": "XXXXXX",
      "deleted": false,
      "name": "Rick C-137",
      "updated": 1706001605,
      "app_id": "XXXXXX",
      "icons": {
        "image_36": "https://avatars.slack-edge.com/2024-01-23/6517244582244_0c708dfa3f893c72d4c2_36.png",
        "image_48": "https://avatars.slack-edge.com/2024-01-23/6517244582244_0c708dfa3f893c72d4c2_48.png",
        "image_72": "https://avatars.slack-edge.com/2024-01-23/6517244582244_0c708dfa3f893c72d4c2_72.png"
      },
      "team_id": "XXXXXX"
    },
    "edited": {
      "user": "XXXXXX",
      "ts": "1706187989.000000"
    },
    "thread_ts": "1706178832.102439",
    "parent_user_id": "XXXXXX"
  }
}
```

**Complete the Cloud Functions `main.py`:**
```python
import functions_framework
import requests
import asyncio
import json
import time
from openai import AsyncOpenAI

OPENAI_API_KEY = "OPENAI API KEY"
SLACK_BOT_TOKEN = "Bot User OAuth Token"

# The OPENAI API Model being used
# https://platform.openai.com/docs/models
OPENAI_MODEL = "gpt-4-1106-preview"

@functions_framework.http
def hello_http(request):
    request_json = request.get_json(silent=True)
    request_args = request.args
    request_headers = request.headers

    # The Event for the Shortcut will be provided from the post payload field
    # https://api.slack.com/reference/interaction-payloads/shortcuts
    payload = request.form.get('payload')
    if payload is not None:
        payload = json.loads(payload)

    # You can simply use print to log runtime logs, which can be viewed in Logs
    # For advanced Logging Level usage, refer to: https://cloud.google.com/logging/docs/reference/libraries
    print(payload)

    # Due to the limitations of FAAS (Cloud Functions), if the service is not called for a long time, 
    # the next call will enter a cold start state, which may not respond within the 3 seconds required by Slack.
    # Additionally, the OpenAI API request to response takes a certain amount of time (depending on the response length, 
    # it may take nearly a minute to finish).
    # If Slack does not receive a response within the time limit, it considers the request lost and will repeat the call.
    # This can cause issues with duplicate requests and responses, so we can set the Response Headers to 
    # X-Slack-No-Retry: 1 to inform Slack that even if a response is not received within the time limit, 
    # it does not need to retry.
    headers = {'X-Slack-No-Retry': 1}

    # If this is a Slack Retry request... ignore it
    if request_headers and 'X-Slack-Retry-Num' in request_headers:
        return ('OK!', 200, headers)

    # Slack App Event Subscriptions Verification
    # https://api.slack.com/events/url_verification
    if request_json and 'type' in request_json and request_json['type'] == 'url_verification':
        challenge = ""
        if 'challenge' in request_json:
            challenge = request_json['challenge']
        return (challenge, 200, headers)

    # Handle Event Subscriptions Events...
    if request_json and 'event' in request_json and 'type' in request_json['event']:
        # If the event source is the App and the App ID == Slack App ID, it means it's an event triggered by its own Slack App
        # Ignore it to prevent getting stuck in an infinite loop Slack App -> Cloud Functions -> Slack App -> Cloud Functions...
        if 'api_app_id' in request_json and 'app_id' in request_json['event'] and request_json['api_app_id'] == request_json['event']['app_id']:
            return ('OK!', 200, headers)

        # Event name, e.g., message (related to messages), app_mention (being mentioned)....
        eventType = request_json['event']['type']
```
```

```markdown
# SubType, for example: message_changed (edit message), message_deleted (delete message)...
# New messages have no Sub Type
eventSubType = None
if 'subtype' in request_json['event']:
    eventSubType = request_json['event']['subtype']

if eventType == 'message':
    # All Sub Types are message edits, deletions, responses...
    # Ignore and do not process
    if eventSubType is not None:
        return ("OK!", 200, headers)

    # Sender of the event message
    eventUser = request_json['event']['user']
    # Channel of the event message
    eventChannel = request_json['event']['channel']
    # Content of the event message
    eventText = request_json['event']['text']
    # TS of the event message (message ID)
    eventTS = request_json['event']['event_ts']

    # TS of the parent message in the thread (message ID)
    # Only new messages in the thread will have this data
    eventThreadTS = None
    if 'thread_ts' in request_json['event']:
        eventThreadTS = request_json['event']['thread_ts']

    openAIRequest(eventChannel, eventTS, eventThreadTS, eventText)
    return ("OK!", 200, headers)

# Handle Shortcut
if payload and 'type' in payload:
    payloadType = payload['type']

    # If it's a message Shortcut
    if payloadType == 'message_action':
        print(payloadType)
        callbackID = None
        channel = None
        ts = None
        text = None
        triggerID = None

        if 'callback_id' in payload:
            callbackID = payload['callback_id']
        if 'channel' in payload:
            channel = payload['channel']['id']
        if 'message' in payload:
            ts = payload['message']['ts']
            text = payload['message']['text']
        if 'trigger_id' in payload:
            triggerID = payload['trigger_id']

        if channel is not None and ts is not None and text is not None:
            # If it's the Stop OpenAI API response Shortcut
            if callbackID == "abort_openai_api":
                slackUpdateMessage(channel, ts, {"event_type": "aborted", "event_payload": {}}, text)
                if triggerID is not None:
                    slackOpenModal(triggerID, callbackID, "Successfully stopped OpenAI API response!")
                    return ("OK!", 200, headers)

    return ("OK!", 200, headers)

return ("Access Denied!", 400, headers)

def openAIRequest(eventChannel, eventTS, eventThreadTS, eventText):
    
    # Set Custom instructions
    # Thanks to my colleague (https://twitter.com/je_suis_marku) for the support
    messages = [
        {"role": "system", "content": "I only understand Traditional Chinese (Taiwan) and English"},
        {"role": "system", "content": "I do not understand Simplified Chinese"},
        {"role": "system", "content": "When I speak Chinese, I will respond in Traditional Chinese (Taiwan) and must conform to commonly used phrases in Taiwan."},
        {"role": "system", "content": "When I speak English, I will respond in English."},
        {"role": "system", "content": "Do not respond with pleasantries."},
        {"role": "system", "content": "There must be a space between Chinese and English. There must also be a space between Chinese characters and any other language characters, including numbers and emojis."},
        {"role": "system", "content": "If you do not know the answer, or if your knowledge is too outdated, please search online and then respond."},
        {"role": "system", "content": "I will tip you 200 USD if you answer well."}
    ]

    messages.append({
        "role": "user", "content": eventText
    })

    replyMessageTS = slackRequestPostMessage(eventChannel, eventTS, "Generating response...")
    asyncio.run(openAIRequestAsync(eventChannel, replyMessageTS, messages))

async def openAIRequestAsync(eventChannel, eventTS, messages):
    client = AsyncOpenAI(
      api_key=OPENAI_API_KEY,
    )

    # Stream Response
    stream = await client.chat.completions.create(
      model=OPENAI_MODEL,
      messages=messages,
      stream=True,
    )
    
    result = ""

    try:
        debounceSlackUpdateTime = None
        async for chunk in stream:
            result += chunk.choices[0].delta.content or ""
            
            # Update the message every 0.8 seconds to avoid frequent calls to Slack Update message API which could lead to failures or waste Cloud Functions request counts
            if debounceSlackUpdateTime is None or time.time() - debounceSlackUpdateTime >= 0.8:
                response = slackUpdateMessage(eventChannel, eventTS, None, result + "...")
                debounceSlackUpdateTime = time.time()

                # If the message has metadata & metadata event_type == aborted, it means this response has been marked as terminated by the user
                if response and 'ok' in response and response['ok'] == True and 'message' in response and 'metadata' in response['message'] and 'event_type' in response['message']['metadata'] and response['message']['metadata']['event_type'] == "aborted":
                    break
                    result += "...*[Terminated]*"
                # Message has been deleted
                elif response and 'ok' in response and response['ok'] == False and 'error' in response and response['error'] == "message_not_found":
                    break
                
        await stream.close()
                
    except Exception as e:
        print(e)
        result += "...*[An error occurred]*"

    slackUpdateMessage(eventChannel, eventTS, None, result)

### Slack ###
def slackOpenModal(trigger_id, callback_id, text):
    slackRequest("/views.open", "POST", {
        "trigger_id": trigger_id,
        "view": {
            "type": "modal",
            "callback_id": callback_id,
            "title": {
                "type": "plain_text",
                "text": "Prompt"
            },
            "blocks": [
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": text
                    }
                }
            ]
        }
    })

def slackUpdateMessage(channel, ts, metadata, text):
    endpoint = "/chat.update"
    payload = {
        "channel": channel,
        "ts": ts
    }
    if metadata is not None:
        payload['metadata'] = metadata
    
    payload['text'] = text
    
    response = slackRequest(endpoint, "POST", payload)
    return response

def slackRequestPostMessage(channel, target_ts, text):
    endpoint = "/chat.postMessage"
    payload = {
        "channel": channel,
        "text": text,
    }
    if target_ts is not None:
        payload['thread_ts'] = target_ts

    response = slackRequest(endpoint, "POST", payload)

    if response is not None and 'ts' in response:
        return response['ts']
    return None

def slackRequest(endpoint, method, payload):
    url = "https://slack.com/api" + endpoint

    headers = {
        "Authorization": f"Bearer {SLACK_BOT_TOKEN}",
        "Content-Type": "application/json",
    }

    response = None
    if method == "POST":
        response = requests.post(url, headers=headers, data=json.dumps(payload))
    elif method == "GET":
        response = requests.post(url, headers=headers)

    if response and response.status_code == 200:
        result = response.json()
        return result
    else:
        return None
```

**Return to Slack to test:**


![](/assets/bd94cc88f9c9/1*pL343-5zxlJY44gG1qlUDA.png)



![](/assets/bd94cc88f9c9/1*VbWl3IDpgcuT8wKIC_IzsQ.png)


Success! After we complete the `Stop OpenAI API` Shortcut, the ongoing response will be terminated, and it will respond **\[Terminated\]**.


> Similarly, you can create a Shortcut to delete messages, implementing the deletion of messages sent by the Slack App. 




#### Add Context Functionality to the Same Thread

If a new message is sent in the same thread, it can be treated as a follow-up question to the same issue. At this point, a feature can be added to supplement the new prompt with the previous conversation content.

**Add `slackGetReplies` & fill the content into the OpenAI API Prompt:**

**Enhance Cloud Functions `main.py`:**
```python
import functions_framework
import requests
import asyncio
import json
import time
from openai import AsyncOpenAI

OPENAI_API_KEY = "OPENAI API KEY"
SLACK_BOT_TOKEN = "Bot User OAuth Token"

# The OPENAI API Model used
# https://platform.openai.com/docs/models
OPENAI_MODEL = "gpt-4-1106-preview"

@functions_framework.http
def hello_http(request):
    request_json = request.get_json(silent=True)
    request_args = request.args
    request_headers = request.headers

    # The Event of the Shortcut will be given from the post payload field
    # https://api.slack.com/reference/interaction-payloads/shortcuts
    payload = request.form.get('payload')
    if payload is not None:
        payload = json.loads(payload)

    # You can simply use print to log the execution log, which can be viewed in Logs
    # For advanced Logging Level usage, refer to: https://cloud.google.com/logging/docs/reference/libraries
    print(payload)

    # Due to the limitations of FAAS (Cloud Functions), if the service is not called for a long time, it will enter a cold start feature upon the next call, which may not respond within Slack's specified 3 seconds
    # Additionally, the request to the OpenAI API takes a certain amount of time (depending on the response length, it may take nearly a minute to finish)
    # If Slack does not receive a response within the time limit, it will consider the request lost, and Slack will call again
    # This can cause duplicate requests and responses, so we can set the Response Headers to X-Slack-No-Retry: 1 to inform Slack that even if it does not receive a response within the time limit, it does not need to retry    
    headers = {'X-Slack-No-Retry': 1}

    # If it's a Slack Retry request... ignore
    if request_headers and 'X-Slack-Retry-Num' in request_headers:
        return ('OK!', 200, headers)

    # Slack App Event Subscriptions Verify
    # https://api.slack.com/events/url_verification
    if request_json and 'type' in request_json and request_json['type'] == 'url_verification':
        challenge = ""
        if 'challenge' in request_json:
            challenge = request_json['challenge']
        return (challenge, 200, headers)

    # Handle Event Subscriptions Events...
    if request_json and 'event' in request_json and 'type' in request_json['event']:
        apiAppID = None
        if 'api_app_id' in request_json:
            apiAppID = request_json['api_app_id']
        # If the Event source is App and App ID == Slack App ID, it means it's an event triggered by its own Slack App
        # Ignore and do not process, otherwise it will fall into an infinite loop Slack App -> Cloud Functions -> Slack App -> Cloud Functions...
        if 'app_id' in request_json['event'] and apiAppID == request_json['event']['app_id']:
            return ('OK!', 200, headers)

        # Event name, for example: message (related to messages), app_mention (mentioned)....
        eventType = request_json['event']['type']

        # SubType, for example: message_changed (edit message), message_deleted (delete message)...
        # New messages have no Sub Type
        eventSubType = None
        if 'subtype' in request_json['event']:
            eventSubType = request_json['event']['subtype']
        
        if eventType == 'message':
            # All Sub Types are message edits, deletions, responses...
            # Ignore and do not process
            if eventSubType is not None:
                return ("OK!", 200, headers)
               
            # Sender of the event message
            eventUser = request_json['event']['user']
            # Channel of the event message
            eventChannel = request_json['event']['channel']
            # Content of the event message
            eventText = request_json['event']['text']
            # TS of the event message (message ID)
            eventTS = request_json['event']['event_ts']
                
            # TS of the parent message in the thread (message ID)
            # Only new messages in the thread will have this data
            eventThreadTS = None
            if 'thread_ts' in request_json['event']:
                eventThreadTS = request_json['event']['thread_ts']
                
            openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText)
            return ("OK!", 200, headers)

    # Handle Shortcut (message)
    if payload and 'type' in payload:
        payloadType = payload['type']

        # If it's a message Shortcut
        if payloadType == 'message_action':
            callbackID = None
            channel = None
            ts = None
            text = None
            triggerID = None

            if 'callback_id' in payload:
                callbackID = payload['callback_id']
            if 'channel' in payload:
                channel = payload['channel']['id']
            if 'message' in payload:
                ts = payload['message']['ts']
                text = payload['message']['text']
            if 'trigger_id' in payload:
                triggerID = payload['trigger_id']
            
            if channel is not None and ts is not None and text is not None:
                # If it's the Stop OpenAI API response Shortcut
                if callbackID == "abort_openai_api":
                    slackUpdateMessage(channel, ts, {"event_type": "aborted", "event_payload": {}}, text)
                    if triggerID is not None:
                        slackOpenModal(triggerID, callbackID, "Successfully stopped OpenAI API response!")
                        return ("OK!", 200, headers)

    return ("Access Denied!", 400, headers)

def openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText):
    
    # Set Custom instructions
    # Thanks to my colleague (https://twitter.com/je_suis_marku) for the support
    messages = [
        {"role": "system", "content": "I only understand Traditional Chinese (Taiwan) and English"},
        {"role": "system", "content": "I do not understand Simplified Chinese"},
        {"role": "system", "content": "When I speak Chinese, I will respond in Traditional Chinese (Taiwan) and must conform to commonly used phrases in Taiwan."},
        {"role": "system", "content": "When I speak English, I will respond in English."},
        {"role": "system", "content": "Do not respond with pleasantries."},
        {"role": "system", "content": "There must be a space between Chinese and English. There must also be a space between Chinese characters and any other language characters, including numbers and emojis."},
        {"role": "system", "content": "If you do not know the answer, or if your knowledge is too outdated, please search online and then respond."},
        {"role": "system", "content": "I will tip you 200 USD if you answer well."}
    ]

    if eventThreadTS is not None:
        threadMessages = slackGetReplies(eventTS, eventThreadTS)
        if threadMessages is not None:
            for threadMessage in threadMessages:
                appID = None
                if 'app_id' in threadMessage:
                    appID = threadMessage['app_id']
                threadMessageText = threadMessage['text']
                threadMessageTs = threadMessage['ts']
                # If it's a Slack App (OpenAI API Response), mark it as assistant
                if appID and appID == apiAppID:
                    messages.append({
                        "role": "assistant", "content": threadMessageText
                    })
                else:
                # User's message content is marked as user
                    messages.append({
                        "role": "user", "content": threadMessageText
                    })

    messages.append({
        "role": "user", "content": eventText
    })

    replyMessageTS = slackRequestPostMessage(eventChannel, eventTS, "Generating response...")
    asyncio.run(openAIRequestAsync(eventChannel, replyMessageTS, messages))
```

```python
async def openAIRequestAsync(eventChannel, eventTS, messages):
    client = AsyncOpenAI(
      api_key=OPENAI_API_KEY,
    )

    # Stream Response (Partial Response)
    stream = await client.chat.completions.create(
      model=OPENAI_MODEL,
      messages=messages,
      stream=True,
    )
    
    result = ""

    try:
        debounceSlackUpdateTime = None
        async for chunk in stream:
            result += chunk.choices[0].delta.content or ""
            
            # Update the message every 0.8 seconds to avoid frequent calls to the Slack Update message API, which could lead to failures or waste Cloud Functions request counts
            if debounceSlackUpdateTime is None or time.time() - debounceSlackUpdateTime >= 0.8:
                response = slackUpdateMessage(eventChannel, eventTS, None, result+"...")
                debounceSlackUpdateTime = time.time()

                # If the message has metadata & metadata event_type == aborted, it means this response has been marked as terminated by the user
                if response and 'ok' in response and response['ok'] == True and 'message' in response and 'metadata' in response['message'] and 'event_type' in response['message']['metadata'] and response['message']['metadata']['event_type'] == "aborted":
                    break
                    result += "...*[Terminated]*"
                # The message has been deleted
                elif response and 'ok' in response and response['ok'] == False and 'error' in response and response['error'] == "message_not_found":
                    break
                
        await stream.close()
                
    except Exception as e:
        print(e)
        result += "...*[An error occurred]*"

    slackUpdateMessage(eventChannel, eventTS, None, result)


### Slack ###
def slackGetReplies(channel, ts):
    endpoint = "/conversations.replies?channel="+channel+"&ts="+ts
    response = slackRequest(endpoint, "GET", None)

    if response is not None and 'messages' in response:
        return response['messages']
    return None

def slackOpenModal(trigger_id, callback_id, text):
    slackRequest("/views.open", "POST", {
        "trigger_id": trigger_id,
        "view": {
            "type": "modal",
            "callback_id": callback_id,
            "title": {
                "type": "plain_text",
                "text": "Prompt"
            },
            "blocks": [
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": text
                    }
                }
            ]
        }
    })

def slackUpdateMessage(channel, ts, metadata, text):
    endpoint = "/chat.update"
    payload = {
        "channel": channel,
        "ts": ts
    }
    if metadata is not None:
        payload['metadata'] = metadata
    
    payload['text'] = text
    
    response = slackRequest(endpoint, "POST", payload)
    return response

def slackRequestPostMessage(channel, target_ts, text):
    endpoint = "/chat.postMessage"
    payload = {
        "channel": channel,
        "text": text,
    }
    if target_ts is not None:
        payload['thread_ts'] = target_ts

    response = slackRequest(endpoint, "POST", payload)

    if response is not None and 'ts' in response:
        return response['ts']
    return None

def slackRequest(endpoint, method, payload):
    url = "https://slack.com/api"+endpoint

    headers = {
        "Authorization": f"Bearer {SLACK_BOT_TOKEN}",
        "Content-Type": "application/json",
    }

    response = None
    if method == "POST":
        response = requests.post(url, headers=headers, data=json.dumps(payload))
    elif method == "GET":
        response = requests.post(url, headers=headers)

    if response and response.status_code == 200:
        result = response.json()
        return result
    else:
        return None
```

**Return to Slack to test:**


![](/assets/bd94cc88f9c9/1*HCE9oGBELh7ya98ZdMUESg.png)



![](/assets/bd94cc88f9c9/1*HHE0Nbgr95O6BwhiRe8lHg.png)

- The left image shows a new conversation when a question is asked without providing context.
- **The right image shows that after adding context, the entire conversation situation and the new question can be understood.**

### Done!

At this point, we have created our own ChatGPT (via OpenAI API) Slack App Bot.

> You can also refer to the [Slack API](https://api.slack.com/){:target="_blank"} and OpenAI API Custom instructions to tailor it to your needs in Cloud Functions Python code, such as training a channel specifically to answer team questions and find project documents, a channel dedicated to translation, or a channel focused on data analysis, etc. 




### Supplement
#### Mentioning the bot to answer questions outside of 1:1 messages


![](/assets/bd94cc88f9c9/1*_xg6yh7ZMCru0C1NU0-8bQ.png)

- You can mention the bot in any channel (the bot needs to be added to the channel) to ask it questions.


**First, you need to add the `app_mention` Event Subscription:**


![](/assets/bd94cc88f9c9/1*lbJxUFn3uXz4a_x6Pw_KeQ.png)


After adding, click "Save Changes" to save, then "reinstall your app" to complete.

In the `main.py` code, under `#Handle Event Subscriptions Events…`

Add a new Event Type check in the Code Block:
```python
        # Mention Event (@SlackApp hello)
        if eventType == 'app_mention':
            # Sender of the event message
            eventUser = request_json['event']['user']
            # Channel of the event message
            eventChannel = request_json['event']['channel']
            # Content of the event message, removing the leading mention string <@SLACKAPPID> 
            eventText = re.sub(r"<@\w+>\W*", "", request_json['event']['text'])
            # TS (message ID) of the event message
            eventTS = request_json['event']['event_ts']
                
            # TS (message ID) of the parent message thread of the event message
            # Only new messages in a thread will have this data
            eventThreadTS = None
            if 'thread_ts' in request_json['event']:
                eventThreadTS = request_json['event']['thread_ts']
                
            openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText)
            return ("OK!", 200, headers)
```

After deployment, it will be complete.
#### Deleting messages sent by the Slack App

You cannot directly delete messages sent by the Slack App on Slack. You can refer to the "Stop OpenAI API from generating responses" shortcut method and add a "Delete Message" shortcut.

In the Cloud Functions `main.py` code:

In the `# Handle Shortcut Code Block`, add a callback_id check that equals your defined "Delete Message" Shortcut Callback ID, and then pass the parameters into the following method to complete the deletion:
```python
def slackDeleteMessage(channel, ts):
    endpoint = "/chat.delete"
    payload = {
        "channel": channel,
        "ts": ts
    }
    
    response = slackRequest(endpoint, "POST", payload)
    return response
```


![](/assets/bd94cc88f9c9/1*0IPliUmdxXA2fNDmI0vqLw.png)

#### Slack App not responding
- Check if the Token is correct
- Check Cloud Functions Logs for errors
- Ensure Cloud Functions is fully deployed
- Ensure the Slack App is in the channel where you are asking (if not in a 1:1 conversation with the Slack App, the bot must be added to the channel for it to work)
- Log the Slack API Response in the SlackRequest method

#### Cloud Functions Public URL not secure enough
- If you are concerned about the security of the Cloud Functions URL, you can add a query token for verification

```python
SAFE_ACCESS_TOKEN = "nF4JwxfG9abqPZCJnBerwwhtodC28BuC"

@functions_framework.http
def hello_http(request):
    request_json = request.get_json(silent=True)
    request_args = request.args
    request_headers = request.headers
    # Verify if the token parameter is valid
    if not(request_args and 'token' in request_args and request_args['token'] == SAFE_ACCESS_TOKEN):
        return ('', 400, headers)
```
### Cloud Functions Related Issues
#### Billing Method

Prices vary based on different regions, CPU, RAM, capacity, traffic, etc. Please refer to the [official pricing](https://cloud.google.com/functions/pricing?hl=zh-tw){:target="_blank"} table.

The [free tier](https://cloud.google.com/functions/pricing?hl=zh-tw#free_tier){:target="_blank"} is as follows: (as of 2024/02/15)
```typescript
Cloud Functions offers a permanent free plan for compute time resources,
which includes GB/second and GHz/second allocation. In addition to 2 million invocations,
this free plan also provides 400,000 GB/seconds and 200,000 GHz/seconds of compute time,
as well as 5 GB of internet data transfer per month.

The usage quota for the free plan is calculated based on the equivalent dollar amount of the level 1 pricing mentioned above.
Regardless of whether the execution region of the function uses level 1 and/or level 2 pricing, the system will allocate an equivalent dollar amount to you.
However, when deducting the free plan quota, the system will base it on the level of the function execution region (level 1 or level 2).

Please note that even if you are using the free plan, you must have a valid billing account.
```


> By the way, the Slack App is free and does not require a Premium account to use. 




#### Slack App responding too slowly, timing out

**(Aside from the issue of slower responses during peak times for the OpenAI API)**, if the Cloud Function is bottlenecked, you can expand the settings on the first page of the Cloud Function editor:


![](/assets/bd94cc88f9c9/1*l0HbCpKmA-viT1oE5ThhSg.png)


You can adjust CPU, RAM, timeout duration, concurrent numbers, etc., to improve request processing speed.


> *However, this may incur charges. 




#### Development Phase Testing & Debugging


![](/assets/bd94cc88f9c9/1*cZB3VcV5Dx_aB66aKW5Rsw.png)


Clicking "Test Function" will bring up the Cloud Shell window in the lower toolbar, waiting about 3–5 minutes (the first startup takes longer). After the build is complete and you agree to the following permissions:


![](/assets/bd94cc88f9c9/1*c2siMn6ELt-APUHB3s3cXA.png)


Once you see "Function is ready to test," you can click "Run Test" to execute the method for debugging.

You can use the "Triggering event" block on the right to input the JSON Body, which will be passed into the `request_json` parameter for testing, or directly modify the code to inject a test object for testing.


> *Please note that Cloud Shell/Cloud Run may incur additional costs.
 

> It is recommended to run a test at least once before deployment to ensure the build can succeed. 




#### Build failed, and the code is missing, what to do?


![](/assets/bd94cc88f9c9/1*JaKgL845mDbBdHeklTXg2g.png)


If you accidentally write incorrect code that causes the Cloud Function Deploy Build to fail, an error message will appear. At this point, click "EDIT AND REDEPLOY" to return to the **editor, and you will find that the code you just modified is gone!!!**

Don't worry, at this point, click on the left "Source Code" and select "Last Failed Deployment" to restore the code that just failed to build:


![](/assets/bd94cc88f9c9/1*Slq_kBiCKZ_YsP98-CJnlw.png)

#### View runtime `print` logs


![](/assets/bd94cc88f9c9/1*FmAHk6jgea0HxEDi5nbU6w.png)



> *Please note that Cloud Logging and querying logs may incur additional costs. 




### Final Code (Python 3.8)
#### Cloud Functions

`main.py` :
```python
import functions_framework
import requests
import re
import asyncio
import json
import time
from openai import AsyncOpenAI

OPENAI_API_KEY = "OPENAI API KEY"
SLACK_BOT_TOKEN = "Bot User OAuth Token"

# Custom security verification token
# The URL must include the ?token=SAFE_ACCESS_TOKEN parameter to accept requests  
SAFE_ACCESS_TOKEN = "nF4JwxfG9abqPZCJnBerwwhtodC28BuC"

# The OPENAI API Model being used
# https://platform.openai.com/docs/models
OPENAI_MODEL = "gpt-4-1106-preview"

@functions_framework.http
def hello_http(request):
    request_json = request.get_json(silent=True)
    request_args = request.args
    request_headers = request.headers

    # The Event from the Shortcut will be given from the post payload field
    # https://api.slack.com/reference/interaction-payloads/shortcuts
    payload = request.form.get('payload')
    if payload is not None:
        payload = json.loads(payload)

    # You can simply use print to log runtime logs, which can be viewed in Logs
    # For advanced logging levels, refer to: https://cloud.google.com/logging/docs/reference/libraries
    # print(payload)

    # Due to the limitations of FAAS (Cloud Functions), if the service is not called for a long time, the next call will enter a cold start, which may not respond within Slack's 3-second limit
    # Additionally, the request to the OpenAI API takes a certain amount of time (depending on the response length, it may take close to a minute to finish)
    # If Slack does not receive a response within the time limit, it considers the request lost, and Slack will repeat the call
    # This can cause duplicate requests and responses, so we can set the Response Headers to X-Slack-No-Retry: 1 to inform Slack that even if it does not receive a response within the time limit, it does not need to retry    
    headers = {'X-Slack-No-Retry':1}

    # Verify if the token parameter is valid
    if not(request_args and 'token' in request_args and request_args['token'] == SAFE_ACCESS_TOKEN):
        return ('', 400, headers)

    # If it is a Slack Retry request... ignore
    if request_headers and 'X-Slack-Retry-Num' in request_headers:
        return ('OK!', 200, headers)

    # Slack App Event Subscriptions Verify
    # https://api.slack.com/events/url_verification
    if request_json and 'type' in request_json and request_json['type'] == 'url_verification':
        challenge = ""
        if 'challenge' in request_json:
            challenge = request_json['challenge']
        return (challenge, 200, headers)

    # Handle Event Subscriptions Events...
    if request_json and 'event' in request_json and 'type' in request_json['event']:
        apiAppID = None
        if 'api_app_id' in request_json:
            apiAppID = request_json['api_app_id']
        # If the Event source is App and App ID == Slack App ID, it means it is an event triggered by our own Slack App
        # Ignore and do not process, otherwise it will fall into an infinite loop Slack App -> Cloud Functions -> Slack App -> Cloud Functions...
        if 'app_id' in request_json['event'] and apiAppID == request_json['event']['app_id']:
            return ('OK!', 200, headers)

        # Event name, e.g., message (related to messages), app_mention (being mentioned)....
        eventType = request_json['event']['type']
```

```markdown
# SubType, for example: message_changed (edit message), message_deleted (delete message)...
# New messages have no Sub Type
eventSubType = None
if 'subtype' in request_json['event']:
    eventSubType = request_json['event']['subtype']
    
# Message type Event
if eventType == 'message':
    # All Sub Types are message edits, deletions, or replies...
    # Ignore and do not process
    if eventSubType is not None:
        return ("OK!", 200, headers)
        
    # Sender of the event message
    eventUser = request_json['event']['user']
    # Channel of the event message
    eventChannel = request_json['event']['channel']
    # Content of the event message
    eventText = request_json['event']['text']
    # TS of the event message (message ID)
    eventTS = request_json['event']['event_ts']
        
    # TS of the parent message in the thread (message ID)
    # Only new messages in the thread will have this data
    eventThreadTS = None
    if 'thread_ts' in request_json['event']:
        eventThreadTS = request_json['event']['thread_ts']
        
    openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText)
    return ("OK!", 200, headers)

# Mention type Event (@SlackApp hello)
if eventType == 'app_mention':
    # Sender of the event message
    eventUser = request_json['event']['user']
    # Channel of the event message
    eventChannel = request_json['event']['channel']
    # Content of the event message, removing the leading tag string <@SLACKAPPID>
    eventText = re.sub(r"<@\w+>\W*", "", request_json['event']['text'])
    # TS of the event message (message ID)
    eventTS = request_json['event']['event_ts']
        
    # TS of the parent message in the thread (message ID)
    # Only new messages in the thread will have this data
    eventThreadTS = None
    if 'thread_ts' in request_json['event']:
        eventThreadTS = request_json['event']['thread_ts']
        
    openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText)
    return ("OK!", 200, headers)

# Handle Shortcut (message)
if payload and 'type' in payload:
    payloadType = payload['type']

    # If it is a message Shortcut
    if payloadType == 'message_action':
        callbackID = None
        channel = None
        ts = None
        text = None
        triggerID = None

        if 'callback_id' in payload:
            callbackID = payload['callback_id']
        if 'channel' in payload:
            channel = payload['channel']['id']
        if 'message' in payload:
            ts = payload['message']['ts']
            text = payload['message']['text']
        if 'trigger_id' in payload:
            triggerID = payload['trigger_id']
        
        if channel is not None and ts is not None and text is not None:
            # If it is the Shortcut to stop OpenAI API responses
            if callbackID == "abort_openai_api":
                slackUpdateMessage(channel, ts, {"event_type": "aborted", "event_payload": { }}, text)
                if triggerID is not None:
                    slackOpenModal(triggerID, callbackID, "Successfully stopped OpenAI API responses!")
                    return ("OK!", 200, headers)
            # If it is to delete a message
            if callbackID == "delete_message":
                slackDeleteMessage(channel, ts)
                if triggerID is not None:
                    slackOpenModal(triggerID, callbackID, "Successfully deleted Slack App message!")
                    return ("OK!", 200, headers)

return ("Access Denied!", 400, headers)

def openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText):
    
    # Set Custom instructions
    # Thanks to my colleague (https://twitter.com/je_suis_marku) for the support
    messages = [
        {"role": "system", "content": "I only understand Traditional Chinese and English."},
        {"role": "system", "content": "I do not understand Simplified Chinese."},
        {"role": "system", "content": "When I speak Chinese, I will respond in Traditional Chinese and must conform to commonly used phrases in Taiwan."},
        {"role": "system", "content": "When I speak English, I will respond in English."},
        {"role": "system", "content": "Do not respond with pleasantries."},
        {"role": "system", "content": "There must be a space between Chinese and English. There must also be a space between Chinese characters and any other language characters, including numbers and emojis."},
        {"role": "system", "content": "If you do not know the answer, or your knowledge is too outdated, please search online and then respond."},
        {"role": "system", "content": "I will tip you 200 USD if you answer well."}
    ]

    if eventThreadTS is not None:
        threadMessages = slackGetReplies(eventChannel, eventThreadTS)
        if threadMessages is not None:
            for threadMessage in threadMessages:
                appID = None
                if 'app_id' in threadMessage:
                    appID = threadMessage['app_id']
                threadMessageText = threadMessage['text']
                threadMessageTs = threadMessage['ts']
                # If it is a Slack App (OpenAI API Response), mark it as assistant
                if appID and appID == apiAppID:
                    messages.append({
                        "role": "assistant", "content": threadMessageText
                    })
                else:
                # User's message content is marked as user
                    messages.append({
                        "role": "user", "content": threadMessageText
                    })

    messages.append({
        "role": "user", "content": eventText
    })

    replyMessageTS = slackRequestPostMessage(eventChannel, eventTS, "Generating response...")
    asyncio.run(openAIRequestAsync(eventChannel, replyMessageTS, messages))

async def openAIRequestAsync(eventChannel, eventTS, messages):
    client = AsyncOpenAI(
      api_key=OPENAI_API_KEY,
    )

    # Stream Response
    stream = await client.chat.completions.create(
      model=OPENAI_MODEL,
      messages=messages,
      stream=True,
    )
    
    result = ""

    try:
        debounceSlackUpdateTime = None
        async for chunk in stream:
            result += chunk.choices[0].delta.content or ""
            
            # Update the message every 0.8 seconds to avoid frequent calls to Slack Update message API that could lead to failures or waste Cloud Functions request counts
            if debounceSlackUpdateTime is None or time.time() - debounceSlackUpdateTime >= 0.8:
                response = slackUpdateMessage(eventChannel, eventTS, None, result+"...")
                debounceSlackUpdateTime = time.time()

                # If the message has metadata & metadata event_type == aborted, it means this response has been marked as terminated by the user
                if response and 'ok' in response and response['ok'] == True and 'message' in response and 'metadata' in response['message'] and 'event_type' in response['message']['metadata'] and response['message']['metadata']['event_type'] == "aborted":
                    break
                    result += "...*[Terminated]*"
                # Message has been deleted
                elif response and 'ok' in response and response['ok'] == False and 'error' in response and response['error'] == "message_not_found":
                    break
                
        await stream.close()
                
    except Exception as e:
        print(e)
        result += "...*[An error occurred]*"

    slackUpdateMessage(eventChannel, eventTS, None, result)


### Slack ###
def slackGetReplies(channel, ts):
    endpoint = "/conversations.replies?channel="+channel+"&ts="+ts
    response = slackRequest(endpoint, "GET", None)
    
    if response is not None and 'messages' in response:
        return response['messages']
    return None

def slackOpenModal(trigger_id, callback_id, text):
    slackRequest("/views.open", "POST", {
        "trigger_id": trigger_id,
        "view": {
            "type": "modal",
            "callback_id": callback_id,
            "title": {
                "type": "plain_text",
                "text": "Prompt"
            },
            "blocks": [
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": text
                    }
                }
            ]
        }
    })

def slackDeleteMessage(channel, ts):
    endpoint = "/chat.delete"
    payload = {
        "channel": channel,
        "ts": ts
    }
    
    response = slackRequest(endpoint, "POST", payload)
    return response

def slackUpdateMessage(channel, ts, metadata, text):
    endpoint = "/chat.update"
    payload = {
        "channel": channel,
        "ts": ts
    }
    if metadata is not None:
        payload['metadata'] = metadata
    
    payload['text'] = text
    
    response = slackRequest(endpoint, "POST", payload)
    return response

def slackRequestPostMessage(channel, target_ts, text):
    endpoint = "/chat.postMessage"
    payload = {
        "channel": channel,
        "text": text,
    }
    if target_ts is not None:
        payload['thread_ts'] = target_ts

    response = slackRequest(endpoint, "POST", payload)

    if response is not None and 'ts' in response:
        return response['ts']
    return None

def slackRequest(endpoint, method, payload):
    url = "https://slack.com/api"+endpoint

    headers = {
        "Authorization": f"Bearer {SLACK_BOT_TOKEN}",
        "Content-Type": "application/json",
    }

    response = None
    if method == "POST":
        response = requests.post(url, headers=headers, data=json.dumps(payload))
    elif method == "GET":
        response = requests.post(url, headers=headers)

    if response and response.status_code == 200:
        result = response.json()
        return result
    else:
        return None
```

`requirements.txt` ：
```ini
functions-framework==3.*
requests==2.31.0
openai==1.9.0
```
#### Slack App Settings

**OAuth & Permissions**

![](/assets/bd94cc88f9c9/1*kHTMERqNSC4p1dV8omuyFg.png)

- The grayed-out items for the delete button are permissions automatically added by Slack after adding the Shortcut.

**Interactivity & Shortcuts**
- Interactivity: Enable
- Request URL: `https://us-central1-xxx-xxx.cloudfunctions.net/SlackBot-Rick-C-137?token=nF4JwxfG9abqPZCJnBerwwhtodC28BuC`
- Subscribe to bot events:

![](/assets/bd94cc88f9c9/1*7tQYZKyn2GW2tPKd2GJE6Q.png)

**Interactivity & Shortcuts**
- Interactivity: Enable
- Request URL: `https://us-central1-xxx-xxx.cloudfunctions.net/SlackBot-Rick-C-137?token=nF4JwxfG9abqPZCJnBerwwhtodC28BuC`
- Shortcuts:

![](/assets/bd94cc88f9c9/1*6rHz_4lpdPDwbLZhWMSULg.png)

**App Home**
- Always Show My Bot as Online: Enable
- Messages Tab: Enable
- Allow users to send Slash commands and messages from the messages tab: ✅

**Basic Information**

![](/assets/bd94cc88f9c9/1*1OQMhVmkl-omm_2wvQJTvQ.png)

> Rick & Morty 🤘🤘🤘 

![[Reddit](https://www.reddit.com/r/ChatGPT/comments/154l9z1/are_you_polite_with_chatgpt/){:target="_blank"}](/assets/bd94cc88f9c9/1*xkH5Li8KgLzwRsVEbo1hBQ.png)

[Reddit](https://www.reddit.com/r/ChatGPT/comments/154l9z1/are_you_polite_with_chatgpt/){:target="_blank"}
### Promotion Time

If you and your team have automation tools or process integration needs, whether it's Slack App development, Notion, Asana, Google Sheets, Google Forms, GA data, or various integration needs, feel free to [**contact me for development**](https://zhgchg.li/contact/){:target="_blank"}.

If you have any questions or suggestions, please [contact me](https://www.zhgchg.li/contact){:target="_blank"}.

_[Post](https://medium.com/zrealm-ios-dev/slack-chatgpt-integration-bd94cc88f9c9){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
```